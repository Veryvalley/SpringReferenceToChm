var contents = new Array("         9.&nbsp;Aspect Oriented Programming with SpringPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next9.&nbsp;Aspect Oriented Programming with Spring    9.1&nbsp;Introduction        \n\r\n\rAspect-Oriented Programming (AOP) complements    Object-Oriented Programming (OOP) by providing another way of thinking    about program structure. The key unit of modularity in OOP is the class,    whereas in AOP the unit of modularity is the aspect.    Aspects enable the modularization of concerns such as transaction    management that cut across multiple types and objects. (Such concerns are    often termed crosscutting concerns in AOP    literature.)    \n\r\n\rOne of the key components of Spring is the AOP    framework. While the Spring IoC container does not depend on    AOP, meaning you do not need to use AOP if you don\'t want to, AOP    complements Spring IoC to provide a very capable middleware    solution.    \n\r\n\rSpring 2.0 AOP            \n\r\n\rSpring 2.0 introduces a simpler and more powerful way of writing      custom aspects using either a schema-based      approach or the @AspectJ annotation      style. Both of these styles offer fully typed advice and use of      the AspectJ pointcut language, while still using Spring AOP for      weaving.      \n\r\n\rThe Spring 2.0 schema- and @AspectJ-based AOP support is discussed      in this chapter. Spring 2.0 AOP remains fully backwards compatible with      Spring 1.2 AOP, and the lower-level AOP support offered by the Spring      1.2 APIs is discussed in the following      chapter.        \n\r\n\rAOP is used in the Spring Framework to...    \n\r        \n\r\n\r... provide declarative enterprise services, especially as a        replacement for EJB declarative services. The most important such        service is declarative transaction        management.      \n\r        \n\r\n\r... allow users to implement custom aspects, complementing their        use of OOP with AOP.      \n\r    \n\r\n\rIf you are interested only in generic declarative services    or other pre-packaged declarative middleware services such as pooling, you    do not need to work directly with Spring AOP, and can skip most of this    chapter.    9.1.1&nbsp;AOP concepts            \n\r\n\rLet us begin by defining some central AOP concepts and      terminology. These terms are not Spring-specific... unfortunately, AOP      terminology is not particularly intuitive; however, it would be even      more confusing if Spring used its own terminology.      \n\r          \n\r\n\rAspect: a modularization of a concern          that cuts across multiple classes. Transaction management is a good          example of a crosscutting concern in enterprise Java applications.          In Spring AOP, aspects are implemented using regular classes (the          schema-based approach) or regular          classes annotated with the @Aspect          annotation (the @AspectJ          style).        \n\r          \n\r\n\rJoin point: a point during the execution          of a program, such as the execution of a method or the handling of          an exception. In Spring AOP, a join point          always represents a method execution.        \n\r          \n\r\n\rAdvice: action taken by an aspect at a          particular join point. Different types of advice include \"around,\"          \"before\" and \"after\" advice. (Advice types are discussed below.)          Many AOP frameworks, including Spring, model an advice as an          interceptor, maintaining a chain of          interceptors around the join point.        \n\r          \n\r\n\rPointcut: a predicate that matches join          points. Advice is associated with a pointcut expression and runs at          any join point matched by the pointcut (for example, the execution          of a method with a certain name). The concept of join points as          matched by pointcut expressions is central to AOP, and Spring uses          the AspectJ pointcut expression language by default.        \n\r          \n\r\n\rIntroduction: declaring additional          methods or fields on behalf of a type. Spring AOP allows you to          introduce new interfaces (and a corresponding implementation) to any          advised object. For example, you could use an introduction to make a          bean implement an IsModified          interface, to simplify caching. (An introduction is known as an          inter-type declaration in the AspectJ community.)        \n\r          \n\r\n\rTarget object: object being advised by          one or more aspects. Also referred to as the          advised object. Since Spring AOP is implemented          using runtime proxies, this object will always be a          proxied object.        \n\r          \n\r\n\rAOP proxy: an object created by the AOP          framework in order to implement the aspect contracts (advise method          executions and so on). In the Spring Framework, an AOP proxy will be          a JDK dynamic proxy or a CGLIB proxy.        \n\r          \n\r\n\rWeaving: linking aspects with other          application types or objects to create an advised object. This can          be done at compile time (using the AspectJ compiler, for example),          load time, or at runtime. Spring AOP, like other pure Java AOP          frameworks, performs weaving at runtime.        \n\r      \n\r\n\rTypes of advice:      \n\r          \n\r\n\rBefore advice: Advice that executes          before a join point, but which does not have the ability to prevent          execution flow proceeding to the join point (unless it throws an          exception).        \n\r          \n\r\n\rAfter returning advice: Advice to be          executed after a join point completes normally: for example, if a          method returns without throwing an exception.        \n\r          \n\r\n\rAfter throwing advice: Advice to be          executed if a method exits by throwing an exception.        \n\r          \n\r\n\rAfter (finally) advice: Advice to be          executed regardless of the means by which a join point exits (normal          or exceptional return).        \n\r          \n\r\n\rAround advice: Advice that surrounds a          join point such as a method invocation. This is the most powerful          kind of advice. Around advice can perform custom behavior before and          after the method invocation. It is also responsible for choosing          whether to proceed to the join point or to shortcut the advised          method execution by returning its own return value or throwing an          exception.        \n\r      \n\r\n\rAround advice is the most general kind of advice. Since Spring      AOP, like AspectJ, provides a full range of advice types, we recommend      that you use the least powerful advice type that can implement the      required behavior. For example, if you need only to update a cache with      the return value of a method, you are better off implementing an after      returning advice than an around advice, although an around advice can      accomplish the same thing. Using the most specific advice type provides      a simpler programming model with less potential for errors. For example,      you do not need to invoke the proceed() method      on the JoinPoint used for around advice,      and hence cannot fail to invoke it.      \n\r\n\rIn Spring 2.0, all advice parameters are statically typed, so that      you work with advice parameters of the appropriate type (the type of the      return value from a method execution for example) rather than      Object arrays.      \n\r\n\rThe concept of join points, matched by pointcuts, is the key to      AOP which distinguishes it from older technologies offering only      interception. Pointcuts enable advice to be targeted independently of      the Object-Oriented hierarchy. For example, an around advice providing      declarative transaction management can be applied to a set of methods      spanning multiple objects (such as all business operations in the      service layer).        9.1.2&nbsp;Spring AOP capabilities and goals            \n\r\n\rSpring AOP is implemented in pure Java. There is no need for a      special compilation process. Spring AOP does not need to control the      class loader hierarchy, and is thus suitable for use in a Servlet      container or application server.      \n\r\n\rSpring AOP currently supports only method execution join points      (advising the execution of methods on Spring beans). Field interception      is not implemented, although support for field interception could be      added without breaking the core Spring AOP APIs. If you need to advise      field access and update join points, consider a language such as      AspectJ.      \n\r\n\rSpring AOP\'s approach to AOP differs from that of most other AOP      frameworks. The aim is not to provide the most complete AOP      implementation (although Spring AOP is quite capable); it is rather to      provide a close integration between AOP implementation and Spring IoC to      help solve common problems in enterprise applications.      \n\r\n\rThus, for example, the Spring Framework\'s AOP functionality is      normally used in conjunction with the Spring IoC container. Aspects are      configured using normal bean definition syntax (although this allows      powerful \"autoproxying\" capabilities): this is a crucial difference from      other AOP implementations. There are some things you cannot do easily or      efficiently with Spring AOP, such as advise very fine-grained objects      (such as domain objects typically): AspectJ is the best choice in such      cases. However, our experience is that Spring AOP provides an excellent      solution to most problems in enterprise Java applications that are      amenable to AOP.      \n\r\n\rSpring AOP will never strive to compete with AspectJ to provide a      comprehensive AOP solution. We believe that both proxy-based frameworks      like Spring AOP and full-blown frameworks such as AspectJ are valuable,      and that they are complementary, rather than in competition. Spring 2.0      seamlessly integrates Spring AOP and IoC with AspectJ, to enable all      uses of AOP to be catered for within a consistent Spring-based      application architecture. This integration does not affect the Spring      AOP API or the AOP Alliance API: Spring AOP remains backward-compatible.      See the following chapter for a      discussion of the Spring AOP APIs.      Note        \n\r\n\rOne of the central tenets of the Spring Framework is that of        non-invasiveness; this is the idea that you        should not be forced to introduce framework-specific classes and        interfaces into your business/domain model. However, in some places        the Spring Framework does give you the option to introduce Spring        Framework-specific dependencies into your codebase: the rationale in        giving you such options is because in certain scenarios it might be        just plain easier to read or code some specific piece of functionality        in such a way. The Spring Framework (almost) always offers you the        choice though: you have the freedom to make an informed decision as to        which option best suits your particular use case or scenario.        \n\r\n\rOne such choice that is relevant to this chapter is that of        which AOP framework (and which AOP style) to choose. You have the        choice of AspectJ and/or Spring AOP, and you also have the choice of        either the @AspectJ annotation-style approach or the Spring XML        configuration-style approach. The fact that this chapter chooses to        introduce the @AspectJ-style approach first should not be taken as an        indication that the Spring team favors the @AspectJ annotation-style        approach over the Spring XML configuration-style.        \n\r\n\rSee Section&nbsp;9.4, &#8220;Choosing which AOP declaration style to use&#8221; for a        more complete discussion of the whys and wherefores of each style.              9.1.3&nbsp;AOP Proxies            \n\r\n\rSpring AOP defaults to using standard J2SE dynamic      proxies for AOP proxies. This enables any interface (or set      of interfaces) to be proxied.      \n\r\n\rSpring AOP can also use CGLIB proxies. This is necessary to proxy      classes, rather than interfaces. CGLIB is used by default if a business      object does not implement an interface. As it is good practice to      program to interfaces rather than classes, business classes normally      will implement one or more business interfaces. It is possible to force the use of CGLIB, in      those (hopefully rare) cases where you need to advise a method that is      not declared on an interface, or where you need to pass a proxied object      to a method as a concrete type.      \n\r\n\rIt is important to grasp the fact that Spring AOP is      proxy-based. See Section&nbsp;9.6.1, &#8220;Understanding AOP proxies&#8221; for a thorough examination of      exactly what this implementation detail actually means.        9.2&nbsp;@AspectJ support        \n\r\n\r@AspectJ refers to a style of declaring aspects as regular Java    classes annotated with Java 5 annotations. The @AspectJ style was    introduced by the AspectJ    project as part of the AspectJ 5 release. Spring 2.0 interprets    the same annotations as AspectJ 5, using a library supplied by AspectJ for    pointcut parsing and matching. The AOP runtime is still pure Spring AOP    though, and there is no dependency on the AspectJ compiler or    weaver.    \n\r\n\rUsing the AspectJ compiler and weaver enables use of the    full AspectJ language, and is discussed in Section&nbsp;9.8, &#8220;Using AspectJ with Spring applications&#8221;.    9.2.1&nbsp;Enabling @AspectJ Support            \n\r\n\rTo use @AspectJ aspects in a Spring configuration you need to      enable Spring support for configuring Spring AOP based on @AspectJ      aspects, and autoproxying beans based on whether or      not they are advised by those aspects. By autoproxying we mean that if      Spring determines that a bean is advised by one or more aspects, it will      automatically generate a proxy for that bean to intercept method      invocations and ensure that advice is executed as needed.      \n\r\n\rThe @AspectJ support can be enabled with XML or Java style      configuration.  In either case you will also need to ensure that      AspectJ\'s aspectjweaver.jar      library is on the classpath of your application (version 1.6.8 or later).      This library is available in the \'lib\'      directory of an AspectJ distribution or via the Maven Central repository.      Enabling @AspectJ Support with Java configuration                \n\r\n\rTo enable @AspectJ support with Java        @Configuration add the        @EnableAspectJAutoProxy annotation:        @Configuration@EnableAspectJAutoProxypublic class AppConfig {}            Enabling @AspectJ Support with XML configuration                \n\r\n\rTo enable @AspectJ support with XML based configuration use the        aop:aspectj-autoproxy element:        &lt;aop:aspectj-autoproxy/&gt;        \n\r\n\rThis assumes that you are using schema support as described in        Appendix&nbsp;E, XML Schema-based configuration. See Section&nbsp;E.2.7, &#8220;The aop schema&#8221; for how to import the tags in        the aop namespace.        \n\r\n\rIf you are using the DTD, it is still possible to enable @AspectJ        support by adding the following definition to your application        context:        &lt;bean class=\"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator\" /&gt;              9.2.2&nbsp;Declaring an aspect            \n\r\n\rWith the @AspectJ support enabled, any bean defined in your      application context with a class that is an @AspectJ aspect (has the      @Aspect annotation) will be automatically      detected by Spring and used to configure Spring AOP. The following      example shows the minimal definition required for a not-very-useful      aspect:      \n\r\n\rA regular bean definition in the application context, pointing to      a bean class that has the @Aspect      annotation:      &lt;bean id=\"myAspect\" class=\"org.xyz.NotVeryUsefulAspect\"&gt;   &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt;      \n\r\n\rAnd the NotVeryUsefulAspect class      definition, annotated with      org.aspectj.lang.annotation.Aspect      annotation;      package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect {}      \n\r\n\rAspects (classes annotated with      @Aspect) may have methods and fields just      like any other class. They may also contain pointcut, advice, and      introduction (inter-type) declarations.      Autodetecting aspects through component scanning                \n\r\n\rYou may register aspect classes as regular beans in your Spring        XML configuration, or autodetect them through classpath scanning -        just like any other Spring-managed bean. However, note that the        @Aspect annotation is not        sufficient for autodetection in the classpath: For that purpose,        you need to add a separate @Component annotation        (or alternatively a custom stereotype annotation that qualifies,        as per the rules of Spring\'s component scanner).            Advising aspects with other aspects?                \n\r\n\rIn Spring AOP, it is not possible to have        aspects themselves be the target of advice from other aspects. The        @Aspect annotation on a class marks it as an        aspect, and hence excludes it from auto-proxying.              9.2.3&nbsp;Declaring a pointcut            \n\r\n\rRecall that pointcuts determine join points of interest, and thus      enable us to control when advice executes. Spring AOP only      supports method execution join points for Spring beans, so      you can think of a pointcut as matching the execution of methods on      Spring beans. A pointcut declaration has two parts: a signature      comprising a name and any parameters, and a pointcut expression that      determines exactly which method executions we are      interested in. In the @AspectJ annotation-style of AOP, a pointcut      signature is provided by a regular method definition, and the pointcut      expression is indicated using the      @Pointcut annotation (the method serving      as the pointcut signature must have a      void return type).      \n\r\n\rAn example will help make this distinction between a pointcut      signature and a pointcut expression clear. The following example defines      a pointcut named \'anyOldTransfer\' that will match the      execution of any method named \'transfer\':      @Pointcut(\"execution(* transfer(..))\")// the pointcut expressionprivate void anyOldTransfer() {}// the pointcut signature      \n\r\n\rThe pointcut expression that forms the value of the      @Pointcut annotation is a regular AspectJ      5 pointcut expression. For a full discussion of AspectJ\'s pointcut      language, see the AspectJ      Programming Guide (and for Java 5 based extensions, the AspectJ      5 Developers Notebook) or one of the books on AspectJ such as      &#8220;Eclipse AspectJ&#8221; by Colyer et. al. or &#8220;AspectJ in      Action&#8221; by Ramnivas Laddad.      Supported Pointcut Designators                \n\r\n\rSpring AOP supports the following AspectJ pointcut designators        (PCD) for use in pointcut expressions:        \n\r\n\rOther pointcut types                    \n\r\n\rThe full AspectJ pointcut language supports additional          pointcut designators that are not supported in Spring. These are:          call, get, set, preinitialization, staticinitialization,          initialization, handler, adviceexecution, withincode, cflow,          cflowbelow, if, @this, and @withincode.          Use of these pointcut designators in pointcut expressions          interpreted by Spring AOP will result in an          IllegalArgumentException being thrown.          \n\r\n\rThe set of pointcut designators supported by Spring AOP may be          extended in future releases to support more of the AspectJ pointcut          designators.                \n\r            \n\r\n\rexecution - for matching method            execution join points, this is the primary pointcut designator you            will use when working with Spring AOP          \n\r            \n\r\n\rwithin - limits matching to join points            within certain types (simply the execution of a method declared            within a matching type when using Spring AOP)          \n\r            \n\r\n\rthis - limits matching to join points            (the execution of methods when using Spring AOP) where the bean            reference (Spring AOP proxy) is an instance of the given            type          \n\r            \n\r\n\rtarget - limits matching to join points            (the execution of methods when using Spring AOP) where the target            object (application object being proxied) is an instance of the            given type          \n\r            \n\r\n\rargs - limits matching to join points            (the execution of methods when using Spring AOP) where the            arguments are instances of the given types          \n\r            \n\r\n\r@target            - limits matching to join points (the execution of methods when            using Spring AOP) where the class of the executing object has an            annotation of the given type          \n\r            \n\r\n\r@args -            limits matching to join points (the execution of methods when            using Spring AOP) where the runtime type of the actual arguments            passed have annotations of the given type(s)          \n\r            \n\r\n\r@within            - limits matching to join points within types that have the given            annotation (the execution of methods declared in types with the            given annotation when using Spring AOP)          \n\r            \n\r\n\r@annotation - limits matching to join            points where the subject of the join point (method being executed            in Spring AOP) has the given annotation          \n\r        \n\r\n\rBecause Spring AOP limits matching to only method execution        join points, the discussion of the pointcut designators above gives a        narrower definition than you will find in the AspectJ programming        guide. In addition, AspectJ itself has type-based semantics and at an        execution join point both \'this\' and        \'target\' refer to the same object - the object        executing the method. Spring AOP is a proxy-based system and        differentiates between the proxy object itself (bound to        \'this\') and the target object behind the proxy        (bound to \'target\').        Note          \n\r\n\rDue to the proxy-based nature of Spring\'s AOP framework,          protected methods are by definition not          intercepted, neither for JDK proxies (where this isn\'t applicable)          nor for CGLIB proxies (where this is technically possible but not          recommendable for AOP purposes). As a consequence, any given pointcut          will be matched against public methods only!          \n\r\n\rIf your interception needs include protected/private methods          or even constructors, consider the use of Spring-driven          native AspectJ weaving instead          of Spring\'s proxy-based AOP framework. This constitutes a different          mode of AOP usage with different characteristics, so be sure to make          yourself familiar with weaving first before making a decision.                \n\r\n\rSpring AOP also supports an additional PCD named        \'bean\'. This PCD allows you to limit the matching        of join points to a particular named Spring bean, or to a set of named        Spring beans (when using wildcards). The \'bean\' PCD        has the following form:        bean(idOrNameOfBean)        \n\r\n\rThe \'idOrNameOfBean\' token can be the name of        any Spring bean: limited wildcard support using the        \'*\' character is provided, so if you establish        some naming conventions for your Spring beans you can quite easily        write a \'bean\' PCD expression to pick them out. As        is the case with other pointcut designators, the        \'bean\' PCD can be &amp;&amp;\'ed, ||\'ed, and !        (negated) too.        Note          \n\r\n\rPlease note that the \'bean\' PCD is          only supported in Spring AOP - and          not in native AspectJ weaving. It is a          Spring-specific extension to the standard PCDs that AspectJ          defines.          \n\r\n\rThe \'bean\' PCD operates at the          instance level (building on the Spring          bean name concept) rather than at the type level only          (which is what weaving-based AOP is limited to).          Instance-based pointcut designators are a special capability          of Spring\'s proxy-based AOP framework and its close integration          with the Spring bean factory, where it is natural and          straightforward to identify specific beans by name.                    Combining pointcut expressions                \n\r\n\rPointcut expressions can be combined using \'&amp;&amp;\', \'||\'        and \'!\'. It is also possible to refer to pointcut expressions by name.        The following example shows three pointcut expressions:        anyPublicOperation (which matches if a method        execution join point represents the execution of any public method);        inTrading (which matches if a method execution is        in the trading module), and tradingOperation (which        matches if a method execution represents any public method in the        trading module).            @Pointcut(\"execution(public * *(..))\")    private void anyPublicOperation() {}    @Pointcut(\"within(com.xyz.someapp.trading..*)\")    private void inTrading() {}    @Pointcut(\"anyPublicOperation() &amp;&amp; inTrading()\")    private void tradingOperation() {}        \n\r\n\rIt is a best practice to build more complex pointcut expressions        out of smaller named components as shown above. When referring to        pointcuts by name, normal Java visibility rules apply (you can see        private pointcuts in the same type, protected pointcuts in the        hierarchy, public pointcuts anywhere and so on). Visibility does not        affect pointcut matching.            Sharing common pointcut definitions                \n\r\n\rWhen working with enterprise applications, you often want to        refer to modules of the application and particular sets of operations        from within several aspects. We recommend defining a        \"SystemArchitecture\" aspect that captures common pointcut expressions        for this purpose. A typical such aspect would look as follows:        package com.xyz.someapp;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class SystemArchitecture {  /**   * A join point is in the web layer if the method is defined   * in a type in the com.xyz.someapp.web package or any sub-package   * under that.   */  @Pointcut(\"within(com.xyz.someapp.web..*)\")  public void inWebLayer() {}  /**   * A join point is in the service layer if the method is defined   * in a type in the com.xyz.someapp.service package or any sub-package   * under that.   */  @Pointcut(\"within(com.xyz.someapp.service..*)\")  public void inServiceLayer() {}  /**   * A join point is in the data access layer if the method is defined   * in a type in the com.xyz.someapp.dao package or any sub-package   * under that.   */  @Pointcut(\"within(com.xyz.someapp.dao..*)\")  public void inDataAccessLayer() {}  /**   * A business service is the execution of any method defined on a service   * interface. This definition assumes that interfaces are placed in the   * \"service\" package, and that implementation types are in sub-packages.   *   * If you group service interfaces by functional area (for example,   * in packages com.xyz.someapp.abc.service and com.xyz.def.service) then   * the pointcut expression \"execution(* com.xyz.someapp..service.*.*(..))\"   * could be used instead.   *   * Alternatively, you can write the expression using the \'bean\'   * PCD, like so \"bean(*Service)\". (This assumes that you have   * named your Spring service beans in a consistent fashion.)   */  @Pointcut(\"execution(* com.xyz.someapp.service.*.*(..))\")  public void businessService() {}  /**   * A data access operation is the execution of any method defined on a   * dao interface. This definition assumes that interfaces are placed in the   * \"dao\" package, and that implementation types are in sub-packages.   */  @Pointcut(\"execution(* com.xyz.someapp.dao.*.*(..))\")  public void dataAccessOperation() {}}        \n\r\n\rThe pointcuts defined in such an aspect can be referred to        anywhere that you need a pointcut expression. For example, to make the        service layer transactional, you could write:        &lt;aop:config&gt;  &lt;aop:advisor      pointcut=\"com.xyz.someapp.SystemArchitecture.businessService()\"      advice-ref=\"tx-advice\"/&gt;&lt;/aop:config&gt;&lt;tx:advice id=\"tx-advice\"&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;        \n\r\n\rThe &lt;aop:config&gt; and        &lt;aop:advisor&gt; elements are discussed in Section&nbsp;9.3, &#8220;Schema-based AOP support&#8221;. The transaction elements are discussed in        Chapter&nbsp;12, Transaction Management.            Examples                \n\r\n\rSpring AOP users are likely to use the        execution pointcut designator the most often. The        format of an execution expression is:        execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)          throws-pattern?)        \n\r\n\rAll parts except the returning type pattern (ret-type-pattern in        the snippet above), name pattern, and parameters pattern are optional.        The returning type pattern determines what the return type of the        method must be in order for a join point to be matched. Most        frequently you will use * as the returning type        pattern, which matches any return type. A fully-qualified type name        will match only when the method returns the given type. The name        pattern matches the method name. You can use the *        wildcard as all or part of a name pattern. The parameters pattern is        slightly more complex: () matches a method that        takes no parameters, whereas (..) matches any        number of parameters (zero or more). The pattern        (*) matches a method taking one parameter of any        type, (*,String) matches a method taking two        parameters, the first can be of any type, the second must be a String.        Consult the         Language Semantics section of the AspectJ Programming Guide        for more information.        \n\r\n\rSome examples of common pointcut expressions are given        below.        \n\r            \n\r\n\rthe execution of any public method:            execution(public * *(..))          \n\r            \n\r\n\rthe execution of any method with a name beginning with            \"set\":            execution(* set*(..))          \n\r            \n\r\n\rthe execution of any method defined by the            AccountService interface:            execution(* com.xyz.service.AccountService.*(..))          \n\r            \n\r\n\rthe execution of any method defined in the service            package:            execution(* com.xyz.service.*.*(..))          \n\r            \n\r\n\rthe execution of any method defined in the service package            or a sub-package:            execution(* com.xyz.service..*.*(..))          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) within            the service package:            within(com.xyz.service.*)          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) within            the service package or a sub-package:            within(com.xyz.service..*)          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) where            the proxy implements the            AccountService interface:            this(com.xyz.service.AccountService)            \n\r\n\r\'this\' is more commonly used in a binding form :-            see the following section on advice for how to make the proxy            object available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) where            the target object implements the            AccountService interface:            target(com.xyz.service.AccountService)            \n\r\n\r\'target\' is more commonly used in a binding form :-            see the following section on advice for how to make the target            object available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) which            takes a single parameter, and where the argument passed at runtime            is Serializable:            args(java.io.Serializable)            \n\r\n\r\'args\' is more commonly used in a binding form :- see the            following section on advice for how to make the method arguments            available in the advice body.            \n\r\n\rNote that the pointcut given in this example is different to            execution(* *(java.io.Serializable)): the args            version matches if the argument passed at runtime is Serializable,            the execution version matches if the method signature declares a            single parameter of type            Serializable.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) where            the target object has an            @Transactional annotation:            @target(org.springframework.transaction.annotation.Transactional)            \n\r\n\r\'@target\' can also be used in a binding form :- see            the following section on advice for how to make the annotation            object available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) where            the declared type of the target object has an            @Transactional annotation:            @within(org.springframework.transaction.annotation.Transactional)            \n\r\n\r\'@within\' can also be used in a binding form :- see            the following section on advice for how to make the annotation            object available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) where            the executing method has an            @Transactional annotation:            @annotation(org.springframework.transaction.annotation.Transactional)            \n\r\n\r\'@annotation\' can also be used in a binding form :-            see the following section on advice for how to make the annotation            object available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) which            takes a single parameter, and where the runtime type of the            argument passed has the @Classified            annotation:            @args(com.xyz.security.Classified)            \n\r\n\r\'@args\' can also be used in a binding form :- see            the following section on advice for how to make the annotation            object(s) available in the advice body.          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) on a            Spring bean named \'tradeService\':            bean(tradeService)          \n\r            \n\r\n\rany join point (method execution only in Spring AOP) on            Spring beans having names that match the wildcard expression            \'*Service\':            bean(*Service)          \n\r            Writing good pointcuts                \n\r\n\rDuring compilation, AspectJ processes pointcuts in order to try and optimize matching performance. Examining code        and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic        match means the match cannot be fully determined from static analysis and a test will be placed in the code to        determine if there is an actual match when the code is running). On first encountering a pointcut declaration,        AspectJ will rewrite it into an optimal form for the matching process. What does this mean? Basically pointcuts        are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those        components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding        the performance of various pointcut designators and may supply them in any order in a pointcut declaration.        \n\r\n\rHowever, AspectJ can only work with what it is told, and for optimal performance of matching you should        think about what they are trying to achieve and narrow the search space for matches as much as possible in the        definition. The existing designators naturally fall into one of three groups: kinded, scoping and context:        \n\r\n\r\n\rKinded designators are those which select a particular kind of join point. For example: execution, get, set, call, handler\n\r\n\r\n\rScoping designators are those which select a group of join points of interest (of probably many kinds). For example: within, withincode\n\r\n\r\n\rContextual designators are those that match (and optionally bind) based on context. For example: this, target, @annotation\n\r        \n\r\n\rA well written pointcut should try and include at least the first two types (kinded and scoping), whilst        the contextual designators may be included if wishing to match based on join point context, or bind that context        for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but        could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping        designators are very fast to match and their usage means AspectJ can very quickly dismiss groups of        join points that should not be further processed - that is why a good pointcut should always include        one if possible.              9.2.4&nbsp;Declaring advice            \n\r\n\rAdvice is associated with a pointcut expression, and runs before,      after, or around method executions matched by the pointcut. The pointcut      expression may be either a simple reference to a named pointcut, or a      pointcut expression declared in place.      Before advice                \n\r\n\rBefore advice is declared in an aspect using the        @Before annotation:        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample {  @Before(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")  public void doAccessCheck() {    // ...  }}        \n\r\n\rIf using an in-place pointcut expression we could rewrite the        above example as:        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample {  @Before(\"execution(* com.xyz.myapp.dao.*.*(..))\")  public void doAccessCheck() {    // ...  }}            After returning advice                \n\r\n\rAfter returning advice runs when a matched method execution        returns normally. It is declared using the        @AfterReturning annotation:        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample {  @AfterReturning(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")  public void doAccessCheck() {    // ...  }}        \n\r\n\rNote: it is of course possible to have multiple advice        declarations, and other members as well, all inside the same aspect.        We\'re just showing a single advice declaration in these examples to        focus on the issue under discussion at the time.        \n\r\n\rSometimes you need access in the advice body to the actual value        that was returned. You can use the form of        @AfterReturning that binds the return        value for this:        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample {  @AfterReturning(    pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\",    returning=\"retVal\")  public void doAccessCheck(Object retVal) {    // ...  }}        \n\r\n\rThe name used in the returning attribute must        correspond to the name of a parameter in the advice method. When a        method execution returns, the return value will be passed to the        advice method as the corresponding argument value. A        returning clause also restricts matching to only        those method executions that return a value of the specified type        (Object in this case, which will match any        return value).        \n\r\n\rPlease note that it is not possible to        return a totally different reference when using after-returning        advice.            After throwing advice                \n\r\n\rAfter throwing advice runs when a matched method execution exits        by throwing an exception. It is declared using the        @AfterThrowing annotation:        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample {  @AfterThrowing(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")  public void doRecoveryActions() {    // ...  }}        \n\r\n\rOften you want the advice to run only when exceptions of a given        type are thrown, and you also often need access to the thrown        exception in the advice body. Use the throwing        attribute to both restrict matching (if desired, use        Throwable as the exception type        otherwise) and bind the thrown exception to an advice        parameter.        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample {  @AfterThrowing(    pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\",    throwing=\"ex\")  public void doRecoveryActions(DataAccessException ex) {    // ...  }}        \n\r\n\rThe name used in the throwing attribute must        correspond to the name of a parameter in the advice method. When a        method execution exits by throwing an exception, the exception will be        passed to the advice method as the corresponding argument value. A        throwing clause also restricts matching to only        those method executions that throw an exception of the specified type        (DataAccessException in this case).            After (finally) advice                \n\r\n\rAfter (finally) advice runs however a matched method execution        exits. It is declared using the @After        annotation. After advice must be prepared to handle both normal and        exception return conditions. It is typically used for releasing        resources, etc.        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.After;@Aspectpublic class AfterFinallyExample {  @After(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")  public void doReleaseLock() {    // ...  }}            Around advice                \n\r\n\rThe final kind of advice is around advice. Around advice runs        \"around\" a matched method execution. It has the opportunity to do work        both before and after the method executes, and to determine when, how,        and even if, the method actually gets to execute at all. Around advice        is often used if you need to share state before and after a method        execution in a thread-safe manner (starting and stopping a timer for        example). Always use the least powerful form of advice that meets your        requirements (i.e. don\'t use around advice if simple before advice        would do).        \n\r\n\rAround advice is declared using the        @Around annotation. The first parameter        of the advice method must be of type        ProceedingJoinPoint. Within the body of        the advice, calling proceed() on the        ProceedingJoinPoint causes the        underlying method to execute. The proceed method        may also be called passing in an Object[] - the        values in the array will be used as the arguments to the method        execution when it proceeds.        \n\r\n\rThe behavior of proceed when called with an        Object[] is a little different than the        behavior of proceed for around advice compiled by the AspectJ        compiler. For around advice written using the traditional AspectJ        language, the number of arguments passed to proceed must match the        number of arguments passed to the around advice (not the number of        arguments taken by the underlying join point), and the value passed to        proceed in a given argument position supplants the original value at        the join point for the entity the value was bound to (Don\'t worry if        this doesn\'t make sense right now!). The approach taken by Spring is        simpler and a better match to its proxy-based, execution only        semantics. You only need to be aware of this difference if you are        compiling @AspectJ aspects written for Spring and using proceed with        arguments with the AspectJ compiler and weaver. There is a way to        write such aspects that is 100% compatible across both Spring AOP and        AspectJ, and this is discussed in the following section on advice        parameters.        import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.ProceedingJoinPoint;@Aspectpublic class AroundExample {  @Around(\"com.xyz.myapp.SystemArchitecture.businessService()\")  public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {    // start stopwatch    Object retVal = pjp.proceed();    // stop stopwatch    return retVal;  }}        \n\r\n\rThe value returned by the around advice will be the return value        seen by the caller of the method. A simple caching aspect for example        could return a value from a cache if it has one, and invoke proceed()        if it does not. Note that proceed may be invoked once, many times, or        not at all within the body of the around advice, all of these are        quite legal.            Advice parameters                \n\r\n\rSpring 2.0 offers fully typed advice - meaning that you declare        the parameters you need in the advice signature (as we saw for the        returning and throwing examples above) rather than work with        Object[] arrays all the time. We\'ll see how to        make argument and other contextual values available to the advice body        in a moment. First let\'s take a look at how to write generic advice        that can find out about the method the advice is currently        advising.        Access to the current          JoinPoint                    \n\r\n\rAny advice method may declare as its first parameter, a          parameter of type          org.aspectj.lang.JoinPoint (please          note that around advice is required to declare          a first parameter of type          ProceedingJoinPoint, which is a          subclass of JoinPoint. The          JoinPoint interface provides a number          of useful methods such as getArgs() (returns the          method arguments), getThis() (returns the          proxy object), getTarget() (returns the          target object), getSignature() (returns a          description of the method that is being advised) and          toString() (prints a useful description of          the method being advised). Please do consult the Javadocs for full          details.                Passing parameters to advice                    \n\r\n\rWe\'ve already seen how to bind the returned value or exception          value (using after returning and after throwing advice). To make          argument values available to the advice body, you can use the          binding form of args. If a parameter name is used          in place of a type name in an args expression, then the value of the          corresponding argument will be passed as the parameter value when          the advice is invoked. An example should make this clearer. Suppose          you want to advise the execution of dao operations that take an          Account object as the first parameter, and you need access to the          account in the advice body. You could write the following:          @Before(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;\" +        \"args(account,..)\")public void validateAccount(Account account) {  // ...}          \n\r\n\rThe args(account,..) part of the pointcut          expression serves two purposes: firstly, it restricts matching to          only those method executions where the method takes at least one          parameter, and the argument passed to that parameter is an instance          of Account; secondly, it makes the actual          Account object available to the advice via          the account parameter.          \n\r\n\rAnother way of writing this is to declare a pointcut that          \"provides\" the Account object value when it          matches a join point, and then just refer to the named pointcut from          the advice. This would look as follows:          @Pointcut(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;\" +          \"args(account,..)\")private void accountDataAccessOperation(Account account) {}@Before(\"accountDataAccessOperation(account)\")public void validateAccount(Account account) {  // ...}          \n\r\n\rThe interested reader is once more referred to the AspectJ          programming guide for more details.          \n\r\n\rThe proxy object (this), target object          (target), and annotations (@within,          @target, @annotation, @args) can all be bound in a similar          fashion. The following example shows how you could match the          execution of methods annotated with an          @Auditable annotation, and extract          the audit code.          \n\r\n\rFirst the definition of the          @Auditable annotation:          @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable {    AuditCode value();}          \n\r\n\rAnd then the advice that matches the execution of          @Auditable methods:          @Before(\"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; \" +        \"@annotation(auditable)\")public void audit(Auditable auditable) {  AuditCode code = auditable.value();  // ...}                Advice parameters and generics                    \n\r\n\rSpring AOP can handle generics used in class declarations and          method parameters. Suppose you have a generic type like this:          public interface Sample&lt;T&gt; {  void sampleGenericMethod(T param);  void sampleGenericCollectionMethod(Collection&gt;T&gt; param);}          \n\r\n\rYou can restrict interception of method types to certain          parameter types by simply typing the advice parameter to the          parameter type you want to intercept the method for:          @Before(\"execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)\")public void beforeSampleMethod(MyType param) {  // Advice implementation}          \n\r\n\rThat this works is pretty obvious as we already discussed          above. However, it\'s worth pointing out that this won\'t work for          generic collections. So you cannot define a pointcut like          this:          @Before(\"execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)\")public void beforeSampleMethod(Collection&lt;MyType&gt; param) {  // Advice implementation}          \n\r\n\rTo make this work we would have to inspect every element of          the collection, which is not reasonable as we also cannot decide how          to treat null values in general. To achieve          something similar to this you have to type the parameter to          Collection&lt;?&gt; and manually          check the type of the elements.                Determining argument names                    \n\r\n\rThe parameter binding in advice invocations relies on matching          names used in pointcut expressions to declared parameter names in          (advice and pointcut) method signatures. Parameter names are          not available through Java reflection, so          Spring AOP uses the following strategies to determine parameter          names:          \n\r              \n\r\n\rIf the parameter names have been specified by the user              explicitly, then the specified parameter names are used: both              the advice and the pointcut annotations have an optional              \"argNames\" attribute which can be used to specify the argument              names of the annotated method - these argument names              are available at runtime. For              example:              @Before(   value=\"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)\",   argNames=\"bean,auditable\")public void audit(Object bean, Auditable auditable) {  AuditCode code = auditable.value();  // ... use code and bean}              \n\r\n\rIf the first parameter is of the              JoinPoint,              ProceedingJoinPoint, or              JoinPoint.StaticPart type, you              may leave out the name of the parameter from the value of the              \"argNames\" attribute. For example, if you modify the preceding              advice to receive the join point object, the \"argNames\"              attribute need not include it:              @Before(   value=\"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)\",   argNames=\"bean,auditable\")public void audit(JoinPoint jp, Object bean, Auditable auditable) {  AuditCode code = auditable.value();  // ... use code, bean, and jp}              \n\r\n\rThe special treatment given to the first parameter of the              JoinPoint,              ProceedingJoinPoint, and              JoinPoint.StaticPart types is              particularly convenient for advice that do not collect any other              join point context. In such situations, you may simply omit the              \"argNames\" attribute. For example, the following advice need not              declare the \"argNames\" attribute:              @Before(   \"com.xyz.lib.Pointcuts.anyPublicMethod()\")public void audit(JoinPoint jp) {  // ... use jp}            \n\r              \n\r\n\rUsing the \'argNames\' attribute is a              little clumsy, so if the \'argNames\' attribute              has not been specified, then Spring AOP will look at the debug              information for the class and try to determine the parameter              names from the local variable table. This information will be              present as long as the classes have been compiled with debug              information (\'-g:vars\' at a minimum). The              consequences of compiling with this flag on are: (1) your code              will be slightly easier to understand (reverse engineer), (2)              the class file sizes will be very slightly bigger (typically              inconsequential), (3) the optimization to remove unused local              variables will not be applied by your compiler. In other words,              you should encounter no difficulties building with this flag              on.              \n\r\n\rIf an @AspectJ aspect has been compiled by the AspectJ              compiler (ajc) even without the debug information then there is              no need to add the argNames attribute as the              compiler will retain the needed information.            \n\r              \n\r\n\rIf the code has been compiled without the necessary debug              information, then Spring AOP will attempt to deduce the pairing              of binding variables to parameters (for example, if only one              variable is bound in the pointcut expression, and the advice              method only takes one parameter, the pairing is obvious!). If              the binding of variables is ambiguous given the available              information, then an              AmbiguousBindingException will be              thrown.            \n\r              \n\r\n\rIf all of the above strategies fail then an              IllegalArgumentException will be              thrown.            \n\r                Proceeding with arguments                    \n\r\n\rWe remarked earlier that we would describe how to write a          proceed call with arguments that works          consistently across Spring AOP and AspectJ. The solution is simply          to ensure that the advice signature binds each of the method          parameters in order. For example:          @Around(\"execution(List&lt;Account&gt; find*(..)) &amp;&amp;\" +        \"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; \" +        \"args(accountHolderNamePattern)\")public Object preProcessQueryPattern(ProceedingJoinPoint pjp, String accountHolderNamePattern)throws Throwable {  String newPattern = preProcess(accountHolderNamePattern);  return pjp.proceed(new Object[] {newPattern});}          \n\r\n\rIn many cases you will be doing this binding anyway (as in the          example above).                    Advice ordering                \n\r\n\rWhat happens when multiple pieces of advice all want to run at        the same join point? Spring AOP follows the same precedence rules as        AspectJ to determine the order of advice execution. The highest        precedence advice runs first \"on the way in\" (so given two pieces of        before advice, the one with highest precedence runs first). \"On the        way out\" from a join point, the highest precedence advice runs last        (so given two pieces of after advice, the one with the highest        precedence will run second).        \n\r\n\rWhen two pieces of advice defined in        different aspects both need to run at the same        join point, unless you specify otherwise the order of execution is        undefined. You can control the order of execution by specifying        precedence. This is done in the normal Spring way by either        implementing the        org.springframework.core.Ordered        interface in the aspect class or annotating it with the        Order annotation. Given two aspects,        the aspect returning the lower value from        Ordered.getValue() (or the annotation value) has        the higher precedence.        \n\r\n\rWhen two pieces of advice defined in the        same aspect both need to run at the same join point, the        ordering is undefined (since there is no way to retrieve the        declaration order via reflection for javac-compiled classes). Consider        collapsing such advice methods into one advice method per join point        in each aspect class, or refactor the pieces of advice into separate        aspect classes - which can be ordered at the aspect level.              9.2.5&nbsp;Introductions            \n\r\n\rIntroductions (known as inter-type declarations in AspectJ) enable      an aspect to declare that advised objects implement a given interface,      and to provide an implementation of that interface on behalf of those      objects.      \n\r\n\rAn introduction is made using the      @DeclareParents annotation. This      annotation is used to declare that matching types have a new parent      (hence the name). For example, given an interface      UsageTracked, and an implementation of      that interface DefaultUsageTracked, the following      aspect declares that all implementors of service interfaces also      implement the UsageTracked interface. (In      order to expose statistics via JMX for example.)      @Aspectpublic class UsageTracking {  @DeclareParents(value=\"com.xzy.myapp.service.*+\",                  defaultImpl=DefaultUsageTracked.class)  public static UsageTracked mixin;  @Before(\"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp;\" +          \"this(usageTracked)\")  public void recordUsage(UsageTracked usageTracked) {    usageTracked.incrementUseCount();  }}      \n\r\n\rThe interface to be implemented is determined by the type of the      annotated field. The value attribute of the      @DeclareParents annotation is an AspectJ      type pattern :- any bean of a matching type will implement the      UsageTracked interface. Note that in the before advice of the above      example, service beans can be directly used as implementations of the      UsageTracked interface. If accessing a      bean programmatically you would write the following:      UsageTracked usageTracked = (UsageTracked) context.getBean(\"myService\");        9.2.6&nbsp;Aspect instantiation models            \n\r\n\r(This is an advanced topic, so if you are just starting out with      AOP you can safely skip it until later.)      \n\r\n\rBy default there will be a single instance of each aspect within      the application context. AspectJ calls this the singleton instantiation      model. It is possible to define aspects with alternate lifecycles :-      Spring supports AspectJ\'s perthis and      pertarget instantiation models (percflow,      percflowbelow, and pertypewithin are not      currently supported).      \n\r\n\rA \"perthis\" aspect is declared by specifying a      perthis clause in the      @Aspect annotation. Let\'s look at an      example, and then we\'ll explain how it works.      @Aspect(\"perthis(com.xyz.myapp.SystemArchitecture.businessService())\")public class MyAspect {  private int someState;  @Before(com.xyz.myapp.SystemArchitecture.businessService())  public void recordServiceUsage() {    // ...  }}      \n\r\n\rThe effect of the \'perthis\' clause is that one      aspect instance will be created for each unique service object executing      a business service (each unique object bound to \'this\' at join points      matched by the pointcut expression). The aspect instance is created the      first time that a method is invoked on the service object. The aspect      goes out of scope when the service object goes out of scope. Before the      aspect instance is created, none of the advice within it executes. As      soon as the aspect instance has been created, the advice declared within      it will execute at matched join points, but only when the service object      is the one this aspect is associated with. See the AspectJ programming      guide for more information on per-clauses.      \n\r\n\rThe \'pertarget\' instantiation model works in      exactly the same way as perthis, but creates one aspect instance for      each unique target object at matched join points.        9.2.7&nbsp;Example            \n\r\n\rNow that you have seen how all the constituent parts work, let\'s      put them together to do something useful!      \n\r\n\rThe execution of business services can sometimes fail due to      concurrency issues (for example, deadlock loser). If the operation is      retried, it is quite likely to succeed next time round. For business      services where it is appropriate to retry in such conditions (idempotent      operations that don\'t need to go back to the user for conflict      resolution), we\'d like to transparently retry the operation to avoid the      client seeing a      PessimisticLockingFailureException. This is a      requirement that clearly cuts across multiple services in the service      layer, and hence is ideal for implementing via an aspect.      \n\r\n\rBecause we want to retry the operation, we will need to use around      advice so that we can call proceed multiple times. Here\'s how the basic      aspect implementation looks:      @Aspectpublic class ConcurrentOperationExecutor implements Ordered {   private static final int DEFAULT_MAX_RETRIES = 2;   private int maxRetries = DEFAULT_MAX_RETRIES;   private int order = 1;   public void setMaxRetries(int maxRetries) {      this.maxRetries = maxRetries;   }   public int getOrder() {      return this.order;   }   public void setOrder(int order) {      this.order = order;   }   @Around(\"com.xyz.myapp.SystemArchitecture.businessService()\")   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {      int numAttempts = 0;      PessimisticLockingFailureException lockFailureException;      do {         numAttempts++;         try {            return pjp.proceed();         }         catch(PessimisticLockingFailureException ex) {            lockFailureException = ex;         }      }      while(numAttempts &lt;= this.maxRetries);      throw lockFailureException;   }}      \n\r\n\rNote that the aspect implements the      Ordered interface so we can set the      precedence of the aspect higher than the transaction advice (we want a      fresh transaction each time we retry). The maxRetries      and order properties will both be configured by      Spring. The main action happens in the      doConcurrentOperation around advice. Notice that for      the moment we\'re applying the retry logic to all      businessService()s. We try to proceed, and if we fail      with an PessimisticLockingFailureException we      simply try again unless we have exhausted all of our retry      attempts.      \n\r\n\rThe corresponding Spring configuration is:      &lt;aop:aspectj-autoproxy/&gt;&lt;bean id=\"concurrentOperationExecutor\"  class=\"com.xyz.myapp.service.impl.ConcurrentOperationExecutor\"&gt;     &lt;property name=\"maxRetries\" value=\"3\"/&gt;     &lt;property name=\"order\" value=\"100\"/&gt;&lt;/bean&gt;      \n\r\n\rTo refine the aspect so that it only retries idempotent      operations, we might define an Idempotent      annotation:      @Retention(RetentionPolicy.RUNTIME)public @interface Idempotent {  // marker annotation}      \n\r\n\rand use the annotation to annotate the implementation of service      operations. The change to the aspect to only retry idempotent operations      simply involves refining the pointcut expression so that only      @Idempotent operations match:      @Around(\"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; \" +        \"@annotation(com.xyz.myapp.service.Idempotent)\")public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {  ...}        9.3&nbsp;Schema-based AOP support        \n\r\n\rIf you are unable to use Java 5, or simply prefer an XML-based    format, then Spring 2.0 also offers support for defining aspects using the    new \"aop\" namespace tags. The exact same pointcut expressions and advice    kinds are supported as when using the @AspectJ style, hence in this    section we will focus on the new syntax and refer the    reader to the discussion in the previous section (Section&nbsp;9.2, &#8220;@AspectJ support&#8221;) for an understanding of writing pointcut    expressions and the binding of advice parameters.    \n\r\n\rTo use the aop namespace tags described in this section, you need to    import the spring-aop schema as described in Appendix&nbsp;E, XML Schema-based configuration. See Section&nbsp;E.2.7, &#8220;The aop schema&#8221; for how to import the tags in the    aop namespace.    \n\r\n\rWithin your Spring configurations, all aspect and advisor elements    must be placed within an &lt;aop:config&gt; element    (you can have more than one &lt;aop:config&gt; element    in an application context configuration). An    &lt;aop:config&gt; element can contain pointcut,    advisor, and aspect elements (note these must be declared in that    order).    Warning      \n\r\n\rThe &lt;aop:config&gt; style of configuration      makes heavy use of Spring\'s auto-proxying mechanism. This can cause      issues (such as advice not being woven) if you are already using      explicit auto-proxying via the use of      BeanNameAutoProxyCreator or suchlike. The      recommended usage pattern is to use either just the      &lt;aop:config&gt; style, or just the      AutoProxyCreator style.        9.3.1&nbsp;Declaring an aspect            \n\r\n\rUsing the schema support, an aspect is simply a regular Java      object defined as a bean in your Spring application context. The state      and behavior is captured in the fields and methods of the object, and      the pointcut and advice information is captured in the XML.      \n\r\n\rAn aspect is declared using the &lt;aop:aspect&gt; element, and      the backing bean is referenced using the ref      attribute:      &lt;aop:config&gt;  &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt;    ...  &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"aBean\" class=\"...\"&gt;  ...&lt;/bean&gt;      \n\r\n\rThe bean backing the aspect (\"aBean\" in this      case) can of course be configured and dependency injected just like any      other Spring bean.        9.3.2&nbsp;Declaring a pointcut            \n\r\n\rA named pointcut can be declared inside an &lt;aop:config&gt;      element, enabling the pointcut definition to be shared across several      aspects and advisors.      \n\r\n\rA pointcut representing the execution of any business service in      the service layer could be defined as follows:      &lt;aop:config&gt;  &lt;aop:pointcut id=\"businessService\"        expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt;&lt;/aop:config&gt;      \n\r\n\rNote that the pointcut expression itself is using the same AspectJ      pointcut expression language as described in Section&nbsp;9.2, &#8220;@AspectJ support&#8221;. If you are using the schema based      declaration style with Java 5, you can refer to named pointcuts defined      in types (@Aspects) within the pointcut expression, but this feature is      not available on JDK 1.4 and below (it relies on the Java 5 specific      AspectJ reflection APIs). On JDK 1.5 therefore, another way of defining      the above pointcut would be:      &lt;aop:config&gt;  &lt;aop:pointcut id=\"businessService\"        expression=\"com.xyz.myapp.SystemArchitecture.businessService()\"/&gt;&lt;/aop:config&gt;      \n\r\n\rAssuming you have a SystemArchitecture aspect      as described in the section called &#8220;Sharing common pointcut definitions&#8221;.      \n\r\n\rDeclaring a pointcut inside an aspect is very similar to declaring      a top-level pointcut:      &lt;aop:config&gt;  &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt;    &lt;aop:pointcut id=\"businessService\"          expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt;    ...  &lt;/aop:aspect&gt;&lt;/aop:config&gt;      \n\r\n\rMuch the same way in an @AspectJ aspect, pointcuts declared using      the schema based definition style may collect join point context. For      example, the following pointcut collects the \'this\' object as the join      point context and passes it to advice:      &lt;aop:config&gt;  &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt;    &lt;aop:pointcut id=\"businessService\"          expression=\"execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)\"/&gt;    &lt;aop:before pointcut-ref=\"businessService\" method=\"monitor\"/&gt;    ...  &lt;/aop:aspect&gt;&lt;/aop:config&gt;      \n\r\n\rThe advice must be declared to receive the collected join point      context by including parameters of the matching names:      public void monitor(Object service) {    ...}      \n\r\n\rWhen combining pointcut sub-expressions, \'&amp;&amp;\' is awkward      within an XML document, and so the keywords \'and\', \'or\' and \'not\' can be      used in place of \'&amp;&amp;\', \'||\' and \'!\' respectively. For example,      the previous pointcut may be better written as:      &lt;aop:config&gt;  &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt;    &lt;aop:pointcut id=\"businessService\"          expression=\"execution(* com.xyz.myapp.service.*.*(..)) and this(service)\"/&gt;    &lt;aop:before pointcut-ref=\"businessService\" method=\"monitor\"/&gt;    ...  &lt;/aop:aspect&gt;&lt;/aop:config&gt;      \n\r\n\rNote that pointcuts defined in this way are referred to by their      XML id and cannot be used as named pointcuts to form composite      pointcuts. The named pointcut support in the schema based definition      style is thus more limited than that offered by the @AspectJ      style.        9.3.3&nbsp;Declaring advice            \n\r\n\rThe same five advice kinds are supported as for the @AspectJ      style, and they have exactly the same semantics.      Before advice                \n\r\n\rBefore advice runs before a matched method execution. It is        declared inside an &lt;aop:aspect&gt; using the        &lt;aop:before&gt; element.        &lt;aop:aspect id=\"beforeExample\" ref=\"aBean\"&gt;    &lt;aop:before      pointcut-ref=\"dataAccessOperation\"      method=\"doAccessCheck\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rHere dataAccessOperation is the id of a        pointcut defined at the top (&lt;aop:config&gt;)        level. To define the pointcut inline instead, replace the        pointcut-ref attribute with a        pointcut attribute:        &lt;aop:aspect id=\"beforeExample\" ref=\"aBean\"&gt;    &lt;aop:before      pointcut=\"execution(* com.xyz.myapp.dao.*.*(..))\"      method=\"doAccessCheck\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rAs we noted in the discussion of the @AspectJ style, using named        pointcuts can significantly improve the readability of your        code.        \n\r\n\rThe method attribute identifies a method        (doAccessCheck) that provides the body of the        advice. This method must be defined for the bean referenced by the        aspect element containing the advice. Before a data access operation        is executed (a method execution join point matched by the pointcut        expression), the \"doAccessCheck\" method on the aspect bean will be        invoked.            After returning advice                \n\r\n\rAfter returning advice runs when a matched method execution        completes normally. It is declared inside an        &lt;aop:aspect&gt; in the same way as before        advice. For example:        &lt;aop:aspect id=\"afterReturningExample\" ref=\"aBean\"&gt;    &lt;aop:after-returning      pointcut-ref=\"dataAccessOperation\"      method=\"doAccessCheck\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rJust as in the @AspectJ style, it is possible to get hold of the        return value within the advice body. Use the returning attribute to        specify the name of the parameter to which the return value should be        passed:        &lt;aop:aspect id=\"afterReturningExample\" ref=\"aBean\"&gt;    &lt;aop:after-returning      pointcut-ref=\"dataAccessOperation\"      returning=\"retVal\"      method=\"doAccessCheck\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rThe doAccessCheck method must declare a parameter named        retVal. The type of this parameter constrains        matching in the same way as described for @AfterReturning. For        example, the method signature may be declared as:        public void doAccessCheck(Object retVal) {...            After throwing advice                \n\r\n\rAfter throwing advice executes when a matched method execution        exits by throwing an exception. It is declared inside an        &lt;aop:aspect&gt; using the after-throwing        element:        &lt;aop:aspect id=\"afterThrowingExample\" ref=\"aBean\"&gt;    &lt;aop:after-throwing      pointcut-ref=\"dataAccessOperation\"      method=\"doRecoveryActions\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rJust as in the @AspectJ style, it is possible to get hold of the        thrown exception within the advice body. Use the throwing attribute to        specify the name of the parameter to which the exception should be        passed:        &lt;aop:aspect id=\"afterThrowingExample\" ref=\"aBean\"&gt;    &lt;aop:after-throwing      pointcut-ref=\"dataAccessOperation\"      throwing=\"dataAccessEx\"      method=\"doRecoveryActions\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rThe doRecoveryActions method must declare a parameter named        dataAccessEx. The type of this parameter constrains        matching in the same way as described for @AfterThrowing. For example,        the method signature may be declared as:        public void doRecoveryActions(DataAccessException dataAccessEx) {...            After (finally) advice                \n\r\n\rAfter (finally) advice runs however a matched method execution        exits. It is declared using the after        element:        &lt;aop:aspect id=\"afterFinallyExample\" ref=\"aBean\"&gt;    &lt;aop:after      pointcut-ref=\"dataAccessOperation\"      method=\"doReleaseLock\"/&gt;    ...&lt;/aop:aspect&gt;            Around advice                \n\r\n\rThe final kind of advice is around advice. Around advice runs        \"around\" a matched method execution. It has the opportunity to do work        both before and after the method executes, and to determine when, how,        and even if, the method actually gets to execute at all. Around advice        is often used if you need to share state before and after a method        execution in a thread-safe manner (starting and stopping a timer for        example). Always use the least powerful form of advice that meets your        requirements; don\'t use around advice if simple before advice would        do.        \n\r\n\rAround advice is declared using the        aop:around element. The first parameter of the        advice method must be of type        ProceedingJoinPoint. Within the body of        the advice, calling proceed() on the        ProceedingJoinPoint causes the        underlying method to execute. The proceed method        may also be calling passing in an Object[] -        the values in the array will be used as the arguments to the method        execution when it proceeds. See the section called &#8220;Around advice&#8221; for notes on calling proceed        with an Object[].        &lt;aop:aspect id=\"aroundExample\" ref=\"aBean\"&gt;    &lt;aop:around      pointcut-ref=\"businessService\"      method=\"doBasicProfiling\"/&gt;    ...&lt;/aop:aspect&gt;        \n\r\n\rThe implementation of the doBasicProfiling        advice would be exactly the same as in the @AspectJ example (minus the        annotation of course):        public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {    // start stopwatch    Object retVal = pjp.proceed();    // stop stopwatch    return retVal;}            Advice parameters                \n\r\n\rThe schema based declaration style supports fully typed advice        in the same way as described for the @AspectJ support - by matching        pointcut parameters by name against advice method parameters. See        the section called &#8220;Advice parameters&#8221; for details. If you        wish to explicitly specify argument names for the advice methods (not        relying on the detection strategies previously described) then this is        done using the arg-names attribute of the advice        element, which is treated in the same manner to the \"argNames\"        attribute in an advice annotation as described in the section called &#8220;Determining argument names&#8221;. For example:        &lt;aop:before  pointcut=\"com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)\"  method=\"audit\"  arg-names=\"auditable\"/&gt;        \n\r\n\rThe arg-names attribute accepts a        comma-delimited list of parameter names.        \n\r\n\rFind below a slightly more involved example of the XSD-based        approach that illustrates some around advice used in conjunction with        a number of strongly typed parameters.        package x.y.service;public interface FooService {   Foo getFoo(String fooName, int age);}public class DefaultFooService implements FooService {   public Foo getFoo(String name, int age) {      return new Foo(name, age);   }}        \n\r\n\rNext up is the aspect. Notice the fact that the        profile(..) method accepts a number of        strongly-typed parameters, the first of which happens to be the join        point used to proceed with the method call: the presence of this        parameter is an indication that the        profile(..) is to be used as        around advice:        package x.y;import org.aspectj.lang.ProceedingJoinPoint;import org.springframework.util.StopWatch;public class SimpleProfiler {   public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {      StopWatch clock = new StopWatch(            \"Profiling for \'\" + name + \"\' and \'\" + age + \"\'\");      try {         clock.start(call.toShortString());         return call.proceed();      } finally {         clock.stop();         System.out.println(clock.prettyPrint());      }   }}        \n\r\n\rFinally, here is the XML configuration that is required to        effect the execution of the above advice for a particular join        point:        &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:aop=\"http://www.springframework.org/schema/aop\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;   &lt;!-- this is the object that will be proxied by Spring\'s AOP infrastructure --&gt;   &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;   &lt;!-- this is the actual advice itself --&gt;   &lt;bean id=\"profiler\" class=\"x.y.SimpleProfiler\"/&gt;   &lt;aop:config&gt;      &lt;aop:aspect ref=\"profiler\"&gt;         &lt;aop:pointcut id=\"theExecutionOfSomeFooServiceMethod\"                    expression=\"execution(* x.y.service.FooService.getFoo(String,int))                    and args(name, age)\"/&gt;         &lt;aop:around pointcut-ref=\"theExecutionOfSomeFooServiceMethod\"                  method=\"profile\"/&gt;      &lt;/aop:aspect&gt;   &lt;/aop:config&gt;&lt;/beans&gt;        \n\r\n\rIf we had the following driver script, we would get output        something like this on standard output:        import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;import x.y.service.FooService;public final class Boot {   public static void main(final String[] args) throws Exception {      BeanFactory ctx = new ClassPathXmlApplicationContext(\"x/y/plain.xml\");      FooService foo = (FooService) ctx.getBean(\"fooService\");      foo.getFoo(\"Pengo\", 12);   }}        StopWatch \'Profiling for \'Pengo\' and \'12\'\': running time (millis) = 0-----------------------------------------ms     %     Task name-----------------------------------------00000  ?  execution(getFoo)            Advice ordering                \n\r\n\rWhen multiple advice needs to execute at the same join point        (executing method) the ordering rules are as described in the section called &#8220;Advice ordering&#8221;. The precedence between        aspects is determined by either adding the        Order annotation to the bean backing        the aspect or by having the bean implement the        Ordered interface.              9.3.4&nbsp;Introductions            \n\r\n\rIntroductions (known as inter-type declarations in AspectJ) enable      an aspect to declare that advised objects implement a given interface,      and to provide an implementation of that interface on behalf of those      objects.      \n\r\n\rAn introduction is made using the      aop:declare-parents element inside an      aop:aspect This element is used to declare that      matching types have a new parent (hence the name). For example, given an      interface UsageTracked, and an      implementation of that interface      DefaultUsageTracked, the following aspect      declares that all implementors of service interfaces also implement the      UsageTracked interface. (In order to      expose statistics via JMX for example.)      &lt;aop:aspect id=\"usageTrackerAspect\" ref=\"usageTracking\"&gt;  &lt;aop:declare-parents      types-matching=\"com.xzy.myapp.service.*+\"      implement-interface=\"com.xyz.myapp.service.tracking.UsageTracked\"      default-impl=\"com.xyz.myapp.service.tracking.DefaultUsageTracked\"/&gt;  &lt;aop:before    pointcut=\"com.xyz.myapp.SystemArchitecture.businessService()              and this(usageTracked)\"    method=\"recordUsage\"/&gt;&lt;/aop:aspect&gt;      \n\r\n\rThe class backing the usageTracking bean would      contain the method:      public void recordUsage(UsageTracked usageTracked) {    usageTracked.incrementUseCount();}      \n\r\n\rThe interface to be implemented is determined by      implement-interface attribute. The value of the      types-matching attribute is an AspectJ type pattern      :- any bean of a matching type will implement the      UsageTracked interface. Note that in the      before advice of the above example, service beans can be directly used      as implementations of the UsageTracked      interface. If accessing a bean programmatically you would write the      following:      UsageTracked usageTracked = (UsageTracked) context.getBean(\"myService\");        9.3.5&nbsp;Aspect instantiation models            \n\r\n\rThe only supported instantiation model for schema-defined aspects      is the singleton model. Other instantiation models may be supported in      future releases.        9.3.6&nbsp;Advisors            \n\r\n\rThe concept of \"advisors\" is brought forward from the AOP support      defined in Spring 1.2 and does not have a direct equivalent in AspectJ.      An advisor is like a small self-contained aspect that has a single piece      of advice. The advice itself is represented by a bean, and must      implement one of the advice interfaces described in Section&nbsp;10.3.2, &#8220;Advice types in Spring&#8221;. Advisors can take advantage of      AspectJ pointcut expressions though.      \n\r\n\rSpring 2.0 supports the advisor concept with the      &lt;aop:advisor&gt; element. You will most commonly      see it used in conjunction with transactional advice, which also has its      own namespace support in Spring 2.0. Here\'s how it looks:      &lt;aop:config&gt;  &lt;aop:pointcut id=\"businessService\"        expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt;  &lt;aop:advisor      pointcut-ref=\"businessService\"      advice-ref=\"tx-advice\"/&gt;&lt;/aop:config&gt;&lt;tx:advice id=\"tx-advice\"&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;      \n\r\n\rAs well as the pointcut-ref attribute used in the      above example, you can also use the pointcut attribute      to define a pointcut expression inline.      \n\r\n\rTo define the precedence of an advisor so that the advice can      participate in ordering, use the order attribute to      define the Ordered value of the advisor.        9.3.7&nbsp;Example            \n\r\n\rLet\'s see how the concurrent locking failure retry example from      Section&nbsp;9.2.7, &#8220;Example&#8221; looks when rewritten using the      schema support.      \n\r\n\rThe execution of business services can sometimes fail due to      concurrency issues (for example, deadlock loser). If the operation is      retried, it is quite likely it will succeed next time round. For      business services where it is appropriate to retry in such conditions      (idempotent operations that don\'t need to go back to the user for      conflict resolution), we\'d like to transparently retry the operation to      avoid the client seeing a      PessimisticLockingFailureException. This is a      requirement that clearly cuts across multiple services in the service      layer, and hence is ideal for implementing via an aspect.      \n\r\n\rBecause we want to retry the operation, we\'ll need to use around      advice so that we can call proceed multiple times. Here\'s how the basic      aspect implementation looks (it\'s just a regular Java class using the      schema support):      public class ConcurrentOperationExecutor implements Ordered {   private static final int DEFAULT_MAX_RETRIES = 2;   private int maxRetries = DEFAULT_MAX_RETRIES;   private int order = 1;   public void setMaxRetries(int maxRetries) {      this.maxRetries = maxRetries;   }   public int getOrder() {      return this.order;   }   public void setOrder(int order) {      this.order = order;   }   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {      int numAttempts = 0;      PessimisticLockingFailureException lockFailureException;      do {         numAttempts++;         try {            return pjp.proceed();         }         catch(PessimisticLockingFailureException ex) {            lockFailureException = ex;         }      }      while(numAttempts &lt;= this.maxRetries);      throw lockFailureException;   }}      \n\r\n\rNote that the aspect implements the      Ordered interface so we can set the      precedence of the aspect higher than the transaction advice (we want a      fresh transaction each time we retry). The maxRetries      and order properties will both be configured by      Spring. The main action happens in the      doConcurrentOperation around advice method. We try to      proceed, and if we fail with a      PessimisticLockingFailureException we simply try      again unless we have exhausted all of our retry attempts.      \n\r\n\rThis class is identical to the one used in the @AspectJ example,      but with the annotations removed.      \n\r\n\rThe corresponding Spring configuration is:      &lt;aop:config&gt;  &lt;aop:aspect id=\"concurrentOperationRetry\" ref=\"concurrentOperationExecutor\"&gt;    &lt;aop:pointcut id=\"idempotentOperation\"        expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt;    &lt;aop:around       pointcut-ref=\"idempotentOperation\"       method=\"doConcurrentOperation\"/&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"concurrentOperationExecutor\"  class=\"com.xyz.myapp.service.impl.ConcurrentOperationExecutor\"&gt;     &lt;property name=\"maxRetries\" value=\"3\"/&gt;     &lt;property name=\"order\" value=\"100\"/&gt;&lt;/bean&gt;      \n\r\n\rNotice that for the time being we assume that all business      services are idempotent. If this is not the case we can refine the      aspect so that it only retries genuinely idempotent operations, by      introducing an Idempotent      annotation:      @Retention(RetentionPolicy.RUNTIME)public @interface Idempotent {  // marker annotation}      \n\r\n\rand using the annotation to annotate the implementation of service      operations. The change to the aspect to retry only idempotent operations      simply involves refining the pointcut expression so that only      @Idempotent operations match:        &lt;aop:pointcut id=\"idempotentOperation\"        expression=\"execution(* com.xyz.myapp.service.*.*(..)) and                    @annotation(com.xyz.myapp.service.Idempotent)\"/&gt;        9.4&nbsp;Choosing which AOP declaration style to use        \n\r\n\rOnce you have decided that an aspect is the best approach for    implementing a given requirement, how do you decide between using Spring    AOP or AspectJ, and between the Aspect language (code) style, @AspectJ    annotation style, or the Spring XML style? These decisions are influenced    by a number of factors including application requirements, development    tools, and team familiarity with AOP.    9.4.1&nbsp;Spring AOP or full AspectJ?            \n\r\n\rUse the simplest thing that can work. Spring AOP is simpler than      using full AspectJ as there is no requirement to introduce the AspectJ      compiler / weaver into your development and build processes. If you only      need to advise the execution of operations on Spring beans, then Spring      AOP is the right choice. If you need to advise objects not managed by      the Spring container (such as domain objects typically), then you will      need to use AspectJ. You will also need to use AspectJ if you wish to      advise join points other than simple method executions (for example,      field get or set join points, and so on).      \n\r\n\rWhen using AspectJ, you have the choice of the AspectJ language      syntax (also known as the \"code style\") or the @AspectJ annotation      style. Clearly, if you are not using Java 5+ then the choice has been      made for you... use the code style. If aspects play a large role in your      design, and you are able to use the AspectJ Development Tools      (AJDT) plugin for Eclipse, then the AspectJ language syntax is      the preferred option: it is cleaner and simpler because the language was      purposefully designed for writing aspects. If you are not using Eclipse,      or have only a few aspects that do not play a major role in your      application, then you may want to consider using the @AspectJ style and      sticking with a regular Java compilation in your IDE, and adding an      aspect weaving phase to your build script.        9.4.2&nbsp;@AspectJ or XML for Spring AOP?            \n\r\n\rIf you have chosen to use Spring AOP, then you have a choice of      @AspectJ or XML style. Clearly if you are not running on Java 5+, then      the XML style is the appropriate choice; for Java 5 projects there are      various tradeoffs to consider.      \n\r\n\rThe XML style will be most familiar to existing Spring users. It      can be used with any JDK level (referring to named pointcuts from within      pointcut expressions does still require Java 5+ though) and is backed by      genuine POJOs. When using AOP as a tool to configure enterprise services      then XML can be a good choice (a good test is whether you consider the      pointcut expression to be a part of your configuration you might want to      change independently). With the XML style arguably it is clearer from      your configuration what aspects are present in the system.      \n\r\n\rThe XML style has two disadvantages. Firstly it does not fully      encapsulate the implementation of the requirement it addresses in a      single place. The DRY principle says that there should be a single,      unambiguous, authoritative representation of any piece of knowledge      within a system. When using the XML style, the knowledge of      how a requirement is implemented is split across      the declaration of the backing bean class, and the XML in the      configuration file. When using the @AspectJ style there is a single      module - the aspect - in which this information is encapsulated.      Secondly, the XML style is slightly more limited in what it can express      than the @AspectJ style: only the \"singleton\" aspect instantiation model      is supported, and it is not possible to combine named pointcuts declared      in XML. For example, in the @AspectJ style you can write something      like:        @Pointcut(execution(* get*()))  public void propertyAccess() {}  @Pointcut(execution(org.xyz.Account+ *(..))  public void operationReturningAnAccount() {}  @Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount())  public void accountPropertyAccess() {}      \n\r\n\rIn the XML style I can declare the first two pointcuts:        &lt;aop:pointcut id=\"propertyAccess\"      expression=\"execution(* get*())\"/&gt;  &lt;aop:pointcut id=\"operationReturningAnAccount\"      expression=\"execution(org.xyz.Account+ *(..))\"/&gt;      \n\r\n\rThe downside of the XML approach is that you cannot define the      \'accountPropertyAccess\' pointcut by combining these      definitions.      \n\r\n\rThe @AspectJ style supports additional instantiation models, and      richer pointcut composition. It has the advantage of keeping the aspect      as a modular unit. It also has the advantage the @AspectJ aspects can be      understood (and thus consumed) both by Spring AOP and by AspectJ - so if      you later decide you need the capabilities of AspectJ to implement      additional requirements then it is very easy to migrate to an      AspectJ-based approach. On balance the Spring team prefer the @AspectJ      style whenever you have aspects that do more than simple \"configuration\"      of enterprise services.        9.5&nbsp;Mixing aspect types        \n\r\n\rIt is perfectly possible to mix @AspectJ style aspects using the    autoproxying support, schema-defined &lt;aop:aspect&gt;    aspects, &lt;aop:advisor&gt; declared advisors and even    proxies and interceptors defined using the Spring 1.2 style in the same    configuration. All of these are implemented using the same underlying    support mechanism and will co-exist without any difficulty.    9.6&nbsp;Proxying mechanisms        \n\r\n\rSpring AOP uses either JDK dynamic proxies or CGLIB to create the    proxy for a given target object. (JDK dynamic proxies are preferred    whenever you have a choice).    \n\r\n\rIf the target object to be proxied implements at least one interface    then a JDK dynamic proxy will be used. All of the interfaces implemented    by the target type will be proxied. If the target object does not    implement any interfaces then a CGLIB proxy will be created.    \n\r\n\rIf you want to force the use of CGLIB proxying (for example, to    proxy every method defined for the target object, not just those    implemented by its interfaces) you can do so. However, there are some    issues to consider:    \n\r        \n\r\n\rfinal methods cannot be advised, as they        cannot be overridden.      \n\r        \n\r\n\rAs of Spring 3.2, it is no longer necessary to add CGLIB to your        project classpath, as CGLIB classes are repackaged under        org.springframework and included directly in the spring-core JAR. This        means that CGLIB-based proxy support \'just works\' in the same way that        JDK dynamic proxies always have.              \n\r        \n\r\n\rThe constructor of your proxied object will be called twice.        This is a natural consequence of the CGLIB proxy model whereby a        subclass is generated for each proxied object. For each proxied        instance, two objects are created: the actual proxied object and an        instance of the subclass that implements the advice. This behavior is        not exhibited when using JDK proxies. Usually, calling the constructor        of the proxied type twice, is not an issue, as there are usually only        assignments taking place and no real logic is implemented in the        constructor.      \n\r    \n\r\n\rTo force the use of CGLIB proxies set    the value of the proxy-target-class attribute of the    &lt;aop:config&gt; element to true:        &lt;aop:config proxy-target-class=\"true\"&gt;    &lt;!-- other beans defined here... --&gt;&lt;/aop:config&gt;    \n\r\n\rTo force CGLIB proxying when using the @AspectJ autoproxy support,    set the \'proxy-target-class\' attribute of the    &lt;aop:aspectj-autoproxy&gt; element to    true:        &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;    Note      \n\r\n\rMultiple &lt;aop:config/&gt; sections are      collapsed into a single unified auto-proxy creator at runtime, which      applies the strongest proxy settings that any of      the &lt;aop:config/&gt; sections (typically from      different XML bean definition files) specified. This also applies to the      &lt;tx:annotation-driven/&gt; and      &lt;aop:aspectj-autoproxy/&gt; elements.      \n\r\n\rTo be clear: using \'proxy-target-class=\"true\"\'      on &lt;tx:annotation-driven/&gt;,      &lt;aop:aspectj-autoproxy/&gt; or      &lt;aop:config/&gt; elements will force the use of      CGLIB proxies for all three of them.        9.6.1&nbsp;Understanding AOP proxies            \n\r\n\rSpring AOP is proxy-based. It is vitally      important that you grasp the semantics of what that last statement      actually means before you write your own aspects or use any of the      Spring AOP-based aspects supplied with the Spring Framework.      \n\r\n\rConsider first the scenario where you have a plain-vanilla,      un-proxied, nothing-special-about-it, straight object reference, as      illustrated by the following code snippet.      public class SimplePojo implements Pojo {   public void foo() {      // this next method invocation is a direct      call on the \'this\' reference      this.bar();   }   public void bar() {      // some logic...   }}      \n\r\n\rIf you invoke a method on an object reference, the method is      invoked directly on that object reference, as can      be seen below.            public class Main {   public static void main(String[] args) {      Pojo pojo = new SimplePojo();      // this is a direct method call on the \'pojo\' reference      pojo.foo();   }}      \n\r\n\rThings change slightly when the reference that client code has is      a proxy. Consider the following diagram and code snippet.            public class Main {   public static void main(String[] args) {      ProxyFactory factory = new ProxyFactory(new SimplePojo());      factory.addInterface(Pojo.class);      factory.addAdvice(new RetryAdvice());      Pojo pojo = (Pojo) factory.getProxy();      // this is a method call on the proxy!      pojo.foo();   }}      \n\r\n\rThe key thing to understand here is that the client code inside      the main(..) of the Main      class has a reference to the proxy. This means that      method calls on that object reference will be calls on the proxy, and as      such the proxy will be able to delegate to all of the interceptors      (advice) that are relevant to that particular method call. However, once      the call has finally reached the target object, the      SimplePojo reference in this case, any method      calls that it may make on itself, such as      this.bar() or      this.foo(), are going to be invoked against the      this reference, and      not the proxy. This has important implications. It      means that self-invocation is not going to result      in the advice associated with a method invocation getting a chance to      execute.      \n\r\n\rOkay, so what is to be done about this? The best approach (the      term best is used loosely here) is to refactor your code such that the      self-invocation does not happen. For sure, this does entail some work on      your part, but it is the best, least-invasive approach. The next      approach is absolutely horrendous, and I am almost reticent to point it      out precisely because it is so horrendous. You can (choke!) totally tie      the logic within your class to Spring AOP by doing this:      public class SimplePojo implements Pojo {   public void foo() {      // this works, but... gah!      ((Pojo) AopContext.currentProxy()).bar();   }   public void bar() {      // some logic...   }}      \n\r\n\rThis totally couples your code to Spring AOP,      and it makes the class itself aware of the fact      that it is being used in an AOP context, which flies in the face of AOP.      It also requires some additional configuration when the proxy is being      created:      public class Main {   public static void main(String[] args) {      ProxyFactory factory = new ProxyFactory(new SimplePojo());      factory.adddInterface(Pojo.class);      factory.addAdvice(new RetryAdvice());      factory.setExposeProxy(true);      Pojo pojo = (Pojo) factory.getProxy();      // this is a method call on the proxy!      pojo.foo();   }}      \n\r\n\rFinally, it must be noted that AspectJ does not have this      self-invocation issue because it is not a proxy-based AOP      framework.        9.7&nbsp;Programmatic creation of @AspectJ Proxies        \n\r\n\rIn addition to declaring aspects in your configuration using either    &lt;aop:config&gt; or    &lt;aop:aspectj-autoproxy&gt;, it is also possible    programmatically to create proxies that advise target objects. For the    full details of Spring\'s AOP API, see the next chapter. Here we want to    focus on the ability to automatically create proxies using @AspectJ    aspects.    \n\r\n\rThe class    org.springframework.aop.aspectj.annotation.AspectJProxyFactory    can be used to create a proxy for a target object that is advised by one    or more @AspectJ aspects. Basic usage for this class is very simple, as    illustrated below. See the Javadocs for full information.    // create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);// now get the proxy object...MyInterfaceType proxy = factory.getProxy();    9.8&nbsp;Using AspectJ with Spring applications        \n\r\n\rEverything we\'ve covered so far in this chapter is pure Spring AOP.    In this section, we\'re going to look at how you can use the AspectJ    compiler/weaver instead of, or in addition to, Spring AOP if your needs go    beyond the facilities offered by Spring AOP alone.    \n\r\n\rSpring ships with a small AspectJ aspect library, which is available    standalone in your distribution as spring-aspects.jar; you\'ll need to add this    to your classpath in order to use the aspects in it. Section&nbsp;9.8.1, &#8220;Using AspectJ to dependency inject domain objects with      Spring&#8221; and Section&nbsp;9.8.2, &#8220;Other Spring aspects for AspectJ&#8221;    discuss the content of this library and how you can use it. Section&nbsp;9.8.3, &#8220;Configuring AspectJ aspects using Spring IoC&#8221; discusses how to dependency inject AspectJ    aspects that are woven using the AspectJ compiler. Finally, Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221; provides an introduction to load-time weaving for    Spring applications using AspectJ.    9.8.1&nbsp;Using AspectJ to dependency inject domain objects with      Spring            \n\r\n\rThe Spring container instantiates and configures beans defined in      your application context. It is also possible to ask a bean factory to      configure a pre-existing object given the name of a      bean definition containing the configuration to be applied. The      spring-aspects.jar contains an      annotation-driven aspect that exploits this capability to allow      dependency injection of any object. The support is      intended to be used for objects created outside of the control      of any container. Domain objects often fall into this      category because they are often created programmatically using the      new operator, or by an ORM tool as a result of a      database query.      \n\r\n\rThe @Configurable annotation marks      a class as eligible for Spring-driven configuration. In the simplest      case it can be used just as a marker annotation:      package com.xyz.myapp.domain;import org.springframework.beans.factory.annotation.Configurable;@Configurablepublic class Account {   // ...}      \n\r\n\rWhen used as a marker interface in this way, Spring will configure      new instances of the annotated type (Account in      this case) using a bean definition (typically prototype-scoped) with the      same name as the fully-qualified type name      (com.xyz.myapp.domain.Account). Since the default      name for a bean is the fully-qualified name of its type, a convenient      way to declare the prototype definition is simply to omit the      id attribute:      &lt;bean class=\"com.xyz.myapp.domain.Account\" scope=\"prototype\"&gt;  &lt;property name=\"fundsTransferService\" ref=\"fundsTransferService\"/&gt;&lt;/bean&gt;      \n\r\n\rIf you want to explicitly specify the name of the prototype bean      definition to use, you can do so directly in the annotation:      package com.xyz.myapp.domain;import org.springframework.beans.factory.annotation.Configurable;@Configurable(\"account\")public class Account {   // ...}      \n\r\n\rSpring will now look for a bean definition named      \"account\" and use that as the definition to configure      new Account instances.      \n\r\n\rYou can also use autowiring to avoid having to specify a      dedicated bean definition at all. To have Spring apply autowiring      use the \'autowire\' property of the      @Configurable annotation: specify either      @Configurable(autowire=Autowire.BY_TYPE) or      @Configurable(autowire=Autowire.BY_NAME for      autowiring by type or by name respectively. As an alternative, as of      Spring 2.5 it is preferable to specify explicit, annotation-driven      dependency injection for your @Configurable      beans by using @Autowired or      @Inject at the field or method level (see      Section&nbsp;5.9, &#8220;Annotation-based container configuration&#8221; for further details).      \n\r\n\rFinally you can enable Spring dependency checking for the object      references in the newly created and configured object by using the      dependencyCheck attribute (for example:      @Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)).      If this attribute is set to true, then Spring will validate after      configuration that all properties (which are not primitives or      collections) have been set.      \n\r\n\rUsing the annotation on its own does nothing of course. It is the      AnnotationBeanConfigurerAspect in spring-aspects.jar that acts on the      presence of the annotation. In essence the aspect says \"after returning      from the initialization of a new object of a type annotated with      @Configurable, configure the newly      created object using Spring in accordance with the properties of the      annotation\". In this context, initialization refers      to newly instantiated objects (e.g., objects instantiated with the      \'new\' operator) as well as to      Serializable objects that are undergoing      deserialization (e.g., via readResolve()).      Note        \n\r\n\rOne of the key phrases in the above paragraph is \'in        essence\'. For most cases, the exact semantics of        \'after returning from the initialization of a new        object\' will be fine... in this context, \'after        initialization\' means that the dependencies will be        injected after the object has been constructed -        this means that the dependencies will not be available for use in the        constructor bodies of the class. If you want the dependencies to be        injected before the constructor bodies execute,        and thus be available for use in the body of the constructors, then        you need to define this on the        @Configurable declaration like        so:        @Configurable(preConstruction=true)        \n\r\n\rYou can find out more information about the language semantics        of the various pointcut types in AspectJ in        this appendix of the AspectJ        Programming Guide.            \n\r\n\rFor this to work the annotated types must be woven with the      AspectJ weaver - you can either use a build-time Ant or Maven task to do      this (see for example the AspectJ      Development Environment Guide) or load-time weaving (see Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;). The      AnnotationBeanConfigurerAspect itself needs      configuring by Spring (in order to obtain a reference to the bean      factory that is to be used to configure new objects). If you are      using Java based configuration simply add      @EnableSpringConfigured to any      @Configuration class.      @Configuration@EnableSpringConfiguredpublic class AppConfig {}      \n\r\n\rIf you prefer XML based configuration, the Spring context      namespace defines a convenient      context:spring-configured element:      &lt;context:spring-configured/&gt;      \n\r\n\rIf you are using the DTD instead of schema, the equivalent      definition is:      &lt;bean      class=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\"      factory-method=\"aspectOf\"/&gt;      \n\r\n\rInstances of @Configurable objects      created before the aspect has been configured will      result in a message being issued to the debug log and no configuration      of the object taking place. An example might be a bean in the Spring      configuration that creates domain objects when it is initialized by      Spring. In this case you can use the \"depends-on\" bean attribute to      manually specify that the bean depends on the configuration      aspect.      &lt;bean id=\"myService\"  class=\"com.xzy.myapp.service.MyService\"  depends-on=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\"&gt;  &lt;!-- ... --&gt;&lt;/bean&gt;      Note        \n\r\n\rDo not activate @Configurable        processing through the bean configurer aspect unless you really        mean to rely on its semantics at runtime. In particular, make sure        that you do not use @Configurable        on bean classes which are registered as regular Spring beans with        the container: You would get double initialization otherwise, once        through the container and once through the aspect.            Unit testing @Configurable        objects                \n\r\n\rOne of the goals of the        @Configurable support is to enable        independent unit testing of domain objects without the difficulties        associated with hard-coded lookups. If        @Configurable types have not been woven        by AspectJ then the annotation has no affect during unit testing, and        you can simply set mock or stub property references in the object        under test and proceed as normal. If        @Configurable types        have been woven by AspectJ then you can still        unit test outside of the container as normal, but you will see a        warning message each time that you construct an        @Configurable object indicating that it        has not been configured by Spring.            Working with multiple application contexts                \n\r\n\rThe AnnotationBeanConfigurerAspect used        to implement the @Configurable support        is an AspectJ singleton aspect. The scope of a singleton aspect is the        same as the scope of static members, that is to say        there is one aspect instance per classloader that defines the type.        This means that if you define multiple application contexts within the        same classloader hierarchy you need to consider where to define the        @EnableSpringConfigured bean and where to        place spring-aspects.jar on        the classpath.        \n\r\n\rConsider a typical Spring web-app configuration with a shared        parent application context defining common business services and        everything needed to support them, and one child application context        per servlet containing definitions particular to that servlet. All of        these contexts will co-exist within the same classloader hierarchy,        and so the AnnotationBeanConfigurerAspect can only        hold a reference to one of them. In this case we recommend defining        the @EnableSpringConfigured bean in the        shared (parent) application context: this defines the services that        you are likely to want to inject into domain objects. A consequence is        that you cannot configure domain objects with references to beans        defined in the child (servlet-specific) contexts using the        @Configurable mechanism (probably not something you want to do        anyway!).        \n\r\n\rWhen deploying multiple web-apps within the same container,        ensure that each web-application loads the types in spring-aspects.jar using its own        classloader (for example, by placing spring-aspects.jar in \'WEB-INF/lib\'). If spring-aspects.jar is only added to the        container wide classpath (and hence loaded by the shared parent        classloader), all web applications will share the same aspect instance        which is probably not what you want.              9.8.2&nbsp;Other Spring aspects for AspectJ            \n\r\n\rIn addition to the @Configurable      aspect, spring-aspects.jar      contains an AspectJ aspect that can be used to drive Spring\'s      transaction management for types and methods annotated with the      @Transactional annotation. This is      primarily intended for users who want to use the Spring Framework\'s      transaction support outside of the Spring container.      \n\r\n\rThe aspect that interprets      @Transactional annotations is the      AnnotationTransactionAspect. When using this      aspect, you must annotate the implementation class      (and/or methods within that class), not the      interface (if any) that the class implements. AspectJ follows Java\'s      rule that annotations on interfaces are not      inherited.      \n\r\n\rA @Transactional annotation on a      class specifies the default transaction semantics for the execution of      any public operation in the class.      \n\r\n\rA @Transactional annotation on a      method within the class overrides the default transaction semantics      given by the class annotation (if present). Methods with      public, protected, and default      visibility may all be annotated. Annotating protected      and default visibility methods directly is the only way to get      transaction demarcation for the execution of such methods.      \n\r\n\rFor AspectJ programmers that want to use the Spring configuration      and transaction management support but don\'t want to (or cannot) use      annotations, spring-aspects.jar      also contains abstract aspects you can extend to      provide your own pointcut definitions. See the sources for the      AbstractBeanConfigurerAspect and      AbstractTransactionAspect aspects for more      information. As an example, the following excerpt shows how you could      write an aspect to configure all instances of objects defined in the      domain model using prototype bean definitions that match the      fully-qualified class names:      public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {  public DomainObjectConfiguration() {    setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());  }  // the creation of a new bean (any object in the domain model)  protected pointcut beanCreation(Object beanInstance) :    initialization(new(..)) &amp;&amp;    SystemArchitecture.inDomainModel() &amp;&amp;    this(beanInstance);}        9.8.3&nbsp;Configuring AspectJ aspects using Spring IoC            \n\r\n\rWhen using AspectJ aspects with Spring applications, it is natural      to both want and expect to be able to configure such aspects using      Spring. The AspectJ runtime itself is responsible for aspect creation,      and the means of configuring the AspectJ created aspects via Spring      depends on the AspectJ instantiation model (the      \'per-xxx\' clause) used by the aspect.      \n\r\n\rThe majority of AspectJ aspects are singleton      aspects. Configuration of these aspects is very easy: simply create a      bean definition referencing the aspect type as normal, and include the      bean attribute \'factory-method=\"aspectOf\"\'. This      ensures that Spring obtains the aspect instance by asking AspectJ for it      rather than trying to create an instance itself. For example:      &lt;bean id=\"profiler\" class=\"com.xyz.profiler.Profiler\"      factory-method=\"aspectOf\"&gt;  &lt;property name=\"profilingStrategy\" ref=\"jamonProfilingStrategy\"/&gt;&lt;/bean&gt;      \n\r\n\rNon-singleton aspects are harder to configure: however it is      possible to do so by creating prototype bean definitions and using the      @Configurable support from spring-aspects.jar to configure the      aspect instances once they have bean created by the AspectJ      runtime.      \n\r\n\rIf you have some @AspectJ aspects that you want to weave with      AspectJ (for example, using load-time weaving for domain model types)      and other @AspectJ aspects that you want to use with Spring AOP, and      these aspects are all configured using Spring, then you will need to      tell the Spring AOP @AspectJ autoproxying support which exact subset of      the @AspectJ aspects defined in the configuration should be used for      autoproxying. You can do this by using one or more      &lt;include/&gt; elements inside the      &lt;aop:aspectj-autoproxy/&gt; declaration. Each      &lt;include/&gt; element specifies a name pattern,      and only beans with names matched by at least one of the patterns will      be used for Spring AOP autoproxy configuration:      &lt;aop:aspectj-autoproxy&gt;  &lt;aop:include name=\"thisBean\"/&gt;  &lt;aop:include name=\"thatBean\"/&gt;&lt;/aop:aspectj-autoproxy&gt;      Note        \n\r\n\rDo not be misled by the name of the        &lt;aop:aspectj-autoproxy/&gt; element: using it        will result in the creation of Spring AOP        proxies. The @AspectJ style of aspect declaration is just        being used here, but the AspectJ runtime is not        involved.              9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework            \n\r\n\rLoad-time weaving (LTW) refers to the process of weaving AspectJ      aspects into an application\'s class files as they are being loaded into      the Java virtual machine (JVM). The focus of this section is on      configuring and using LTW in the specific context of the Spring      Framework: this section is not an introduction to LTW though. For full      details on the specifics of LTW and configuring LTW with just AspectJ      (with Spring not being involved at all), see the LTW      section of the AspectJ Development Environment Guide.      \n\r\n\rThe value-add that the Spring Framework brings to AspectJ LTW is      in enabling much finer-grained control over the weaving process.      \'Vanilla\' AspectJ LTW is effected using a Java (5+) agent, which is      switched on by specifying a VM argument when starting up a JVM. It is      thus a JVM-wide setting, which may be fine in some situations, but often      is a little too coarse. Spring-enabled LTW enables you to switch on LTW      on a per-ClassLoader basis,      which obviously is more fine-grained and which can make more sense in a      \'single-JVM-multiple-application\' environment (such as is found in a      typical application server environment).      \n\r\n\rFurther, in certain      environments, this support enables load-time weaving      without making any modifications to the application server\'s      launch script that will be needed to add      -javaagent:path/to/aspectjweaver.jar or (as we describe later in this      section) -javaagent:path/to/org.springframework.instrument-{version}.jar      (previously named spring-agent.jar). Developers simply modify      one or more files that form the application context to enable load-time      weaving instead of relying on administrators who typically are in charge      of the deployment configuration such as the launch script.      \n\r\n\rNow that the sales pitch is over, let us first walk through a      quick example of AspectJ LTW using Spring, followed by detailed      specifics about elements introduced in the following example. For a      complete example, please see the Petclinic sample application.      A first example                \n\r\n\rLet us assume that you are an application developer who has been        tasked with diagnosing the cause of some performance problems in a        system. Rather than break out a profiling tool, what we are going to        do is switch on a simple profiling aspect that will enable us to very        quickly get some performance metrics, so that we can then apply a        finer-grained profiling tool to that specific area immediately        afterwards.        Note          \n\r\n\rThe example presented here uses XML style configuration, it is          also possible to configure and use @AspectJ with          Java Configuration.          Specifically the @EnableLoadTimeWeaving          annotation can be used as an alternative to          &lt;context:load-time-weaver/&gt;          (see below for details).                \n\r\n\rHere is the profiling aspect. Nothing too fancy, just a        quick-and-dirty time-based profiler, using the @AspectJ-style of        aspect declaration.        package foo;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Pointcut;import org.springframework.util.StopWatch;import org.springframework.core.annotation.Order;@Aspectpublic class ProfilingAspect {    @Around(\"methodsToBeProfiled()\")    public Object profile(ProceedingJoinPoint pjp) throws Throwable {        StopWatch sw = new StopWatch(getClass().getSimpleName());        try {            sw.start(pjp.getSignature().getName());            return pjp.proceed();        } finally {            sw.stop();            System.out.println(sw.prettyPrint());        }    }    @Pointcut(\"execution(public * foo..*.*(..))\")    public void methodsToBeProfiled(){}}        \n\r\n\rWe will also need to create an        \'META-INF/aop.xml\' file, to inform the AspectJ        weaver that we want to weave our        ProfilingAspect into our classes. This file        convention, namely the presence of a file (or files) on the Java        classpath called \' META-INF/aop.xml\' is standard        AspectJ.        &lt;!DOCTYPE aspectj PUBLIC        \"-//AspectJ//DTD//EN\" \"http://www.eclipse.org/aspectj/dtd/aspectj.dtd\"&gt;&lt;aspectj&gt;    &lt;weaver&gt;        &lt;!-- only weave classes in our application-specific packages --&gt;        &lt;include within=\"foo.*\"/&gt;    &lt;/weaver&gt;    &lt;aspects&gt;        &lt;!-- weave in just this aspect --&gt;        &lt;aspect name=\"foo.ProfilingAspect\"/&gt;    &lt;/aspects&gt;  &lt;/aspectj&gt;        \n\r\n\rNow to the Spring-specific portion of the configuration. We need        to configure a LoadTimeWeaver (all        explained later, just take it on trust for now). This load-time weaver        is the essential component responsible for weaving the aspect        configuration in one or more \'META-INF/aop.xml\'        files into the classes in your application. The good thing is that it        does not require a lot of configuration, as can be seen below (there        are some more options that you can specify, but these are detailed        later).        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- a service object; we will be profiling its methods --&gt;    &lt;bean id=\"entitlementCalculationService\"          class=\"foo.StubEntitlementCalculationService\"/&gt;    &lt;!-- this switches on the load-time weaving --&gt;    &lt;context:load-time-weaver/&gt;&lt;/beans&gt;        \n\r\n\rNow that all the required artifacts are in place - the aspect,        the \'META-INF/aop.xml\' file, and the Spring        configuration -, let us create a simple driver class with a        main(..) method to demonstrate the LTW in        action.        package foo;import org.springframework.context.support.ClassPathXmlApplicationContext;public final class Main {    public static void main(String[] args) {        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\", Main.class);        EntitlementCalculationService entitlementCalculationService            = (EntitlementCalculationService) ctx.getBean(\"entitlementCalculationService\");        // the profiling aspect is \'woven\' around this method execution        entitlementCalculationService.calculateEntitlement();    }}        \n\r\n\rThere is one last thing to do. The introduction to this section        did say that one could switch on LTW selectively on a        per-ClassLoader basis with Spring, and this is        true. However, just for this example, we are going to use a Java agent        (supplied with Spring) to switch on the LTW. This is the command line        we will use to run the above Main class:        java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main        \n\r\n\rThe \'-javaagent\' is a Java 5+ flag for        specifying and enabling agents        to instrument programs running on the JVM. The Spring        Framework ships with such an agent, the        InstrumentationSavingAgent, which is packaged        in the spring-instrument.jar        that        was supplied as the value of the -javaagent        argument in the above example.        \n\r\n\rThe output from the execution of the Main        program will look something like that below. (I have introduced a        Thread.sleep(..) statement into the        calculateEntitlement() implementation so that        the profiler actually captures something other than 0 milliseconds -        the 01234 milliseconds is not        an overhead introduced by the AOP :) )        Calculating entitlementStopWatch \'ProfilingAspect\': running time (millis) = 1234------ ----- ----------------------------ms     %     Task name------ ----- ----------------------------01234  100%  calculateEntitlement        \n\r\n\rSince this LTW is effected using full-blown AspectJ, we are not        just limited to advising Spring beans; the following slight variation        on the Main program will yield the same        result.        package foo;import org.springframework.context.support.ClassPathXmlApplicationContext;public final class Main {    public static void main(String[] args) {        new ClassPathXmlApplicationContext(\"beans.xml\", Main.class);        EntitlementCalculationService entitlementCalculationService =            new StubEntitlementCalculationService();        // the profiling aspect will be \'woven\' around this method execution        entitlementCalculationService.calculateEntitlement();    }}        \n\r\n\rNotice how in the above program we are simply bootstrapping the        Spring container, and then creating a new instance of the        StubEntitlementCalculationService totally        outside the context of Spring... the profiling advice still gets woven        in.        \n\r\n\rThe example admittedly is simplistic... however the basics of        the LTW support in Spring have all been introduced in the above        example, and the rest of this section will explain the \'why\' behind        each bit of configuration and usage in detail.        Note          \n\r\n\rThe ProfilingAspect used in this          example may be basic, but it is quite useful. It is a nice example          of a development-time aspect that developers can use during          development (of course), and then quite easily exclude from builds          of the application being deployed into UAT or production.                    Aspects                \n\r\n\rThe aspects that you use in LTW have to be AspectJ aspects. They        can be written in either the AspectJ language itself or you can write        your aspects in the @AspectJ-style. The latter option is of course        only an option if you are using Java 5+, but it does mean that your        aspects are then both valid AspectJ and Spring        AOP aspects. Furthermore, the compiled aspect classes need to be        available on the classpath.            \'META-INF/aop.xml\'                \n\r\n\rThe AspectJ LTW infrastructure is configured using one or more        \'META-INF/aop.xml\' files, that are on the Java        classpath (either directly, or more typically in jar files).        \n\r\n\rThe structure and contents of this file is detailed in the main        AspectJ reference documentation, and the interested reader is referred        to that resource. (I appreciate that this section is brief,        but the \'aop.xml\' file is 100% AspectJ - there is        no Spring-specific information or semantics that apply to it, and so        there is no extra value that I can contribute either as a result), so        rather than rehash the quite satisfactory section that the AspectJ        developers wrote, I am just directing you there.)            Required libraries (JARS)                \n\r\n\rAt a minimum you will need the following libraries to use the        Spring Framework\'s support for AspectJ LTW:        \n\r            \n\r\n\rspring-aop.jar (version            2.5 or later, plus all mandatory dependencies)          \n\r            \n\r\n\raspectjweaver.jar            (version 1.6.8 or later)          \n\r        \n\r\n\rIf you are using the Spring-provided agent to        enable instrumentation, you will also need:        \n\r            \n\r\n\rspring-instrument.jar          \n\r            Spring configuration                \n\r\n\rThe key component in Spring\'s LTW support is the        LoadTimeWeaver interface (in the        org.springframework.instrument.classloading        package), and the numerous implementations of it that ship with the        Spring distribution. A LoadTimeWeaver        is responsible for adding one or more        java.lang.instrument.ClassFileTransformers to a        ClassLoader at runtime, which opens the door to        all manner of interesting applications, one of which happens to be the        LTW of aspects.        Tip          \n\r\n\rIf you are unfamiliar with the idea of runtime class file          transformation, you are encouraged to read the Javadoc API          documentation for the java.lang.instrument          package before continuing. This is not a huge chore because there is          - rather annoyingly - precious little documentation there... the key          interfaces and classes will at least be laid out in front of you for          reference as you read through this section.                \n\r\n\rConfiguring a LoadTimeWeaver        for a particular        ApplicationContext can be as easy as        adding one line. (Please note that you almost certainly will need to        be using an ApplicationContext as your        Spring container - typically a        BeanFactory will not be enough because        the LTW support makes use of        BeanFactoryPostProcessors.)        \n\r\n\rTo enable the Spring Framework\'s LTW support, you need to        configure a LoadTimeWeaver, which        typically is done using the        @EnableLoadTimeWeaving annotation.        @Configuration@EnableLoadTimeWeavingpublic class AppConfig {}        \n\r\n\rAlternatively, if you prefer XML based configuration, use the        &lt;context:load-time-weaver/&gt; element. Note        that the element is defined in the \'context\' namespace.        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:load-time-weaver/&gt;&lt;/beans&gt;        \n\r\n\rThe above configuration will define and register a number of        LTW-specific infrastructure beans for you automatically, such        as a LoadTimeWeaver and an        AspectJWeavingEnabler.  The default        LoadTimeWeaver is the        DefaultContextLoadTimeWeaver class, which        attempts to decorate an automatically detected        LoadTimeWeaver: the exact type of        LoadTimeWeaver that will be        \'automatically detected\' is dependent upon your runtime environment        (summarized in the following table).        \n\r\n\rTable&nbsp;9.1.&nbsp;DefaultContextLoadTimeWeaver          LoadTimeWeavers                    Runtime EnvironmentLoadTimeWeaver implementation\n\r\n\rRunning in BEA\'s                Weblogic 10\n\r\n\rWebLogicLoadTimeWeaver\n\r\n\rRunning in IBM WebSphere Application Server 7\n\r\n\rWebSphereLoadTimeWeaver\n\r\n\rRunning in Oracle\'s                OC4J\n\r\n\rOC4JLoadTimeWeaver\n\r\n\rRunning in GlassFish\n\r\n\rGlassFishLoadTimeWeaver\n\r\n\rRunning in JBoss AS\n\r\n\rJBossLoadTimeWeaver\n\r\n\rJVM started with Spring                InstrumentationSavingAgent                \n\r\n\r(java                -javaagent:path/to/spring-instrument.jar)\n\r\n\rInstrumentationLoadTimeWeaver\n\r\n\rFallback, expecting the underlying ClassLoader to follow common conventions                (e.g. applicable to TomcatInstrumentableClassLoader and                Resin)\n\r\n\rReflectiveLoadTimeWeaver        \n\r        \n\r\n\rNote that these are just the        LoadTimeWeavers that are autodetected        when using the DefaultContextLoadTimeWeaver: it        is of course possible to specify exactly which        LoadTimeWeaver implementation that you        wish to use.        \n\r\n\rTo specify a specific LoadTimeWeaver        with Java configuration implement the        LoadTimeWeavingConfigurer interface and override        the getLoadTimeWeaver() method:        @Configuration@EnableLoadTimeWeavingpublic class AppConfig implements LoadTimeWeavingConfigurer {    @Override    public LoadTimeWeaver getLoadTimeWeaver() {        return new ReflectiveLoadTimeWeaver();    }}        \n\r\n\rIf you are using XML based configuration you can specify the fully-qualified        classname as the value of the \'weaver-class\' attribute on the        &lt;context:load-time-weaver/&gt; element:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:load-time-weaver            weaver-class=\"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\"/&gt;&lt;/beans&gt;        \n\r\n\rThe LoadTimeWeaver that is        defined and registered by the configuration can be        later retrieved from the Spring container using the well-known name        \'loadTimeWeaver\'. Remember that the        LoadTimeWeaver exists just as a        mechanism for Spring\'s LTW infrastructure to add one or more        ClassFileTransformers. The actual        ClassFileTransformer that does the LTW is the        ClassPreProcessorAgentAdapter (from the        org.aspectj.weaver.loadtime package) class. See the        class-level Javadoc for the        ClassPreProcessorAgentAdapter class for further        details, because the specifics of how the weaving is actually effected        is beyond the scope of this section.        \n\r\n\rThere is one final attribute of the configuration left to discuss:        the \'aspectjWeaving\' attribute        (or \'aspectj-weaving\' if you are using XML). This is a simple        attribute that controls whether LTW is enabled or not, it is as simple        as that. It accepts one of three possible values, summarized below,        with the default value if the attribute is not present being        \'autodetect\'        \n\r\n\rTable&nbsp;9.2.&nbsp;AspectJ weaving attribute values                    Annotation ValueXML ValueExplanation\n\r\n\rENABLED\n\r\n\ron\n\r\n\rAspectJ weaving is on, and aspects will be woven                at load-time as appropriate.\n\r\n\rDISABLED\n\r\n\roff\n\r\n\rLTW is off... no aspect will be woven at                load-time.\n\r\n\rAUTODETECT\n\r\n\rautodetect\n\r\n\rIf the Spring LTW infrastructure can find at                least one \'META-INF/aop.xml\' file, then                AspectJ weaving is on, else it is off. This is the default                value.        \n\r            Environment-specific configuration                \n\r\n\rThis last section contains any additional settings and        configuration that you will need when using Spring\'s LTW support in        environments such as application servers and web containers.        Tomcat                    \n\r\n\rApache Tomcat\'s default class loader          does not support class transformation which is why Spring provides an enhanced implementation that          addresses this need. Named TomcatInstrumentableClassLoader, the loader works          on Tomcat 5.0 and above and can be registered individually for each web application          as follows:          \n\r              \n\r\n\rTomcat 6.0.x or higher            \n\r                \n\r\n\rCopy org.springframework.instrument.tomcat.jar                into $CATALINA_HOME/lib, where                $CATALINA_HOME represents the root of the                Tomcat installation)              \n\r                \n\r\n\rInstruct Tomcat to use the custom class loader (instead                of the default) by editing the web application context                file:                &lt;Context path=\"/myWebApp\" docBase=\"/my/webApp/location\"&gt;    &lt;Loader        loaderClass=\"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader\"/&gt;&lt;/Context&gt;                \n\r\n\rApache Tomcat 6.0.x (similar to 5.0.x/5.5.x) series supports several context locations:                    \n\r\n\r\n\rserver configuration file - $CATALINA_HOME/conf/server.xml\n\r\n\r\n\rdefault context configuration - $CATALINA_HOME/conf/context.xml - that                        affects all deployed web applications\n\r\n\r\n\rper-web application configuration which can be deployed either on the server-side at                        $CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml or embedded inside                        the web-app archive at META-INF/context.xml\n\r                \n\r\n\rFor efficiency, the embedded per-web-app configuration style is                recommended because it will impact only applications that use                the custom class loader and does not require any changes to the server configuration.                See the Tomcat 6.0.x documentation                for more details about available context locations.              \n\r            \n\r              \n\r\n\rTomcat 5.0.x/5.5.x            \n\r                \n\r\n\rCopy org.springframework.instrument.tomcat.jar                into $CATALINA_HOME/server/lib, where                $CATALINA_HOME represents the root of the                Tomcat installation.              \n\r                \n\r\n\rInstruct Tomcat to use the custom class loader instead                of the default one by editing the web application context                file:                &lt;Context path=\"/myWebApp\" docBase=\"/my/webApp/location\"&gt;    &lt;Loader        loaderClass=\"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader\"/&gt;&lt;/Context&gt;                \n\r\n\rTomcat 5.0.x and 5.5.x series supports several context locations:                    \n\r\n\r\n\rserver configuration file - $CATALINA_HOME/conf/server.xml\n\r\n\r\n\rdefault context configuration - $CATALINA_HOME/conf/context.xml - that                        affects all deployed web applications\n\r\n\r\n\rper-web application configuration which can be deployed either on the server-side at                        $CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml or embedded inside                        the web-app archive at META-INF/context.xml\n\r                \n\r\n\rFor efficiency, the embedded web-app configuration style is recommended                recommended because it will impact only applications that use the class loader. See the Tomcat 5.x documentation                for more details about available context locations.                \n\r\n\rTomcat versions prior to 5.5.20 contained a bug in the                XML configuration parsing that prevented usage of the                Loader tag inside                server.xml configuration, regardless of whether a class                loader is specified or whether it is the official or a custom                one. See Tomcat\'s bugzilla for more                details.                \n\r\n\rIn Tomcat 5.5.x, versions 5.5.20 or later, you should set                useSystemClassLoaderAsParent to                false to fix this problem:                                &lt;Context path=\"/myWebApp\" docBase=\"/my/webApp/location\"&gt;    &lt;Loader        loaderClass=\"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader\"            useSystemClassLoaderAsParent=\"false\"/&gt;&lt;/Context&gt;\n\r\n\rThis setting is not needed on Tomcat 6 or higher.              \n\r            \n\r          \n\r\n\rAlternatively, consider the use of the Spring-provided generic          VM agent, to be specified in Tomcat\'s launch script (see above).          This will make instrumentation available to all deployed web          applications, no matter what ClassLoader they happen to run on.                WebLogic, WebSphere, OC4J, Resin, GlassFish, JBoss                    \n\r\n\rRecent versions of BEA WebLogic (version 10 and above), IBM WebSphere Application Server (version 7 and above),          Oracle Containers for Java EE (OC4J 10.1.3.1 and above), Resin (3.1 and above) and JBoss (5.x or above)          provide a ClassLoader that is capable of local instrumentation.          Spring\'s native LTW leverages such ClassLoaders to enable AspectJ weaving.          You can enable LTW by simply activating load-time weaving          as described earlier. Specifically, you do not          need to modify the launch script to add          -javaagent:path/to/spring-instrument.jar.          \n\r\n\rNote that GlassFish instrumentation-capable ClassLoader is available only in its EAR environment.          For GlassFish web applications, follow the Tomcat setup instructions as outlined above.          \n\r\n\rNote that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from loading the classes          before the application actually starts. A quick workaround is to add to your artifact a file named          WEB-INF/jboss-scanning.xml with the following content:          &lt;scanning xmlns=\"urn:jboss:scanning:1.0\"/&gt;                  Generic Java applications                    \n\r\n\rWhen class instrumentation is required in environments that do not support or          are not supported by the existing LoadTimeWeaver          implementations,          a JDK agent can be the only solution. For such cases, Spring          provides InstrumentationLoadTimeWeaver,          which requires a Spring-specific (but very general) VM agent,          org.springframework.instrument-{version}.jar          (previously named spring-agent.jar).          \n\r\n\rTo use it, you must start the virtual machine with the Spring agent, by          supplying the following JVM options:          -javaagent:/path/to/org.springframework.instrument-{version}.jar          \n\r\n\r          Note that this requires modification of the VM launch script which may prevent you from using this in application server          environments (depending on your operation policies). Additionally, the JDK agent will instrument the entire          VM which can prove expensive.          \n\r\n\rFor performance reasons, it is recommended to use this configuration only if your target environment          (such as Jetty) does not have (or does not support) a dedicated LTW.                      9.9&nbsp;Further Resources        \n\r\n\rMore information on AspectJ can be found on the AspectJ website.    \n\r\n\rThe book Eclipse AspectJ by Adrian Colyer et.    al. (Addison-Wesley, 2005) provides a comprehensive introduction and    reference for the AspectJ language.    \n\r\n\rThe book AspectJ in Action by Ramnivas Laddad    (Manning, 2003) comes highly recommended; the focus of the book is on    AspectJ, but a lot of general AOP themes are explored (in some depth).  Prev&nbsp;Up&nbsp;Next8.&nbsp;Spring Expression Language (SpEL)&nbsp;Home&nbsp;10.&nbsp;Spring AOP APIs","9. Aspect Oriented Programming with Spring","scr\\aop.html","         10.&nbsp;Spring AOP APIsPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next10.&nbsp;Spring AOP APIs    10.1&nbsp;Introduction        \n\r\n\rThe previous chapter described the Spring 2.0 and later version\'s    support for AOP using @AspectJ and schema-based aspect definitions. In    this chapter we discuss the lower-level Spring AOP APIs and the AOP    support used in Spring 1.2 applications. For new applications, we    recommend the use of the Spring 2.0 and later AOP support described in the    previous chapter, but when working with existing applications, or when    reading books and articles, you may come across Spring 1.2 style examples.    Spring 3.0 is backwards compatible with Spring 1.2 and everything    described in this chapter is fully supported in Spring 3.0.    10.2&nbsp;Pointcut API in Spring        \n\r\n\rLet\'s look at how Spring handles the crucial pointcut    concept.    10.2.1&nbsp;Concepts            \n\r\n\rSpring\'s pointcut model enables pointcut reuse independent of      advice types. It\'s possible to target different advice using the same      pointcut.      \n\r\n\rThe org.springframework.aop.Pointcut interface      is the central interface, used to target advices to particular classes      and methods. The complete interface is shown below:      public interface Pointcut {    ClassFilter getClassFilter();    MethodMatcher getMethodMatcher();}      \n\r\n\rSplitting the Pointcut interface      into two parts allows reuse of class and method matching parts, and      fine-grained composition operations (such as performing a \"union\" with      another method matcher).      \n\r\n\rThe ClassFilter interface is used      to restrict the pointcut to a given set of target classes. If the      matches() method always returns true, all target      classes will be matched:      public interface ClassFilter {    boolean matches(Class clazz);}      \n\r\n\rThe MethodMatcher interface is      normally more important. The complete interface is shown below:      public interface MethodMatcher {    boolean matches(Method m, Class targetClass);    boolean isRuntime();    boolean matches(Method m, Class targetClass, Object[] args);}      \n\r\n\rThe matches(Method, Class) method is used to      test whether this pointcut will ever match a given method on a target      class. This evaluation can be performed when an AOP proxy is created, to      avoid the need for a test on every method invocation. If the 2-argument      matches method returns true for a given method, and the      isRuntime() method for the MethodMatcher returns      true, the 3-argument matches method will be invoked on every method      invocation. This enables a pointcut to look at the arguments passed to      the method invocation immediately before the target advice is to      execute.      \n\r\n\rMost MethodMatchers are static, meaning that their      isRuntime() method returns false. In this case, the      3-argument matches method will never be invoked.      Tip        \n\r\n\rIf possible, try to make pointcuts static, allowing the AOP        framework to cache the results of pointcut evaluation when an AOP        proxy is created.              10.2.2&nbsp;Operations on pointcuts            \n\r\n\rSpring supports operations on pointcuts: notably,      union and intersection.      \n\r          \n\r\n\rUnion means the methods that either pointcut matches.        \n\r          \n\r\n\rIntersection means the methods that both pointcuts          match.        \n\r          \n\r\n\rUnion is usually more useful.        \n\r          \n\r\n\rPointcuts can be composed using the static methods in the          org.springframework.aop.support.Pointcuts          class, or using the ComposablePointcut class in          the same package. However, using AspectJ pointcut expressions is          usually a simpler approach.        \n\r        10.2.3&nbsp;AspectJ expression pointcuts            \n\r\n\rSince 2.0, the most important type of pointcut used by Spring is      org.springframework.aop.aspectj.AspectJExpressionPointcut.      This is a pointcut that uses an AspectJ supplied library to parse an      AspectJ pointcut expression string.      \n\r\n\rSee the previous chapter for a discussion of supported AspectJ      pointcut primitives.        10.2.4&nbsp;Convenience pointcut implementations            \n\r\n\rSpring provides several convenient pointcut implementations. Some      can be used out of the box; others are intended to be subclassed in      application-specific pointcuts.      Static pointcuts                \n\r\n\rStatic pointcuts are based on method and target class, and        cannot take into account the method\'s arguments. Static pointcuts are        sufficient - and best - for most usages. It\'s        possible for Spring to evaluate a static pointcut only once, when a        method is first invoked: after that, there is no need to evaluate the        pointcut again with each method invocation.        \n\r\n\rLet\'s consider some static pointcut implementations included        with Spring.        Regular expression pointcuts                    \n\r\n\rOne obvious way to specify static pointcuts is regular          expressions. Several AOP frameworks besides Spring make this          possible.          org.springframework.aop.support.JdkRegexpMethodPointcut          is a generic regular expression pointcut, using the regular          expression support in JDK 1.4+.          \n\r\n\rUsing the JdkRegexpMethodPointcut class,          you can provide a list of pattern Strings. If any of these is a          match, the pointcut will evaluate to true. (So the result is          effectively the union of these pointcuts.)          \n\r\n\rThe usage is shown below:          &lt;bean id=\"settersAndAbsquatulatePointcut\"    class=\"org.springframework.aop.support.JdkRegexpMethodPointcut\"&gt;    &lt;property name=\"patterns\"&gt;        &lt;list&gt;            &lt;value&gt;.*set.*&lt;/value&gt;            &lt;value&gt;.*absquatulate&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;          \n\r\n\rSpring provides a convenience class,          RegexpMethodPointcutAdvisor, that allows us to          also reference an Advice (remember that an Advice can be an          interceptor, before advice, throws advice etc.). Behind the scenes,          Spring will use a JdkRegexpMethodPointcut. Using          RegexpMethodPointcutAdvisor simplifies wiring, as          the one bean encapsulates both pointcut and advice, as shown          below:          &lt;bean id=\"settersAndAbsquatulateAdvisor\"    class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\"&gt;    &lt;property name=\"advice\"&gt;        &lt;ref local=\"beanNameOfAopAllianceInterceptor\"/&gt;    &lt;/property&gt;    &lt;property name=\"patterns\"&gt;        &lt;list&gt;            &lt;value&gt;.*set.*&lt;/value&gt;            &lt;value&gt;.*absquatulate&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;          \n\r\n\rRegexpMethodPointcutAdvisor can be used          with any Advice type.                Attribute-driven pointcuts                    \n\r\n\rAn important type of static pointcut is a          metadata-driven pointcut. This uses the values          of metadata attributes: typically, source-level metadata.                    Dynamic pointcuts                \n\r\n\rDynamic pointcuts are costlier to evaluate than static        pointcuts. They take into account method        arguments, as well as static information. This        means that they must be evaluated with every method invocation; the        result cannot be cached, as arguments will vary.        \n\r\n\rThe main example is the control flow        pointcut.        Control flow pointcuts                    \n\r\n\rSpring control flow pointcuts are conceptually similar to          AspectJ cflow pointcuts, although less          powerful. (There is currently no way to specify that a pointcut          executes below a join point matched by another pointcut.) A control          flow pointcut matches the current call stack. For example, it might          fire if the join point was invoked by a method in the          com.mycompany.web package, or by the          SomeCaller class. Control flow pointcuts are          specified using the          org.springframework.aop.support.ControlFlowPointcut          class.Note              \n\r\n\rControl flow pointcuts are significantly more expensive to              evaluate at runtime than even other dynamic pointcuts. In Java              1.4, the cost is about 5 times that of other dynamic              pointcuts.                                  10.2.5&nbsp;Pointcut superclasses            \n\r\n\rSpring provides useful pointcut superclasses to help you to      implement your own pointcuts.      \n\r\n\rBecause static pointcuts are most useful, you\'ll probably subclass      StaticMethodMatcherPointcut, as shown below. This requires implementing      just one abstract method (although it\'s possible to override other      methods to customize behavior):      class TestStaticPointcut extends StaticMethodMatcherPointcut {    public boolean matches(Method m, Class targetClass) {        // return true if custom criteria match    }}\n\r\n\rThere are also superclasses for dynamic pointcuts.      \n\r\n\rYou can use custom pointcuts with any advice type in Spring 1.0      RC2 and above.        10.2.6&nbsp;Custom pointcuts            \n\r\n\rBecause pointcuts in Spring AOP are Java classes, rather than      language features (as in AspectJ) it\'s possible to declare custom      pointcuts, whether static or dynamic. Custom pointcuts in Spring can be      arbitrarily complex. However, using the AspectJ pointcut expression      language is recommended if possible.      Note        \n\r\n\rLater versions of Spring may offer support for \"semantic        pointcuts\" as offered by JAC: for example, \"all methods that change        instance variables in the target object.\"              10.3&nbsp;Advice API in Spring        \n\r\n\rLet\'s now look at how Spring AOP handles advice.    10.3.1&nbsp;Advice lifecycles            \n\r\n\rEach advice is a Spring bean. An advice instance can be shared      across all advised objects, or unique to each advised object. This      corresponds to per-class or      per-instance advice.      \n\r\n\rPer-class advice is used most often. It is appropriate for generic      advice such as transaction advisors. These do not depend on the state of      the proxied object or add new state; they merely act on the method and      arguments.      \n\r\n\rPer-instance advice is appropriate for introductions, to support      mixins. In this case, the advice adds state to the proxied      object.      \n\r\n\rIt\'s possible to use a mix of shared and per-instance advice in      the same AOP proxy.        10.3.2&nbsp;Advice types in Spring            \n\r\n\rSpring provides several advice types out of the box, and is      extensible to support arbitrary advice types. Let us look at the basic      concepts and standard advice types.      Interception around advice                \n\r\n\rThe most fundamental advice type in Spring is        interception around advice.        \n\r\n\rSpring is compliant with the AOP Alliance interface for around        advice using method interception. MethodInterceptors implementing        around advice should implement the following interface:        public interface MethodInterceptor extends Interceptor {    Object invoke(MethodInvocation invocation) throws Throwable;}        \n\r\n\rThe MethodInvocation argument to the        invoke() method exposes the method being        invoked; the target join point; the AOP proxy; and the arguments to        the method. The invoke() method should return        the invocation\'s result: the return value of the join point.        \n\r\n\rA simple MethodInterceptor implementation        looks as follows:        public class DebugInterceptor implements MethodInterceptor {    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println(\"Before: invocation=[\" + invocation + \"]\");        Object rval = invocation.proceed();        System.out.println(\"Invocation returned\");        return rval;    }}        \n\r\n\rNote the call to the MethodInvocation\'s        proceed() method. This proceeds down the        interceptor chain towards the join point. Most interceptors will        invoke this method, and return its return value. However, a        MethodInterceptor, like any around advice, can return a different        value or throw an exception rather than invoke the proceed method.        However, you don\'t want to do this without good reason!        Note          \n\r\n\rMethodInterceptors offer interoperability with other AOP          Alliance-compliant AOP implementations. The other advice types          discussed in the remainder of this section implement common AOP          concepts, but in a Spring-specific way. While there is an advantage          in using the most specific advice type, stick with MethodInterceptor          around advice if you are likely to want to run the aspect in another          AOP framework. Note that pointcuts are not currently interoperable          between frameworks, and the AOP Alliance does not currently define          pointcut interfaces.                    Before advice                \n\r\n\rA simpler advice type is a before        advice. This does not need a        MethodInvocation object, since it will only be        called before entering the method.        \n\r\n\rThe main advantage of a before advice is that there is no need        to invoke the proceed() method, and therefore no        possibility of inadvertently failing to proceed down the interceptor        chain.        \n\r\n\rThe MethodBeforeAdvice interface is shown        below. (Spring\'s API design would allow for field before advice,        although the usual objects apply to field interception and it\'s        unlikely that Spring will ever implement it).        public interface MethodBeforeAdvice extends BeforeAdvice {    void before(Method m, Object[] args, Object target) throws Throwable;}        \n\r\n\rNote the return type is void. Before advice        can insert custom behavior before the join point executes, but cannot        change the return value. If a before advice throws an exception, this        will abort further execution of the interceptor chain. The exception        will propagate back up the interceptor chain. If it is unchecked, or        on the signature of the invoked method, it will be passed directly to        the client; otherwise it will be wrapped in an unchecked exception by        the AOP proxy.        \n\r\n\rAn example of a before advice in Spring, which counts all method        invocations:        public class CountingBeforeAdvice implements MethodBeforeAdvice {    private int count;    public void before(Method m, Object[] args, Object target) throws Throwable {        ++count;    }    public int getCount() {        return count;    }}        Tip          \n\r\n\rBefore advice can be used with any pointcut.                    Throws advice                \n\r\n\rThrows advice is invoked after        the return of the join point if the join point threw an exception.        Spring offers typed throws advice. Note that this means that the        org.springframework.aop.ThrowsAdvice interface does        not contain any methods: It is a tag interface identifying that the        given object implements one or more typed throws advice methods. These        should be in the form of:        afterThrowing([Method, args, target], subclassOfThrowable)         \n\r\n\rOnly the last argument is required. The method signatures may        have either one or four arguments, depending on whether the advice        method is interested in the method and arguments. The following        classes are examples of throws advice.        \n\r\n\rThe advice below is invoked if a        RemoteException is thrown (including        subclasses):        public class RemoteThrowsAdvice implements ThrowsAdvice {    public void afterThrowing(RemoteException ex) throws Throwable {        // Do something with remote exception    }}        \n\r\n\rThe following advice is invoked if a        ServletException is thrown. Unlike the        above advice, it declares 4 arguments, so that it has access to the        invoked method, method arguments and target object:        public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {        // Do something with all arguments    }}        \n\r\n\rThe final example illustrates how these two methods could be        used in a single class, which handles both        RemoteException and        ServletException. Any number of throws advice        methods can be combined in a single class.        public static class CombinedThrowsAdvice implements ThrowsAdvice {    public void afterThrowing(RemoteException ex) throws Throwable {        // Do something with remote exception    }    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {        // Do something with all arguments    }}        \n\r\n\rNote: If a throws-advice method throws an        exception itself, it will override the original exception (i.e. change        the exception thrown to the user). The overriding exception will        typically be a RuntimeException; this is compatible with any method        signature. However, if a throws-advice method throws a checked        exception, it will have to match the declared exceptions of the target        method and is hence to some degree coupled to specific target method        signatures. Do not throw an undeclared checked exception        that is incompatible with the target method\'s        signature!        Tip          \n\r\n\rThrows advice can be used with any pointcut.                    After Returning advice                \n\r\n\rAn after returning advice in Spring must implement the        org.springframework.aop.AfterReturningAdvice        interface, shown below:        public interface AfterReturningAdvice extends Advice {    void afterReturning(Object returnValue, Method m, Object[] args, Object target)            throws Throwable;}        \n\r\n\rAn after returning advice has access to the return value (which        it cannot modify), invoked method, methods arguments and        target.        \n\r\n\rThe following after returning advice counts all successful        method invocations that have not thrown exceptions:        public class CountingAfterReturningAdvice implements AfterReturningAdvice {    private int count;    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)            throws Throwable {        ++count;    }    public int getCount() {        return count;    }}        \n\r\n\rThis advice doesn\'t change the execution path. If it throws an        exception, this will be thrown up the interceptor chain instead of the        return value.        Tip          \n\r\n\rAfter returning advice can be used with any pointcut.                    Introduction advice                \n\r\n\rSpring treats introduction advice as a special kind of        interception advice.        \n\r\n\rIntroduction requires an IntroductionAdvisor,        and an IntroductionInterceptor, implementing the        following interface:        public interface IntroductionInterceptor extends MethodInterceptor {    boolean implementsInterface(Class intf);}        \n\r\n\rThe invoke() method inherited from the AOP        Alliance MethodInterceptor interface must implement        the introduction: that is, if the invoked method is on an introduced        interface, the introduction interceptor is responsible for handling        the method call - it cannot invoke        proceed().        \n\r\n\rIntroduction advice cannot be used with any pointcut, as it        applies only at class, rather than method, level. You can only use        introduction advice with the IntroductionAdvisor,        which has the following methods:        public interface IntroductionAdvisor extends Advisor, IntroductionInfo {    ClassFilter getClassFilter();    void validateInterfaces() throws IllegalArgumentException;}public interface IntroductionInfo {    Class[] getInterfaces();}        \n\r\n\rThere is no MethodMatcher, and        hence no Pointcut, associated with        introduction advice. Only class filtering is logical.        \n\r\n\rThe getInterfaces() method returns the        interfaces introduced by this advisor.        \n\r\n\rThe validateInterfaces() method is used internally to        see whether or not the introduced interfaces can be implemented by the configured        IntroductionInterceptor.        \n\r\n\rLet\'s look at a simple example from the Spring test suite. Let\'s        suppose we want to introduce the following interface to one or more        objects:        \n\r\n\r          public interface Lockable {    void lock();    void unlock();    boolean locked();}\n\r\n\r                \n\r\n\rThis illustrates a mixin. We        want to be able to cast advised objects to Lockable, whatever their        type, and call lock and unlock methods. If we call the lock() method,        we want all setter methods to throw a        LockedException. Thus we can add an aspect that        provides the ability to make objects immutable, without them having        any knowledge of it: a good example of AOP.        \n\r\n\rFirstly, we\'ll need an        IntroductionInterceptor that does the heavy        lifting. In this case, we extend the        org.springframework.aop.support.DelegatingIntroductionInterceptor        convenience class. We could implement IntroductionInterceptor        directly, but using        DelegatingIntroductionInterceptor is best for most        cases.        \n\r\n\rThe DelegatingIntroductionInterceptor is        designed to delegate an introduction to an actual implementation of        the introduced interface(s), concealing the use of interception to do        so. The delegate can be set to any object using a constructor        argument; the default delegate (when the no-arg constructor is used)        is this. Thus in the example below, the delegate is the        LockMixin subclass of        DelegatingIntroductionInterceptor. Given a delegate        (by default itself), a        DelegatingIntroductionInterceptor instance looks        for all interfaces implemented by the delegate (other than        IntroductionInterceptor), and will support introductions against any        of them. It\'s possible for subclasses such as        LockMixin to call the        suppressInterface(Class intf) method to suppress        interfaces that should not be exposed. However, no matter how many        interfaces an IntroductionInterceptor is prepared        to support, the IntroductionAdvisor used will        control which interfaces are actually exposed. An introduced interface        will conceal any implementation of the same interface by the        target.        \n\r\n\rThus LockMixin subclasses        DelegatingIntroductionInterceptor and implements        Lockable itself. The superclass automatically picks up that Lockable        can be supported for introduction, so we don\'t need to specify that.        We could introduce any number of interfaces in this way.        \n\r\n\rNote the use of the locked instance variable.        This effectively adds additional state to that held in the target        object.        \n\r\n\r          public class LockMixin extends DelegatingIntroductionInterceptor    implements Lockable {    private boolean locked;    public void lock() {        this.locked = true;    }    public void unlock() {        this.locked = false;    }    public boolean locked() {        return this.locked;    }    public Object invoke(MethodInvocation invocation) throws Throwable {        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf(\"set\") == 0)            throw new LockedException();        return super.invoke(invocation);    }}\n\r\n\r                \n\r\n\rOften it isn\'t necessary to override the invoke()        method: the        DelegatingIntroductionInterceptor implementation -        which calls the delegate method if the method is introduced, otherwise        proceeds towards the join point - is usually sufficient. In the        present case, we need to add a check: no setter method can be invoked        if in locked mode.        \n\r\n\rThe introduction advisor required is simple. All it needs to do        is hold a distinct LockMixin instance, and specify        the introduced interfaces - in this case, just        Lockable. A more complex example might take a        reference to the introduction interceptor (which would be defined as a        prototype): in this case, there\'s no configuration relevant for a        LockMixin, so we simply create it using        new.        \n\r\n\r          public class LockMixinAdvisor extends DefaultIntroductionAdvisor {    public LockMixinAdvisor() {        super(new LockMixin(), Lockable.class);    }}\n\r\n\r                \n\r\n\rWe can apply this advisor very simply: it requires no        configuration. (However, it is necessary: It\'s        impossible to use an IntroductionInterceptor        without an IntroductionAdvisor.) As usual with        introductions, the advisor must be per-instance, as it is stateful. We        need a different instance of LockMixinAdvisor, and        hence LockMixin, for each advised object. The        advisor comprises part of the advised object\'s state.        \n\r\n\rWe can apply this advisor programmatically, using the        Advised.addAdvisor() method, or (the recommended        way) in XML configuration, like any other advisor. All proxy creation        choices discussed below, including \"auto proxy creators,\" correctly        handle introductions and stateful mixins.              10.4&nbsp;Advisor API in Spring        \n\r\n\rIn Spring, an Advisor is an aspect that contains just a single    advice object associated with a pointcut expression.    \n\r\n\rApart from the special case of introductions, any advisor can be    used with any advice.    org.springframework.aop.support.DefaultPointcutAdvisor    is the most commonly used advisor class. For example, it can be used with    a MethodInterceptor, BeforeAdvice or    ThrowsAdvice.    \n\r\n\rIt is possible to mix advisor and advice types in Spring in the same    AOP proxy. For example, you could use a interception around advice, throws    advice and before advice in one proxy configuration: Spring will    automatically create the necessary interceptor chain.    10.5&nbsp;Using the ProxyFactoryBean to create AOP proxies        \n\r\n\rIf you\'re using the Spring IoC container (an ApplicationContext or    BeanFactory) for your business objects - and you should be! - you will    want to use one of Spring\'s AOP FactoryBeans. (Remember that a factory    bean introduces a layer of indirection, enabling it to create objects of a    different type.)    Note      \n\r\n\rThe Spring 2.0 AOP support also uses factory beans under the      covers.        \n\r\n\rThe basic way to create an AOP proxy in Spring is to use the    org.springframework.aop.framework.ProxyFactoryBean.    This gives complete control over the pointcuts and advice that will apply,    and their ordering. However, there are simpler options that are preferable    if you don\'t need such control.    10.5.1&nbsp;Basics            \n\r\n\rThe ProxyFactoryBean, like other Spring      FactoryBean implementations, introduces a level of      indirection. If you define a ProxyFactoryBean with      name foo, what objects referencing      foo see is not the      ProxyFactoryBean instance itself, but an object      created by the ProxyFactoryBean\'s implementation of      the getObject() method. This method will create an      AOP proxy wrapping a target object.      \n\r\n\rOne of the most important benefits of using a      ProxyFactoryBean or another IoC-aware class to create      AOP proxies, is that it means that advices and pointcuts can also be      managed by IoC. This is a powerful feature, enabling certain approaches      that are hard to achieve with other AOP frameworks. For example, an      advice may itself reference application objects (besides the target,      which should be available in any AOP framework), benefiting from all the      pluggability provided by Dependency Injection.        10.5.2&nbsp;JavaBean properties            \n\r\n\rIn common with most FactoryBean      implementations provided with Spring, the      ProxyFactoryBean class is itself a JavaBean. Its      properties are used to:      \n\r          \n\r\n\rSpecify the target you want to proxy.        \n\r          \n\r\n\rSpecify whether to use CGLIB (see below and also          Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).        \n\r      \n\r\n\rSome key properties are inherited from      org.springframework.aop.framework.ProxyConfig      (the superclass for all AOP proxy factories in Spring). These key      properties include:      \n\r          \n\r\n\rproxyTargetClass: true          if the target class is to be proxied, rather than the target class\'          interfaces. If this property value is set to          true, then CGLIB proxies will be created (but see          also Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).        \n\r          \n\r\n\roptimize: controls whether or not          aggressive optimizations are applied to proxies created          via CGLIB. One should not blithely use this setting          unless one fully understands how the relevant AOP proxy handles          optimization. This is currently used only for CGLIB proxies; it has          no effect with JDK dynamic proxies.        \n\r          \n\r\n\rfrozen: if a proxy configuration is          frozen, then changes to the configuration are no          longer allowed. This is useful both as a slight optimization and for          those cases when you don\'t want callers to be able to manipulate the          proxy (via the Advised interface)          after the proxy has been created. The default value of this property          is false, so changes such as adding additional          advice are allowed.        \n\r          \n\r\n\rexposeProxy: determines whether or not the          current proxy should be exposed in a          ThreadLocal so that it can be accessed by the          target. If a target needs to obtain the proxy and the          exposeProxy property is set to          true, the target can use the          AopContext.currentProxy() method.        \n\r      \n\r\n\rOther properties specific to      ProxyFactoryBean include:      \n\r          \n\r\n\rproxyInterfaces: array of String interface          names. If this isn\'t supplied, a CGLIB proxy for the target class          will be used (but see also Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).        \n\r          \n\r\n\rinterceptorNames: String array of          Advisor, interceptor or other advice          names to apply. Ordering is significant, on a first come-first          served basis. That is to say that the first interceptor in the list          will be the first to be able to intercept the invocation.          \n\r\n\rThe names are bean names in the current factory, including          bean names from ancestor factories. You can\'t mention bean          references here since doing so would result in the          ProxyFactoryBean ignoring the singleton          setting of the advice.          \n\r\n\rYou can append an interceptor name with an asterisk          (*). This will result in the application of all          advisor beans with names starting with the part before the asterisk          to be applied. An example of using this feature can be found in          Section&nbsp;10.5.6, &#8220;Using \'global\' advisors&#8221;.        \n\r          \n\r\n\rsingleton: whether or not the factory should return a single          object, no matter how often the getObject()          method is called. Several FactoryBean          implementations offer such a method. The default value is          true. If you want to use stateful advice - for          example, for stateful mixins - use prototype advices along with a          singleton value of false.        \n\r        10.5.3&nbsp;JDK- and CGLIB-based proxies            \n\r\n\rThis section serves as the definitive documentation on how the      ProxyFactoryBean chooses to create one of either      a JDK- and CGLIB-based proxy for a particular target object (that is to      be proxied).      Note        \n\r\n\rThe behavior of the ProxyFactoryBean with        regard to creating JDK- or CGLIB-based proxies changed between        versions 1.2.x and 2.0 of Spring. The        ProxyFactoryBean now exhibits similar semantics        with regard to auto-detecting interfaces as those of the        TransactionProxyFactoryBean class.            \n\r\n\rIf the class of a target object that is to be proxied (hereafter      simply referred to as the target class) doesn\'t implement any      interfaces, then a CGLIB-based proxy will be created. This is the      easiest scenario, because JDK proxies are interface based, and no      interfaces means JDK proxying isn\'t even possible. One simply plugs in      the target bean, and specifies the list of interceptors via the      interceptorNames property. Note that a CGLIB-based      proxy will be created even if the proxyTargetClass      property of the ProxyFactoryBean has been set to      false. (Obviously this makes no sense, and is best      removed from the bean definition because it is at best redundant, and at      worst confusing.)      \n\r\n\rIf the target class implements one (or more) interfaces, then the      type of proxy that is created depends on the configuration of the      ProxyFactoryBean.      \n\r\n\rIf the proxyTargetClass property of the      ProxyFactoryBean has been set to      true, then a CGLIB-based proxy will be created. This      makes sense, and is in keeping with the principle of least surprise.      Even if the proxyInterfaces property of the      ProxyFactoryBean has been set to one or more      fully qualified interface names, the fact that the      proxyTargetClass property is set to      true will cause CGLIB-based      proxying to be in effect.      \n\r\n\rIf the proxyInterfaces property of the      ProxyFactoryBean has been set to one or more      fully qualified interface names, then a JDK-based proxy will be created.      The created proxy will implement all of the interfaces that were      specified in the proxyInterfaces property; if the      target class happens to implement a whole lot more interfaces than those      specified in the proxyInterfaces property, that is      all well and good but those additional interfaces will not be      implemented by the returned proxy.      \n\r\n\rIf the proxyInterfaces property of the      ProxyFactoryBean has not      been set, but the target class does implement one (or      more) interfaces, then the      ProxyFactoryBean will auto-detect the fact that      the target class does actually implement at least one interface, and a      JDK-based proxy will be created. The interfaces that are actually      proxied will be all of the interfaces that the      target class implements; in effect, this is the same as simply supplying      a list of each and every interface that the target class implements to      the proxyInterfaces property. However, it is      significantly less work, and less prone to typos.        10.5.4&nbsp;Proxying interfaces            \n\r\n\rLet\'s look at a simple example of      ProxyFactoryBean in action. This example      involves:      \n\r          \n\r\n\rA target bean that will be proxied. This          is the \"personTarget\" bean definition in the example below.        \n\r          \n\r\n\rAn Advisor and an Interceptor used to provide advice.        \n\r          \n\r\n\rAn AOP proxy bean definition specifying the target object (the          personTarget bean) and the interfaces to proxy, along with the          advices to apply.        \n\r      &lt;bean id=\"personTarget\" class=\"com.mycompany.PersonImpl\"&gt;    &lt;property name=\"name\" value=\"Tony\"/&gt;    &lt;property name=\"age\" value=\"51\"/&gt;&lt;/bean&gt;&lt;bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\"&gt;    &lt;property name=\"someProperty\" value=\"Custom string property value\"/&gt;&lt;/bean&gt;&lt;bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"&gt;&lt;/bean&gt;&lt;bean id=\"person\"    class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;    &lt;property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/&gt;    &lt;property name=\"target\" ref=\"personTarget\"/&gt;    &lt;property name=\"interceptorNames\"&gt;        &lt;list&gt;            &lt;value&gt;myAdvisor&lt;/value&gt;            &lt;value&gt;debugInterceptor&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rNote that the interceptorNames property takes a      list of String: the bean names of the interceptor or advisors in the      current factory. Advisors, interceptors, before, after returning and      throws advice objects can be used. The ordering of advisors is      significant.      Note        \n\r\n\rYou might be wondering why the list doesn\'t hold bean        references. The reason for this is that if the ProxyFactoryBean\'s        singleton property is set to false, it must be able to return        independent proxy instances. If any of the advisors is itself a        prototype, an independent instance would need to be returned, so it\'s        necessary to be able to obtain an instance of the prototype from the        factory; holding a reference isn\'t sufficient.            \n\r\n\rThe \"person\" bean definition above can be used in place of a      Person implementation, as follows:      Person person = (Person) factory.getBean(\"person\");      \n\r\n\rOther beans in the same IoC context can express a strongly typed      dependency on it, as with an ordinary Java object:      &lt;bean id=\"personUser\" class=\"com.mycompany.PersonUser\"&gt;  &lt;property name=\"person\"&gt;&lt;ref local=\"person\"/&gt;&lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe PersonUser class in this example would      expose a property of type Person. As far as it\'s concerned, the AOP      proxy can be used transparently in place of a \"real\" person      implementation. However, its class would be a dynamic proxy class. It      would be possible to cast it to the Advised interface      (discussed below).      \n\r\n\rIt\'s possible to conceal the distinction between target and proxy      using an anonymous inner bean, as follows. Only the      ProxyFactoryBean definition is different; the advice      is included only for completeness:      &lt;bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\"&gt;  &lt;property name=\"someProperty\" value=\"Custom string property value\"/&gt;&lt;/bean&gt;&lt;bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/&gt;&lt;bean id=\"person\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/&gt;  &lt;!-- Use inner bean, not local reference to target --&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"com.mycompany.PersonImpl\"&gt;      &lt;property name=\"name\" value=\"Tony\"/&gt;      &lt;property name=\"age\" value=\"51\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;myAdvisor&lt;/value&gt;      &lt;value&gt;debugInterceptor&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThis has the advantage that there\'s only one object of type      Person: useful if we want to prevent users of the      application context from obtaining a reference to the un-advised object,      or need to avoid any ambiguity with Spring IoC      autowiring. There\'s also arguably an advantage in      that the ProxyFactoryBean definition is self-contained. However, there      are times when being able to obtain the un-advised target from the      factory might actually be an advantage: for      example, in certain test scenarios.        10.5.5&nbsp;Proxying classes            \n\r\n\rWhat if you need to proxy a class, rather than one or more      interfaces?      \n\r\n\rImagine that in our example above, there was no      Person interface: we needed to advise a class called      Person that didn\'t implement any business interface.      In this case, you can configure Spring to use CGLIB proxying, rather      than dynamic proxies. Simply set the proxyTargetClass      property on the ProxyFactoryBean above to true. While it\'s best to      program to interfaces, rather than classes, the ability to advise      classes that don\'t implement interfaces can be useful when working with      legacy code. (In general, Spring isn\'t prescriptive. While it makes it      easy to apply good practices, it avoids forcing a particular      approach.)      \n\r\n\rIf you want to, you can force the use of CGLIB in any case, even      if you do have interfaces.      \n\r\n\rCGLIB proxying works by generating a subclass of the target class      at runtime. Spring configures this generated subclass to delegate method      calls to the original target: the subclass is used to implement the      Decorator pattern, weaving in the advice.      \n\r\n\rCGLIB proxying should generally be transparent to users. However,      there are some issues to consider:      \n\r          \n\r\n\rFinal methods can\'t be advised, as they          can\'t be overridden.        \n\r          \n\r\n\rThere is no need to add CGLIB to your classpath. As of Spring          3.2, CGLIB is repackaged and included in the spring-core JAR. In          other words, CGLIB-based AOP will work \"out of the box\" just as do          JDK dynamic proxies.        \n\r      \n\r\n\rThere\'s little performance difference between CGLIB proxying and      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.      However, this may change in the future. Performance should not be a      decisive consideration in this case.        10.5.6&nbsp;Using \'global\' advisors            \n\r\n\rBy appending an asterisk to an interceptor name, all advisors with      bean names matching the part before the asterisk, will be added to the      advisor chain. This can come in handy if you need to add a standard set      of \'global\' advisors: &lt;bean id=\"proxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"target\" ref=\"service\"/&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;global*&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"global_debug\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/&gt;&lt;bean id=\"global_performance\" class=\"org.springframework.aop.interceptor.PerformanceMonitorInterceptor\"/&gt;        10.6&nbsp;Concise proxy definitions        \n\r\n\rEspecially when defining transactional proxies, you may end up with    many similar proxy definitions. The use of parent and child bean    definitions, along with inner bean definitions, can result in much cleaner    and more concise proxy definitions.    \n\r\n\rFirst a parent, template, bean definition is    created for the proxy:    &lt;bean id=\"txProxyTemplate\" abstract=\"true\"        class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributes\"&gt;    &lt;props&gt;      &lt;prop key=\"*\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;    &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rThis will never be instantiated itself, so may actually be    incomplete. Then each proxy which needs to be created is just a child bean    definition, which wraps the target of the proxy as an inner bean    definition, since the target will never be used on its own    anyway.&lt;bean id=\"myService\" parent=\"txProxyTemplate\"&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"org.springframework.samples.MyServiceImpl\"&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rIt is of course possible to override properties from the parent    template, such as in this case, the transaction propagation    settings:&lt;bean id=\"mySpecialService\" parent=\"txProxyTemplate\"&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"org.springframework.samples.MySpecialServiceImpl\"&gt;    &lt;/bean&gt;  &lt;/property&gt;  &lt;property name=\"transactionAttributes\"&gt;    &lt;props&gt;      &lt;prop key=\"get*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"find*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"load*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"store*\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;    &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rNote that in the example above, we have explicitly marked the parent    bean definition as abstract by using the    abstract attribute, as described previously, so that it may    not actually ever be instantiated. Application contexts (but not simple    bean factories) will by default pre-instantiate all singletons. It is    therefore important (at least for singleton beans) that if you have a    (parent) bean definition which you intend to use only as a template, and    this definition specifies a class, you must make sure to set the    abstract attribute to true,    otherwise the application context will actually try to pre-instantiate    it.    10.7&nbsp;Creating AOP proxies programmatically with the ProxyFactory        \n\r\n\rIt\'s easy to create AOP proxies programmatically using Spring. This    enables you to use Spring AOP without dependency on Spring IoC.    \n\r\n\rThe following listing shows creation of a proxy for a target object,    with one interceptor and one advisor. The interfaces implemented by the    target object will automatically be proxied:    ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);factory.addAdvice(myMethodInterceptor);factory.addAdvisor(myAdvisor);MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();    \n\r\n\rThe first step is to construct an object of type    org.springframework.aop.framework.ProxyFactory. You can    create this with a target object, as in the above example, or specify the    interfaces to be proxied in an alternate constructor.    \n\r\n\rYou can add advices (with interceptors as a specialized kind of advice)    and/or advisors, and manipulate them for the life of the ProxyFactory.    If you add an IntroductionInterceptionAroundAdvisor, you can cause the proxy    to implement additional interfaces.    \n\r\n\rThere are also convenience methods on ProxyFactory (inherited from    AdvisedSupport) which allow you to add other advice    types such as before and throws advice. AdvisedSupport is the superclass    of both ProxyFactory and ProxyFactoryBean.    Tip      \n\r\n\rIntegrating AOP proxy creation with the IoC framework is best      practice in most applications. We recommend that you externalize      configuration from Java code with AOP, as in general.        10.8&nbsp;Manipulating advised objects        \n\r\n\rHowever you create AOP proxies, you can manipulate them using the    org.springframework.aop.framework.Advised interface.    Any AOP proxy can be cast to this interface, whichever other interfaces it    implements. This interface includes the following methods:    Advisor[] getAdvisors();void addAdvice(Advice advice) throws AopConfigException;void addAdvice(int pos, Advice advice)        throws AopConfigException;void addAdvisor(Advisor advisor) throws AopConfigException;void addAdvisor(int pos, Advisor advisor) throws AopConfigException;int indexOf(Advisor advisor);boolean removeAdvisor(Advisor advisor) throws AopConfigException;void removeAdvisor(int index) throws AopConfigException;boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;boolean isFrozen();    \n\r\n\rThe getAdvisors() method will return an Advisor    for every advisor, interceptor or other advice type that has been added to    the factory. If you added an Advisor, the returned advisor at this index    will be the object that you added. If you added an interceptor or other    advice type, Spring will have wrapped this in an advisor with a pointcut    that always returns true. Thus if you added a    MethodInterceptor, the advisor returned for this index    will be an DefaultPointcutAdvisor returning your    MethodInterceptor and a pointcut that matches all    classes and methods.    \n\r\n\rThe addAdvisor() methods can be used to add any    Advisor. Usually the advisor holding pointcut and advice will be the    generic DefaultPointcutAdvisor, which can be used with    any advice or pointcut (but not for introductions).    \n\r\n\rBy default, it\'s possible to add or remove advisors or interceptors    even once a proxy has been created. The only restriction is that it\'s    impossible to add or remove an introduction advisor, as existing proxies    from the factory will not show the interface change. (You can obtain a new    proxy from the factory to avoid this problem.)    \n\r\n\rA simple example of casting an AOP proxy to the    Advised interface and examining and manipulating its    advice:    Advised advised = (Advised) myObject;Advisor[] advisors = advised.getAdvisors();int oldAdvisorCount = advisors.length;System.out.println(oldAdvisorCount + \" advisors\");// Add an advice like an interceptor without a pointcut// Will match all proxied methods// Can use for interceptors, before, after returning or throws adviceadvised.addAdvice(new DebugInterceptor());// Add selective advice using a pointcutadvised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));assertEquals(\"Added two advisors\",     oldAdvisorCount + 2, advised.getAdvisors().length);    Note      \n\r\n\rIt\'s questionable whether it\'s advisable (no pun intended) to      modify advice on a business object in production, although there are no      doubt legitimate usage cases. However, it can be very useful in      development: for example, in tests. I have sometimes found it very      useful to be able to add test code in the form of an interceptor or      other advice, getting inside a method invocation I want to test. (For      example, the advice can get inside a transaction created for that      method: for example, to run SQL to check that a database was correctly      updated, before marking the transaction for roll back.)        \n\r\n\rDepending on how you created the proxy, you can usually set a    frozen flag, in which case the    Advised isFrozen() method will    return true, and any attempts to modify advice through addition or removal    will result in an AopConfigException. The ability to    freeze the state of an advised object is useful in some cases, for    example, to prevent calling code removing a security interceptor. It may    also be used in Spring 1.1 to allow aggressive optimization if runtime    advice modification is known not to be required.    10.9&nbsp;Using the \"auto-proxy\" facility        \n\r\n\rSo far we\'ve considered explicit creation of AOP proxies using a    ProxyFactoryBean or similar factory bean.    \n\r\n\rSpring also allows us to use \"auto-proxy\" bean definitions, which can    automatically proxy selected bean definitions. This is built on Spring    \"bean post processor\" infrastructure, which enables modification of any    bean definition as the container loads.    \n\r\n\rIn this model, you set up some special bean definitions in your XML    bean definition file to configure the auto proxy infrastructure. This    allows you just to declare the targets eligible for auto-proxying: you    don\'t need to use ProxyFactoryBean.    \n\r\n\rThere are two ways to do this:    \n\r        \n\r\n\rUsing an auto-proxy creator that refers to specific beans in the        current context.      \n\r        \n\r\n\rA special case of auto-proxy creation that deserves to be        considered separately; auto-proxy creation driven by source-level        metadata attributes.      \n\r    10.9.1&nbsp;Autoproxy bean definitions            \n\r\n\rThe org.springframework.aop.framework.autoproxy      package provides the following standard auto-proxy creators.      BeanNameAutoProxyCreator                \n\r\n\rThe BeanNameAutoProxyCreator class is a        BeanPostProcessor that automatically creates AOP        proxies for beans with names matching literal values or        wildcards.        &lt;bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\"&gt;  &lt;property name=\"beanNames\" value=\"jdk*,onlyJdk\"/&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;myInterceptor&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;        \n\r\n\rAs with ProxyFactoryBean, there is an        interceptorNames property rather than a list of        interceptors, to allow correct behavior for prototype advisors. Named        \"interceptors\" can be advisors or any advice type.        \n\r\n\rAs with auto proxying in general, the main point of using        BeanNameAutoProxyCreator is to apply the same        configuration consistently to multiple objects, with minimal volume of        configuration. It is a popular choice for applying declarative        transactions to multiple objects.        \n\r\n\rBean definitions whose names match, such as \"jdkMyBean\" and        \"onlyJdk\" in the above example, are plain old bean definitions with        the target class. An AOP proxy will be created automatically by the        BeanNameAutoProxyCreator. The same advice will be        applied to all matching beans. Note that if advisors are used (rather        than the interceptor in the above example), the pointcuts may apply        differently to different beans.            DefaultAdvisorAutoProxyCreator                \n\r\n\rA more general and extremely powerful auto proxy creator is        DefaultAdvisorAutoProxyCreator. This will        automagically apply eligible advisors in the current context, without        the need to include specific bean names in the auto-proxy advisor\'s        bean definition. It offers the same merit of consistent configuration        and avoidance of duplication as        BeanNameAutoProxyCreator.        \n\r\n\rUsing this mechanism involves:        \n\r            \n\r\n\rSpecifying a            DefaultAdvisorAutoProxyCreator bean            definition.          \n\r            \n\r\n\rSpecifying any number of Advisors in the same or related            contexts. Note that these must be Advisors,            not just interceptors or other advices. This is necessary because            there must be a pointcut to evaluate, to check the eligibility of            each advice to candidate bean definitions.          \n\r        \n\r\n\rThe DefaultAdvisorAutoProxyCreator will        automatically evaluate the pointcut contained in each advisor, to see        what (if any) advice it should apply to each business object (such as        \"businessObject1\" and \"businessObject2\" in the example).        \n\r\n\rThis means that any number of advisors can be applied        automatically to each business object. If no pointcut in any of the        advisors matches any method in a business object, the object will not        be proxied. As bean definitions are added for new business objects,        they will automatically be proxied if necessary.        \n\r\n\rAutoproxying in general has the advantage of making it        impossible for callers or dependencies to obtain an un-advised object.        Calling getBean(\"businessObject1\") on this ApplicationContext will        return an AOP proxy, not the target business object. (The \"inner bean\"        idiom shown earlier also offers this benefit.)        &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"customAdvisor\" class=\"com.mycompany.MyAdvisor\"/&gt;&lt;bean id=\"businessObject1\" class=\"com.mycompany.BusinessObject1\"&gt;  &lt;!-- Properties omitted --&gt;&lt;/bean&gt;&lt;bean id=\"businessObject2\" class=\"com.mycompany.BusinessObject2\"/&gt;        \n\r\n\rThe DefaultAdvisorAutoProxyCreator is very        useful if you want to apply the same advice consistently to many        business objects. Once the infrastructure definitions are in place,        you can simply add new business objects without including specific        proxy configuration. You can also drop in additional aspects very        easily - for example, tracing or performance monitoring aspects - with        minimal change to configuration.        \n\r\n\rThe DefaultAdvisorAutoProxyCreator offers support for filtering        (using a naming convention so that only certain advisors are        evaluated, allowing use of multiple, differently configured,        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors        can implement the org.springframework.core.Ordered        interface to ensure correct ordering if this is an issue. The        TransactionAttributeSourceAdvisor used in the above example has a        configurable order value; the default setting is unordered.            AbstractAdvisorAutoProxyCreator                \n\r\n\rThis is the superclass of DefaultAdvisorAutoProxyCreator. You        can create your own auto-proxy creators by subclassing this class, in        the unlikely event that advisor definitions offer insufficient        customization to the behavior of the framework        DefaultAdvisorAutoProxyCreator.              10.9.2&nbsp;Using metadata-driven auto-proxying            \n\r\n\rA particularly important type of auto-proxying is driven by      metadata. This produces a similar programming model to .NET      ServicedComponents. Instead of defining metadata      in XML descriptors, configuration for transaction management and      other enterprise services is held in source-level attributes.      \n\r\n\rIn this case, you use the      DefaultAdvisorAutoProxyCreator, in combination with      Advisors that understand metadata attributes. The metadata specifics are      held in the pointcut part of the candidate advisors, rather than in the      auto-proxy creation class itself.      \n\r\n\rThis is really a special case of the      DefaultAdvisorAutoProxyCreator, but deserves      consideration on its own. (The metadata-aware code is in the pointcuts      contained in the advisors, not the AOP framework itself.)      \n\r\n\rThe /attributes directory of the JPetStore      sample application shows the use of attribute-driven auto-proxying.      In this case, there\'s no need to use the      TransactionProxyFactoryBean. Simply defining      transactional attributes on business objects is sufficient, because of      the use of metadata-aware pointcuts. The bean definitions include the      following code, in /WEB-INF/declarativeServices.xml.      Note that this is generic, and can be used outside the JPetStore:      &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"transactionInterceptor\"    class=\"org.springframework.transaction.interceptor.TransactionInterceptor\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributeSource\"&gt;    &lt;bean class=\"org.springframework.transaction.interceptor.AttributesTransactionAttributeSource\"&gt;      &lt;property name=\"attributes\" ref=\"attributes\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"attributes\" class=\"org.springframework.metadata.commons.CommonsAttributes\"/&gt;      \n\r\n\rThe DefaultAdvisorAutoProxyCreator bean      definition (the name is not significant, hence it can even be omitted)      will pick up all eligible pointcuts in the current application context.      In this case, the \"transactionAdvisor\" bean definition, of type      TransactionAttributeSourceAdvisor, will apply to      classes or methods carrying a transaction attribute. The      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,      via constructor dependency. The example resolves this via autowiring.      The AttributesTransactionAttributeSource depends on      an implementation of the      org.springframework.metadata.Attributes interface. In      this fragment, the \"attributes\" bean satisfies this, using the Jakarta      Commons Attributes API to obtain attribute information. (The application      code must have been compiled using the Commons Attributes compilation      task.)      \n\r\n\rThe /annotation directory of the JPetStore      sample application contains an analogous example for auto-proxying      driven by JDK 1.5+ annotations. The following configuration enables      automatic detection of Spring\'s Transactional      annotation, leading to implicit proxies for beans containing that      annotation:      &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"transactionInterceptor\"    class=\"org.springframework.transaction.interceptor.TransactionInterceptor\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributeSource\"&gt;    &lt;bean class=\"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\"/&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe TransactionInterceptor defined here depends      on a PlatformTransactionManager definition, which is      not included in this generic file (although it could be) because it will      be specific to the application\'s transaction requirements (typically      JTA, as in this example, or Hibernate, JDO or JDBC):      &lt;bean id=\"transactionManager\"    class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;      Tip        \n\r\n\rIf you require only declarative transaction management, using        these generic XML definitions will result in Spring automatically        proxying all classes or methods with transaction attributes. You won\'t        need to work directly with AOP, and the programming model is similar        to that of .NET ServicedComponents.            \n\r\n\rThis mechanism is extensible. It\'s possible to do auto-proxying      based on custom attributes. You need to:      \n\r          \n\r\n\rDefine your custom attribute.        \n\r          \n\r\n\rSpecify an Advisor with the necessary advice, including a          pointcut that is triggered by the presence of the custom attribute          on a class or method. You may be able to use an existing advice,          merely implementing a static pointcut that picks up the custom          attribute.        \n\r      \n\r\n\rIt\'s possible for such advisors to be unique to each advised class      (for example, mixins): they simply need to be defined as prototype,      rather than singleton, bean definitions. For example, the      LockMixin introduction interceptor from the Spring      test suite, shown above, could be used in conjunction with an      attribute-driven pointcut to target a mixin, as shown here. We use the      generic DefaultPointcutAdvisor, configured using      JavaBean properties:      &lt;bean id=\"lockMixin\" class=\"org.springframework.aop.LockMixin\"    scope=\"prototype\"/&gt;&lt;bean id=\"lockableAdvisor\" class=\"org.springframework.aop.support.DefaultPointcutAdvisor\"    scope=\"prototype\"&gt;  &lt;property name=\"pointcut\" ref=\"myAttributeAwarePointcut\"/&gt;  &lt;property name=\"advice\" ref=\"lockMixin\"/&gt;&lt;/bean&gt;&lt;bean id=\"anyBean\" class=\"anyclass\" ...      \n\r\n\rIf the attribute aware pointcut matches any methods in the      anyBean or other bean definitions, the mixin will be      applied. Note that both lockMixin and      lockableAdvisor definitions are prototypes. The      myAttributeAwarePointcut pointcut can be a singleton      definition, as it doesn\'t hold state for individual advised      objects.        10.10&nbsp;Using TargetSources        \n\r\n\rSpring offers the concept of a TargetSource,    expressed in the org.springframework.aop.TargetSource    interface. This interface is responsible for returning the \"target object\"    implementing the join point. The TargetSource    implementation is asked for a target instance each time the AOP proxy    handles a method invocation.    \n\r\n\rDevelopers using Spring AOP don\'t normally need to work directly    with TargetSources, but this provides a powerful means of supporting    pooling, hot swappable and other sophisticated targets. For example, a    pooling TargetSource can return a different target instance for each    invocation, using a pool to manage instances.    \n\r\n\rIf you do not specify a TargetSource, a default implementation is    used that wraps a local object. The same target is returned for each    invocation (as you would expect).    \n\r\n\rLet\'s look at the standard target sources provided with Spring, and    how you can use them.    Tip      \n\r\n\rWhen using a custom target source, your target will usually need      to be a prototype rather than a singleton bean definition. This allows      Spring to create a new target instance when required.        10.10.1&nbsp;Hot swappable target sources            \n\r\n\rThe      org.springframework.aop.target.HotSwappableTargetSource      exists to allow the target of an AOP proxy to be switched while allowing      callers to keep their references to it.      \n\r\n\rChanging the target source\'s target takes effect immediately. The      HotSwappableTargetSource is threadsafe.      \n\r\n\rYou can change the target via the swap() method      on HotSwappableTargetSource as follows:      HotSwappableTargetSource swapper =    (HotSwappableTargetSource) beanFactory.getBean(\"swapper\");Object oldTarget = swapper.swap(newTarget);      \n\r\n\rThe XML definitions required look as follows:      &lt;bean id=\"initialTarget\" class=\"mycompany.OldTarget\"/&gt;&lt;bean id=\"swapper\" class=\"org.springframework.aop.target.HotSwappableTargetSource\"&gt;  &lt;constructor-arg ref=\"initialTarget\"/&gt;&lt;/bean&gt;&lt;bean id=\"swappable\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"targetSource\" ref=\"swapper\"/&gt;&lt;/bean&gt;      \n\r\n\rThe above swap() call changes the target of the      swappable bean. Clients who hold a reference to that bean will be      unaware of the change, but will immediately start hitting the new      target.      \n\r\n\rAlthough this example doesn\'t add any advice - and it\'s not      necessary to add advice to use a TargetSource - of      course any TargetSource can be used in conjunction      with arbitrary advice.        10.10.2&nbsp;Pooling target sources            \n\r\n\rUsing a pooling target source provides a similar programming model      to stateless session EJBs, in which a pool of identical instances is      maintained, with method invocations going to free objects in the      pool.      \n\r\n\rA crucial difference between Spring pooling and SLSB pooling is      that Spring pooling can be applied to any POJO. As with Spring in      general, this service can be applied in a non-invasive way.      \n\r\n\rSpring provides out-of-the-box support for Jakarta Commons Pool      1.3, which provides a fairly efficient pooling implementation. You\'ll      need the commons-pool Jar on your application\'s classpath to use this      feature. It\'s also possible to subclass      org.springframework.aop.target.AbstractPoolingTargetSource      to support any other pooling API.      \n\r\n\rSample configuration is shown below:      &lt;bean id=\"businessObjectTarget\" class=\"com.mycompany.MyBusinessObject\"    scope=\"prototype\"&gt;  ... properties omitted&lt;/bean&gt;&lt;bean id=\"poolTargetSource\" class=\"org.springframework.aop.target.CommonsPoolTargetSource\"&gt;  &lt;property name=\"targetBeanName\" value=\"businessObjectTarget\"/&gt;  &lt;property name=\"maxSize\" value=\"25\"/&gt;&lt;/bean&gt;&lt;bean id=\"businessObject\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"targetSource\" ref=\"poolTargetSource\"/&gt;  &lt;property name=\"interceptorNames\" value=\"myInterceptor\"/&gt;&lt;/bean&gt;      \n\r\n\rNote that the target object - \"businessObjectTarget\" in the      example - must be a prototype. This allows the      PoolingTargetSource implementation to create new      instances of the target to grow the pool as necessary. See the javadoc      for AbstractPoolingTargetSource and the concrete      subclass you wish to use for information about its properties: \"maxSize\"      is the most basic, and always guaranteed to be present.      \n\r\n\rIn this case, \"myInterceptor\" is the name of an interceptor that      would need to be defined in the same IoC context. However, it isn\'t      necessary to specify interceptors to use pooling. If you want only      pooling, and no other advice, don\'t set the interceptorNames property at      all.      \n\r\n\rIt\'s possible to configure Spring so as to be able to cast any      pooled object to the      org.springframework.aop.target.PoolingConfig      interface, which exposes information about the configuration and current      size of the pool through an introduction. You\'ll need to define an      advisor like this:      &lt;bean id=\"poolConfigAdvisor\" class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"poolTargetSource\"/&gt;  &lt;property name=\"targetMethod\" value=\"getPoolingConfigMixin\"/&gt;&lt;/bean&gt;      \n\r\n\rThis advisor is obtained by calling a convenience method on the      AbstractPoolingTargetSource class, hence the use of      MethodInvokingFactoryBean. This advisor\'s name (\"poolConfigAdvisor\"      here) must be in the list of interceptors names in the ProxyFactoryBean      exposing the pooled object.      \n\r\n\rThe cast will look as follows:      PoolingConfig conf = (PoolingConfig) beanFactory.getBean(\"businessObject\");System.out.println(\"Max pool size is \" + conf.getMaxSize());      Note        \n\r\n\rPooling stateless service objects is not usually necessary. We        don\'t believe it should be the default choice, as most stateless        objects are naturally thread safe, and instance pooling is problematic        if resources are cached.            \n\r\n\rSimpler pooling is available using auto-proxying. It\'s possible to      set the TargetSources used by any auto-proxy creator.        10.10.3&nbsp;Prototype target sources            \n\r\n\rSetting up a \"prototype\" target source is similar to a pooling      TargetSource. In this case, a new instance of the target will be created      on every method invocation. Although the cost of creating a new object      isn\'t high in a modern JVM, the cost of wiring up the new object      (satisfying its IoC dependencies) may be more expensive. Thus you      shouldn\'t use this approach without very good reason.      \n\r\n\rTo do this, you could modify the      poolTargetSource definition shown above as follows.      (I\'ve also changed the name, for clarity.)      &lt;bean id=\"prototypeTargetSource\" class=\"org.springframework.aop.target.PrototypeTargetSource\"&gt;  &lt;property name=\"targetBeanName\" ref=\"businessObjectTarget\"/&gt;&lt;/bean&gt;      \n\r\n\rThere\'s only one property: the name of the target bean.      Inheritance is used in the TargetSource implementations to ensure      consistent naming. As with the pooling target source, the target bean      must be a prototype bean definition.        10.10.4&nbsp;ThreadLocal target sources            \n\r\n\rThreadLocal target sources are useful if      you need an object to be created for each incoming request (per thread      that is). The concept of a ThreadLocal provide a      JDK-wide facility to transparently store resource alongside a thread.      Setting up a ThreadLocalTargetSource is pretty      much the same as was explained for the other types of target      source:      &lt;bean id=\"threadlocalTargetSource\" class=\"org.springframework.aop.target.ThreadLocalTargetSource\"&gt;  &lt;property name=\"targetBeanName\" value=\"businessObjectTarget\"/&gt;&lt;/bean&gt;      Note        \n\r\n\rThreadLocals come with serious issues (potentially resulting in        memory leaks) when incorrectly using them in a multi-threaded and        multi-classloader environments. One should always consider wrapping a        threadlocal in some other class and never directly use the        ThreadLocal itself (except of course in the        wrapper class). Also, one should always remember to correctly set and        unset (where the latter simply involved a call to        ThreadLocal.set(null)) the resource local to the        thread. Unsetting should be done in any case since not unsetting it        might result in problematic behavior. Spring\'s ThreadLocal support        does this for you and should always be considered in favor of using        ThreadLocals without other proper handling code.              10.11&nbsp;Defining new Advice types        \n\r\n\rSpring AOP is designed to be extensible. While the interception    implementation strategy is presently used internally, it is possible to    support arbitrary advice types in addition to the out-of-the-box    interception around advice, before, throws advice and after returning    advice.    \n\r\n\rThe org.springframework.aop.framework.adapter    package is an SPI package allowing support for new custom advice types to    be added without changing the core framework. The only constraint on a    custom Advice type is that it must    implement the org.aopalliance.aop.Advice    tag interface.    \n\r\n\rPlease refer to the    org.springframework.aop.framework.adapter package\'s    Javadocs for further information.    10.12&nbsp;Further resources        \n\r\n\rPlease refer to the Spring sample applications for further examples    of Spring AOP:    \n\r        \n\r\n\rThe JPetStore\'s default configuration illustrates the use of the        TransactionProxyFactoryBean for declarative        transaction management.      \n\r        \n\r\n\rThe /attributes directory of the JPetStore        illustrates the use of attribute-driven declarative transaction        management.      \n\r  Prev&nbsp;Up&nbsp;Next9.&nbsp;Aspect Oriented Programming with Spring&nbsp;Home&nbsp;11.&nbsp;Testing","10. Spring AOP APIs","scr\\aop-api.html","         5.&nbsp;The IoC containerPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next5.&nbsp;The IoC container    5.1&nbsp;Introduction to the Spring IoC container and beans        \n\r\n\rThis chapter covers the Spring Framework implementation of the      Inversion of Control (IoC) [1]principle. IoC is also known as dependency      injection (DI). It is a process whereby objects define their      dependencies, that is, the other objects they work with, only through      constructor arguments, arguments to a factory method, or properties that      are set on the object instance after it is constructed or returned from a      factory method. The container then injects those      dependencies when it creates the bean. This process is fundamentally the      inverse, hence the name Inversion of Control (IoC),      of the bean itself controlling the instantiation or location of its      dependencies by using direct construction of classes, or a mechanism such      as the Service Locator pattern.        \n\r\n\rThe org.springframework.beans and      org.springframework.context packages are the basis for      Spring Framework\'s IoC container. The BeanFactory interface provides an advanced      configuration mechanism capable of managing any type of object.      ApplicationContext is a sub-interface of      BeanFactory. It adds easier integration      with Spring\'s AOP features; message resource handling (for use in      internationalization), event publication; and application-layer specific      contexts such as the WebApplicationContext      for use in web applications.    \n\r\n\rIn short, the BeanFactory provides the      configuration framework and basic functionality, and the      ApplicationContext adds more      enterprise-specific functionality. The      ApplicationContext is a complete superset      of the BeanFactory, and is used exclusively      in this chapter in descriptions of Spring\'s IoC container.      For      more information on using the BeanFactory instead      of the ApplicationContext, refer to Section&nbsp;5.15, &#8220;The BeanFactory&#8221;.    \n\r\n\rIn Spring, the objects that form the backbone of your application and      that are managed by the Spring IoC container are      called beans. A bean is an object that is      instantiated, assembled, and otherwise managed by a Spring IoC container.      Otherwise, a bean is simply one of many objects in your application.      Beans, and the dependencies among them, are      reflected in the configuration metadata used by a      container.    5.2&nbsp;Container overview        \n\r\n\rThe interface      org.springframework.context.ApplicationContext      represents the Spring IoC container and is responsible for instantiating,      configuring, and assembling the aforementioned beans. The container gets      its instructions on what objects to instantiate, configure, and assemble      by reading configuration metadata. The configuration metadata is      represented in XML, Java annotations, or Java code. It allows you to      express the objects that compose your application and the rich      interdependencies between such objects.    \n\r\n\rSeveral implementations of the      ApplicationContext interface are supplied      out-of-the-box with Spring. In standalone applications it is common to      create an instance of ClassPathXmlApplicationContext or FileSystemXmlApplicationContext.       While XML has been the traditional format      for defining configuration metadata you can instruct the container to use      Java annotations or code as the metadata format by providing a small amount      of XML configuration to declaratively enable support for these additional      metadata formats.    \n\r\n\rIn most application scenarios, explicit user code is not required to      instantiate one or more instances of a Spring IoC container. For example,      in a web application scenario, a simple eight (or so) lines of boilerplate      J2EE web descriptor XML in the web.xml file of the      application will typically suffice (see Section&nbsp;5.14.4, &#8220;Convenient ApplicationContext      instantiation for web applications&#8221;).      If you are using the SpringSource Tool Suite Eclipse-powered development environment      or Spring Roo this      boilerplate configuration can be easily created with few mouse clicks or      keystrokes.    \n\r\n\rThe following diagram is a high-level view of how Spring works. Your      application classes are combined with configuration metadata so that after      the ApplicationContext is created and initialized,      you have a fully configured and executable system or application.    \n\r\n\rThe Spring IoC container    5.2.1&nbsp;Configuration metadata            \n\r\n\rAs the preceding diagram shows, the Spring IoC container consumes a        form of configuration metadata; this configuration        metadata represents how you as an application developer tell the Spring        container to instantiate, configure, and assemble the objects in your        application.      \n\r\n\rConfiguration metadata is traditionally supplied in a simple and        intuitive XML format, which is what most of this chapter uses to convey        key concepts and features of the Spring IoC container.      Note        \n\r\n\rXML-based metadata is not the only allowed          form of configuration metadata. The Spring IoC container itself is          totally decoupled from the format in which this          configuration metadata is actually written.            \n\r\n\rFor information about using other forms of metadata with the Spring        container, see:      \n\r          \n\r\n\rAnnotation-based            configuration: Spring 2.5 introduced support for            annotation-based configuration metadata.        \n\r          \n\r\n\rJava-based configuration:            Starting with Spring 3.0, many features provided by the Spring JavaConfig            project became part of the core Spring Framework. Thus you            can define beans external to your application classes by using Java            rather than XML files. To use these new features, see the            @Configuration, @Bean,            @Import and            @DependsOn annotations.        \n\r      \n\r\n\rSpring configuration consists of at least one and typically more        than one bean definition that the container must manage. XML-based        configuration metadata shows these beans configured as        &lt;bean/&gt; elements inside a top-level        &lt;beans/&gt; element.      \n\r\n\rThese bean definitions correspond to the actual objects that make up        your application. Typically you define service layer objects, data        access objects (DAOs), presentation objects such as Struts        Action instances, infrastructure objects        such as Hibernate SessionFactories, JMS        Queues, and so forth. Typically one does        not configure fine-grained domain objects in the container, because it        is usually the responsibility of DAOs and business logic to create and        load domain objects. However, you can use Spring\'s integration with        AspectJ to configure objects that have been created outside the control        of an IoC container. See Using        AspectJ to dependency-inject domain objects with Spring.      \n\r\n\rThe following example shows the basic structure of XML-based        configuration metadata:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean id=\"...\" class=\"...\"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;bean id=\"...\" class=\"...\"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt;      \n\r\n\rThe id attribute is a string that you use to        identify the individual bean definition. The class        attribute defines the type of the bean and uses the fully qualified        classname. The value of the id attribute refers to collaborating        objects. The XML for referring to collaborating objects is not shown in        this example; see Dependencies        for more information.        5.2.2&nbsp;Instantiating a container            \n\r\n\rInstantiating a Spring IoC container is straightforward. The        location path or paths supplied to an        ApplicationContext constructor are        actually resource strings that allow the container to load configuration        metadata from a variety of external resources such as the local file        system, from the Java CLASSPATH, and so on.      ApplicationContext context =    new ClassPathXmlApplicationContext(new String[] {\"services.xml\", \"daos.xml\"});      Note        \n\r\n\rAfter you learn about Spring\'s IoC container, you may want to know          more about Spring\'s Resource          abstraction, as described in Chapter&nbsp;6, Resources, which          provides a convenient mechanism for reading an InputStream from          locations defined in a URI syntax. In particular,          Resource paths are used to construct          applications contexts as described in Section&nbsp;6.7, &#8220;Application contexts and Resource paths&#8221;.            \n\r\n\rThe following example shows the service layer objects        (services.xml) configuration file:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;!-- services --&gt;  &lt;bean id=\"petStore\"        class=\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\"&gt;    &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt;    &lt;property name=\"itemDao\" ref=\"itemDao\"/&gt;    &lt;!-- additional collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt;      \n\r\n\rThe following example shows the data access objects        daos.xml file:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean id=\"accountDao\"      class=\"org.springframework.samples.jpetstore.dao.ibatis.SqlMapAccountDao\"&gt;    &lt;!-- additional collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.ibatis.SqlMapItemDao\"&gt;    &lt;!-- additional collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;      \n\r\n\rIn the preceding example, the service layer consists of the class        PetStoreServiceImpl, and two data access objects        of the type SqlMapAccountDao and SqlMapItemDao        are based on the iBatis        Object/Relational mapping framework. The property        name element refers to the name of the JavaBean property, and        the ref element refers to the name of another bean        definition. This linkage between id and ref elements expresses the        dependency between collaborating objects. For details of configuring an        object\'s dependencies, see Dependencies.      Composing XML-based configuration metadata                \n\r\n\rIt can be useful to have bean definitions span multiple XML files.          Often each individual XML configuration file represents a logical          layer or module in your architecture.        \n\r\n\rYou can use the application context constructor to load bean          definitions from all these XML fragments. This constructor takes          multiple Resource locations, as was          shown in the previous section. Alternatively, use one or more          occurrences of the &lt;import/&gt; element to load          bean definitions from another file or files. For example:        &lt;beans&gt;    &lt;import resource=\"services.xml\"/&gt;    &lt;import resource=\"resources/messageSource.xml\"/&gt;    &lt;import resource=\"/resources/themeSource.xml\"/&gt;    &lt;bean id=\"bean1\" class=\"...\"/&gt;    &lt;bean id=\"bean2\" class=\"...\"/&gt;&lt;/beans&gt;        \n\r\n\rIn the preceding example, external bean definitions are loaded          from three files, services.xml,          messageSource.xml, and          themeSource.xml. All location paths are relative to          the definition file doing the importing, so          services.xml must be in the same directory or          classpath location as the file doing the importing, while          messageSource.xml and          themeSource.xml must be in a          resources location below the location of the          importing file. As you can see, a leading slash is ignored, but given          that these paths are relative, it is better form not to use the slash          at all. The contents of the files being imported, including the top          level &lt;beans/&gt; element, must be valid XML          bean definitions according to the Spring Schema or DTD.        Note          \n\r\n\rIt is possible, but not recommended, to reference files in            parent directories using a relative \"../\" path. Doing so creates a            dependency on a file that is outside the current application. In            particular, this reference is not recommended for \"classpath:\" URLs            (for example, \"classpath:../services.xml\"), where the runtime            resolution process chooses the \"nearest\" classpath root and then            looks into its parent directory. Classpath configuration changes may            lead to the choice of a different, incorrect directory.          \n\r\n\rYou can always use fully qualified resource locations instead of            relative paths: for example, \"file:C:/config/services.xml\" or            \"classpath:/config/services.xml\". However, be aware that you are            coupling your application\'s configuration to specific absolute            locations. It is generally preferable to keep an indirection for            such absolute locations, for example, through \"${...}\" placeholders            that are resolved against JVM system properties at runtime.                      5.2.3&nbsp;Using the container            \n\r\n\rThe ApplicationContext is the        interface for an advanced factory capable of maintaining a registry of        different beans and their dependencies. Using the method T        getBean(String name, Class&lt;T&gt; requiredType) you can        retrieve instances of your beans.      \n\r\n\rThe ApplicationContext enables you to        read bean definitions and access them as follows:      // create and configure beansApplicationContext context =    new ClassPathXmlApplicationContext(new String[] {\"services.xml\", \"daos.xml\"});// retrieve configured instancePetStoreServiceImpl service = context.getBean(\"petStore\", PetStoreServiceImpl.class);// use configured instanceList userList = service.getUsernameList();      \n\r\n\rYou use getBean() to retrieve instances of        your beans. The ApplicationContext        interface has a few other methods for retrieving beans, but ideally your        application code should never use them. Indeed, your application code        should have no calls to the getBean() method at        all, and thus no dependency on Spring APIs at all. For example, Spring\'s        integration with web frameworks provides for dependency injection for        various web framework classes such as controllers and JSF-managed        beans.        5.3&nbsp;Bean overview        \n\r\n\rA Spring IoC container manages one or more beans.      These beans are created with the configuration metadata that you supply to      the container, for example, in the form of XML      &lt;bean/&gt; definitions.    \n\r\n\rWithin the container itself, these bean definitions are represented as      BeanDefinition objects, which contain      (among other information) the following metadata:    \n\r        \n\r\n\rA package-qualified class name: typically the          actual implementation class of the bean being defined.      \n\r        \n\r\n\rBean behavioral configuration elements, which state how the bean          should behave in the container (scope, lifecycle callbacks, and so          forth).      \n\r        \n\r\n\rReferences to other beans that are needed for the bean to do its          work; these references are also called          collaborators or          dependencies.      \n\r        \n\r\n\rOther configuration settings to set in the newly created object,          for example, the number of connections to use in a bean that manages a          connection pool, or the size limit of the pool.      \n\r    \n\r\n\rThis metadata translates to a set of properties that make up each bean      definition.    \n\r\n\rTable&nbsp;5.1.&nbsp;The bean definition            PropertyExplained in...class\n\r\n\r Section&nbsp;5.3.2, &#8220;Instantiating beans&#8221; name\n\r\n\r Section&nbsp;5.3.1, &#8220;Naming beans&#8221; scope\n\r\n\r Section&nbsp;5.5, &#8220;Bean scopes&#8221; constructor arguments\n\r\n\r Section&nbsp;5.4.1, &#8220;Dependency injection&#8221;              properties\n\r\n\r Section&nbsp;5.4.1, &#8220;Dependency injection&#8221;              autowiring mode\n\r\n\r Section&nbsp;5.4.5, &#8220;Autowiring collaborators&#8221;              lazy-initialization mode\n\r\n\r Section&nbsp;5.4.4, &#8220;Lazy-initialized      beans&#8221;              initialization method\n\r\n\r the section called &#8220;Initialization callbacks&#8221;              destruction method\n\r\n\r the section called &#8220;Destruction callbacks&#8221;     \n\r    \n\r\n\rIn addition to bean definitions that contain information on how to      create a specific bean, the      ApplicationContext implementations also      permit the registration of existing objects that are created outside the      container, by users. This is done by accessing the ApplicationContext\'s      BeanFactory via the method getBeanFactory() which      returns the BeanFactory implementation      DefaultListableBeanFactory.      DefaultListableBeanFactory supports this      registration through the methods      registerSingleton(..) and      registerBeanDefinition(..). However, typical      applications work solely with beans defined through metadata bean      definitions.    5.3.1&nbsp;Naming beans            \n\r\n\rEvery bean has one or more identifiers. These identifiers must be        unique within the container that hosts the bean. A bean usually has only        one identifier, but if it requires more than one, the extra ones can be        considered aliases.      \n\r\n\rIn XML-based configuration metadata, you use the        id and/or name attributes to        specify the bean identifier(s). The id attribute        allows you to specify exactly one id.  Conventionally these names are        alphanumeric (\'myBean\', \'fooService\', etc), but may special characters        as well.  If you want to introduce other aliases to the bean, you can        also specify them in the name attribute, separated by        a comma (,), semicolon (;), or        white space.  As a historical note, in versions prior to Spring 3.1, the        id attribute was typed as an        xsd:ID, which constrained possible characters.  As of        3.1, it is now xsd:string.  Note that bean id        uniqueness is still enforced by the container, though no longer by XML        parsers.      \n\r\n\rYou are not required to supply a name or id for a bean. If no name        or id is supplied explicitly, the container generates a unique name for        that bean. However, if you want to refer to that bean by name, through        the use of the ref element or Service Locator style lookup,        you must provide a name. Motivations for not supplying a name are        related to using inner beans        and autowiring        collaborators.      \n\r\n\rBean naming conventions                \n\r\n\rThe convention is to use the standard Java convention for instance          field names when naming beans. That is, bean names start with a          lowercase letter, and are camel-cased from then on. Examples of such          names would be (without quotes) \'accountManager\',          \'accountService\', \'userDao\',          \'loginController\', and so forth.        \n\r\n\rNaming beans consistently makes your configuration easier to read          and understand, and if you are using Spring AOP it helps a lot when          applying advice to a set of beans related by name.            Aliasing a bean outside the bean definition                \n\r\n\rIn a bean definition itself, you can supply more than one name for          the bean, by using a combination of up to one name specified by the          id attribute, and any number of other names in the          name attribute. These names can be equivalent          aliases to the same bean, and are useful for some situations, such as          allowing each component in an application to refer to a common          dependency by using a bean name that is specific to that component          itself.        \n\r\n\rSpecifying all aliases where the bean is actually defined is not          always adequate, however. It is sometimes desirable to introduce an          alias for a bean that is defined elsewhere. This is commonly the case          in large systems where configuration is split amongst each subsystem,          each subsystem having its own set of object definitions. In XML-based          configuration metadata, you can use the          &lt;alias/&gt; element to accomplish this.        &lt;alias name=\"fromName\" alias=\"toName\"/&gt;        \n\r\n\rIn this case, a bean in the same container which is named          fromName, may also after the use of this alias          definition, be referred to as toName.                \n\r\n\rFor example, the configuration metadata for subsystem A may refer          to a DataSource via the name \'subsystemA-dataSource. The configuration          metadata for subsystem B may refer to a DataSource via the name          \'subsystemB-dataSource\'. When composing the main application that uses          both these subsystems the main application refers to the DataSource          via the name \'myApp-dataSource\'. To have all three names refer to the          same object you add to the MyApp configuration metadata the following          aliases definitions:        &lt;alias name=\"subsystemA-dataSource\" alias=\"subsystemB-dataSource\"/&gt;&lt;alias name=\"subsystemA-dataSource\" alias=\"myApp-dataSource\" /&gt;        \n\r\n\rNow each component and the main application can refer to the          dataSource through a name that is unique and guaranteed not to clash          with any other definition (effectively creating a namespace), yet they          refer to the same bean.              5.3.2&nbsp;Instantiating beans            \n\r\n\rA bean definition essentially is a recipe for creating one or more        objects. The container looks at the recipe for a named bean when asked,        and uses the configuration metadata encapsulated by that bean definition        to create (or acquire) an actual object.      \n\r\n\rIf you use XML-based configuration metadata, you specify the type        (or class) of object that is to be instantiated in the        class attribute of the        &lt;bean/&gt; element. This class        attribute, which internally is a Class property        on a BeanDefinition instance, is usually        mandatory. (For exceptions, see the section called &#8220;Instantiation using an instance factory method&#8221; and Section&nbsp;5.7, &#8220;Bean definition inheritance&#8221;.) You use the        Class property in one of two ways: \n\r          \n\r\n\rTypically, to specify the bean class to be constructed in the            case where the container itself directly creates the bean by calling            its constructor reflectively, somewhat equivalent to Java code using            the new operator.        \n\r      \n\r          \n\r\n\rTo specify the actual class containing the            static factory method that will be invoked to            create the object, in the less common case where the container            invokes a static, factory            method on a class to create the bean. The object type returned from            the invocation of the static factory method may            be the same class or another class entirely.        \n\r      \n\r\n\rInner class names                \n\r\n\rIf you want to configure a bean definition for a          static nested class, you have to use the          binary name of the inner class.        \n\r\n\rFor example, if you have a class called Foo          in the com.example package, and this          Foo class has a static inner          class called Bar, the value of the          \'class\' attribute on a bean definition would          be...        \n\r\n\rcom.example.Foo$Bar        \n\r\n\rNotice the use of the $ character in the name          to separate the inner class name from the outer class name.            Instantiation with a constructor                \n\r\n\rWhen you create a bean by the constructor approach, all normal          classes are usable by and compatible with Spring. That is, the class          being developed does not need to implement any specific interfaces or          to be coded in a specific fashion. Simply specifying the bean class          should suffice. However, depending on what type of IoC you use for          that specific bean, you may need a default (empty) constructor.        \n\r\n\rThe Spring IoC container can manage virtually          any class you want it to manage; it is not          limited to managing true JavaBeans. Most Spring users prefer actual          JavaBeans with only a default (no-argument) constructor and          appropriate setters and getters modeled after the properties in the          container. You can also have more exotic non-bean-style classes in          your container. If, for example, you need to use a legacy connection          pool that absolutely does not adhere to the JavaBean specification,          Spring can manage it as well.        \n\r\n\rWith XML-based configuration metadata you can specify your bean          class as follows:        &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/&gt;&lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/&gt;        \n\r\n\rFor details about the mechanism for supplying arguments to the          constructor (if required) and setting object instance properties after          the object is constructed, see Injecting          Dependencies.            Instantiation with a static factory method                \n\r\n\rWhen defining a bean that you create with a static factory method,          you use the class attribute to specify the class          containing the static factory method and an          attribute named factory-method to specify the name          of the factory method itself. You should be able to call this method          (with optional arguments as described later) and return a live object,          which subsequently is treated as if it had been created through a          constructor. One use for such a bean definition is to call          static factories in legacy code.        \n\r\n\rThe following bean definition specifies that the bean will be          created by calling a factory-method. The definition does not specify          the type (class) of the returned object, only the class containing the          factory method. In this example, the          createInstance() method must be a          static method.        &lt;bean id=\"clientService\"      class=\"examples.ClientService\"      factory-method=\"createInstance\"/&gt;        public class ClientService {  private static ClientService clientService = new ClientService();  private ClientService() {}  public static ClientService createInstance() {    return clientService;  }}        \n\r\n\rFor details about the mechanism for supplying (optional) arguments          to the factory method and setting object instance properties after the          object is returned from the factory, see Dependencies and          configuration in detail.            Instantiation using an instance factory method                \n\r\n\rSimilar to instantiation through a static factory          method, instantiation with an instance factory method invokes a          non-static method of an existing bean from the container to create a          new bean. To use this mechanism, leave the class          attribute empty, and in the factory-bean          attribute, specify the name of a bean in the current (or          parent/ancestor) container that contains the instance method that is          to be invoked to create the object. Set the name of the factory method          itself with the factory-method attribute.        &lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt;  &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id=\"clientService\"      factory-bean=\"serviceLocator\"      factory-method=\"createClientServiceInstance\"/&gt;        public class DefaultServiceLocator {  private static ClientService clientService = new ClientServiceImpl();  private DefaultServiceLocator() {}  public ClientService createClientServiceInstance() {    return clientService;  }}        \n\r\n\rOne factory class can also hold more than one factory method as          shown here:        &lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt;  &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=\"clientService\"      factory-bean=\"serviceLocator\"      factory-method=\"createClientServiceInstance\"/&gt;&lt;bean id=\"accountService\"      factory-bean=\"serviceLocator\"      factory-method=\"createAccountServiceInstance\"/&gt;        public class DefaultServiceLocator {  private static ClientService clientService = new ClientServiceImpl();  private static AccountService accountService = new AccountServiceImpl();  private DefaultServiceLocator() {}  public ClientService createClientServiceInstance() {    return clientService;  }  public AccountService createAccountServiceInstance() {    return accountService;  }}        \n\r\n\rThis approach shows that the factory bean itself can be managed          and configured through dependency injection (DI). See Dependencies and          configuration in detail.        Note          \n\r\n\rIn Spring documentation, factory bean            refers to a bean that is configured in the Spring container that            will create objects through an instance or static            factory method. By contrast,            FactoryBean (notice the            capitalization) refers to a Spring-specific             FactoryBean .                      5.4&nbsp;Dependencies    \n\r\n\rA typical enterprise application does not consist of a single object (or    bean in the Spring parlance). Even the simplest application has a few    objects that work together to present what the end-user sees as a coherent    application. This next section explains how you go from defining a number of    bean definitions that stand alone to a fully realized application where    objects collaborate to achieve a goal.  5.4.1&nbsp;Dependency injection            \n\r\n\rDependency injection (DI) is a process whereby      objects define their dependencies, that is, the other objects they work      with, only through constructor arguments, arguments to a factory method,      or properties that are set on the object instance after it is constructed      or returned from a factory method. The container then      injects those dependencies when it creates the bean.      This process is fundamentally the inverse, hence the name      Inversion of Control (IoC), of the bean itself      controlling the instantiation or location of its dependencies on its own      by using direct construction of classes, or the Service      Locator pattern.    \n\r\n\rCode is cleaner with the DI principle and decoupling is more effective      when objects are provided with their dependencies. The object does not      look up its dependencies, and does not know the location or class of the      dependencies. As such, your classes become easier to test, in particular      when the dependencies are on interfaces or abstract base classes, which      allow for stub or mock implementations to be used in unit tests.    \n\r\n\rDI exists in two major variants, Constructor-based dependency      injection and Setter-based      dependency injection.    Constructor-based dependency injection            \n\r\n\rConstructor-based DI is accomplished by the        container invoking a constructor with a number of arguments, each        representing a dependency. Calling a static factory        method with specific arguments to construct the bean is nearly        equivalent, and this discussion treats arguments to a constructor and to        a static factory method similarly. The following        example shows a class that can only be dependency-injected with        constructor injection. Notice that there is nothing        special about this class, it is a POJO that has no        dependencies on container specific interfaces, base classes or        annotations.      public class SimpleMovieLister {  // the SimpleMovieLister has a dependency on a MovieFinder  private MovieFinder movieFinder;  // a constructor so that the Spring container can \'inject\' a MovieFinder  public SimpleMovieLister(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // business logic that actually \'uses\' the injected MovieFinder is omitted...}      Constructor argument resolution                \n\r\n\rConstructor argument resolution matching occurs using the          argument\'s type. If no potential ambiguity exists in the constructor          arguments of a bean definition, then the order in which the          constructor arguments are defined in a bean definition is the order in          which those arguments are supplied to the appropriate constructor when          the bean is being instantiated. Consider the following class:        package x.y;public class Foo {  public Foo(Bar bar, Baz baz) {      // ...  }}        \n\r\n\rNo potential ambiguity exists, assuming that          Bar and Baz classes are          not related by inheritance. Thus the following configuration works          fine, and you do not need to specify the constructor argument indexes          and/or types explicitly in the          &lt;constructor-arg/&gt; element.        &lt;beans&gt;  &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt;      &lt;constructor-arg ref=\"bar\"/&gt;      &lt;constructor-arg ref=\"baz\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"bar\" class=\"x.y.Bar\"/&gt;  &lt;bean id=\"baz\" class=\"x.y.Baz\"/&gt;&lt;/beans&gt;        \n\r\n\rWhen another bean is referenced, the type is known, and matching          can occur (as was the case with the preceding example). When a simple          type is used, such as          &lt;value&gt;true&lt;value&gt;, Spring cannot          determine the type of the value, and so cannot match by type without          help. Consider the following class:        package examples;public class ExampleBean {  // No. of years to the calculate the Ultimate Answer  private int years;  // The Answer to Life, the Universe, and Everything  private String ultimateAnswer;  public ExampleBean(int years, String ultimateAnswer) {      this.years = years;      this.ultimateAnswer = ultimateAnswer;  }}        Constructor argument type matching                    \n\r\n\rIn the preceding scenario, the container            can use type matching with simple types if you            explicitly specify the type of the constructor argument using the            type attribute. For example:          &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;&lt;constructor-arg type=\"int\" value=\"7500000\"/&gt;&lt;constructor-arg type=\"java.lang.String\" value=\"42\"/&gt;&lt;/bean&gt;                Constructor argument index                    \n\r\n\rUse the index attribute to specify explicitly            the index of constructor arguments. For example:          &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;&lt;constructor-arg index=\"0\" value=\"7500000\"/&gt;&lt;constructor-arg index=\"1\" value=\"42\"/&gt;&lt;/bean&gt;          \n\r\n\rIn addition to resolving the ambiguity of multiple simple            values, specifying an index resolves ambiguity where a constructor            has two arguments of the same type. Note that the index is            0 based.                Constructor argument name                    \n\r\n\rAs of Spring 3.0 you can also use the constructor parameter          name for value disambiguation:          &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;&lt;constructor-arg name=\"years\" value=\"7500000\"/&gt;&lt;constructor-arg name=\"ultimateanswer\" value=\"42\"/&gt;&lt;/bean&gt;          \n\r\n\rKeep in mind that to make this work out of the box your code          must be compiled with the debug flag enabled so that Spring can          look up the parameter name from the constructor. If you can\'t compile          your code with debug flag (or don\'t want to) you can use          @ConstructorProperties          JDK annotation to explicitly name your constructor arguments. The          sample class would then have to look as follows:          package examples;public class ExampleBean {  // Fields omitted  @ConstructorProperties({\"years\", \"ultimateAnswer\"})  public ExampleBean(int years, String ultimateAnswer) {      this.years = years;      this.ultimateAnswer = ultimateAnswer;  }}                      Setter-based dependency injection            \n\r\n\rSetter-based DI is accomplished by the        container calling setter methods on your beans after invoking a        no-argument constructor or no-argument static factory        method to instantiate your bean.      \n\r\n\rThe following example shows a class that can only be        dependency-injected using pure setter injection. This class is        conventional Java. It is a POJO that has no dependencies on container        specific interfaces, base classes or annotations.      public class SimpleMovieLister {  // the SimpleMovieLister has a dependency on the MovieFinder  private MovieFinder movieFinder;  // a setter method so that the Spring container can \'inject\' a MovieFinder  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // business logic that actually \'uses\' the injected MovieFinder is omitted...}      \n\r\n\rThe ApplicationContext supports        constructor- and setter-based DI for the beans it manages. It also        supports setter-based DI after some dependencies are already injected        through the constructor approach. You configure the dependencies in the        form of a BeanDefinition, which you use        with PropertyEditor instances to convert        properties from one format to another. However, most Spring users do not        work with these classes directly (programmatically), but rather with an        XML definition file that is then converted internally into instances of        these classes, and used to load an entire Spring IoC container        instance.      \n\r\n\rConstructor-based or setter-based DI?                \n\r\n\rSince you can mix both, Constructor- and Setter-based DI, it is a          good rule of thumb to use constructor arguments for mandatory          dependencies and setters for optional dependencies. Note that the use          of a @Required          annotation on a setter can be used to make setters required          dependencies.        \n\r\n\rThe Spring team generally advocates setter injection, because          large numbers of constructor arguments can get unwieldy, especially          when properties are optional. Setter methods also make objects of that          class amenable to reconfiguration or re-injection later. Management          through JMX MBeans is a compelling use          case.        \n\r\n\rSome purists favor constructor-based injection. Supplying all          object dependencies means that the object is always returned to client          (calling) code in a totally initialized state. The disadvantage is          that the object becomes less amenable to reconfiguration and          re-injection.        \n\r\n\rUse the DI that makes the most sense for a particular class.          Sometimes, when dealing with third-party classes to which you do not          have the source, the choice is made for you. A legacy class may not          expose any setter methods, and so constructor injection is the only          available DI.              Dependency resolution process            \n\r\n\rThe container performs bean dependency resolution as follows:            \n\r          \n\r\n\rThe ApplicationContext is created            and initialized with configuration metadata that describes all the            beans. Configuration metadata can be specified via XML, Java code or            annotations.        \n\r          \n\r\n\rFor each bean, its dependencies are expressed in the form of            properties, constructor arguments, or arguments to the            static-factory method if you are using that instead of a normal            constructor. These dependencies are provided to the bean,            when the bean is actually created.        \n\r          \n\r\n\rEach property or constructor argument is an actual definition of            the value to set, or a reference to another bean in the            container.        \n\r          \n\r\n\rEach property or constructor argument which is a value is            converted from its specified format to the actual type of that            property or constructor argument. By default Spring can convert a            value supplied in string format to all built-in types, such as            int, long,            String, boolean, etc.        \n\r      \n\r\n\rThe Spring container validates the configuration of each bean as the        container is created, including the validation of whether bean reference        properties refer to valid beans. However, the bean properties themselves        are not set until the bean is actually created.        Beans that are singleton-scoped and set to be pre-instantiated (the        default) are created when the container is created. Scopes are defined        in Section&nbsp;5.5, &#8220;Bean scopes&#8221; Otherwise, the bean is created        only when it is requested. Creation of a bean potentially causes a graph        of beans to be created, as the bean\'s dependencies and its dependencies\'        dependencies (and so on) are created and assigned.      \n\r\n\rCircular dependencies                \n\r\n\rIf you use predominantly constructor injection, it is possible to          create an unresolvable circular dependency scenario.        \n\r\n\rFor example: Class A requires an instance of class B through          constructor injection, and class B requires an instance of class A          through constructor injection. If you configure beans for classes A          and B to be injected into each other, the Spring IoC container detects          this circular reference at runtime, and throws a          BeanCurrentlyInCreationException.        \n\r\n\rOne possible solution is to edit the source code of some classes          to be configured by setters rather than constructors. Alternatively,          avoid constructor injection and use setter injection only. In other          words, although it is not recommended, you can configure circular          dependencies with setter injection.        \n\r\n\rUnlike the typical case (with no circular          dependencies), a circular dependency between bean A and bean B forces          one of the beans to be injected into the other prior to being fully          initialized itself (a classic chicken/egg scenario).            \n\r\n\rYou can generally trust Spring to do the right thing. It detects        configuration problems, such as references to non-existent beans and        circular dependencies, at container load-time. Spring sets properties        and resolves dependencies as late as possible, when the bean is actually        created. This means that a Spring container which has loaded correctly        can later generate an exception when you request an object if there is a        problem creating that object or one of its dependencies. For example,        the bean throws an exception as a result of a missing or invalid        property. This potentially delayed visibility of some configuration        issues is why ApplicationContext        implementations by default pre-instantiate singleton beans. At the cost        of some upfront time and memory to create these beans before they are        actually needed, you discover configuration issues when the        ApplicationContext is created, not later.        You can still override this default behavior so that singleton beans        will lazy-initialize, rather than be pre-instantiated.      \n\r\n\rIf no circular dependencies exist, when one or more collaborating        beans are being injected into a dependent bean, each collaborating bean        is totally configured prior to being injected into        the dependent bean. This means that if bean A has a dependency on bean        B, the Spring IoC container completely configures bean B prior to        invoking the setter method on bean A. In other words, the bean is        instantiated (if not a pre-instantiated singleton), its dependencies are        set, and the relevant lifecycle methods (such as a configured init        method or the InitializingBean        callback method) are invoked.        Examples of dependency injection            \n\r\n\rThe following example uses XML-based configuration metadata for        setter-based DI. A small part of a Spring XML configuration file        specifies some bean definitions:      &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;&lt;!-- setter injection using the nested &lt;ref/&gt; element --&gt;&lt;property name=\"beanOne\"&gt;&lt;ref bean=\"anotherExampleBean\"/&gt;&lt;/property&gt;&lt;!-- setter injection using the neater \'ref\' attribute --&gt;&lt;property name=\"beanTwo\" ref=\"yetAnotherBean\"/&gt;&lt;property name=\"integerProperty\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/&gt;&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/&gt;      public class ExampleBean {  private AnotherBean beanOne;  private YetAnotherBean beanTwo;  private int i;  public void setBeanOne(AnotherBean beanOne) {      this.beanOne = beanOne;  }  public void setBeanTwo(YetAnotherBean beanTwo) {      this.beanTwo = beanTwo;  }  public void setIntegerProperty(int i) {      this.i = i;  }}      \n\r\n\rIn the preceding example, setters are declared to match against the        properties specified in the XML file. The following example uses        constructor-based DI:      &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt;&lt;!-- constructor injection using the nested &lt;ref/&gt; element --&gt;&lt;constructor-arg&gt;  &lt;ref bean=\"anotherExampleBean\"/&gt;&lt;/constructor-arg&gt;&lt;!-- constructor injection using the neater \'ref\' attribute --&gt;&lt;constructor-arg ref=\"yetAnotherBean\"/&gt;&lt;constructor-arg type=\"int\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/&gt;&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/&gt;      public class ExampleBean {  private AnotherBean beanOne;  private YetAnotherBean beanTwo;  private int i;  public ExampleBean(      AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {      this.beanOne = anotherBean;      this.beanTwo = yetAnotherBean;      this.i = i;  }}      \n\r\n\rThe constructor arguments specified in the bean definition will be        used as arguments to the constructor of the        ExampleBean.      \n\r\n\rNow consider a variant of this example, where instead of using a        constructor, Spring is told to call a static factory        method to return an instance of the object:      &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"    factory-method=\"createInstance\"&gt;&lt;constructor-arg ref=\"anotherExampleBean\"/&gt;&lt;constructor-arg ref=\"yetAnotherBean\"/&gt;&lt;constructor-arg value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/&gt;&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/&gt;      public class ExampleBean {  // a private constructor  private ExampleBean(...) {    ...  }    // a static factory method; the arguments to this method can be  // considered the dependencies of the bean that is returned,  // regardless of how those arguments are actually used.  public static ExampleBean createInstance (          AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {      ExampleBean eb = new ExampleBean (...);      // some other operations...      return eb;  }}      \n\r\n\rArguments to the static factory method are        supplied via &lt;constructor-arg/&gt; elements,        exactly the same as if a constructor had actually been used. The type of        the class being returned by the factory method does not have to be of        the same type as the class that contains the static        factory method, although in this example it is. An instance (non-static)        factory method would be used in an essentially identical fashion (aside        from the use of the factory-bean attribute instead of        the class attribute), so details will not be        discussed here.        5.4.2&nbsp;Dependencies and configuration in detail        \n\r\n\rAs mentioned in the previous section, you can define bean properties      and constructor arguments as references to other managed beans      (collaborators), or as values defined inline. Spring\'s XML-based      configuration metadata supports sub-element types within its      &lt;property/&gt; and      &lt;constructor-arg/&gt; elements for this      purpose.    Straight values (primitives, Strings, and so        on)            \n\r\n\rThe value attribute of the        &lt;property/&gt; element specifies a property or        constructor argument as a human-readable string representation. As mentioned previously,        JavaBeans PropertyEditors are used to convert these        string values from a String to the actual type of        the property or argument.      &lt;bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;&lt;!-- results in a setDriverClassName(String) call --&gt;&lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt;&lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/&gt;&lt;property name=\"username\" value=\"root\"/&gt;&lt;property name=\"password\" value=\"masterkaoli\"/&gt;&lt;/bean&gt;      \n\r\n\rThe following example uses the p-namespace for even more succinct XML configuration.      &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:p=\"http://www.springframework.org/schema/p\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"      destroy-method=\"close\"      p:driverClassName=\"com.mysql.jdbc.Driver\"      p:url=\"jdbc:mysql://localhost:3306/mydb\"      p:username=\"root\"      p:password=\"masterkaoli\"/&gt;&lt;/beans&gt;      \n\r\n\rThe preceding XML is more succinct; however, typos are discovered at        runtime rather than design time, unless you use an IDE such as IntelliJ IDEA or the SpringSource Tool        Suite (STS) that support automatic property completion when you        create bean definitions. Such IDE assistance is highly        recommended.      \n\r\n\rYou can also configure a java.util.Properties        instance as:      &lt;bean id=\"mappings\"    class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;!-- typed as a java.util.Properties --&gt; &lt;property name=\"properties\"&gt;    &lt;value&gt;       jdbc.driver.className=com.mysql.jdbc.Driver       jdbc.url=jdbc:mysql://localhost:3306/mydb    &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe Spring container converts the text inside the        &lt;value/&gt; element into a        java.util.Properties instance by using the        JavaBeans PropertyEditor mechanism. This        is a nice shortcut, and is one of a few places where the Spring team do        favor the use of the nested &lt;value/&gt; element        over the value attribute style.      The idref element                \n\r\n\rThe idref element is simply an error-proof way          to pass the id (string value - not a reference)          of another bean in the container to a          &lt;constructor-arg/&gt; or          &lt;property/&gt; element.        &lt;bean id=\"theTargetBean\" class=\"...\"/&gt;&lt;bean id=\"theClientBean\" class=\"...\"&gt;  &lt;property name=\"targetName\"&gt;      &lt;idref bean=\"theTargetBean\" /&gt;  &lt;/property&gt;&lt;/bean&gt;        \n\r\n\rThe above bean definition snippet is exactly          equivalent (at runtime) to the following snippet:        &lt;bean id=\"theTargetBean\" class=\"...\" /&gt;&lt;bean id=\"client\" class=\"...\"&gt;  &lt;property name=\"targetName\" value=\"theTargetBean\" /&gt;&lt;/bean&gt;        \n\r\n\rThe first form is preferable to the second, because using the          idref tag allows the container to validate          at deployment time that the referenced, named          bean actually exists. In the second variation, no validation is          performed on the value that is passed to the          targetName property of the          client bean. Typos are only discovered (with most          likely fatal results) when the client bean is          actually instantiated. If the client bean is a          prototype bean, this typo          and the resulting exception may only be discovered long after the          container is deployed.        \n\r\n\rAdditionally, if the referenced bean is in the same XML unit, and          the bean name is the bean id, you can use the          local attribute, which allows the XML parser itself          to validate the bean id earlier, at XML document parse time.        &lt;property name=\"targetName\"&gt; &lt;!-- a bean with id \'theTargetBean\' must exist; otherwise an exception will be thrown --&gt; &lt;idref local=\"theTargetBean\"/&gt;&lt;/property&gt;        \n\r\n\rA common place (at least in versions earlier than Spring 2.0)          where the &lt;idref/&gt; element brings value is in the configuration          of AOP interceptors in a          ProxyFactoryBean bean definition. Using          &lt;idref/&gt; elements when you specify the interceptor names          prevents you from misspelling an interceptor id.              References to other beans (collaborators)            \n\r\n\rThe ref element is the final element inside a        &lt;constructor-arg/&gt; or        &lt;property/&gt; definition element. Here you set        the value of the specified property of a bean to be a reference to        another bean (a collaborator) managed by the container. The referenced        bean is a dependency of the bean whose property will be set, and it is        initialized on demand as needed before the property is set. (If the        collaborator is a singleton bean, it may be initialized already by the        container.) All references are ultimately a reference to another object.        Scoping and validation depend on whether you specify the id/name of the        other object through the        bean,local, or        parent attributes.      \n\r\n\rSpecifying the target bean through the bean        attribute of the &lt;ref/&gt; tag is the most general        form, and allows creation of a reference to any bean in the same        container or parent container, regardless of whether it is in the same        XML file. The value of the bean attribute may be the        same as the id attribute of the target bean, or as        one of the values in the name attribute of the target        bean.      &lt;ref bean=\"someBean\"/&gt;      \n\r\n\rSpecifying the target bean through the local        attribute leverages the ability of the XML parser to validate XML id        references within the same file. The value of the        local attribute must be the same as the        id attribute of the target bean. The XML parser        issues an error if no matching element is found in the same file. As        such, using the local variant is the best choice (in order to know about        errors as early as possible) if the target bean is in the same XML        file.      &lt;ref local=\"someBean\"/&gt;      \n\r\n\rSpecifying the target bean through the parent        attribute creates a reference to a bean that is in a parent container of        the current container. The value of the parent        attribute may be the same as either the id attribute        of the target bean, or one of the values in the name        attribute of the target bean, and the target bean must be in a parent        container of the current one. You use this bean reference variant mainly        when you have a hierarchy of containers and you want to wrap an existing        bean in a parent container with a proxy that will have the same name as        the parent bean.      &lt;!-- in the parent context --&gt;&lt;bean id=\"accountService\" class=\"com.foo.SimpleAccountService\"&gt;  &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;      &lt;!-- in the child (descendant) context --&gt;&lt;bean id=\"accountService\"  &lt;-- bean name is the same as the parent bean --&gt;    class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;    &lt;property name=\"target\"&gt;        &lt;ref parent=\"accountService\"/&gt;  &lt;!-- notice how we refer to the parent bean --&gt;    &lt;/property&gt;  &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt;        Inner beans            \n\r\n\rA &lt;bean/&gt; element inside the        &lt;property/&gt; or        &lt;constructor-arg/&gt; elements defines a so-called        inner bean.      &lt;bean id=\"outer\" class=\"...\"&gt;&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;&lt;property name=\"target\"&gt;  &lt;bean class=\"com.example.Person\"&gt; &lt;!-- this is the inner bean --&gt;    &lt;property name=\"name\" value=\"Fiona Apple\"/&gt;    &lt;property name=\"age\" value=\"25\"/&gt;  &lt;/bean&gt;&lt;/property&gt;&lt;/bean&gt;      \n\r\n\rAn inner bean definition does not require a defined id or name; the        container ignores these values. It also ignores the        scope flag. Inner beans are        always anonymous and they are        always created with the outer bean. It is        not possible to inject inner beans into        collaborating beans other than into the enclosing bean.        Collections            \n\r\n\rIn the &lt;list/&gt;,        &lt;set/&gt;, &lt;map/&gt;, and        &lt;props/&gt; elements, you set the properties and        arguments of the Java Collection types        List, Set,        Map, and        Properties, respectively.      &lt;bean id=\"moreComplexObject\" class=\"example.ComplexObject\"&gt;&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;&lt;property name=\"adminEmails\"&gt;  &lt;props&gt;      &lt;prop key=\"administrator\"&gt;administrator@example.org&lt;/prop&gt;      &lt;prop key=\"support\"&gt;support@example.org&lt;/prop&gt;      &lt;prop key=\"development\"&gt;development@example.org&lt;/prop&gt;  &lt;/props&gt;&lt;/property&gt;&lt;!-- results in a setSomeList(java.util.List) call --&gt;&lt;property name=\"someList\"&gt;  &lt;list&gt;      &lt;value&gt;a list element followed by a reference&lt;/value&gt;      &lt;ref bean=\"myDataSource\" /&gt;  &lt;/list&gt;&lt;/property&gt;&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;&lt;property name=\"someMap\"&gt;  &lt;map&gt;      &lt;entry key=\"an entry\" value=\"just some string\"/&gt;      &lt;entry key =\"a ref\" value-ref=\"myDataSource\"/&gt;  &lt;/map&gt;&lt;/property&gt;&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;&lt;property name=\"someSet\"&gt;  &lt;set&gt;      &lt;value&gt;just some string&lt;/value&gt;      &lt;ref bean=\"myDataSource\" /&gt;  &lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe value of a map key or value, or a set value, can also        again be any of the following elements:      bean | ref | idref | list | set | map | props | value | null      Collection merging                \n\r\n\rAs of Spring 2.0, the container supports the          merging of collections. An application developer          can define a parent-style &lt;list/&gt;,          &lt;map/&gt;, &lt;set/&gt; or          &lt;props/&gt; element, and have child-style          &lt;list/&gt;, &lt;map/&gt;,          &lt;set/&gt; or &lt;props/&gt;          elements inherit and override values from the parent collection. That          is, the child collection\'s values are the result of merging the          elements of the parent and child collections, with the child\'s          collection elements overriding values specified in the parent          collection.        \n\r\n\rThis section on merging discusses the parent-child bean          mechanism. Readers unfamiliar with parent and child bean definitions          may wish to read the relevant section before continuing.        \n\r\n\rThe following example demonstrates collection merging:        &lt;beans&gt;&lt;bean id=\"parent\" abstract=\"true\" class=\"example.ComplexObject\"&gt;  &lt;property name=\"adminEmails\"&gt;      &lt;props&gt;          &lt;prop key=\"administrator\"&gt;administrator@example.com&lt;/prop&gt;          &lt;prop key=\"support\"&gt;support@example.com&lt;/prop&gt;      &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"child\" parent=\"parent\"&gt;  &lt;property name=\"adminEmails\"&gt;      &lt;!-- the merge is specified on the *child* collection definition --&gt;      &lt;props merge=\"true\"&gt;          &lt;prop key=\"sales\"&gt;sales@example.com&lt;/prop&gt;          &lt;prop key=\"support\"&gt;support@example.co.uk&lt;/prop&gt;      &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;beans&gt;        \n\r\n\rNotice the use of the merge=true attribute on          the &lt;props/&gt; element of the          adminEmails property of the          child bean definition. When the          child bean is resolved and instantiated by the          container, the resulting instance has an          adminEmails Properties          collection that contains the result of the merging of the child\'s          adminEmails collection with the parent\'s          adminEmails collection.        administrator=administrator@example.comsales=sales@example.comsupport=support@example.co.uk        \n\r\n\rThe child Properties collection\'s value set          inherits all property elements from the parent          &lt;props/&gt;, and the child\'s value for the          support value overrides the value in the parent          collection.        \n\r\n\rThis merging behavior applies similarly to the          &lt;list/&gt;, &lt;map/&gt;, and          &lt;set/&gt; collection types. In the specific case          of the &lt;list/&gt; element, the semantics          associated with the List collection type, that          is, the notion of an ordered collection of values,          is maintained; the parent\'s values precede all of the child list\'s          values. In the case of the Map,          Set, and          Properties collection types, no          ordering exists. Hence no ordering semantics are in effect for the          collection types that underlie the associated          Map,          Set, and          Properties implementation types that          the container uses internally.            Limitations of collection merging                \n\r\n\rYou cannot merge different collection types (such as a          Map and a          List), and if you do attempt to do so          an appropriate Exception is thrown. The          merge attribute must be specified on the lower,          inherited, child definition; specifying the merge          attribute on a parent collection definition is redundant and will not          result in the desired merging. The merging feature is available only          in Spring 2.0 and later.            Strongly-typed collection (Java 5+ only)                \n\r\n\rIn Java 5 and later, you can use strongly typed collections (using          generic types). That is, it is possible to declare a          Collection type such that it can only          contain String elements (for example). If you          are using Spring to dependency-inject a strongly-typed          Collection into a bean, you can take          advantage of Spring\'s type-conversion support such that the elements          of your strongly-typed Collection          instances are converted to the appropriate type prior to being added          to the Collection.        public class Foo {  private Map&lt;String, Float&gt; accounts;  public void setAccounts(Map&lt;String, Float&gt; accounts) {      this.accounts = accounts;  }}        &lt;beans&gt;  &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt;      &lt;property name=\"accounts\"&gt;          &lt;map&gt;              &lt;entry key=\"one\" value=\"9.99\"/&gt;              &lt;entry key=\"two\" value=\"2.75\"/&gt;              &lt;entry key=\"six\" value=\"3.99\"/&gt;          &lt;/map&gt;      &lt;/property&gt;  &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\rWhen the accounts property of the          foo bean is prepared for injection, the generics          information about the element type of the strongly-typed          Map&lt;String, Float&gt; is available by          reflection. Thus Spring\'s type conversion infrastructure recognizes          the various value elements as being of type          Float, and the string values 9.99,          2.75, and 3.99 are converted into an          actual Float type.              Null and empty string values            \n\r\n\rSpring        treats empty arguments for properties and the like as empty        Strings. The following XML-based configuration        metadata snippet sets the email property to the empty        String value (\"\")      &lt;bean class=\"ExampleBean\"&gt;&lt;property name=\"email\" value=\"\"/&gt;&lt;/bean&gt;      \n\r\n\rThe preceding example is equivalent to the following Java code:        exampleBean.setEmail(\"\"). The        &lt;null/&gt; element handles null        values. For example:      &lt;bean class=\"ExampleBean\"&gt;&lt;property name=\"email\"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe above configuration is equivalent to the following Java code:        exampleBean.setEmail(null).        XML shortcut with the p-namespace            \n\r\n\rThe p-namespace enables you to use the bean        element\'s attributes, instead of nested        &lt;property/&gt; elements, to describe your property        values and/or collaborating beans.      \n\r\n\rSpring 2.0 and later supports extensible configuration formats with namespaces, which are based on an XML        Schema definition. The beans configuration format        discussed in this chapter is defined in an XML Schema document. However,        the p-namespace is not defined in an XSD file and exists only in the        core of Spring.      \n\r\n\rThe following example shows two XML snippets that resolve to the        same result: The first uses standard XML format and the second uses the        p-namespace.      &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:p=\"http://www.springframework.org/schema/p\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean name=\"classic\" class=\"com.example.ExampleBean\"&gt;      &lt;property name=\"email\" value=\"foo@bar.com\"/&gt;  &lt;/bean&gt;  &lt;bean name=\"p-namespace\" class=\"com.example.ExampleBean\"        p:email=\"foo@bar.com\"/&gt;&lt;/beans&gt;      \n\r\n\rThe example shows an attribute in the p-namespace called email in        the bean definition. This tells Spring to include a property        declaration. As previously mentioned, the p-namespace does not have a        schema definition, so you can set the name of the attribute to the        property name.      \n\r\n\rThis next example includes two more bean definitions that both have        a reference to another bean:      &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:p=\"http://www.springframework.org/schema/p\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean name=\"john-classic\" class=\"com.example.Person\"&gt;      &lt;property name=\"name\" value=\"John Doe\"/&gt;      &lt;property name=\"spouse\" ref=\"jane\"/&gt;  &lt;/bean&gt;  &lt;bean name=\"john-modern\"      class=\"com.example.Person\"      p:name=\"John Doe\"      p:spouse-ref=\"jane\"/&gt;  &lt;bean name=\"jane\" class=\"com.example.Person\"&gt;      &lt;property name=\"name\" value=\"Jane Doe\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rAs you can see, this example includes not only a property value        using the p-namespace, but also uses a special format to declare        property references. Whereas the first bean definition uses        &lt;property name=\"spouse\" ref=\"jane\"/&gt; to create        a reference from bean john to bean        jane, the second bean definition uses        p:spouse-ref=\"jane\" as an attribute to do the exact        same thing. In this case spouse is the property name,        whereas the -ref part indicates that this is not a        straight value but rather a reference to another bean.      Note        \n\r\n\rThe p-namespace is not as flexible as the standard XML format. For          example, the format for declaring property references clashes with          properties that end in Ref, whereas the standard          XML format does not. We recommend that you choose your approach          carefully and communicate this to your team members, to avoid          producing XML documents that use all three approaches at the same          time.                 XML shortcut with the c-namespace            \n\r\n\rSimilar to the the section called &#8220;XML shortcut with the p-namespace&#8221;, the c-namespace, newly introduced in Spring 3.1,      allows usage of inlined attributes for configuring the constructor arguments rather then nested constructor-arg      elements.      \n\r\n\rLet\'s review the examples from the section called &#8220;Constructor-based dependency injection&#8221; with the c namespace:      &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:c=\"http://www.springframework.org/schema/c\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean id=\"bar\" class=\"x.y.Bar\"/&gt;  &lt;bean id=\"baz\" class=\"x.y.Baz\"/&gt;  &lt;-- \'traditional\' declaration --&gt;  &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt;      &lt;constructor-arg ref=\"bar\"/&gt;      &lt;constructor-arg ref=\"baz\"/&gt;      &lt;constructor-arg value=\"foo@bar.com\"/&gt;  &lt;/bean&gt;  &lt;-- \'c-namespace\' declaration --&gt;  &lt;bean id=\"foo\" class=\"x.y.Foo\" c:bar-ref=\"bar\" c:baz-ref=\"baz\" c:email=\"foo@bar.com\"&gt;&lt;/beans&gt;      \n\r\n\rThe c: namespace uses the same conventions as the p: one (trailing -ref for bean references)      for setting the constructor arguments by their names. And just as well, it needs to be declared even though it is not defined in an XSD schema      (but it exists inside the Spring core).      \n\r\n\rFor the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can      use fallback to the argument indexes:      &lt;-- \'c-namespace\' index declaration --&gt;&lt;bean id=\"foo\" class=\"x.y.Foo\" c:_0-ref=\"bar\" c:_1-ref=\"baz\"&gt;      Note\n\r\n\rDue to the XML grammar, the index notation requires the presence of the leading _ as XML attribute names cannot start      with a number (even though some IDE allow it).      \n\r\n\rIn practice, the constructor resolution mechanism is quite efficient in matching arguments so      unless one really needs to, we recommend using the name notation through-out your configuration.        Compound property names            \n\r\n\rYou can use compound or nested property names when you set bean        properties, as long as all components of the path except the final        property name are not null. Consider the following        bean definition.      &lt;bean id=\"foo\" class=\"foo.Bar\"&gt;&lt;property name=\"fred.bob.sammy\" value=\"123\" /&gt;&lt;/bean&gt;      \n\r\n\rThe foo bean has a fred        property, which has a bob property, which has a        sammy property, and that final        sammy property is being set to the value        123. In order for this to work, the        fred property of foo, and the        bob property of fred must not be        null after the bean is constructed, or a        NullPointerException is thrown.        5.4.3&nbsp;Using depends-on        \n\r\n\rIf a bean is a dependency of another that usually means that one bean      is set as a property of another. Typically you accomplish this with the      &lt;ref/&gt;      element in XML-based configuration metadata. However, sometimes      dependencies between beans are less direct; for example, a static      initializer in a class needs to be triggered, such as database driver      registration. The depends-on attribute can explicitly      force one or more beans to be initialized before the bean using this      element is initialized. The following example uses the      depends-on attribute to express a dependency on a      single bean:    &lt;bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager\"/&gt;&lt;bean id=\"manager\" class=\"ManagerBean\" /&gt;    \n\r\n\rTo express a dependency on multiple beans, supply a list of bean names      as the value of the depends-on attribute, with commas,      whitespace and semicolons, used as valid delimiters:    &lt;bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager,accountDao\"&gt;&lt;property name=\"manager\" ref=\"manager\" /&gt;&lt;/bean&gt;&lt;bean id=\"manager\" class=\"ManagerBean\" /&gt;&lt;bean id=\"accountDao\" class=\"x.y.jdbc.JdbcAccountDao\" /&gt;    Note      \n\r\n\rThe depends-on attribute in the bean definition        can specify both an initialization time dependency and, in the case of        singleton beans        only, a corresponding destroy time dependency. Dependent beans that        define a depends-on relationship with a given bean        are destroyed first, prior to the given bean itself being destroyed.        Thus depends-on can also control shutdown        order.        5.4.4&nbsp;Lazy-initialized      beans        \n\r\n\rBy default, ApplicationContext      implementations eagerly create and configure all singleton beans as part of      the initialization process. Generally, this pre-instantiation is      desirable, because errors in the configuration or surrounding environment      are discovered immediately, as opposed to hours or even days later. When      this behavior is not desirable, you can prevent      pre-instantiation of a singleton bean by marking the bean definition as      lazy-initialized. A lazy-initialized bean tells the IoC container to      create a bean instance when it is first requested, rather than at      startup.    \n\r\n\rIn XML, this behavior is controlled by the      lazy-init attribute on the      &lt;bean/&gt; element; for example:    &lt;bean id=\"lazy\" class=\"com.foo.ExpensiveToCreateBean\" lazy-init=\"true\"/&gt;&lt;bean name=\"not.lazy\" class=\"com.foo.AnotherBean\"/&gt;    \n\r\n\rWhen the preceding configuration is consumed by an      ApplicationContext, the bean named      lazy is not eagerly pre-instantiated when the      ApplicationContext is starting up, whereas      the not.lazy bean is eagerly pre-instantiated.    \n\r\n\rHowever, when a lazy-initialized bean is a dependency of a singleton      bean that is not lazy-initialized, the      ApplicationContext creates the      lazy-initialized bean at startup, because it must satisfy the singleton\'s      dependencies. The lazy-initialized bean is injected into a singleton bean      elsewhere that is not lazy-initialized.    \n\r\n\rYou can also control lazy-initialization at the container level by      using the default-lazy-init attribute on the      &lt;beans/&gt; element; for example:    &lt;beans default-lazy-init=\"true\"&gt;  &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;    5.4.5&nbsp;Autowiring collaborators            \n\r\n\rThe Spring container can autowire relationships      between collaborating beans. You can allow Spring to resolve collaborators      (other beans) automatically for your bean by inspecting the contents of      the ApplicationContext. Autowiring has the      following advantages:    \n\r        \n\r\n\rAutowiring can significantly reduce the need to specify properties          or constructor arguments. (Other mechanisms such as a bean template          discussed elsewhere in          this chapter are also valuable in this regard.)      \n\r        \n\r\n\rAutowiring can update a configuration as your objects evolve. For          example, if you need to add a dependency to a class, that dependency          can be satisfied automatically without you needing to modify the          configuration. Thus autowiring can be especially useful during          development, without negating the option of switching to explicit          wiring when the code base becomes more stable.      \n\r\n\r\n\r When using XML-based configuration metadata[2], you specify autowire mode for a bean definition with the      autowire attribute of the      &lt;bean/&gt; element. The autowiring functionality has      five modes. You specify autowiring per bean and thus      can choose which ones to autowire.    \n\r\n\rTable&nbsp;5.2.&nbsp;Autowiring modes            ModeExplanationno\n\r\n\r(Default) No autowiring. Bean references must be              defined via a ref element. Changing the default              setting is not recommended for larger deployments, because              specifying collaborators explicitly gives greater control and              clarity. To some extent, it documents the structure of a              system.byName\n\r\n\rAutowiring by property name. Spring looks for a bean              with the same name as the property that needs to be autowired. For              example, if a bean definition is set to autowire by name, and it              contains a master property (that is, it has a              setMaster(..) method), Spring looks for a              bean definition named master, and uses it to              set the property.byType\n\r\n\rAllows a property to be autowired if exactly one bean              of the property type exists in the container. If more than one              exists, a fatal exception is thrown, which indicates that you may              not use byType autowiring for that bean. If              there are no matching beans, nothing happens; the property is not              set.constructor\n\r\n\rAnalogous to byType, but applies              to constructor arguments. If there is not exactly one bean of the              constructor argument type in the container, a fatal error is              raised.    \n\r    \n\r\n\rWith byType or constructor      autowiring mode, you can wire arrays and typed-collections. In such cases      all autowire candidates within the container that      match the expected type are provided to satisfy the dependency. You can      autowire strongly-typed Maps if the expected key type is      String. An autowired Maps values will consist of      all bean instances that match the expected type, and the Maps keys will      contain the corresponding bean names.    \n\r\n\rYou can combine autowire behavior with dependency checking, which is      performed after autowiring completes.    Limitations and disadvantages of autowiring            \n\r\n\rAutowiring works best when it is used consistently across a project.        If autowiring is not used in general, it might be confusing to        developers to use it to wire only one or two bean definitions.      \n\r\n\rConsider the limitations and disadvantages of autowiring:      \n\r          \n\r\n\rExplicit dependencies in property and            constructor-arg settings always override            autowiring. You cannot autowire so-called            simple properties such as primitives,            Strings, and Classes            (and arrays of such simple properties). This limitation is            by-design.        \n\r      \n\r          \n\r\n\rAutowiring is less exact than explicit wiring. Although, as            noted in the above table, Spring is careful to avoid guessing in            case of ambiguity that might have unexpected results, the            relationships between your Spring-managed objects are no longer            documented explicitly.        \n\r          \n\r\n\rWiring information may not be available to tools that may            generate documentation from a Spring container.        \n\r      \n\r          \n\r\n\rMultiple bean definitions within the container may match the            type specified by the setter method or constructor argument to be            autowired. For arrays, collections, or Maps, this is not necessarily            a problem. However for dependencies that expect a single value, this            ambiguity is not arbitrarily resolved. If no unique bean definition            is available, an exception is thrown.        \n\r      \n\r\n\rIn the latter scenario, you have several options:      \n\r          \n\r\n\rAbandon autowiring in favor of explicit wiring.        \n\r          \n\r\n\rAvoid autowiring for a bean definition by setting its            autowire-candidate attributes to            false as described in the next section.        \n\r          \n\r\n\rDesignate a single bean definition as the            primary candidate by setting the            primary attribute of its            &lt;bean/&gt; element to            true.        \n\r          \n\r\n\rIf you are using Java 5 or later, implement the more            fine-grained control available with annotation-based configuration,            as described in Section&nbsp;5.9, &#8220;Annotation-based container configuration&#8221;.        \n\r        Excluding a bean from autowiring            \n\r\n\rOn a per-bean basis, you can exclude a bean from autowiring. In        Spring\'s XML format, set the autowire-candidate        attribute of the &lt;bean/&gt; element to        false; the container makes that specific bean        definition unavailable to the autowiring infrastructure (including        annotation style configurations such as @Autowired).      \n\r\n\rYou can also limit autowire candidates based on pattern-matching        against bean names. The top-level &lt;beans/&gt;        element accepts one or more patterns within its        default-autowire-candidates attribute. For example,        to limit autowire candidate status to any bean whose name ends with        Repository, provide a value of *Repository. To        provide multiple patterns, define them in a comma-separated list. An        explicit value of true or false        for a bean definitions autowire-candidate attribute        always takes precedence, and for such beans, the pattern matching rules        do not apply.      \n\r\n\rThese techniques are useful for beans that you never want to be        injected into other beans by autowiring. It does not mean that an        excluded bean cannot itself be configured using autowiring. Rather, the        bean itself is not a candidate for autowiring other beans.              5.4.6&nbsp;Method injection        \n\r\n\rIn most application scenarios, most beans in the container are singletons. When a      singleton bean needs to collaborate with another singleton bean, or a      non-singleton bean needs to collaborate with another non-singleton bean,      you typically handle the dependency by defining one bean as a property of      the other. A problem arises when the bean lifecycles are different.      Suppose singleton bean A needs to use non-singleton (prototype) bean B,      perhaps on each method invocation on A. The container only creates the      singleton bean A once, and thus only gets one opportunity to set the      properties. The container cannot provide bean A with a new instance of      bean B every time one is needed.    \n\r\n\rA solution is to forego some inversion of control. You can make bean A aware of the container by      implementing the ApplicationContextAware      interface, and by making a      getBean(\"B\") call to the container ask for (a typically new) bean B      instance every time bean A needs it. The following is an example of this      approach:    // a class that uses a stateful Command-style class to perform some processingpackage fiona.apple;// Spring-API importsimport org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class CommandManager implements ApplicationContextAware { private ApplicationContext applicationContext; public Object process(Map commandState) {    // grab a new instance of the appropriate Command    Command command = createCommand();    // set the state on the (hopefully brand new) Command instance    command.setState(commandState);    return command.execute(); } protected Command createCommand() {    // notice the Spring API dependency!    return this.applicationContext.getBean(\"command\", Command.class); } public void setApplicationContext(ApplicationContext applicationContext)                                                                  throws BeansException {    this.applicationContext = applicationContext; }}    \n\r\n\rThe preceding is not desirable, because the business code is aware of      and coupled to the Spring Framework. Method Injection, a somewhat advanced      feature of the Spring IoC container, allows this use case to be handled in      a clean      fashion.    \n\r\n\r      \n\r\n\rYou can read more about the motivation for Method Injection in        this blog entry.        Lookup method injection                  \n\r\n\rLookup method injection is the ability of the container to override        methods on container managed beans, to return the        lookup result for another named bean in the container. The lookup        typically involves a prototype bean as in the scenario described in the        preceding section. The Spring Framework implements this method injection        by using bytecode generation from the CGLIB library to generate        dynamically a subclass that overrides the        method.      Note        \n\r\n\rFor this dynamic subclassing to work, the class that the Spring          container will subclass cannot be final, and the          method to be overridden cannot be final either. Also,          testing a class that has an abstract method requires          you to subclass the class yourself and to supply a stub implementation          of the abstract method. Finally, objects that have          been the target of method injection cannot be serialized. As of Spring          3.2 it is no longer necessary to add CGLIB to your classpath, because          CGLIB classes are repackaged under org.springframework and distributed          within the spring-core JAR. This is done both for convenience as well          as to avoid potential conflicts with other projects that use differing          versions of CGLIB.            \n\r\n\rLooking at the CommandManager class in the        previous code snippet, you see that the Spring container will        dynamically override the implementation of the        createCommand() method. Your        CommandManager class will not have any Spring        dependencies, as can be seen in the reworked example:      package fiona.apple;// no more Spring imports! public abstract class CommandManager { public Object process(Object commandState) {    // grab a new instance of the appropriate Command interface    Command command = createCommand();    // set the state on the (hopefully brand new) Command instance    command.setState(commandState);    return command.execute(); }  // okay... but where is the implementation of this method? protected abstract Command createCommand();}      \n\r\n\rIn the client class containing the method to be injected (the        CommandManager in this case), the method to be        injected requires a signature of the following form:      &lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);      \n\r\n\rIf the method is abstract, the        dynamically-generated subclass implements the method. Otherwise, the        dynamically-generated subclass overrides the concrete method defined in        the original class. For example:      &lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id=\"command\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\"&gt;&lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id=\"commandManager\" class=\"fiona.apple.CommandManager\"&gt;&lt;lookup-method name=\"createCommand\" bean=\"command\"/&gt;&lt;/bean&gt;      \n\r\n\rThe bean identified as commandManager calls its        own method createCommand() whenever it needs a        new instance of the command bean. You must be        careful to deploy the command bean as a prototype, if        that is actually what is needed. If it is deployed as a singleton, the same        instance of the command bean is returned each        time.      Tip        \n\r\n\rThe interested reader may also find the          ServiceLocatorFactoryBean (in the          org.springframework.beans.factory.config package)          to be of use. The approach used in ServiceLocatorFactoryBean is          similar to that of another utility class,          ObjectFactoryCreatingFactoryBean, but it allows          you to specify your own lookup interface as opposed to a          Spring-specific lookup interface. Consult the JavaDocs for these          classes as well as this blog entry for additional information          ServiceLocatorFactoryBean.              Arbitrary method replacement            \n\r\n\rA less useful form of method injection than lookup method Injection        is the ability to replace arbitrary methods in a managed bean with        another method implementation. Users may safely skip the rest of this        section until the functionality is actually        needed.      \n\r\n\rWith XML-based configuration metadata, you can use the        replaced-method element to replace an existing method        implementation with another, for a deployed bean. Consider the following        class, with a method computeValue, which we want to override:      public class MyValueCalculator {public String computeValue(String input) {  // some real code...}// some other methods...}      \n\r\n\rA class implementing the        org.springframework.beans.factory.support.MethodReplacer        interface provides the new method definition.      /** meant to be used to override the existing computeValue(String)  implementation in MyValueCalculator*/public class ReplacementComputeValue implements MethodReplacer {  public Object reimplement(Object o, Method m, Object[] args) throws Throwable {      // get the input value, work with it, and return a computed result      String input = (String) args[0];      ...      return ...;  }}      \n\r\n\rThe bean definition to deploy the original class and specify the        method override would look like this:      &lt;bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\"&gt;&lt;!-- arbitrary method replacement --&gt;&lt;replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"&gt;  &lt;arg-type&gt;String&lt;/arg-type&gt;&lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/&gt;      \n\r\n\rYou can use one or more contained        &lt;arg-type/&gt; elements within the        &lt;replaced-method/&gt; element to indicate the        method signature of the method being overridden. The signature for the        arguments is necessary only if the method is overloaded and multiple        variants exist within the class. For convenience, the type string for an        argument may be a substring of the fully qualified type name. For        example, the following all match        java.lang.String:          java.lang.String  String  Str      \n\r\n\rBecause the number of arguments is often enough to distinguish        between each possible choice, this shortcut can save a lot of typing, by        allowing you to type only the shortest string that will match an        argument type.        5.5&nbsp;Bean scopes    \n\r\n\rWhen you create a bean definition, you create a    recipe for creating actual instances of the class    defined by that bean definition. The idea that a bean definition is a recipe    is important, because it means that, as with a class, you can create many    object instances from a single recipe.  \n\r\n\rYou can control not only the various dependencies and configuration    values that are to be plugged into an object that is created from a    particular bean definition, but also the scope of the    objects created from a particular bean definition. This approach is powerful    and flexible in that you can choose the scope of the    objects you create through configuration instead of having to bake in the    scope of an object at the Java class level. Beans can be defined to be    deployed in one of a number of scopes: out of the box, the Spring Framework    supports five scopes, three of which are available only if you use a    web-aware ApplicationContext.  \n\r\n\rThe following scopes are supported out of the box. You can also create    a custom scope.  \n\r\n\rTable&nbsp;5.3.&nbsp;Bean scopes        ScopeDescription\n\r\n\r singleton \n\r\n\r(Default) Scopes a single bean definition to a single            object instance per Spring IoC container.\n\r\n\r prototype \n\r\n\rScopes a single bean definition to any number of object            instances.\n\r\n\r request \n\r\n\rScopes a single bean definition to the lifecycle of a            single HTTP request; that is, each HTTP request has its own instance            of a bean created off the back of a single bean definition. Only            valid in the context of a web-aware Spring            ApplicationContext.\n\r\n\r session \n\r\n\rScopes a single bean definition to the lifecycle of an            HTTP Session. Only valid in the            context of a web-aware Spring            ApplicationContext.\n\r\n\r global session \n\r\n\rScopes a single bean definition to the lifecycle of a            global HTTP Session. Typically only            valid when used in a portlet context. Only valid in the context of a            web-aware Spring            ApplicationContext.  \n\r  Thread-scoped beans        \n\r\n\rAs of Spring 3.0, a thread scope is available,      but is not registered by default. For more information, see the      documentation for SimpleThreadScope. For instructions on how to register this or      any other custom scope, see the section called &#8220;Using a custom scope&#8221;.    5.5.1&nbsp;The singleton scope        \n\r\n\rOnly one shared instance of a singleton bean is      managed, and all requests for beans with an id or ids matching that bean      definition result in that one specific bean instance being returned by the      Spring container.    \n\r\n\rTo put it another way, when you define a bean definition and it is      scoped as a singleton, the Spring IoC container creates exactly      one instance of the object defined by that bean definition.      This single instance is stored in a cache of such singleton beans, and      all subsequent requests and references for that named      bean return the cached object.        \n\r\n\rSpring\'s concept of a singleton bean differs from the Singleton      pattern as defined in the Gang of Four (GoF) patterns book. The GoF      Singleton hard-codes the scope of an object such that one and      only one instance of a particular class is created      per ClassLoader. The scope of the Spring      singleton is best described as per container and per      bean. This means that if you define one bean for a particular      class in a single Spring container, then the Spring container creates one      and only one instance of the class defined by that      bean definition. The singleton scope is the default scope in      Spring. To define a bean as a singleton in XML, you would      write, for example:    &lt;bean id=\"accountService\" class=\"com.foo.DefaultAccountService\"/&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"singleton\"/&gt;    5.5.2&nbsp;The prototype scope        \n\r\n\rThe non-singleton, prototype scope of bean deployment results in the      creation of a new bean instance every time a request      for that specific bean is made. That is, the bean is injected into another      bean or you request it through a getBean() method call      on the container. As a rule, use the prototype scope for all stateful      beans and the singleton scope for stateless beans.    \n\r\n\rThe following diagram illustrates the Spring prototype scope.      A data access object (DAO) is not typically configured as a      prototype, because a typical DAO does not hold any conversational state;      it was just easier for this author to reuse the core of the singleton      diagram.        \n\r\n\rThe following example defines a bean as a prototype in XML:    &lt;!-- using spring-beans-2.0.dtd --&gt;&lt;bean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"prototype\"/&gt;    \n\r\n\rIn contrast to the other scopes, Spring does not manage the complete      lifecycle of a prototype bean: the container instantiates, configures, and      otherwise assembles a prototype object, and hands it to the client, with      no further record of that prototype instance. Thus, although      initialization lifecycle callback methods are called      on all objects regardless of scope, in the case of prototypes, configured      destruction lifecycle callbacks are      not called. The client code must clean up      prototype-scoped objects and release expensive resources that the      prototype bean(s) are holding. To get the Spring container to release      resources held by prototype-scoped beans, try using a custom bean post-processor, which      holds a reference to beans that need to be cleaned up.    \n\r\n\rIn some respects, the Spring container\'s role in regard to a      prototype-scoped bean is a replacement for the Java new      operator. All lifecycle management past that point must be handled by the      client. (For details on the lifecycle of a bean in the Spring container,      see Section&nbsp;5.6.1, &#8220;Lifecycle callbacks&#8221;.)    5.5.3&nbsp;Singleton beans with prototype-bean dependencies        \n\r\n\rWhen you use singleton-scoped beans with dependencies on prototype      beans, be aware that dependencies are resolved at instantiation      time. Thus if you dependency-inject a prototype-scoped bean      into a singleton-scoped bean, a new prototype bean is instantiated and      then dependency-injected into the singleton bean. The prototype instance      is the sole instance that is ever supplied to the singleton-scoped      bean.    \n\r\n\rHowever, suppose you want the singleton-scoped bean to acquire a new      instance of the prototype-scoped bean repeatedly at runtime. You cannot      dependency-inject a prototype-scoped bean into your singleton bean,      because that injection occurs only once, when the      Spring container is instantiating the singleton bean and resolving and      injecting its dependencies. If you need a new instance of a prototype bean      at runtime more than once, see Section&nbsp;5.4.6, &#8220;Method injection&#8221;    5.5.4&nbsp;Request, session, and global session scopes        \n\r\n\rThe request, session, and      global session scopes are only      available if you use a web-aware Spring      ApplicationContext implementation (such as      XmlWebApplicationContext). If you use these scopes      with regular Spring IoC containers such as the      ClassPathXmlApplicationContext, you get an      IllegalStateException complaining about an unknown      bean scope.    Initial web configuration            \n\r\n\rTo support the scoping of beans at the request,        session, and global session levels        (web-scoped beans), some minor initial configuration is required before        you define your beans. (This initial setup is not        required for the standard scopes, singleton and prototype.)      \n\r\n\rHow you accomplish this initial setup depends on your particular        Servlet environment..      \n\r\n\rIf you access scoped beans within Spring Web MVC, in effect, within        a request that is processed by the Spring        DispatcherServlet, or        DispatcherPortlet, then no special setup is        necessary: DispatcherServlet and        DispatcherPortlet already expose all relevant        state.      \n\r\n\rIf you use a Servlet 2.4+ web container, with requests processed        outside of Spring\'s DispatcherServlet (for example, when using JSF or        Struts), you need to add the following        javax.servlet.ServletRequestListener to        the declarations in your web applications web.xml        file:      &lt;web-app&gt;...&lt;listener&gt;  &lt;listener-class&gt;      org.springframework.web.context.request.RequestContextListener  &lt;/listener-class&gt;&lt;/listener&gt;...&lt;/web-app&gt;      \n\r\n\rIf you use an older web container (Servlet 2.3), use the provided        javax.servlet.Filter implementation. The        following snippet of XML configuration must be included in the        web.xml file of your web application if you want to        access web-scoped beans in requests outside of Spring\'s        DispatcherServlet on a Servlet 2.3 container. (The filter mapping        depends on the surrounding web application configuration, so you must        change it as appropriate.)      &lt;web-app&gt;..&lt;filter&gt;  &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;  &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;...&lt;/web-app&gt;      \n\r\n\rDispatcherServlet,        RequestContextListener and        RequestContextFilter all do exactly the same        thing, namely bind the HTTP request object to the        Thread that is servicing that request. This makes        beans that are request- and session-scoped available further down the        call chain.        Request scope            \n\r\n\rConsider the following bean definition:      &lt;bean id=\"loginAction\" class=\"com.foo.LoginAction\" scope=\"request\"/&gt;      \n\r\n\rThe Spring container creates a new instance of the        LoginAction bean by using the        loginAction bean definition for each and every HTTP        request. That is, the loginAction bean is scoped at        the HTTP request level. You can change the internal state of the        instance that is created as much as you want, because other instances        created from the same loginAction bean definition        will not see these changes in state; they are particular to an        individual request. When the request completes processing, the bean that        is scoped to the request is discarded.        Session scope            \n\r\n\rConsider the following bean definition:      &lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"/&gt;      \n\r\n\rThe Spring container creates a new instance of the        UserPreferences bean by using the        userPreferences bean definition for the lifetime of a        single HTTP Session. In other words, the        userPreferences bean is effectively scoped at the        HTTP Session level. As with        request-scoped beans, you can change the internal        state of the instance that is created as much as you want, knowing that        other HTTP Session instances that are        also using instances created from the same        userPreferences bean definition do not see these        changes in state, because they are particular to an individual HTTP        Session. When the HTTP        Session is eventually discarded, the bean        that is scoped to that particular HTTP        Session is also discarded.        Global session scope            \n\r\n\rConsider the following bean definition:      &lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"globalSession\"/&gt;      \n\r\n\rThe global session scope is similar to the        standard HTTP Session scope (described above), and        applies only in the context of portlet-based web applications. The        portlet specification defines the notion of a global        Session that is shared among all portlets        that make up a single portlet web application. Beans defined at the        global session scope are scoped (or bound) to the        lifetime of the global portlet        Session.      \n\r\n\rIf you write a standard Servlet-based web application and you define        one or more beans as having global session scope, the        standard HTTP Session scope is used, and        no error is raised.        Scoped beans as dependencies            \n\r\n\rThe Spring IoC container manages not only the instantiation of your        objects (beans), but also the wiring up of collaborators (or        dependencies). If you want to inject (for example) an HTTP request        scoped bean into another bean, you must inject an AOP proxy in place of        the scoped bean. That is, you need to inject a proxy object that exposes        the same public interface as the scoped object but that can also        retrieve the real, target object from the relevant scope (for example,        an HTTP request) and delegate method calls onto the real object.      Note        \n\r\n\rYou do not need to use the          &lt;aop:scoped-proxy/&gt; in conjunction with beans          that are scoped as singletons or          prototypes.            \n\r\n\rThe configuration in the following example is only one line, but it        is important to understand the &#8220;why&#8221; as well as the        &#8220;how&#8221; behind it.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;  &lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"&gt;        &lt;!-- instructs the container to proxy the surrounding bean --&gt;        &lt;aop:scoped-proxy/&gt;  &lt;/bean&gt;  &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;  &lt;bean id=\"userService\" class=\"com.foo.SimpleUserService\"&gt;      &lt;!-- a reference to the proxied userPreferences bean --&gt;      &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rTo create such a proxy, you insert a child        &lt;aop:scoped-proxy/&gt; element into a scoped bean        definition.  See the section called &#8220;Choosing the type of proxy to create&#8221; and Appendix&nbsp;E, XML Schema-based configuration.) Why do definitions of beans scoped at the        request, session,        globalSession and custom-scope levels require the        &lt;aop:scoped-proxy/&gt; element ? Let\'s examine the        following singleton bean definition and contrast it with what you need        to define for the aforementioned scopes. (The following        userPreferences bean definition as it stands is        incomplete.)      &lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"/&gt;&lt;bean id=\"userManager\" class=\"com.foo.UserManager\"&gt;  &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;&lt;/bean&gt;      \n\r\n\rIn the preceding example, the singleton bean        userManager is injected with a reference to the HTTP        Session-scoped bean        userPreferences. The salient point here is that the        userManager bean is a singleton: it will be        instantiated exactly once per container, and its        dependencies (in this case only one, the        userPreferences bean) are also injected only once.        This means that the userManager bean will only        operate on the exact same userPreferences object,        that is, the one that it was originally injected with.            \n\r\n\rThis is not the behavior you want when        injecting a shorter-lived scoped bean into a longer-lived scoped bean,        for example injecting an HTTP        Session-scoped collaborating bean as a        dependency into singleton bean. Rather, you need a single        userManager object, and for the lifetime of an HTTP        Session, you need a        userPreferences object that is specific to said HTTP        Session. Thus the container creates an        object that exposes the exact same public interface as the        UserPreferences class (ideally an object that        is a UserPreferences        instance) which can fetch the real        UserPreferences object from the scoping mechanism        (HTTP request, Session, etc.). The        container injects this proxy object into the        userManager bean, which is unaware that this        UserPreferences reference is a proxy. In this        example, when a UserManager instance        invokes a method on the dependency-injected        UserPreferences object, it actually is invoking a        method on the proxy. The proxy then fetches the real        UserPreferences object from (in this case) the        HTTP Session, and delegates the method        invocation onto the retrieved real        UserPreferences object.      \n\r\n\rThus you need the following, correct and complete, configuration        when injecting request-, session-,        and globalSession-scoped beans into collaborating        objects:      &lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"&gt;  &lt;aop:scoped-proxy/&gt;&lt;/bean&gt;&lt;bean id=\"userManager\" class=\"com.foo.UserManager\"&gt;  &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;&lt;/bean&gt;      Choosing the type of proxy to create                \n\r\n\rBy default, when the Spring container creates a proxy for a bean          that is marked up with the          &lt;aop:scoped-proxy/&gt; element, a          CGLIB-based class proxy is created.        \n\r\n\rNote: CGLIB proxies only intercept public method          calls! Do not call non-public methods on such a proxy; they          will not be delegated to the scoped target object.        \n\r\n\rAlternatively, you can configure the Spring container to create          standard JDK interface-based proxies for such scoped beans, by          specifying false for the value of the          proxy-target-class attribute of the          &lt;aop:scoped-proxy/&gt; element. Using JDK          interface-based proxies means that you do not need additional          libraries in your application classpath to effect such proxying.          However, it also means that the class of the scoped bean must          implement at least one interface, and that all          collaborators into which the scoped bean is injected must reference          the bean through one of its interfaces.        &lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;&lt;bean id=\"userPreferences\" class=\"com.foo.DefaultUserPreferences\" scope=\"session\"&gt;  &lt;aop:scoped-proxy proxy-target-class=\"false\"/&gt;&lt;/bean&gt;&lt;bean id=\"userManager\" class=\"com.foo.UserManager\"&gt;  &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;&lt;/bean&gt;        \n\r\n\rFor more detailed information about choosing class-based or          interface-based proxying, see Section&nbsp;9.6, &#8220;Proxying mechanisms&#8221;.              5.5.5&nbsp;Custom scopes        \n\r\n\rAs of Spring 2.0, the bean scoping mechanism is extensible. You can      define your own scopes, or even redefine existing scopes, although the      latter is considered bad practice and you cannot      override the built-in singleton and      prototype scopes.    Creating a custom scope            \n\r\n\rTo integrate your custom scope(s) into the Spring container, you        need to implement the        org.springframework.beans.factory.config.Scope        interface, which is described in this section. For an idea of how to        implement your own scopes, see the Scope        implementations that are supplied with the Spring Framework itself and        the Scope Javadoc, which explains the methods you need to implement        in more detail.      \n\r\n\rThe Scope interface has four methods to get        objects from the scope, remove them from the scope, and allow them to be        destroyed.      \n\r\n\rThe following method returns the object from the underlying scope.        The session scope implementation, for example, returns the        session-scoped bean (and if it does not exist, the method returns a new        instance of the bean, after having bound it to the session for future        reference).      Object get(String name, ObjectFactory objectFactory)      \n\r\n\rThe following method removes the object from the underlying scope.        The session scope implementation for example, removes the session-scoped        bean from the underlying session. The object should be returned, but you        can return null if the object with the specified name is not        found.      Object remove(String name)      \n\r\n\rThe following method registers the callbacks the scope should        execute when it is destroyed or when the specified object in the scope        is destroyed. Refer to the Javadoc or a Spring scope implementation for        more information on destruction callbacks.      void registerDestructionCallback(String name, Runnable destructionCallback)      \n\r\n\rThe following method obtains the conversation identifier for the        underlying scope. This identifier is different for each scope. For a        session scoped implementation, this identifier can be the session        identifier.      String getConversationId()        Using a custom scope            \n\r\n\rAfter you write and test one or more custom        Scope implementations, you need to make        the Spring container aware of your new scope(s). The following method is        the central method to register a new        Scope with the Spring container:      void registerScope(String scopeName, Scope scope);      \n\r\n\rThis method is declared on the        ConfigurableBeanFactory interface, which        is available on most of the concrete        ApplicationContext implementations that        ship with Spring via the BeanFactory property.      \n\r\n\rThe first argument to the registerScope(..)        method is the unique name associated with a scope; examples of such        names in the Spring container itself are singleton        and prototype. The second argument to the        registerScope(..) method is an actual instance        of the custom Scope implementation that        you wish to register and use.      \n\r\n\rSuppose that you write your custom        Scope implementation, and then register        it as below.      Note        \n\r\n\rThe example below uses SimpleThreadScope which          is included with Spring, but not registered by default. The          instructions would be the same for your own custom          Scope implementations.            Scope threadScope = new SimpleThreadScope();beanFactory.registerScope(\"thread\", threadScope);      \n\r\n\rYou then create bean definitions that adhere to the scoping rules of        your custom Scope:      &lt;bean id=\"...\" class=\"...\" scope=\"thread\"&gt;      \n\r\n\rWith a custom Scope implementation,        you are not limited to programmatic registration of the scope. You can        also do the Scope registration        declaratively, using the CustomScopeConfigurer        class:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\"&gt;      &lt;property name=\"scopes\"&gt;          &lt;map&gt;              &lt;entry key=\"thread\"&gt;                  &lt;bean class=\"org.springframework.context.support.SimpleThreadScope\"/&gt;              &lt;/entry&gt;          &lt;/map&gt;      &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"bar\" class=\"x.y.Bar\" scope=\"thread\"&gt;      &lt;property name=\"name\" value=\"Rick\"/&gt;      &lt;aop:scoped-proxy/&gt;  &lt;/bean&gt;  &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt;      &lt;property name=\"bar\" ref=\"bar\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      Note        \n\r\n\rWhen you place &lt;aop:scoped-proxy/&gt; in a          FactoryBean implementation, it is the          factory bean itself that is scoped, not the object returned from          getObject().              5.6&nbsp;Customizing the nature of a bean    5.6.1&nbsp;Lifecycle callbacks        \n\r\n\rTo interact with the container\'s management of the bean lifecycle, you      can implement the Spring InitializingBean      and DisposableBean interfaces. The      container calls afterPropertiesSet() for the      former and destroy() for the latter to allow the      bean to perform certain actions upon initialization and destruction of      your beans.      Tip          \n\r\n\rThe JSR-250 @PostConstruct and          @PreDestroy annotations are generally          considered best practice for receiving lifecycle callbacks in a modern          Spring application. Using these annotations means that your beans are not          coupled to Spring specific interfaces. For details see          Section&nbsp;5.9.6, &#8220;@PostConstruct and      @PreDestroy&#8221;.          \n\r\n\rIf you don\'t want to use the JSR-250 annotations but you are still          looking to remove coupling consider the use of init-method and destroy-method          object definition metadata.          \n\r\n\rInternally, the Spring Framework uses      BeanPostProcessor implementations to      process any callback interfaces it can find and call the appropriate      methods. If you need custom features or other lifecycle behavior Spring      does not offer out-of-the-box, you can implement a      BeanPostProcessor yourself. For more      information, see Section&nbsp;5.8, &#8220;Container Extension Points&#8221;.    \n\r\n\rIn addition to the initialization and destruction callbacks,      Spring-managed objects may also implement the      Lifecycle interface so that those objects      can participate in the startup and shutdown process as driven by the      container\'s own lifecycle.    \n\r\n\rThe lifecycle callback interfaces are described in this      section.    Initialization callbacks            \n\r\n\rThe        org.springframework.beans.factory.InitializingBean        interface allows a bean to perform initialization work after all        necessary properties on the bean have been set by the container. The        InitializingBean interface specifies a        single method:      void afterPropertiesSet() throws Exception;      \n\r\n\rIt is recommended that you do not use the        InitializingBean interface because it        unnecessarily couples the code to Spring. Alternatively, use the                @PostConstruct annotation or specify a POJO        initialization method. In the case of XML-based configuration metadata,        you use the init-method attribute to specify the name        of the method that has a void no-argument signature. For example, the        following definition:      &lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt;      public class ExampleBean {  public void init() {      // do some initialization work  }}      \n\r\n\r...is exactly the same as...      &lt;bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/&gt;      public class AnotherExampleBean implements InitializingBean {  public void afterPropertiesSet() {      // do some initialization work  }}      \n\r\n\r... but does not couple the code to Spring.        Destruction callbacks            \n\r\n\rImplementing the        org.springframework.beans.factory.DisposableBean        interface allows a bean to get a callback when the container containing        it is destroyed. The DisposableBean        interface specifies a single method:      void destroy() throws Exception;      \n\r\n\rIt is recommended that you do not use the        DisposableBean callback interface because        it unnecessarily couples the code to Spring. Alternatively, use the                @PreDestroy annotation or specify a        generic method that is supported by bean definitions. With XML-based        configuration metadata, you use the destroy-method        attribute on the &lt;bean/&gt;. For example, the        following definition:      &lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/&gt;      public class ExampleBean {  public void cleanup() {      // do some destruction work (like releasing pooled connections)  }}      \n\r\n\r...is exactly the same as...      &lt;bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/&gt;      public class AnotherExampleBean implements DisposableBean {  public void destroy() {      // do some destruction work (like releasing pooled connections)  }}      \n\r\n\r... but does not couple the code to Spring.        Default initialization and destroy methods            \n\r\n\rWhen you write initialization and destroy method callbacks that do        not use the Spring-specific        InitializingBean and        DisposableBean callback interfaces, you        typically write methods with names such as init(),        initialize(), dispose(), and so        on. Ideally, the names of such lifecycle callback methods are        standardized across a project so that all developers use the same method        names and ensure consistency.      \n\r\n\rYou can configure the Spring container to look        for named initialization and destroy callback method names on        every bean. This means that you, as an application        developer, can write your application classes and use an initialization        callback called init(), without having to configure        an init-method=\"init\" attribute with each bean        definition. The Spring IoC container calls that method when the bean is        created (and in accordance with the standard lifecycle callback contract        described previously). This feature also enforces a consistent naming        convention for initialization and destroy method callbacks.      \n\r\n\rSuppose that your initialization callback methods are named        init() and destroy callback methods are named        destroy(). Your class will resemble the class in the        following example.      public class DefaultBlogService implements BlogService {  private BlogDao blogDao;  public void setBlogDao(BlogDao blogDao) {      this.blogDao = blogDao;  }  // this is (unsurprisingly) the initialization callback method  public void init() {      if (this.blogDao == null) {          throw new IllegalStateException(\"The [blogDao] property must be set.\");      }  }}      &lt;beans default-init-method=\"init\"&gt;  &lt;bean id=\"blogService\" class=\"com.foo.DefaultBlogService\"&gt;      &lt;property name=\"blogDao\" ref=\"blogDao\" /&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe presence of the default-init-method attribute        on the top-level &lt;beans/&gt; element attribute        causes the Spring IoC container to recognize a method called        init on beans as the initialization method callback.        When a bean is created and assembled, if the bean class has such a        method, it is invoked at the appropriate time.      \n\r\n\rYou configure destroy method callbacks similarly (in XML, that is)        by using the default-destroy-method attribute on the        top-level &lt;beans/&gt; element.      \n\r\n\rWhere existing bean classes already have callback methods that are        named at variance with the convention, you can override the default by        specifying (in XML, that is) the method name using the        init-method and destroy-method        attributes of the &lt;bean/&gt; itself.      \n\r\n\rThe Spring container guarantees that a configured initialization        callback is called immediately after a bean is supplied with all        dependencies. Thus the initialization callback is called on the raw bean        reference, which means that AOP interceptors and so forth are not yet        applied to the bean. A target bean is fully created        first, then an AOP proxy (for        example) with its interceptor chain is applied. If the target bean and        the proxy are defined separately, your code can even interact with the        raw target bean, bypassing the proxy. Hence, it would be inconsistent to        apply the interceptors to the init method, because doing so would couple        the lifecycle of the target bean with its proxy/interceptors and leave        strange semantics when your code interacts directly to the raw target        bean.        Combining lifecycle mechanisms            \n\r\n\rAs of Spring 2.5, you have three options for controlling bean        lifecycle behavior: the InitializingBean and DisposableBean callback        interfaces; custom init() and        destroy() methods; and the @PostConstruct and        @PreDestroy annotations. You can        combine these mechanisms to control a given bean.      Note        \n\r\n\rIf multiple lifecycle mechanisms are configured for a bean, and          each mechanism is configured with a different method name, then each          configured method is executed in the order listed below. However, if          the same method name is configured - for example,          init() for an initialization method - for more than          one of these lifecycle mechanisms, that method is executed once, as          explained in the preceding section.            \n\r\n\rMultiple lifecycle mechanisms configured for the same bean, with        different initialization methods, are called as follows:      \n\r          \n\r\n\rMethods annotated with            @PostConstruct        \n\r          \n\r\n\rafterPropertiesSet() as defined by the            InitializingBean callback            interface        \n\r          \n\r\n\rA custom configured init() method        \n\r      \n\r\n\rDestroy methods are called in the same order:      \n\r          \n\r\n\rMethods annotated with            @PreDestroy        \n\r          \n\r\n\rdestroy() as defined by the            DisposableBean callback            interface        \n\r          \n\r\n\rA custom configured destroy() method        \n\r        Startup and shutdown callbacks            \n\r\n\rThe Lifecycle interface defines the        essential methods for any object that has its own lifecycle requirements        (e.g. starts and stops some background process):      public interface Lifecycle {  void start();  void stop();  boolean isRunning();}      \n\r\n\rAny Spring-managed object may implement that interface. Then, when        the ApplicationContext itself starts and stops, it will cascade those        calls to all Lifecycle implementations defined within that context. It        does this by delegating to a        LifecycleProcessor:      public interface LifecycleProcessor extends Lifecycle {  void onRefresh();  void onClose();}      \n\r\n\rNotice that the LifecycleProcessor is        itself an extension of the Lifecycle        interface. It also adds two other methods for reacting to the context        being refreshed and closed.      \n\r\n\rThe order of startup and shutdown invocations can be important. If a        \"depends-on\" relationship exists between any two objects, the dependent        side will start after its dependency, and it will        stop before its dependency. However, at times the        direct dependencies are unknown. You may only know that objects of a        certain type should start prior to objects of another type. In those        cases, the SmartLifecycle interface        defines another option, namely the getPhase()        method as defined on its super-interface,        Phased.      public interface Phased {  int getPhase();}public interface SmartLifecycle extends Lifecycle, Phased {  boolean isAutoStartup();  void stop(Runnable callback);}      \n\r\n\rWhen starting, the objects with the lowest phase start first, and        when stopping, the reverse order is followed. Therefore, an object that        implements SmartLifecycle and whose        getPhase() method returns Integer.MIN_VALUE would be        among the first to start and the last to stop. At the other end of the        spectrum, a phase value of Integer.MAX_VALUE would        indicate that the object should be started last and stopped first        (likely because it depends on other processes to be running). When        considering the phase value, it\'s also important to know that the        default phase for any \"normal\" Lifecycle        object that does not implement        SmartLifecycle would be 0. Therefore, any        negative phase value would indicate that an object should start before        those standard components (and stop after them), and vice versa for any        positive phase value.      \n\r\n\rAs you can see the stop method defined by        SmartLifecycle accepts a callback. Any        implementation must invoke that callback\'s run()        method after that implementation\'s shutdown process is complete. That        enables asynchronous shutdown where necessary since the default        implementation of the LifecycleProcessor        interface, DefaultLifecycleProcessor, will wait        up to its timeout value for the group of objects within each phase to        invoke that callback. The default per-phase timeout is 30 seconds. You        can override the default lifecycle processor instance by defining a bean        named \"lifecycleProcessor\" within the context. If you only want to        modify the timeout, then defining the following would be        sufficient:      &lt;bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\"&gt;  &lt;!-- timeout value in milliseconds --&gt;  &lt;property name=\"timeoutPerShutdownPhase\" value=\"10000\"/&gt;&lt;/bean&gt;      \n\r\n\rAs mentioned, the LifecycleProcessor        interface defines callback methods for the refreshing and closing of the        context as well. The latter will simply drive the shutdown process as if        stop() had been called explicitly, but it will happen when the context        is closing. The \'refresh\' callback on the other hand enables another        feature of SmartLifecycle beans. When the        context is refreshed (after all objects have been instantiated and        initialized), that callback will be invoked, and at that point the        default lifecycle processor will check the boolean value returned by        each SmartLifecycle object\'s        isAutoStartup() method. If \"true\", then that        object will be started at that point rather than waiting for an explicit        invocation of the context\'s or its own start() method (unlike the        context refresh, the context start does not happen automatically for a        standard context implementation). The \"phase\" value as well as any        \"depends-on\" relationships will determine the startup order in the same        way as described above.        Shutting down the Spring IoC container gracefully in non-web        applications            Note        \n\r\n\rThis section applies only to non-web applications. Spring\'s          web-based ApplicationContext          implementations already have code in place to shut down the Spring IoC          container gracefully when the relevant web application is shut          down.            \n\r\n\rIf you are using Spring\'s IoC container in a non-web application        environment; for example, in a rich client desktop environment; you        register a shutdown hook with the JVM. Doing so ensures a graceful        shutdown and calls the relevant destroy methods on your singleton beans        so that all resources are released. Of course, you must still configure        and implement these destroy callbacks correctly.      \n\r\n\rTo register a shutdown hook, you call the        registerShutdownHook() method that is declared        on the AbstractApplicationContext class:      import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public final class Boot {  public static void main(final String[] args) throws Exception {      AbstractApplicationContext ctx          = new ClassPathXmlApplicationContext(new String []{\"beans.xml\"});      // add a shutdown hook for the above context...       ctx.registerShutdownHook();      // app runs here...      // main method exits, hook is called prior to the app shutting down...  }}        5.6.2&nbsp;ApplicationContextAware and      BeanNameAware        \n\r\n\rWhen an ApplicationContext creates a      class that implements the      org.springframework.context.ApplicationContextAware      interface, the class is provided with a reference to that      ApplicationContext.    public interface ApplicationContextAware {  void setApplicationContext(ApplicationContext applicationContext) throws BeansException;}    \n\r\n\rThus beans can manipulate programmatically the      ApplicationContext that created them,      through the ApplicationContext interface,      or by casting the reference to a known subclass of this interface, such as      ConfigurableApplicationContext, which exposes      additional functionality. One use would be the programmatic retrieval of      other beans. Sometimes this capability is useful; however, in general you      should avoid it, because it couples the code to Spring and does not follow      the Inversion of Control style, where collaborators are provided to beans      as properties. Other methods of the ApplicationContext provide access to      file resources, publishing application events, and accessing a      MessageSource. These additional features are described in Section&nbsp;5.14, &#8220;Additional Capabilities of the    ApplicationContext&#8221;    \n\r\n\rAs of Spring 2.5, autowiring is another alternative to obtain      reference to the ApplicationContext. The      \"traditional\" constructor and byType      autowiring modes (as described in Section&nbsp;5.4.5, &#8220;Autowiring collaborators&#8221;) can provide a dependency of type      ApplicationContext for a constructor      argument or setter method parameter, respectively. For more flexibility,      including the ability to autowire fields and multiple parameter methods,      use the new annotation-based autowiring features. If you do, the      ApplicationContext is autowired into a      field, constructor argument, or method parameter that is expecting the      ApplicationContext type if the field,      constructor, or method in question carries the      @Autowired annotation. For more      information, see Section&nbsp;5.9.2, &#8220;@Autowired&#8221;.    \n\r\n\rWhen an ApplicationContext creates a class that implements the      org.springframework.beans.factory.BeanNameAware      interface, the class is provided with a reference to the name defined in      its associated object definition.    public interface BeanNameAware {  void setBeanName(string name) throws BeansException;}    \n\r\n\rThe callback is invoked after population of normal bean properties but      before an initialization callback such as      InitializingBeans      afterPropertiesSet or a custom init-method.    5.6.3&nbsp;Other Aware interfaces        \n\r\n\rBesides ApplicationContextAware and      BeanNameAware discussed above, Spring      offers a range of      Aware interfaces that      allow beans to indicate to the container that they require a certain      infrastructure dependency. The most important      Aware interfaces are summarized below - as      a general rule, the name is a good indication of the dependency      type:    \n\r\n\rTable&nbsp;5.4.&nbsp;Aware interfaces            NameInjected DependencyExplained in...\n\r\n\rApplicationContextAware\n\r\n\rDeclaring              ApplicationContext\n\r\n\rSection&nbsp;5.6.2, &#8220;ApplicationContextAware and      BeanNameAware&#8221;\n\r\n\rApplicationEventPublisherAware\n\r\n\rEvent publisher of the enclosing              ApplicationContext\n\r\n\rSection&nbsp;5.14, &#8220;Additional Capabilities of the    ApplicationContext&#8221;\n\r\n\rBeanClassLoaderAware\n\r\n\rClass loader used to load the bean              classes.\n\r\n\rSection&nbsp;5.3.2, &#8220;Instantiating beans&#8221;\n\r\n\rBeanFactoryAware\n\r\n\rDeclaring              BeanFactory\n\r\n\rSection&nbsp;5.6.2, &#8220;ApplicationContextAware and      BeanNameAware&#8221;\n\r\n\rBeanNameAware\n\r\n\rName of the declaring bean\n\r\n\rSection&nbsp;5.6.2, &#8220;ApplicationContextAware and      BeanNameAware&#8221;\n\r\n\rBootstrapContextAware\n\r\n\rResource adapter              BootstrapContext the container runs              in. Typically available only in JCA aware              ApplicationContexts\n\r\n\rChapter&nbsp;25, JCA CCI\n\r\n\rLoadTimeWeaverAware\n\r\n\rDefined weaver for processing              class definition at load time\n\r\n\rSection&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;\n\r\n\rMessageSourceAware\n\r\n\rConfigured strategy for resolving messages (with              support for parametrization and              internationalization)\n\r\n\rSection&nbsp;5.14, &#8220;Additional Capabilities of the    ApplicationContext&#8221;\n\r\n\rNotificationPublisherAware\n\r\n\rSpring JMX notification publisher\n\r\n\rSection&nbsp;24.7, &#8220;Notifications&#8221;\n\r\n\rPortletConfigAware\n\r\n\rCurrent PortletConfig              the container runs in. Valid only in a web-aware Spring              ApplicationContext\n\r\n\rChapter&nbsp;20, Portlet MVC Framework\n\r\n\rPortletContextAware\n\r\n\rCurrent PortletContext              the container runs in. Valid only in a web-aware Spring              ApplicationContext\n\r\n\rChapter&nbsp;20, Portlet MVC Framework\n\r\n\rResourceLoaderAware\n\r\n\rConfigured loader for low-level access to              resources\n\r\n\rChapter&nbsp;6, Resources\n\r\n\rServletConfigAware\n\r\n\rCurrent ServletConfig              the container runs in. Valid only in a web-aware Spring              ApplicationContext\n\r\n\rChapter&nbsp;17, Web MVC framework\n\r\n\rServletContextAware\n\r\n\rCurrent ServletContext              the container runs in. Valid only in a web-aware Spring              ApplicationContext\n\r\n\rChapter&nbsp;17, Web MVC framework    \n\r    \n\r\n\rNote again that usage of these interfaces ties your code to the Spring      API and does not follow the Inversion of Control style. As such, they are      recommended for infrastructure beans that require programmatic access to      the container.    5.7&nbsp;Bean definition inheritance        \n\r\n\rA bean definition can contain a lot of configuration information,      including constructor arguments, property values, and container-specific      information such as initialization method, static factory method name, and      so on. A child bean definition inherits configuration data from a parent      definition. The child definition can override some values, or add others,      as needed. Using parent and child bean definitions can save a lot of      typing. Effectively, this is a form of templating.    \n\r\n\rIf you work with an ApplicationContext      interface programmatically, child bean definitions are represented by the      ChildBeanDefinition class. Most users do not work      with them on this level, instead configuring bean definitions      declaratively in something like the      ClassPathXmlApplicationContext. When you use      XML-based configuration metadata, you indicate a child bean definition by      using the parent attribute, specifying the parent bean      as the value of this attribute.    &lt;bean id=\"inheritedTestBean\" abstract=\"true\"    class=\"org.springframework.beans.TestBean\"&gt;  &lt;property name=\"name\" value=\"parent\"/&gt;  &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"inheritsWithDifferentClass\"      class=\"org.springframework.beans.DerivedTestBean\"      parent=\"inheritedTestBean\" init-method=\"initialize\"&gt;  &lt;property name=\"name\" value=\"override\"/&gt;  &lt;!-- the age property value of 1 will be inherited from  parent --&gt;&lt;/bean&gt;    \n\r\n\rA child bean definition uses the bean class from the parent definition      if none is specified, but can also override it. In the latter case, the      child bean class must be compatible with the parent, that is, it must      accept the parent\'s property values.    \n\r\n\rA child bean definition inherits constructor argument values, property      values, and method overrides from the parent, with the option to add new      values. Any initialization method, destroy method, and/or      static factory method settings that you specify will      override the corresponding parent settings.    \n\r\n\rThe remaining settings are always taken from the      child definition: depends on, autowire      mode, dependency check,      singleton, scope, lazy      init.    \n\r\n\rThe preceding example explicitly marks the parent bean definition as      abstract by using the abstract attribute. If the parent      definition does not specify a class, explicitly marking the parent bean      definition as abstract is required, as follows:    &lt;bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\"&gt;    &lt;property name=\"name\" value=\"parent\"/&gt;    &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"inheritsWithClass\" class=\"org.springframework.beans.DerivedTestBean\"    parent=\"inheritedTestBeanWithoutClass\" init-method=\"initialize\"&gt;  &lt;property name=\"name\" value=\"override\"/&gt;  &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;&lt;/bean&gt;    \n\r\n\rThe parent bean cannot be instantiated on its own because it is      incomplete, and it is also explicitly marked as      abstract. When a definition is      abstract like this, it is usable only as a pure      template bean definition that serves as a parent definition for child      definitions. Trying to use such an abstract parent bean      on its own, by referring to it as a ref property of another bean or doing      an explicit getBean() call with the parent bean      id, returns an error. Similarly, the container\'s internal      preInstantiateSingletons() method ignores bean      definitions that are defined as abstract.    Note      \n\r\n\rApplicationContext pre-instantiates all        singletons by default. Therefore, it is important (at least for        singleton beans) that if you have a (parent) bean definition which you        intend to use only as a template, and this definition specifies a class,        you must make sure to set the abstract attribute to        true, otherwise the application context will        actually (attempt to) pre-instantiate the abstract        bean.        5.8&nbsp;Container Extension Points    \n\r\n\rTypically, an application developer does not need to subclass    ApplicationContext implementation classes.    Instead, the Spring IoC container can be extended by plugging in    implementations of special integration interfaces. The next few sections    describe these integration interfaces.  5.8.1&nbsp;Customizing beans using a      BeanPostProcessor        \n\r\n\rThe BeanPostProcessor interface defines      callback methods that you can implement to provide      your own (or override the container\'s default) instantiation logic,      dependency-resolution logic, and so forth. If you want to implement some      custom logic after the Spring container finishes instantiating,      configuring, and initializing a bean, you can plug in one or      more BeanPostProcessor      implementations.    \n\r\n\rYou can configure multiple BeanPostProcessor      instances, and you can control the order in which these      BeanPostProcessors execute by setting the      order property. You can set this property only if the      BeanPostProcessor implements the      Ordered interface; if you write your own      BeanPostProcessor you should consider      implementing the Ordered interface too. For      further details, consult the Javadoc for the      BeanPostProcessor and      Ordered interfaces. See also the note below on            programmatic registration of BeanPostProcessors          Note      \n\r\n\rBeanPostProcessors operate on bean (or object)        instances; that is to say, the Spring IoC container        instantiates a bean instance and then        BeanPostProcessors do their work.      \n\r\n\rBeanPostProcessors are scoped        per-container. This is only relevant if you are        using container hierarchies. If you define a        BeanPostProcessor in one container, it        will only post-process the beans in that        container. In other words, beans that are defined in one container are not        post-processed by a BeanPostProcessor defined in another        container, even if both containers are part of the same hierarchy.      \n\r\n\rTo change the actual bean definition (i.e., the        blueprint that defines the bean), you instead need to use a        BeanFactoryPostProcessor as described        in Section&nbsp;5.8.2, &#8220;Customizing configuration metadata with a      BeanFactoryPostProcessor&#8221;.        \n\r\n\rThe org.springframework.beans.factory.config.BeanPostProcessor      interface consists of exactly two callback methods. When such a class is      registered as a post-processor with the container, for each bean instance      that is created by the container, the post-processor gets a callback from      the container both before container initialization      methods (such as InitializingBean\'s afterPropertiesSet()      and any declared init method) are called as well as after      any bean initialization callbacks. The post-processor can take      any action with the bean instance, including ignoring the callback      completely. A bean post-processor typically checks for callback      interfaces or may wrap a bean with a proxy. Some Spring AOP      infrastructure classes are implemented as bean post-processors in order      to provide proxy-wrapping logic.    \n\r\n\rAn ApplicationContext      automatically detects any beans that are defined in      the configuration metadata which implement the      BeanPostProcessor interface. The      ApplicationContext registers these beans as      post-processors so that they can be called later upon bean creation.      Bean post-processors can be deployed in the container just like any other      beans.        Programmatically registering BeanPostProcessors                    \n\r\n\rWhile the recommended approach for BeanPostProcessor          registration is through ApplicationContext          auto-detection (as described above), it is also         possible to register them programmatically         against a ConfigurableBeanFactory using the         addBeanPostProcessor method. This can be useful         when needing to evaluate conditional logic before registration, or even         for copying bean post processors across contexts in a hierarchy.  Note         however that BeanPostProcessors added         programmatically do not respect the Ordered          interface. Here it is the order of         registration that dictates the order of execution.  Note also         that BeanPostProcessors registered         programmatically are always processed before those registered through         auto-detection, regardless of any explicit ordering.        BeanPostProcessors and AOP        auto-proxying            \n\r\n\rClasses that implement the        BeanPostProcessor interface are        special and are treated differently by the        container. All BeanPostProcessors        and beans that they reference directly are        instantiated on startup, as part of the special startup phase of the        ApplicationContext. Next, all        BeanPostProcessors are registered in a        sorted fashion and applied to all further beans in the container.        Because AOP auto-proxying is implemented as a        BeanPostProcessor itself, neither        BeanPostProcessors nor the beans they reference        directly are eligible for auto-proxying, and thus do not have aspects woven        into them.      \n\r\n\rFor any such bean, you should see an informational log message:        &#8220;Bean foo is not eligible for getting processed by all        BeanPostProcessor interfaces (for example: not eligible for        auto-proxying)&#8221;.      \n\r\n\rNote that if you have beans wired into your BeanPostProcessor        using autowiring or @Resource (which may fall back to autowiring),        Spring might access unexpected beans when searching for type-matching dependency candidates,        and therefore make them ineligible for auto-proxying or other kinds of bean post-processing.        For example, if you have a dependency annotated with @Resource        where the field/setter name does not directly correspond to the declared name of a bean and        no name attribute is used, then Spring will access other beans for matching them by type.        \n\r\n\rThe following examples show how to write, register, and use      BeanPostProcessors in an      ApplicationContext.    Example: Hello World,        BeanPostProcessor-style            \n\r\n\rThis first example illustrates basic usage. The example shows a        custom BeanPostProcessor implementation        that invokes the toString() method of each bean        as it is created by the container and prints the resulting string to the        system console.      \n\r\n\rFind below the custom        BeanPostProcessor implementation class        definition:      package scripting;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.beans.BeansException;public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {  // simply return the instantiated bean as-is  public Object postProcessBeforeInitialization(Object bean, String beanName)                                                                     throws BeansException {      return bean; // we could potentially return any object reference here...  }  public Object postProcessAfterInitialization(Object bean, String beanName)                                                                     throws BeansException {      System.out.println(\"Bean \'\" + beanName + \"\' created : \" + bean.toString());      return bean;  }}      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:lang=\"http://www.springframework.org/schema/lang\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/lang         http://www.springframework.org/schema/lang/spring-lang.xsd\"&gt;  &lt;lang:groovy id=\"messenger\"        script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\"&gt;      &lt;lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/&gt;  &lt;/lang:groovy&gt;  &lt;!--      when the above bean (messenger) is instantiated, this custom      BeanPostProcessor implementation will output the fact to the system console   --&gt;  &lt;bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/&gt;&lt;/beans&gt;      \n\r\n\rNotice how the        InstantiationTracingBeanPostProcessor is simply        defined. It does not even have a name, and because it is a bean it can        be dependency-injected just like any other bean. (The preceding        configuration also defines a bean that is backed by a Groovy script. The        Spring 2.0 dynamic language support is detailed in the chapter entitled        Chapter&nbsp;28, Dynamic language support.)      \n\r\n\rThe following simple Java application executes the preceding code and        configuration:      import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.scripting.Messenger;public final class Boot {  public static void main(final String[] args) throws Exception {      ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\");      Messenger messenger = (Messenger) ctx.getBean(\"messenger\");      System.out.println(messenger);  }}      \n\r\n\rThe output of the preceding application resembles the        following:      Bean \'messenger\' created : org.springframework.scripting.groovy.GroovyMessenger@272961org.springframework.scripting.groovy.GroovyMessenger@272961        Example: The        RequiredAnnotationBeanPostProcessor            \n\r\n\rUsing callback interfaces or annotations in conjunction with a        custom BeanPostProcessor implementation        is a common means of extending the Spring IoC container. An example is        Spring\'s RequiredAnnotationBeanPostProcessor &#151; a        BeanPostProcessor implementation that        ships with the Spring distribution which ensures that JavaBean        properties on beans that are marked with an (arbitrary) annotation are        actually (configured to be) dependency-injected with a value.        5.8.2&nbsp;Customizing configuration metadata with a      BeanFactoryPostProcessor        \n\r\n\rThe next extension point that we will look at is the      org.springframework.beans.factory.config.BeanFactoryPostProcessor.      The semantics of this interface are similar to those of the      BeanPostProcessor, with one major      difference: BeanFactoryPostProcessors operate on the      bean configuration metadata; that is, the Spring IoC      container allows BeanFactoryPostProcessors to read the      configuration metadata and potentially change it      before the container instantiates any beans other      than BeanFactoryPostProcessors.    \n\r\n\rYou can configure multiple      BeanFactoryPostProcessors, and you can control the order in      which these BeanFactoryPostProcessors execute by      setting the order property. However, you can only set      this property if the      BeanFactoryPostProcessor implements the      Ordered interface. If you write your own      BeanFactoryPostProcessor, you should      consider implementing the Ordered interface      too. Consult the Javadoc for the      BeanFactoryPostProcessor and      Ordered interfaces for more details.    Note      \n\r\n\rIf you want to change the actual bean instances        (i.e., the objects that are created from the configuration metadata), then you        instead need to use a BeanPostProcessor        (described above in Section&nbsp;5.8.1, &#8220;Customizing beans using a      BeanPostProcessor&#8221;). While        it is technically possible to work with bean instances within a        BeanFactoryPostProcessor (e.g., using        BeanFactory.getBean()), doing so causes        premature bean instantiation, violating the standard container lifecycle.        This may cause negative side effects such as bypassing bean post        processing.      \n\r\n\rAlso, BeanFactoryPostProcessors are scoped        per-container. This is only relevant if you are        using container hierarchies. If you define a        BeanFactoryPostProcessor in one        container, it will only be applied to the bean        definitions in that container. Bean definitions in one container        will not be post-processed by        BeanFactoryPostProcessors in another container, even        if both containers are part of the same hierarchy.        \n\r\n\rA bean factory post-processor is executed automatically when it is      declared inside an ApplicationContext,      in order to apply changes to the configuration metadata that define the      container. Spring includes a number of predefined bean factory      post-processors, such as PropertyOverrideConfigurer      and PropertyPlaceholderConfigurer. A custom      BeanFactoryPostProcessor can also be used,      for example, to register custom property editors.        \n\r\n\rAn ApplicationContext automatically      detects any beans that are deployed into it that implement the      BeanFactoryPostProcessor interface. It      uses these beans as bean factory post-processors, at the      appropriate time. You can deploy these post-processor beans as you      would any other bean.    Note      \n\r\n\rAs with BeanPostProcessors, you typically        do not want to configure BeanFactoryPostProcessors        for lazy initialization. If no other bean references a        Bean(Factory)PostProcessor,        that post-processor will not get instantiated at all. Thus, marking it for        lazy initialization will be ignored, and the        Bean(Factory)PostProcessor will be        instantiated eagerly even if you set the default-lazy-init        attribute to true on the declaration of your        &lt;beans /&gt; element.        Example: the        PropertyPlaceholderConfigurer            \n\r\n\rYou use the        PropertyPlaceholderConfigurer to        externalize property values from a bean definition in a separate        file using the standard Java Properties format.        Doing so enables the person deploying an application to customize        environment-specific properties such as database URLs and passwords,        without the complexity or risk of modifying the main XML definition file        or files for the container.            \n\r\n\rConsider the following XML-based configuration metadata fragment,        where a DataSource with placeholder        values is defined. The example shows properties configured from an        external Properties file. At runtime, a        PropertyPlaceholderConfigurer is applied to the        metadata that will replace some properties of the DataSource. The values        to replace are specified as placeholders of the form        ${property-name} which follows the Ant / log4j / JSP EL style.      &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt;  &lt;property name=\"locations\" value=\"classpath:com/foo/jdbc.properties\"/&gt;&lt;/bean&gt;&lt;bean id=\"dataSource\" destroy-method=\"close\"    class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;  &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;  &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;  &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;  &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;      \n\r\n\rThe actual values come from another file in the standard Java        Properties format:      jdbc.driverClassName=org.hsqldb.jdbcDriverjdbc.url=jdbc:hsqldb:hsql://production:9002jdbc.username=sajdbc.password=root      \n\r\n\rTherefore, the string ${jdbc.username} is replaced        at runtime with the value \'sa\', and the same applies for other placeholder        values that match keys in the properties file. The        PropertyPlaceholderConfigurer checks for        placeholders in most properties and attributes of a bean definition.        Furthermore, the placeholder prefix and suffix can be customized.      \n\r\n\rWith the context namespace introduced in Spring        2.5, it is possible to configure property placeholders with a dedicated        configuration element. One or more locations can be provided as a        comma-separated list in the location        attribute.      &lt;context:property-placeholder location=\"classpath:com/foo/jdbc.properties\"/&gt;      \n\r\n\rThe PropertyPlaceholderConfigurer not only        looks for properties in the Properties file        you specify. By default it also checks against the Java        System properties if it cannot find a property        in the specified properties files. You can customize this behavior by setting the        systemPropertiesMode property of the configurer with        one of the following three supported integer values:                                \n\r                \n\r\n\rnever (0): Never check system properties            \n\r                \n\r\n\rfallback (1): Check system properties if not resolvable in the specified properties files. This is the default.            \n\r                \n\r\n\roverride (2): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.            \n\r      \n\r\n\r        Consult the Javadoc for the PropertyPlaceholderConfigurer        for more information.      Class name substitution                \n\r\n\rYou can use the          PropertyPlaceholderConfigurer to substitute          class names, which is sometimes useful when you have to pick a          particular implementation class at runtime. For example:        &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt;  &lt;property name=\"locations\"&gt;      &lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;  &lt;/property&gt;  &lt;property name=\"properties\"&gt;      &lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/&gt;        \n\r\n\rIf the class cannot be resolved at runtime to a valid class,          resolution of the bean fails when it is about to be created, which is          during the preInstantiateSingletons() phase          of an ApplicationContext for a          non-lazy-init bean.              Example: the        PropertyOverrideConfigurer            \n\r\n\rThe PropertyOverrideConfigurer, another bean        factory post-processor, resembles the        PropertyPlaceholderConfigurer, but unlike        the latter, the original definitions can have default values or no        values at all for bean properties. If an overriding        Properties file does not have an entry for a        certain bean property, the default context definition is used.      \n\r\n\rNote that the bean definition is not aware of        being overridden, so it is not immediately obvious from the XML        definition file that the override configurer is being used. In case of        multiple PropertyOverrideConfigurer instances        that define different values for the same bean property, the last one        wins, due to the overriding mechanism.      \n\r\n\rProperties file configuration lines take this format:      beanName.property=value      \n\r\n\rFor example:      dataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql:mydb      \n\r\n\rThis example file can be used with a container definition that        contains a bean called dataSource, which has        driver and url        properties.      \n\r\n\rCompound property names are also supported, as long as every        component of the path except the final property being overridden is        already non-null (presumably initialized by the constructors). In this        example...      foo.fred.bob.sammy=123      \n\r\n\r... the sammy property of the        bob property of the fred property        of the foo bean is set to the scalar value        123.      Note        \n\r\n\rSpecified override values are always literal          values; they are not translated into bean references. This convention          also applies when the original value in the XML bean definition          specifies a bean reference.            \n\r\n\rWith the context namespace introduced in Spring        2.5, it is possible to configure property overriding with a dedicated        configuration element:      &lt;context:property-override location=\"classpath:override.properties\"/&gt;        5.8.3&nbsp;Customizing instantiation logic with a      FactoryBean        \n\r\n\rImplement the      org.springframework.beans.factory.FactoryBean      interface for objects that are themselves      factories.    \n\r\n\rThe FactoryBean interface is a point of      pluggability into the Spring IoC container\'s instantiation logic. If you      have complex initialization code that is better expressed in Java as      opposed to a (potentially) verbose amount of XML, you can create your own      FactoryBean, write the complex      initialization inside that class, and then plug your custom      FactoryBean into the container.    \n\r\n\rThe FactoryBean interface provides      three methods:    \n\r        \n\r\n\rObject getObject(): returns an instance          of the object this factory creates. The instance can possibly be          shared, depending on whether this factory returns singletons or          prototypes.      \n\r        \n\r\n\rboolean isSingleton(): returns          true if this          FactoryBean returns singletons,          false otherwise.      \n\r        \n\r\n\rClass getObjectType(): returns the object          type returned by the getObject() method or          null if the type is not known in advance.      \n\r    \n\r\n\rThe FactoryBean concept and interface      is used in a number of places within the Spring Framework; more than 50      implementations of the FactoryBean      interface ship with Spring itself.    \n\r\n\rWhen you need to ask a container for an actual      FactoryBean instance itself instead of the bean      it produces, preface the bean\'s id with the ampersand symbol      (&amp;) when calling the      getBean() method of the      ApplicationContext. So for a given      FactoryBean with an id of      myBean, invoking getBean(\"myBean\")      on the container returns the product of the      FactoryBean; whereas, invoking      getBean(\"&amp;myBean\") returns the      FactoryBean instance      itself.    5.9&nbsp;Annotation-based container configuration    \n\r\n\rAre annotations better than XML for configuring Spring?        \n\r\n\rThe introduction of annotation-based configurations raised the      question of whether this approach is \'better\' than XML. The short answer      is it depends. The long answer is that each approach      has its pros and cons, and usually it is up to the developer to decide      which strategy suits her better. Due to the way they are defined,      annotations provide a lot of context in their declaration, leading to      shorter and more concise configuration. However, XML excels at wiring up      components without touching their source code or recompiling them. Some      developers prefer having the wiring close to the source while others argue      that annotated classes are no longer POJOs and, furthermore, that the      configuration becomes decentralized and harder to control.    \n\r\n\rNo matter the choice, Spring can accommodate both styles and even mix      them together. It\'s worth pointing out that through its JavaConfig option, Spring allows annotations      to be used in a non-invasive way, without touching the target components      source code and that in terms of tooling, all configuration styles are      supported by the SpringSource Tool Suite.    \n\r\n\rAn alternative to XML setups is provided by annotation-based    configuration which rely on the bytecode metadata for wiring up components    instead of angle-bracket declarations. Instead of using XML to describe a    bean wiring, the developer moves the configuration into the component class    itself by using annotations on the relevant class, method, or field    declaration. As mentioned in the section called &#8220;Example: The        RequiredAnnotationBeanPostProcessor&#8221;, using a    BeanPostProcessor in conjunction with    annotations is a common means of extending the Spring IoC container. For    example, Spring 2.0 introduced the possibility of enforcing required    properties with the @Required annotation. Spring 2.5 made it possible to follow    that same general approach to drive Spring\'s dependency injection.    Essentially, the @Autowired annotation    provides the same capabilities as described in Section&nbsp;5.4.5, &#8220;Autowiring collaborators&#8221; but with more fine-grained control and    wider applicability. Spring 2.5 also added support for JSR-250 annotations    such as @PostConstruct, and    @PreDestroy. Spring 3.0 added support for    JSR-330 (Dependency Injection for Java) annotations contained in the    javax.inject package such as @Inject and     @Named. Details about those annotations can be found in the relevant section. Note\n\r\n\rAnnotation injection is performed    before XML injection, thus the latter configuration    will override the former for properties wired through both approaches.    \n\r\n\r As always, you can register them as individual bean definitions, but    they can also be implicitly registered by including the following tag in an    XML-based Spring configuration (notice the inclusion of the    context namespace):  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:context=\"http://www.springframework.org/schema/context\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd\"&gt;   &lt;context:annotation-config/&gt;&lt;/beans&gt;  \n\r\n\r(The implicitly registered post-processors include AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, as    well as the aforementioned RequiredAnnotationBeanPostProcessor.)  Note    \n\r\n\r&lt;context:annotation-config/&gt; only looks for      annotations on beans in the same application context in which it is      defined. This means that, if you put      &lt;context:annotation-config/&gt; in a      WebApplicationContext for a      DispatcherServlet, it only checks for      @Autowired beans in your controllers, and      not your services. See Section&nbsp;17.2, &#8220;The DispatcherServlet&#8221; for more      information.    5.9.1&nbsp;@Required        \n\r\n\rThe @Required annotation applies to      bean property setter methods, as in the following example:    public class SimpleMovieLister {  private MovieFinder movieFinder;  @Required  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}    \n\r\n\rThis annotation simply indicates that the affected bean property must      be populated at configuration time, through an explicit property value in      a bean definition or through autowiring. The container throws an exception      if the affected bean property has not been populated; this allows for      eager and explicit failure, avoiding      NullPointerExceptions or the like later on. It is      still recommended that you put assertions into the bean class itself, for      example, into an init method. Doing so enforces those required references      and values even when you use the class outside of a container.    5.9.2&nbsp;@Autowired        \n\r\n\rAs expected, you can apply the      @Autowired annotation to \"traditional\"      setter methods:    public class SimpleMovieLister {  private MovieFinder movieFinder;  @Autowired  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}    Note      \n\r\n\rJSR 330\'s @Inject annotation can be used in place of Spring\'s        @Autowired annotation in the examples below. See here for more details        \n\r\n\rYou can also apply the annotation to methods with arbitrary names      and/or multiple arguments:    public class MovieRecommender {  private MovieCatalog movieCatalog;  private CustomerPreferenceDao customerPreferenceDao;  @Autowired  public void prepare(MovieCatalog movieCatalog,                      CustomerPreferenceDao customerPreferenceDao) {      this.movieCatalog = movieCatalog;      this.customerPreferenceDao = customerPreferenceDao;  }  // ...}    \n\r\n\rYou can apply @Autowired to      constructors and fields:    public class MovieRecommender {  @Autowired  private MovieCatalog movieCatalog;  private CustomerPreferenceDao customerPreferenceDao;  @Autowired  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {      this.customerPreferenceDao = customerPreferenceDao;  }  // ...}    \n\r\n\rIt is also possible to provide all beans of a      particular type from the ApplicationContext      by adding the annotation to a field or method that expects an array of      that type:    public class MovieRecommender {  @Autowired  private MovieCatalog[] movieCatalogs;  // ...}    \n\r\n\rThe same applies for typed collections:    public class MovieRecommender {  private Set&lt;MovieCatalog&gt; movieCatalogs;  @Autowired  public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {      this.movieCatalogs = movieCatalogs;  }  // ...}    \n\r\n\rEven typed Maps can be autowired as long as the expected key type is      String. The Map values will contain all beans of      the expected type, and the keys will contain the corresponding bean      names:    public class MovieRecommender {  private Map&lt;String, MovieCatalog&gt; movieCatalogs;  @Autowired  public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {      this.movieCatalogs = movieCatalogs;  }  // ...}    \n\r\n\rBy default, the autowiring fails whenever zero      candidate beans are available; the default behavior is to treat annotated      methods, constructors, and fields as indicating      required dependencies. This behavior can be changed      as demonstrated below.    public class SimpleMovieLister {  private MovieFinder movieFinder;  @Autowired(required=false)  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}    Note      \n\r\n\rOnly one annotated constructor per-class can be        marked as required, but multiple non-required        constructors can be annotated. In that case, each is considered among        the candidates and Spring uses the greediest        constructor whose dependencies can be satisfied, that is the constructor        that has the largest number of arguments.      \n\r\n\r@Autowired\'s        required attribute is recommended over the        @Required annotation. The        required attribute indicates that the property is        not required for autowiring purposes, the property is ignored if it        cannot be autowired. @Required, on the        other hand, is stronger in that it enforces the property that was set by        any means supported by the container. If no value is injected, a        corresponding exception is raised.        \n\r\n\rYou can also use @Autowired for      interfaces that are well-known resolvable dependencies:      BeanFactory,      ApplicationContext,      Environment,      ResourceLoader,      ApplicationEventPublisher, and      MessageSource. These interfaces and their      extended interfaces, such as      ConfigurableApplicationContext or      ResourcePatternResolver, are automatically      resolved, with no special setup necessary.    public class MovieRecommender {  @Autowired  private ApplicationContext context;  public MovieRecommender() {  }  // ...}    Note      \n\r\n\r        @Autowired,        @Inject,        @Resource, and        @Value annotations are handled by a        Spring BeanPostProcessor implementations        which in turn means that you cannot        apply these annotations within your own        BeanPostProcessor or        BeanFactoryPostProcessor types (if any). These        types must be \'wired up\' explicitly via XML or using a Spring        @Bean method.        5.9.3&nbsp;Fine-tuning annotation-based autowiring with qualifiers        \n\r\n\rBecause autowiring by type may lead to multiple candidates, it is      often necessary to have more control over the selection process. One way      to accomplish this is with Spring\'s      @Qualifier annotation. You can associate      qualifier values with specific arguments, narrowing the set of type      matches so that a specific bean is chosen for each argument. In the      simplest case, this can be a plain descriptive value:    public class MovieRecommender {  @Autowired  @Qualifier(\"main\")  private MovieCatalog movieCatalog;  // ...}    \n\r\n\rThe @Qualifier annotation can also be      specified on individual constructor arguments or method parameters:    public class MovieRecommender {  private MovieCatalog movieCatalog;  private CustomerPreferenceDao customerPreferenceDao;  @Autowired  public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog,                      CustomerPreferenceDao customerPreferenceDao) {      this.movieCatalog = movieCatalog;      this.customerPreferenceDao = customerPreferenceDao;  }  // ...}    \n\r\n\rThe corresponding bean definitions appear as follows. The bean with      qualifier value \"main\" is wired with the constructor argument that is      qualified with the same value.    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:context=\"http://www.springframework.org/schema/context\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context.xsd\"&gt;  &lt;context:annotation-config/&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier value=\"main\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier value=\"action\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/&gt;&lt;/beans&gt;    \n\r\n\rFor a fallback match, the bean name is considered a default qualifier      value. Thus you can define the bean with an id \"main\" instead of the      nested qualifier element, leading to the same matching result. However,      although you can use this convention to refer to specific beans by name,      @Autowired is fundamentally about      type-driven injection with optional semantic qualifiers. This means that      qualifier values, even with the bean name fallback, always have narrowing      semantics within the set of type matches; they do not semantically express      a reference to a unique bean id. Good qualifier values are \"main\" or      \"EMEA\" or \"persistent\", expressing characteristics of a specific component      that are independent from the bean id, which may be auto-generated in case      of an anonymous bean definition like the one in the preceding      example.    \n\r\n\rQualifiers also apply to typed collections, as discussed above, for      example, to Set&lt;MovieCatalog&gt;. In this case, all      matching beans according to the declared qualifiers are injected as a      collection. This implies that qualifiers do not have to be unique; they      rather simply constitute filtering criteria. For example, you can define      multiple MovieCatalog beans with the same qualifier      value \"action\"; all of which would be injected into a      Set&lt;MovieCatalog&gt; annotated with      @Qualifier(\"action\").    Tip      \n\r\n\rIf you intend to express annotation-driven injection by name, do not        primarily use @Autowired, even if is        technically capable of referring to a bean name through        @Qualifier values. Instead, use the        JSR-250 @Resource annotation, which is        semantically defined to identify a specific target component by its        unique name, with the declared type being irrelevant for the matching        process.      \n\r\n\rAs a specific consequence of this semantic difference, beans that        are themselves defined as a collection or map type cannot be injected        through @Autowired, because type matching        is not properly applicable to them. Use        @Resource for such beans, referring to        the specific collection or map bean by unique name.      \n\r\n\r@Autowired applies to fields,        constructors, and multi-argument methods, allowing for narrowing through        qualifier annotations at the parameter level. By contrast,        @Resource is supported only for fields        and bean property setter methods with a single argument. As a        consequence, stick with qualifiers if your injection target is a        constructor or a multi-argument method.        \n\r\n\rYou can create your own custom qualifier annotations. Simply define an      annotation and provide the @Qualifier      annotation within your definition:    @Target({ElementType.FIELD, ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Genre {  String value();}    \n\r\n\rThen you can provide the custom qualifier on autowired fields and      parameters:    public class MovieRecommender {  @Autowired  @Genre(\"Action\")  private MovieCatalog actionCatalog;  private MovieCatalog comedyCatalog;  @Autowired  public void setComedyCatalog(@Genre(\"Comedy\") MovieCatalog comedyCatalog) {      this.comedyCatalog = comedyCatalog;  }  // ...}    \n\r\n\rNext, provide the information for the candidate bean definitions. You      can add &lt;qualifier/&gt; tags as sub-elements of the      &lt;bean/&gt; tag and then specify the      type and value to match your custom      qualifier annotations. The type is matched against the fully-qualified      class name of the annotation. Or, as a convenience if no risk of      conflicting names exists, you can use the short class name. Both      approaches are demonstrated in the following example.    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:context=\"http://www.springframework.org/schema/context\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context.xsd\"&gt;  &lt;context:annotation-config/&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier type=\"Genre\" value=\"Action\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier type=\"example.Genre\" value=\"Comedy\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/&gt;&lt;/beans&gt;    \n\r\n\rIn Section&nbsp;5.10, &#8220;Classpath scanning and managed components&#8221;, you will see an      annotation-based alternative to providing the qualifier metadata in XML.      Specifically, see Section&nbsp;5.10.7, &#8220;Providing qualifier metadata with annotations&#8221;.    \n\r\n\rIn some cases, it may be sufficient to use an annotation without a      value. This may be useful when the annotation serves a more generic      purpose and can be applied across several different types of dependencies.      For example, you may provide an offline catalog that      would be searched when no Internet connection is available. First define      the simple annotation:    @Target({ElementType.FIELD, ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Offline {}    \n\r\n\rThen add the annotation to the field or property to be      autowired:    public class MovieRecommender {  @Autowired  @Offline  private MovieCatalog offlineCatalog;  // ...}    \n\r\n\rNow the bean definition only needs a qualifier      type:    &lt;bean class=\"example.SimpleMovieCatalog\"&gt;  &lt;qualifier type=\"Offline\"/&gt;  &lt;!-- inject any dependencies required by this bean --&gt;&lt;/bean&gt;    \n\r\n\rYou can also define custom qualifier annotations that accept named      attributes in addition to or instead of the simple      value attribute. If multiple attribute values are then      specified on a field or parameter to be autowired, a bean definition must      match all such attribute values to be considered an      autowire candidate. As an example, consider the following annotation      definition:    @Target({ElementType.FIELD, ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface MovieQualifier {  String genre();  Format format();}    \n\r\n\rIn this case Format is an enum:    public enum Format {  VHS, DVD, BLURAY}    \n\r\n\rThe fields to be autowired are annotated with the custom qualifier and      include values for both attributes: genre and      format.    public class MovieRecommender {  @Autowired  @MovieQualifier(format=Format.VHS, genre=\"Action\")  private MovieCatalog actionVhsCatalog;  @Autowired  @MovieQualifier(format=Format.VHS, genre=\"Comedy\")  private MovieCatalog comedyVhsCatalog;  @Autowired  @MovieQualifier(format=Format.DVD, genre=\"Action\")  private MovieCatalog actionDvdCatalog;  @Autowired  @MovieQualifier(format=Format.BLURAY, genre=\"Comedy\")  private MovieCatalog comedyBluRayCatalog;  // ...}    \n\r\n\rFinally, the bean definitions should contain matching qualifier      values. This example also demonstrates that bean meta      attributes may be used instead of the      &lt;qualifier/&gt; sub-elements. If available, the      &lt;qualifier/&gt; and its attributes take precedence,      but the autowiring mechanism falls back on the values provided within the      &lt;meta/&gt; tags if no such qualifier is present, as      in the last two bean definitions in the following example.    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:context=\"http://www.springframework.org/schema/context\"  xsi:schemaLocation=\"http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context.xsd\"&gt;  &lt;context:annotation-config/&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier type=\"MovieQualifier\"&gt;          &lt;attribute key=\"format\" value=\"VHS\"/&gt;          &lt;attribute key=\"genre\" value=\"Action\"/&gt;      &lt;/qualifier&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;qualifier type=\"MovieQualifier\"&gt;          &lt;attribute key=\"format\" value=\"VHS\"/&gt;          &lt;attribute key=\"genre\" value=\"Comedy\"/&gt;      &lt;/qualifier&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;meta key=\"format\" value=\"DVD\"/&gt;      &lt;meta key=\"genre\" value=\"Action\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;  &lt;bean class=\"example.SimpleMovieCatalog\"&gt;      &lt;meta key=\"format\" value=\"BLURAY\"/&gt;      &lt;meta key=\"genre\" value=\"Comedy\"/&gt;      &lt;!-- inject any dependencies required by this bean --&gt;  &lt;/bean&gt;&lt;/beans&gt;    5.9.4&nbsp;CustomAutowireConfigurer        \n\r\n\rThe CustomAutowireConfigurer is a      BeanFactoryPostProcessor that enables you      to register your own custom qualifier annotation types even if they are      not annotated with Spring\'s @Qualifier      annotation.    &lt;bean id=\"customAutowireConfigurer\"     class=\"org.springframework.beans.factory.annotation.CustomAutowireConfigurer\"&gt;  &lt;property name=\"customQualifierTypes\"&gt;      &lt;set&gt;          &lt;value&gt;example.CustomQualifier&lt;/value&gt;      &lt;/set&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rThe particular implementation of      AutowireCandidateResolver that is activated      for the application context depends on the Java version. In versions      earlier than Java 5, the qualifier annotations are not supported, and      therefore autowire candidates are solely determined by the      autowire-candidate value of each bean definition as      well as by any default-autowire-candidates pattern(s)      available on the &lt;beans/&gt; element. In Java 5 or      later, the presence of @Qualifier      annotations and any custom annotations registered with the      CustomAutowireConfigurer will also play a      role.    \n\r\n\rRegardless of the Java version, when multiple beans qualify as      autowire candidates, the determination of a \"primary\" candidate is the      same: if exactly one bean definition among the candidates has a      primary attribute set to true, it      will be selected.    5.9.5&nbsp;@Resource        \n\r\n\rSpring also supports injection using the JSR-250      @Resource annotation on fields or bean      property setter methods. This is a common pattern in Java EE 5 and 6, for      example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports      this pattern for Spring-managed objects as well.    \n\r\n\r@Resource takes a name attribute, and      by default Spring interprets that value as the bean name to be injected.      In other words, it follows by-name semantics, as      demonstrated in this example:    public class SimpleMovieLister {  private MovieFinder movieFinder;  @Resource(name=\"myMovieFinder\")  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }}    \n\r\n\rIf no name is specified explicitly, the default name is derived from      the field name or setter method. In case of a field, it takes the field      name; in case of a setter method, it takes the bean property name. So the      following example is going to have the bean with name \"movieFinder\"      injected into its setter method:    public class SimpleMovieLister {  private MovieFinder movieFinder;  @Resource  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }}    Note      \n\r\n\rThe name provided with the annotation is resolved as a bean name by        the ApplicationContext of which the        CommonAnnotationBeanPostProcessor is aware. The        names can be resolved through JNDI if you configure Spring\'s SimpleJndiBeanFactory explicitly.        However, it is recommended that you rely on the default behavior and        simply use Spring\'s JNDI lookup capabilities to preserve the level of        indirection.        \n\r\n\rIn the exclusive case of @Resource      usage with no explicit name specified, and similar to      @Autowired,      @Resource finds a primary type match      instead of a specific named bean and resolves well-known resolvable      dependencies: the      BeanFactory,      ApplicationContext, ResourceLoader,      ApplicationEventPublisher, and      MessageSource interfaces.    \n\r\n\rThus in the following example, the      customerPreferenceDao field first looks for a bean      named customerPreferenceDao, then falls back to a primary type match for      the type CustomerPreferenceDao. The \"context\" field      is injected based on the known resolvable dependency type      ApplicationContext.    public class MovieRecommender {  @Resource  private CustomerPreferenceDao customerPreferenceDao;  @Resource  private ApplicationContext context;  public MovieRecommender() {  }  // ...}    5.9.6&nbsp;@PostConstruct and      @PreDestroy        \n\r\n\rThe CommonAnnotationBeanPostProcessor not only      recognizes the @Resource annotation but      also the JSR-250 lifecycle annotations. Introduced in      Spring 2.5, the support for these annotations offers yet another      alternative to those described in initialization      callbacks and destruction      callbacks. Provided that the      CommonAnnotationBeanPostProcessor is registered      within the Spring ApplicationContext, a      method carrying one of these annotations is invoked at the same point in      the lifecycle as the corresponding Spring lifecycle interface method or      explicitly declared callback method. In the example below, the cache will      be pre-populated upon initialization and cleared upon destruction.    public class CachingMovieLister {  @PostConstruct  public void populateMovieCache() {      // populates the movie cache upon initialization...  }  @PreDestroy  public void clearMovieCache() {      // clears the movie cache upon destruction...  }}    Note      \n\r\n\rFor details about the effects of combining various lifecycle        mechanisms, see the section called &#8220;Combining lifecycle mechanisms&#8221;.        5.10&nbsp;Classpath scanning and managed components    \n\r\n\rMost examples in this chapter use XML to specify the configuration    metadata that produces each BeanDefinition    within the Spring container. The previous section    (Section&nbsp;5.9, &#8220;Annotation-based container configuration&#8221;) demonstrates how to provide a    lot of the configuration metadata through source-level annotations. Even    in those examples, however, the \"base\" bean definitions are explicitly    defined in the XML file, while the annotations only drive the dependency    injection. This section describes an option for implicitly detecting the    candidate components by scanning the classpath.    Candidate components are classes that match against a filter criteria and    have a corresponding bean definition registered with the container. This    removes the need to use XML to perform bean registration, instead you can    use annotations (for example @Component), AspectJ type expressions, or your    own custom filter criteria to select which classes will have bean    definitions registered with the container.  Note    \n\r\n\rStarting with Spring 3.0, many features provided by the Spring JavaConfig      project are part of the core Spring Framework. This allows you to      define beans using Java rather than using the traditional XML files. Take      a look at the @Configuration,      @Bean,      @Import, and      @DependsOn annotations for examples of how      to use these new features.    5.10.1&nbsp;@Component and further stereotype      annotations        \n\r\n\rIn Spring 2.0 and later, the      @Repository annotation is a marker for any      class that fulfills the role or stereotype (also      known as Data Access Object or DAO) of a repository. Among the uses of      this marker is the automatic translation of exceptions as described in      Section&nbsp;15.2.2, &#8220;Exception translation&#8221;.    \n\r\n\rSpring 2.5 introduces further stereotype annotations:      @Component,      @Service, and      @Controller.      @Component is a generic stereotype for any      Spring-managed component. @Repository,      @Service, and      @Controller are specializations of      @Component for more specific use cases, for      example, in the persistence, service, and presentation layers,      respectively. Therefore, you can annotate your component classes with      @Component, but by annotating them with      @Repository,      @Service, or      @Controller instead, your classes are more      properly suited for processing by tools or associating with aspects. For      example, these stereotype annotations make ideal targets for pointcuts. It      is also possible that @Repository,      @Service, and      @Controller may carry additional semantics      in future releases of the Spring Framework. Thus, if you are choosing      between using @Component or      @Service for your service layer,      @Service is clearly the better choice.      Similarly, as stated above, @Repository is      already supported as a marker for automatic exception translation in your      persistence layer.    5.10.2&nbsp;Automatically detecting classes and registering bean      definitions        \n\r\n\rSpring can automatically detect stereotyped classes and register      corresponding BeanDefinitions with the      ApplicationContext. For example, the      following two classes are eligible for such autodetection:    @Servicepublic class SimpleMovieLister {  private MovieFinder movieFinder;  @Autowired  public SimpleMovieLister(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }}    @Repositorypublic class JpaMovieFinder implements MovieFinder {  // implementation elided for clarity}    \n\r\n\rTo autodetect these classes and register the corresponding beans, you      need to include the following element in XML, where the base-package      element is a common parent package for the two classes. (Alternatively,      you can specify a comma-separated list that includes the parent package of      each class.)    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:context=\"http://www.springframework.org/schema/context\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd\"&gt;   &lt;context:component-scan base-package=\"org.example\"/&gt;&lt;/beans&gt;    Tip      \n\r\n\rThe use of &lt;context:component-scan&gt; implicitly      enables the functionality of &lt;context:annotation-config&gt;.      There is usually no need to include the &lt;context:annotation-config&gt;      element when using &lt;context:component-scan&gt;.              Note      \n\r\n\rThe scanning of classpath packages requires the presence of        corresponding directory entries in the classpath. When you build JARs        with Ant, make sure that you do not activate the        files-only switch of the JAR task.        \n\r\n\rFurthermore, the      AutowiredAnnotationBeanPostProcessor and      CommonAnnotationBeanPostProcessor are both      included implicitly when you use the component-scan element. That means      that the two components are autodetected and wired      together - all without any bean configuration metadata provided in      XML.    Note      \n\r\n\rYou can disable the registration of        AutowiredAnnotationBeanPostProcessor and        CommonAnnotationBeanPostProcessor by        including the annotation-config attribute with a        value of false.            5.10.3&nbsp;Using filters to customize scanning        \n\r\n\rBy default, classes annotated with      @Component,      @Repository,      @Service,      @Controller, or a custom annotation that      itself is annotated with @Component are the      only detected candidate components. However, you can modify and extend      this behavior simply by applying custom filters. Add them as      include-filter or exclude-filter      sub-elements of the component-scan element. Each filter      element requires the type and      expression attributes. The following table describes      the filtering options.    \n\r\n\rTable&nbsp;5.5.&nbsp;Filter Types            Filter TypeExample ExpressionDescriptionannotationorg.example.SomeAnnotationAn annotation to be present at the type level in target              components.assignableorg.example.SomeClassA class (or interface) that the target components are              assignable to (extend/implement).aspectjorg.example..*Service+An AspectJ type expression to be matched by the target              components.regexorg\\.example\\.Default.*A regex expression to be matched by the target components              class names.customorg.example.MyTypeFilterA custom implementation of the              org.springframework.core.type              .TypeFilter interface.    \n\r    \n\r\n\rThe following example shows the XML configuration ignoring all      @Repository annotations and using \"stub\"      repositories instead.    &lt;beans&gt;   &lt;context:component-scan base-package=\"org.example\"&gt;      &lt;context:include-filter type=\"regex\" expression=\".*Stub.*Repository\"/&gt;      &lt;context:exclude-filter type=\"annotation\"                              expression=\"org.springframework.stereotype.Repository\"/&gt;   &lt;/context:component-scan&gt;&lt;/beans&gt;    Note      \n\r\n\rYou can also disable the default filters by providing        use-default-filters=\"false\" as an attribute of the        &lt;component-scan/&gt; element. This will in effect disable automatic        detection of classes annotated with        @Component,        @Repository,        @Service, or        @Controller.        5.10.4&nbsp;Defining bean metadata within components        \n\r\n\rSpring components can also contribute bean definition metadata to the      container. You do this with the same @Bean annotation      used to define bean metadata within @Configuration      annotated classes. Here is a simple example:    @Componentpublic class FactoryMethodComponent {  @Bean @Qualifier(\"public\")  public TestBean publicInstance() {      return new TestBean(\"publicInstance\");  }  public void doWork() {      // Component method implementation omitted  }}    \n\r\n\rThis class is a Spring component that has application-specific code      contained in its doWork() method. However, it      also contributes a bean definition that has a factory method referring to      the method publicInstance(). The      @Bean annotation identifies the factory method and      other bean definition properties, such as a qualifier value through the      @Qualifier annotation. Other method level      annotations that can be specified are @Scope,      @Lazy, and custom qualifier annotations. Autowired      fields and methods are supported as previously discussed, with additional      support for autowiring of @Bean methods:    @Componentpublic class FactoryMethodComponent {  private static int i;  @Bean @Qualifier(\"public\")  public TestBean publicInstance() {      return new TestBean(\"publicInstance\");  }  // use of a custom qualifier and autowiring of method parameters  @Bean  protected TestBean protectedInstance(@Qualifier(\"public\") TestBean spouse,                                       @Value(\"#{privateInstance.age}\") String country) {      TestBean tb = new TestBean(\"protectedInstance\", 1);      tb.setSpouse(tb);      tb.setCountry(country);      return tb;  }  @Bean @Scope(BeanDefinition.SCOPE_SINGLETON)  private TestBean privateInstance() {      return new TestBean(\"privateInstance\", i++);  }  @Bean @Scope(value = WebApplicationContext.SCOPE_SESSION,               proxyMode = ScopedProxyMode.TARGET_CLASS)  public TestBean requestScopedInstance() {      return new TestBean(\"requestScopedInstance\", 3);  }}    \n\r\n\rThe example autowires the String method      parameter country to the value of the      Age property on another bean named      privateInstance. A Spring Expression Language element      defines the value of the property through the notation #{      &lt;expression&gt; }. For @Value annotations,      an expression resolver is preconfigured to look for bean names when      resolving expression text.    \n\r\n\rThe @Bean methods in a Spring component are      processed differently than their counterparts inside a Spring      @Configuration class. The difference is that      @Component classes are not enhanced with CGLIB to      intercept the invocation of methods and fields. CGLIB proxying is the      means by which invoking methods or fields within      @Configuration classes @Bean methods      create bean metadata references to collaborating objects. Methods are      not invoked with normal Java semantics. In contrast,      calling a method or field within a @Component classes      @Bean method has standard Java      semantics.    5.10.5&nbsp;Naming autodetected components        \n\r\n\rWhen a component is autodetected as part of the scanning process, its      bean name is generated by the      BeanNameGenerator strategy known to that      scanner. By default, any Spring stereotype annotation      (@Component,      @Repository,      @Service, and      @Controller) that contains a      name value will thereby provide that name to the      corresponding bean definition.    \n\r\n\rIf such an annotation contains no name value or for      any other detected component (such as those discovered by custom filters),      the default bean name generator returns the uncapitalized non-qualified      class name. For example, if the following two components were detected,      the names would be myMovieLister and movieFinderImpl:    @Service(\"myMovieLister\")public class SimpleMovieLister {  // ...}    @Repositorypublic class MovieFinderImpl implements MovieFinder {  // ...}    Note      \n\r\n\rIf you do not want to rely on the default bean-naming strategy, you        can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and        be sure to include a default no-arg constructor. Then, provide the        fully-qualified class name when configuring the scanner:        &lt;beans&gt;   &lt;context:component-scan base-package=\"org.example\"                           name-generator=\"org.example.MyNameGenerator\" /&gt;&lt;/beans&gt;    \n\r\n\rAs a general rule, consider specifying the name with the annotation      whenever other components may be making explicit references to it. On the      other hand, the auto-generated names are adequate whenever the container      is responsible for wiring.    5.10.6&nbsp;Providing a scope for autodetected components        \n\r\n\rAs with Spring-managed components in general, the default and most      common scope for autodetected components is singleton. However, sometimes      you need other scopes, which Spring 2.5 provides with a new      @Scope annotation. Simply provide the name      of the scope within the annotation:    @Scope(\"prototype\")@Repositorypublic class MovieFinderImpl implements MovieFinder {  // ...}    Note      \n\r\n\rTo provide a custom strategy for scope resolution rather than        relying on the annotation-based approach, implement the ScopeMetadataResolver interface,        and be sure to include a default no-arg constructor. Then, provide the        fully-qualified class name when configuring the scanner:        &lt;beans&gt;   &lt;context:component-scan base-package=\"org.example\"                           scope-resolver=\"org.example.MyScopeResolver\" /&gt;&lt;/beans&gt;    \n\r\n\rWhen using certain non-singleton scopes, it may be necessary to      generate proxies for the scoped objects. The reasoning is described in      the section called &#8220;Scoped beans as dependencies&#8221;. For this purpose,      a scoped-proxy attribute is available on the      component-scan element. The three possible values are: no, interfaces, and      targetClass. For example, the following configuration will result in      standard JDK dynamic proxies:    &lt;beans&gt;   &lt;context:component-scan base-package=\"org.example\"                           scoped-proxy=\"interfaces\" /&gt;&lt;/beans&gt;    5.10.7&nbsp;Providing qualifier metadata with annotations        \n\r\n\rThe @Qualifier annotation is discussed      in Section&nbsp;5.9.3, &#8220;Fine-tuning annotation-based autowiring with qualifiers&#8221;. The examples      in that section demonstrate the use of the      @Qualifier annotation and custom qualifier      annotations to provide fine-grained control when you resolve autowire      candidates. Because those examples were based on XML bean definitions, the      qualifier metadata was provided on the candidate bean definitions using      the qualifier or meta sub-elements      of the bean element in the XML. When relying upon      classpath scanning for autodetection of components, you provide the      qualifier metadata with type-level annotations on the candidate class. The      following three examples demonstrate this technique:    @Component@Qualifier(\"Action\")public class ActionMovieCatalog implements MovieCatalog {  // ...}    @Component@Genre(\"Action\")public class ActionMovieCatalog implements MovieCatalog {  // ...}    @Component@Offlinepublic class CachingMovieCatalog implements MovieCatalog {  // ...}    Note      \n\r\n\rAs with most annotation-based alternatives, keep in mind that the        annotation metadata is bound to the class definition itself, while the        use of XML allows for multiple beans of the same        type to provide variations in their qualifier metadata,        because that metadata is provided per-instance rather than        per-class.        5.11&nbsp;Using JSR 330 Standard Annotations    \n\r\n\rStarting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency Injection).  Those annotations are scanned in the same way as the Spring annotations. You just need to have the relevant jars in your classpath.    Note      \n\r\n\r      If you are using Maven, the javax.inject artifact is available      in the standard Maven repository      (http://repo1.maven.org/maven2/javax/inject/javax.inject/1/).      You can add the following dependency to your file pom.xml:          &lt;dependency&gt;    &lt;groupId&gt;javax.inject&lt;/groupId&gt;    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;    &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt;    5.11.1&nbsp;Dependency Injection with @Inject and @Named        \n\r\n\rInstead of @Autowired,      @javax.inject.Inject may be used as follows:    import javax.inject.Inject;public class SimpleMovieLister {  private MovieFinder movieFinder;  @Inject  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}\n\r\n\r        \n\r\n\rAs with @Autowired, it is possible to use @Inject    at the class-level, field-level, method-level and constructor-argument level.    If you would like to use a qualified name for the dependency that should be injected,    you should use the @Named annotation as follows:    import javax.inject.Inject;import javax.inject.Named;public class SimpleMovieLister {  private MovieFinder movieFinder;  @Inject  public void setMovieFinder(@Named(\"main\") MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}\n\r\n\r      5.11.2&nbsp;@Named: a standard equivalent to the @Component annotation        \n\r\n\r    Instead of @Component, @javax.inject.Named may be used as follows:        import javax.inject.Inject;import javax.inject.Named;@Named(\"movieListener\")public class SimpleMovieLister {  private MovieFinder movieFinder;  @Inject  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}\n\r\n\r\n\r\n\rIt is very common to use @Component withoutspecifying a name for the component. @Namedcan be used in a similar fashion:    import javax.inject.Inject;import javax.inject.Named;@Namedpublic class SimpleMovieLister {  private MovieFinder movieFinder;  @Inject  public void setMovieFinder(MovieFinder movieFinder) {      this.movieFinder = movieFinder;  }  // ...}\n\r\n\r\n\r\n\rWhen using @Named, it is possible to usecomponent-scanning in the exact same way as when using Spring annotations:    &lt;beans&gt;    &lt;context:component-scan base-package=\"org.example\"/&gt;&lt;/beans&gt;\n\r\n\r5.11.3&nbsp;Limitations of the standard approach        \n\r\n\rWhen working with standard annotations, it is important to know that    some significant features are not available as shown in the table below:     \n\r\n\rTable&nbsp;5.6.&nbsp;Spring annotations vs. standard annotations                    Springjavax.inject.*javax.inject restrictions / comments@Autowired@Inject@Inject has no \'required\' attribute@Component@Named&#151;@Scope(\"singleton\")@Singleton                    \n\r\n\r                        The JSR-330 default scope is like Spring\'s prototype.                        However, in order to keep it consistent with Spring\'s general defaults,                        a JSR-330 bean declared in the Spring container is a                        singleton by default. In order to use a                        scope other than singleton, you should use Spring\'s                        @Scope annotation.                                        \n\r\n\r                        javax.inject also provides a                        @Scope annotation.                        Nevertheless, this one is only intended to be used for creating your own annotations.                                    @Qualifier@Named&#151;@Value&#151;no equivalent@Required&#151;no equivalent@Lazy&#151;no equivalent         \n\r\n\r\n\r              5.12&nbsp;Java-based container configuration    5.12.1&nbsp;Basic concepts: @Bean and @Configuration        \n\r\n\rFull @Configuration vs \'lite\' @Beans mode?            \n\r\n\rWhen @Bean methods are declared within        classes that are not annotated with        @Configuration they are referred to as being        processed in a \'lite\' mode. For example, bean methods declared in a        @Component or even in a plain old        class will be considered \'lite\'.      \n\r\n\rUnlike full @Configuration, lite        @Bean methods cannot easily declare inter-bean        dependencies. Usually one @Bean method should not        invoke another  @Bean method when operating in        \'lite\' mode.      \n\r\n\rOnly using @Bean methods within        @Configuration classes is a recommended approach        of ensuring that \'full\' mode is always used. This will prevent the same        @Bean method from accidentally being invoked        multiple times and helps to reduce subtle bugs that can be hard to track down        when operating in \'lite\' mode.        \n\r\n\rThe central artifacts in Spring\'s new Java-configuration support are      @Configuration-annotated classes and      @Bean-annotated methods.    \n\r\n\rThe @Bean annotation is used to indicate that a      method instantiates, configures and initializes a new object to be managed by      the Spring IoC container. For those familiar with Spring\'s      &lt;beans/&gt; XML configuration the @Bean      annotation plays the same role as the &lt;bean/&gt;      element. You can use @Bean annotated methods with      any Spring @Component, however, they are most      often used with @Configuration beans.    \n\r\n\rAnnotating a class with @Configuration      indicates that its primary purpose is as a source of bean definitions. Furthermore,      @Configuration classes allow inter-bean      dependencies to be defined by simply calling other @Bean      methods in the same class.  The simplest possible      @Configuration class would read as follows:      @Configurationpublic class AppConfig {  @Bean  public MyService myService() {      return new MyServiceImpl();  }}    \n\r\n\rThe AppConfig class above would be equivalent to the      following Spring &lt;beans/&gt; XML:      &lt;beans&gt;  &lt;bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/&gt;&lt;/beans&gt;\n\r\n\r      The @Bean and @Configuration      annotations will be discussed in depth in the sections below. First, however, we\'ll      cover the various ways of creating a spring container using Java-based      configuration.    5.12.2&nbsp;Instantiating the Spring container using      AnnotationConfigApplicationContext        \n\r\n\rThe sections below document Spring\'s      AnnotationConfigApplicationContext, new in Spring 3.0.      This versatile ApplicationContext implementation is      capable of accepting not only @Configuration classes as      input, but also plain @Component classes and classes      annotated with JSR-330 metadata.    \n\r\n\rWhen @Configuration classes are provided as input,      the @Configuration class itself is registered as a bean      definition, and all declared @Bean methods within the      class are also registered as bean definitions.    \n\r\n\rWhen @Component and JSR-330 classes are provided,      they are registered as bean definitions, and it is assumed that DI      metadata such as @Autowired or      @Inject are used within those classes where      necessary.    Simple construction            \n\r\n\rIn much the same way that Spring XML files are used as input when        instantiating a ClassPathXmlApplicationContext,        @Configuration classes may be used as input when        instantiating an AnnotationConfigApplicationContext.        This allows for completely XML-free usage of the Spring container:        public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);  MyService myService = ctx.getBean(MyService.class);  myService.doStuff();}\n\r\n\r        As mentioned above,        AnnotationConfigApplicationContext is not limited to        working only with @Configuration classes. Any        @Component or JSR-330 annotated class may be supplied        as input to the constructor. For example:        public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);  MyService myService = ctx.getBean(MyService.class);  myService.doStuff();}\n\r\n\r        The above assumes that MyServiceImpl,        Dependency1 and Dependency2 use        Spring dependency injection annotations such as        @Autowired.        Building the container programmatically using        register(Class&lt;?&gt;...)            \n\r\n\rAn AnnotationConfigApplicationContext may be        instantiated using a no-arg constructor and then configured using the        register() method. This approach is particularly        useful when programmatically building an        AnnotationConfigApplicationContext.        public static void main(String[] args) {  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();  ctx.register(AppConfig.class, OtherConfig.class);  ctx.register(AdditionalConfig.class);  ctx.refresh();  MyService myService = ctx.getBean(MyService.class);  myService.doStuff();}        Enabling component scanning with        scan(String...)            \n\r\n\rExperienced Spring users will be familiar with the following        commonly-used XML declaration from Spring\'s context:        namespace        &lt;beans&gt;  &lt;context:component-scan base-package=\"com.acme\"/&gt;&lt;/beans&gt;\n\r\n\r        In the example above, the com.acme package will be        scanned, looking for any @Component-annotated        classes, and those classes will be registered as Spring bean definitions        within the container.        AnnotationConfigApplicationContext exposes the        scan(String...) method to allow for the same        component-scanning        functionality:public static void main(String[] args) {  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();  ctx.scan(\"com.acme\");  ctx.refresh();  MyService myService = ctx.getBean(MyService.class);}      Note        \n\r\n\rRemember that @Configuration classes are          meta-annotated with @Component, so they are          candidates for component-scanning! In the example above, assuming that          AppConfig is declared within the          com.acme package (or any package underneath), it          will be picked up during the call to scan(), and          upon refresh() all its @Bean          methods will be processed and registered as bean definitions within          the container.              Support for web applications with        AnnotationConfigWebApplicationContext            \n\r\n\rA WebApplicationContext variant of        AnnotationConfigApplicationContext is available with        AnnotationConfigWebApplicationContext. This        implementation may be used when configuring the Spring        ContextLoaderListener servlet listener, Spring MVC        DispatcherServlet, etc. What follows is a        web.xml snippet that configures a typical Spring MVC        web application. Note the use of the contextClass        context-param and init-param:        &lt;web-app&gt;  &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext       instead of the default XmlWebApplicationContext --&gt;  &lt;context-param&gt;      &lt;param-name&gt;contextClass&lt;/param-name&gt;      &lt;param-value&gt;          org.springframework.web.context.support.AnnotationConfigWebApplicationContext      &lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!-- Configuration locations must consist of one or more comma- or space-delimited       fully-qualified @Configuration classes. Fully-qualified packages may also be       specified for component-scanning --&gt;  &lt;context-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;  &lt;listener&gt;      &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext           instead of the default XmlWebApplicationContext --&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextClass&lt;/param-name&gt;          &lt;param-value&gt;              org.springframework.web.context.support.AnnotationConfigWebApplicationContext          &lt;/param-value&gt;      &lt;/init-param&gt;      &lt;!-- Again, config locations must consist of one or more comma- or space-delimited           and fully-qualified @Configuration classes --&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;      &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;        5.12.3&nbsp;Using the @Bean annotation        \n\r\n\r@Bean is a method-level annotation and      a direct analog of the XML &lt;bean/&gt; element. The      annotation supports some of the attributes offered by      &lt;bean/&gt;, such as: init-method, destroy-method, autowiring and      name.    \n\r\n\rYou can use the @Bean annotation in a      @Configuration-annotated or in a      @Component-annotated class.    Declaring a bean            \n\r\n\rTo declare a bean, simply annotate a method with the        @Bean annotation. You use this method to        register a bean definition within an ApplicationContext of        the type specified as the method\'s return value. By default, the bean        name will be the same as the method name. The following is a simple        example of a @Bean method declaration:        @Configurationpublic class AppConfig {  @Bean  public TransferService transferService() {      return new TransferServiceImpl();  }}      \n\r\n\rThe preceding configuration is exactly equivalent to the following        Spring XML:        &lt;beans&gt;  &lt;bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/&gt;&lt;/beans&gt;                      \n\r\n\rBoth declarations make a bean named transferService        available in the ApplicationContext, bound to an object        instance of type TransferServiceImpl:        transferService -&gt; com.acme.TransferServiceImpl                      Receiving lifecycle callbacks            \n\r\n\rAny classes defined with the        @Bean annotation support        the regular lifecycle callbacks and can use the        @PostConstruct and @PreDestroy        annotations from JSR-250, see JSR-250        annotations for further details.      \n\r\n\rThe regular Spring lifecycle callbacks are fully supported as well. If a bean        implements InitializingBean, DisposableBean,        or Lifecycle, their respective methods are called by the        container.      \n\r\n\rThe standard set of *Aware interfaces such as        BeanFactoryAware,        BeanNameAware,        MessageSourceAware, ApplicationContextAware, and        so on are also fully supported.      \n\r\n\rThe @Bean annotation supports        specifying arbitrary initialization and destruction callback methods,        much like Spring XML\'s init-method and        destroy-method attributes on the bean element:        public class Foo {  public void init() {      // initialization logic  }}public class Bar {  public void cleanup() {      // destruction logic  }}@Configurationpublic class AppConfig {  @Bean(initMethod = \"init\")  public Foo foo() {      return new Foo();  }  @Bean(destroyMethod = \"cleanup\")  public Bar bar() {      return new Bar();  }}      \n\r\n\rOf course, in the case of Foo above, it would be        equally as valid to call the init() method directly during        construction:        @Configurationpublic class AppConfig {  @Bean  public Foo foo() {      Foo foo = new Foo();      foo.init();      return foo;  }  // ...}                          Tip        \n\r\n\rWhen you work directly in Java, you can do anything you like with          your objects and do not always need to rely on the container          lifecycle!              Specifying bean scope            Using the @Scope          annotation                        \n\r\n\rYou can specify that your beans defined with the          @Bean annotation should have a specific          scope. You can use any of the standard scopes specified in the Bean Scopes section.        \n\r\n\rThe default scope is singleton, but you can          override this with the @Scope          annotation:          @Configurationpublic class MyConfiguration {  @Bean  @Scope(\"prototype\")  public Encryptor encryptor() {      // ...  }}            @Scope and scoped-proxy                \n\r\n\rSpring offers a convenient way of working with scoped dependencies          through scoped          proxies. The easiest way to create such a proxy when using the          XML configuration is the &lt;aop:scoped-proxy/&gt;          element. Configuring your beans in Java with a @Scope annotation          offers equivalent support with the proxyMode attribute. The default is          no proxy (ScopedProxyMode.NO), but you can specify          ScopedProxyMode.TARGET_CLASS or          ScopedProxyMode.INTERFACES.        \n\r\n\rIf you port the scoped proxy example from the XML reference          documentation (see preceding link) to our          @Bean using Java, it would look like          the following:          // an HTTP Session-scoped bean exposed as a proxy@Bean@Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)public UserPreferences userPreferences() { return new UserPreferences();}@Beanpublic Service userService() { UserService service = new SimpleUserService(); // a reference to the proxied userPreferences bean service.setUserPreferences(userPreferences()); return service;}                              Customizing bean naming            \n\r\n\rBy default, configuration classes use a        @Bean method\'s name as the name of the        resulting bean. This functionality can be overridden, however, with the        name attribute.        @Configurationpublic class AppConfig {  @Bean(name = \"myFoo\")  public Foo foo() {      return new Foo();  }}                Bean aliasing            \n\r\n\rAs discussed in Section&nbsp;5.3.1, &#8220;Naming beans&#8221;, it is sometimes        desirable to give a single bean multiple names, otherwise known as        bean aliasing. The name        attribute of the @Bean annotation accepts a String        array for this purpose.        @Configurationpublic class AppConfig {  @Bean(name = { \"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\" })  public DataSource dataSource() {      // instantiate, configure and return DataSource bean...  }}                5.12.4&nbsp;Using the @Configuration annotation        \n\r\n\r@Configuration is a class-level annotation      indicating that an object is a source of bean definitions.      @Configuration classes declare beans via      public @Bean annotated methods. Calls to      @Bean methods on      @Configuration classes can also be used to      define inter-bean dependencies. See Section&nbsp;5.12.1, &#8220;Basic concepts: @Bean and @Configuration&#8221; for      a general introduction.    Injecting inter-bean dependencies            \n\r\n\rWhen @Beans have dependencies on one        another, expressing that dependency is as simple as having one bean        method call another:        @Configurationpublic class AppConfig {  @Bean  public Foo foo() {      return new Foo(bar());  }  @Bean  public Bar bar() {      return new Bar();  }}                      \n\r\n\rIn the example above, the foo bean receives a reference        to  bar via constructor injection.      Note        \n\r\n\rThis method of declaring inter-bean dependencies only works when        the @Bean method is declared within a        @Configuration class. You cannot declare        inter-bean dependencies using plain @Component        classes.              Lookup method injection            \n\r\n\rAs noted earlier, lookup method injection is an advanced feature that you should        use rarely. It is useful in cases where a singleton-scoped bean has a        dependency on a prototype-scoped bean. Using Java for this type of        configuration provides a natural means for implementing this pattern.        public abstract class CommandManager {  public Object process(Object commandState) {      // grab a new instance of the appropriate Command interface      Command command = createCommand();      // set the state on the (hopefully brand new) Command instance      command.setState(commandState);      return command.execute();  }  // okay... but where is the implementation of this method?  protected abstract Command createCommand();}                         \n\r\n\rUsing Java-configuration support , you can create a subclass of        CommandManager where the abstract        createCommand() method is overridden in such a way that        it looks up a new (prototype) command object:        @Bean@Scope(\"prototype\")public AsyncCommand asyncCommand() {  AsyncCommand command = new AsyncCommand();  // inject dependencies here as required  return command;}@Beanpublic CommandManager commandManager() {  // return new anonymous implementation of CommandManager with command() overridden  // to return a new prototype Command object  return new CommandManager() {      protected Command createCommand() {          return asyncCommand();      }  }}                            Further information about how Java-based configuration works      internally        \n\r\n\rThe following example shows a @Bean annotated      method being called twice:    @Configurationpublic class AppConfig {  @Bean  public ClientService clientService1() {    ClientServiceImpl clientService = new ClientServiceImpl();    clientService.setClientDao(clientDao());    return clientService;  }  @Bean  public ClientService clientService2() {    ClientServiceImpl clientService = new ClientServiceImpl();    clientService.setClientDao(clientDao());    return clientService;  }  @Bean  public ClientDao clientDao() {    return new ClientDaoImpl();  }}        \n\r\n\r clientDao() has been called once in      clientService1() and once in      clientService2(). Since this method creates a new      instance of ClientDaoImpl and returns it, you would      normally expect having 2 instances (one for each service). That definitely      would be problematic: in Spring, instantiated beans have a      singleton scope by default. This is where the magic      comes in: All @Configuration classes are subclassed at      startup-time with CGLIB. In the subclass, the child      method checks the container first for any cached (scoped) beans before it      calls the parent method and creates a new instance. Note that as of Spring      3.2, it is no longer necessary to add CGLIB to your classpath because      CGLIB classes have been repackaged under org.springframework and included      directly within the spring-core JAR.    Note      \n\r\n\r The behavior could be different according to the scope of your        bean. We are talking about singletons here.         Note      \n\r\n\r There are a few restrictions due to the fact that CGLIB dynamically        adds features at startup-time: \n\r          \n\r\n\rConfiguration classes should not be final        \n\r          \n\r\n\rThey should have a constructor with no arguments        \n\r\n\r\n\r           5.12.5&nbsp;Composing Java-based configurations        Using the @Import annotation            \n\r\n\rMuch as the &lt;import/&gt; element is used        within Spring XML files to aid in modularizing configurations, the        @Import annotation allows for loading        @Bean definitions from another configuration        class:@Configurationpublic class ConfigA {  public @Bean A a() { return new A(); }}@Configuration@Import(ConfigA.class)public class ConfigB {  public @Bean B b() { return new B(); }}\n\r\n\r        Now, rather than needing to specify both        ConfigA.class and ConfigB.class        when instantiating the context, only ConfigB needs to        be supplied        explicitly:public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);  // now both beans A and B will be available...  A a = ctx.getBean(A.class);  B b = ctx.getBean(B.class);}\n\r\n\r        This approach simplifies container instantiation, as only one class        needs to be dealt with, rather than requiring the developer to remember        a potentially large number of @Configuration classes        during construction.      Injecting dependencies on imported @Bean          definitions                \n\r\n\rThe example above works, but is simplistic. In most practical          scenarios, beans will have dependencies on one another across          configuration classes. When using XML, this is not an issue, per se,          because there is no compiler involved, and one can simply declare          ref=\"someBean\" and trust that Spring will work it          out during container initialization. Of course, when using          @Configuration classes, the Java compiler places          constraints on the configuration model, in that references to other          beans must be valid Java syntax.        \n\r\n\rFortunately, solving this problem is simple. Remember that          @Configuration classes are ultimately just another          bean in the container - this means that they can take advantage of          @Autowired injection metadata just like any other          bean!        \n\r\n\rLet\'s consider a more real-world scenario with several          @Configuration classes, each depending on beans          declared in the          others:@Configurationpublic class ServiceConfig {  private @Autowired AccountRepository accountRepository;  public @Bean TransferService transferService() {      return new TransferServiceImpl(accountRepository);  }}@Configurationpublic class RepositoryConfig {  private @Autowired DataSource dataSource;  public @Bean AccountRepository accountRepository() {      return new JdbcAccountRepository(dataSource);  }}@Configuration@Import({ServiceConfig.class, RepositoryConfig.class})public class SystemTestConfig {  public @Bean DataSource dataSource() { /* return new DataSource */ }}public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);  // everything wires up across configuration classes...  TransferService transferService = ctx.getBean(TransferService.class);  transferService.transfer(100.00, \"A123\", \"C456\");}        Fully-qualifying imported beans for ease of navigation                    \n\r\n\rIn the scenario above, using @Autowired works            well and provides the desired modularity, but determining exactly            where the autowired bean definitions are declared is still somewhat            ambiguous. For example, as a developer looking at            ServiceConfig, how do you know exactly where the            @Autowired AccountRepository bean is declared?            It\'s not explicit in the code, and this may be just fine. Remember            that the SpringSource Tool Suite provides tooling that can render            graphs showing how everything is wired up - that may be all you            need. Also, your Java IDE can easily find all declarations and uses            of the AccountRepository type, and will quickly            show you the location of @Bean methods that            return that type.          \n\r\n\rIn cases where this ambiguity is not acceptable and you wish to            have direct navigation from within your IDE from one            @Configuration class to another, consider            autowiring the configuration classes themselves:            @Configurationpublic class ServiceConfig {  private @Autowired RepositoryConfig repositoryConfig;  public @Bean TransferService transferService() {      // navigate \'through\' the config class to the @Bean method!      return new TransferServiceImpl(repositoryConfig.accountRepository());  }}\n\r\n\r            In the situation above, it is completely explicit where            AccountRepository is defined. However,            ServiceConfig is now tightly coupled to            RepositoryConfig; that\'s the tradeoff. This tight            coupling can be somewhat mitigated by using interface-based or            abstract class-based @Configuration classes.            Consider the following:            @Configurationpublic class ServiceConfig {  private @Autowired RepositoryConfig repositoryConfig;  public @Bean TransferService transferService() {      return new TransferServiceImpl(repositoryConfig.accountRepository());  }}@Configurationpublic interface RepositoryConfig {  @Bean AccountRepository accountRepository();}@Configurationpublic class DefaultRepositoryConfig implements RepositoryConfig {  public @Bean AccountRepository accountRepository() {      return new JdbcAccountRepository(...);  }}@Configuration@Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!public class SystemTestConfig {  public @Bean DataSource dataSource() { /* return DataSource */ }}public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);  TransferService transferService = ctx.getBean(TransferService.class);  transferService.transfer(100.00, \"A123\", \"C456\");}\n\r\n\r            Now ServiceConfig is loosely coupled with respect            to the concrete DefaultRepositoryConfig, and            built-in IDE tooling is still useful: it will be easy for the            developer to get a type hierarchy of            RepositoryConfig implementations. In this way,            navigating @Configuration classes and their            dependencies becomes no different than the usual process of            navigating interface-based code.                      Combining Java and XML configuration            \n\r\n\rSpring\'s @Configuration class support does not        aim to be a 100% complete replacement for Spring XML. Some facilities        such as Spring XML namespaces remain an ideal way to configure the        container. In cases where XML is convenient or necessary, you have a        choice: either instantiate the container in an \"XML-centric\" way using,        for example, ClassPathXmlApplicationContext, or in a        \"Java-centric\" fashion using        AnnotationConfigApplicationContext and the        @ImportResource annotation to import XML as        needed.      XML-centric use of @Configuration          classes                \n\r\n\rIt may be preferable to bootstrap the Spring container from XML          and include @Configuration classes in an ad-hoc          fashion. For example, in a large existing codebase that uses Spring          XML, it will be easier to create @Configuration          classes on an as-needed basis and include them from the existing XML          files. Below you\'ll find the options for using          @Configuration classes in this kind of          \"XML-centric\" situation.        Declaring @Configuration classes as plain            Spring &lt;bean/&gt; elements                    \n\r\n\rRemember that @Configuration classes are            ultimately just bean definitions in the container. In this example,            we create a @Configuration class named            AppConfig and include it within            system-test-config.xml as a            &lt;bean/&gt;definition. Because            &lt;context:annotation-config/&gt; is switched            on, the container will recognize the            @Configuration annotation, and process the            @Bean methods declared in            AppConfig            properly.@Configurationpublic class AppConfig {  private @Autowired DataSource dataSource;  public @Bean AccountRepository accountRepository() {      return new JdbcAccountRepository(dataSource);  }  public @Bean TransferService transferService() {      return new TransferService(accountRepository());  }}\n\r\n\r            system-test-config.xml&lt;beans&gt;  &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;  &lt;context:annotation-config/&gt;  &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/&gt;  &lt;bean class=\"com.acme.AppConfig\"/&gt;  &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;      &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;      &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;      &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;\n\r\n\r            jdbc.propertiesjdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password=\n\r\n\r            public static void main(String[] args) {  ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\");  TransferService transferService = ctx.getBean(TransferService.class);  // ...}          Note            \n\r\n\rIn system-test-config.xml above, the              AppConfig&lt;bean/&gt; does not declare an              id element. While it would be acceptable to do              so, it is unnecessary given that no other bean will ever refer to              it, and it is unlikely that it will be explicitly fetched from the              container by name. Likewise with the DataSource              bean - it is only ever autowired by type, so an explicit bean id              is not strictly required.                          Using &lt;context:component-scan/&gt; to            pick up @Configuration classes                    \n\r\n\rBecause @Configuration is meta-annotated with            @Component,            @Configuration-annotated classes are            automatically candidates for component scanning. Using the same            scenario as above, we can redefine            system-test-config.xml to take advantage of            component-scanning. Note that in this case, we don\'t need to            explicitly declare            &lt;context:annotation-config/&gt;, because            &lt;context:component-scan/&gt; enables all the            same            functionality.system-test-config.xml&lt;beans&gt;  &lt;!-- picks up and registers AppConfig as a bean definition --&gt;  &lt;context:component-scan base-package=\"com.acme\"/&gt;  &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/&gt;  &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;      &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;      &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;      &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;                    @Configuration class-centric use of XML with          @ImportResource                \n\r\n\rIn applications where @Configuration classes          are the primary mechanism for configuring the container, it will still          likely be necessary to use at least some XML. In these scenarios,          simply use @ImportResource and define only as much          XML as is needed. Doing so achieves a \"Java-centric\" approach to          configuring the container and keeps XML to a bare minimum.          @Configuration@ImportResource(\"classpath:/com/acme/properties-config.xml\")public class AppConfig {  private @Value(\"${jdbc.url}\") String url;  private @Value(\"${jdbc.username}\") String username;  private @Value(\"${jdbc.password}\") String password;  public @Bean DataSource dataSource() {      return new DriverManagerDataSource(url, username, password);  }}\n\r\n\r          properties-config.xml&lt;beans&gt;  &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/&gt;&lt;/beans&gt;\n\r\n\r          jdbc.propertiesjdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password=\n\r\n\r          public static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);  TransferService transferService = ctx.getBean(TransferService.class);  // ...}              5.13&nbsp;Registering a LoadTimeWeaver        \n\r\n\rThe LoadTimeWeaver is used by Spring to dynamically    transform classes as they are loaded into the Java virtual machine (JVM).    \n\r\n\rTo enable load-time weaving add the @EnableLoadTimeWeaving    to one of your @Configuration classes:    @Configuration@EnableLoadTimeWeavingpublic class AppConfig {}    \n\r\n\rAlternatively for XML configuration use the  context:load-time-weaver element:    &lt;beans&gt;     &lt;context:load-time-weaver/&gt;&lt;/beans&gt;    \n\r\n\rOnce configured for the      ApplicationContext. Any bean within that      ApplicationContext may implement      LoadTimeWeaverAware, thereby receiving a      reference to the load-time weaver instance. This is particularly useful in      combination with Spring\'s JPA support where      load-time weaving may be necessary for JPA class transformation. Consult      the LocalContainerEntityManagerFactoryBean Javadoc      for more detail. For more on AspectJ load-time weaving, see Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;.    5.14&nbsp;Additional Capabilities of the    ApplicationContext      \n\r\n\rAs was discussed in the chapter introduction, the    org.springframework.beans.factory package provides basic    functionality for managing and manipulating beans, including in a    programmatic way. The org.springframework.context package    adds the ApplicationContext interface, which    extends the BeanFactory interface, in    addition to extending other interfaces to provide additional functionality    in a more application framework-oriented style. Many    people use the ApplicationContext in a    completely declarative fashion, not even creating it programmatically, but    instead relying on support classes such as    ContextLoader to automatically instantiate an    ApplicationContext as part of the normal    startup process of a J2EE web application.  \n\r\n\rTo enhance BeanFactory functionality in a    more framework-oriented style the context package also provides the    following functionality:  \n\r      \n\r\n\rAccess to messages in i18n-style, through the        MessageSource interface.    \n\r      \n\r\n\rAccess to resources, such as URLs and files,        through the ResourceLoader        interface.    \n\r      \n\r\n\rEvent publication to beans implementing the        ApplicationListener interface, through        the use of the ApplicationEventPublisher        interface.    \n\r      \n\r\n\rLoading of multiple (hierarchical) contexts,        allowing each to be focused on one particular layer, such as the web        layer of an application, through the        HierarchicalBeanFactory interface.    \n\r  5.14.1&nbsp;Internationalization using      MessageSource            \n\r\n\rThe ApplicationContext interface      extends an interface called MessageSource,      and therefore provides internationalization (i18n) functionality. Spring      also provides the interface      HierarchicalMessageSource, which can resolve      messages hierarchically. Together these interfaces provide the foundation      upon which Spring effects message resolution. The methods defined on these      interfaces include:    \n\r        \n\r\n\rString getMessage(String code, Object[] args, String          default, Locale loc): The basic method used to retrieve a          message from the MessageSource. When no          message is found for the specified locale, the default message is          used. Any arguments passed in become replacement values, using the          MessageFormat functionality provided by          the standard library.      \n\r        \n\r\n\rString getMessage(String code, Object[] args, Locale          loc): Essentially the same as the previous method, but          with one difference: no default message can be specified; if the          message cannot be found, a          NoSuchMessageException is thrown.      \n\r        \n\r\n\rString getMessage(MessageSourceResolvable resolvable,          Locale locale): All properties used in the preceding          methods are also wrapped in a class named          MessageSourceResolvable, which you can          use with this method.      \n\r    \n\r\n\rWhen an ApplicationContext is loaded,      it automatically searches for a      MessageSource bean defined in the context.      The bean must have the name messageSource. If such a      bean is found, all calls to the preceding methods are delegated to the      message source. If no message source is found, the      ApplicationContext attempts to find a      parent containing a bean with the same name. If it does, it uses that bean      as the MessageSource. If the      ApplicationContext cannot find any source      for messages, an empty DelegatingMessageSource is      instantiated in order to be able to accept calls to the methods defined      above.    \n\r\n\rSpring provides two MessageSource      implementations, ResourceBundleMessageSource and      StaticMessageSource. Both implement      HierarchicalMessageSource in order to do      nested messaging. The StaticMessageSource is rarely      used but provides programmatic ways to add messages to the source. The      ResourceBundleMessageSource is shown in the      following example:    &lt;beans&gt;&lt;bean id=\"messageSource\"      class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;  &lt;property name=\"basenames\"&gt;    &lt;list&gt;      &lt;value&gt;format&lt;/value&gt;      &lt;value&gt;exceptions&lt;/value&gt;      &lt;value&gt;windows&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;    \n\r\n\rIn the example it is assumed you have three resource bundles defined      in your classpath called format,      exceptions and windows. Any request      to resolve a message will be handled in the JDK standard way of resolving      messages through ResourceBundles. For the purposes of the example, assume      the contents of two of the above resource bundle files are...    # in format.propertiesmessage=Alligators rock!    # in exceptions.propertiesargument.required=The \'{0}\' argument is required.    \n\r\n\rA program to execute the MessageSource      functionality is shown in the next example. Remember that all      ApplicationContext implementations are also      MessageSource implementations and so can be cast to      the MessageSource interface.    public static void main(String[] args) {  MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");  String message = resources.getMessage(\"message\", null, \"Default\", null);  System.out.println(message);}    \n\r\n\rThe resulting output from the above program will be...    Alligators rock!    \n\r\n\rSo to summarize, the MessageSource is defined      in a file called beans.xml, which exists at the root of      your classpath. The messageSource bean definition      refers to a number of resource bundles through its      basenames property. The three files that are passed in      the list to the basenames property exist as files at      the root of your classpath and are called      format.properties,      exceptions.properties, and      windows.properties respectively.    \n\r\n\rThe next example shows arguments passed to the message lookup; these      arguments will be converted into Strings and inserted into placeholders in      the lookup message.    &lt;beans&gt;  &lt;!-- this MessageSource is being used in a web application --&gt;  &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;      &lt;property name=\"basename\" value=\"exceptions\"/&gt;  &lt;/bean&gt;  &lt;!-- lets inject the above MessageSource into this POJO --&gt;  &lt;bean id=\"example\" class=\"com.foo.Example\"&gt;      &lt;property name=\"messages\" ref=\"messageSource\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;    public class Example {  private MessageSource messages;  public void setMessages(MessageSource messages) {      this.messages = messages;  }  public void execute() {      String message = this.messages.getMessage(\"argument.required\",          new Object [] {\"userDao\"}, \"Required\", null);      System.out.println(message);  }}    \n\r\n\rThe resulting output from the invocation of the      execute() method will be...    The userDao argument is required.    \n\r\n\rWith regard to internationalization (i18n), Spring\'s various      MessageResource implementations follow the same      locale resolution and fallback rules as the standard JDK      ResourceBundle. In short, and continuing with the      example messageSource defined previously, if you want      to resolve messages against the British (en-GB) locale, you would create      files called format_en_GB.properties,      exceptions_en_GB.properties, and      windows_en_GB.properties respectively.    \n\r\n\rTypically, locale resolution is managed by the surrounding environment      of the application. In this example, the locale against which (British)      messages will be resolved is specified manually.    # in exceptions_en_GB.propertiesargument.required=Ebagum lad, the \'{0}\' argument is required, I say, required.    public static void main(final String[] args) {  MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");  String message = resources.getMessage(\"argument.required\",      new Object [] {\"userDao\"}, \"Required\", Locale.UK);  System.out.println(message);}    \n\r\n\rThe resulting output from the running of the above program will      be...    Ebagum lad, the \'userDao\' argument is required, I say, required.    \n\r\n\rYou can also use the MessageSourceAware      interface to acquire a reference to any      MessageSource that has been defined. Any bean that      is defined in an ApplicationContext that implements      the MessageSourceAware interface is injected with      the application context\'s MessageSource when the      bean is created and configured.    Note      \n\r\n\rAs an alternative to        ResourceBundleMessageSource, Spring provides a        ReloadableResourceBundleMessageSource class. This        variant supports the same bundle file format but is more flexible than        the standard JDK based        ResourceBundleMessageSource        implementation. In particular, it allows for reading files        from any Spring resource location (not just from the classpath) and        supports hot reloading of bundle property files (while efficiently        caching them in between). Check out the        ReloadableResourceBundleMessageSource javadoc for        details.        5.14.2&nbsp;Standard and Custom Events        \n\r\n\rEvent handling in the      ApplicationContext is provided through the      ApplicationEvent class and      ApplicationListener interface. If a bean      that implements the ApplicationListener      interface is deployed into the context, every time an      ApplicationEvent gets published to the      ApplicationContext, that bean is notified.      Essentially, this is the standard Observer design      pattern. Spring provides the following standard events:    \n\r\n\rTable&nbsp;5.7.&nbsp;Built-in Events            EventExplanationContextRefreshedEventPublished when the              ApplicationContext is initialized              or refreshed, for example, using the              refresh() method on the              ConfigurableApplicationContext              interface. \"Initialized\" here means that all beans are loaded,              post-processor beans are detected and activated, singletons are              pre-instantiated, and the              ApplicationContext object is ready              for use. As long as the context has not been closed, a refresh can              be triggered multiple times, provided that the chosen              ApplicationContext actually              supports such \"hot\" refreshes. For example,              XmlWebApplicationContext supports hot              refreshes, but GenericApplicationContext              does not.ContextStartedEventPublished when the              ApplicationContext is started,              using the start() method on the              ConfigurableApplicationContext              interface. \"Started\" here means that all              Lifecycle beans receive an explicit              start signal. Typically this signal is used to restart beans after              an explicit stop, but it may also be used to start components that              have not been configured for autostart , for example, components              that have not already started on initialization.ContextStoppedEventPublished when the              ApplicationContext is stopped,              using the stop() method on the              ConfigurableApplicationContext              interface. \"Stopped\" here means that all              Lifecycle beans receive an explicit              stop signal. A stopped context may be restarted through a              start() call.ContextClosedEventPublished when the              ApplicationContext is closed, using              the close() method on the              ConfigurableApplicationContext              interface. \"Closed\" here means that all singleton beans are              destroyed. A closed context reaches its end of life; it cannot be              refreshed or restarted.RequestHandledEventA web-specific event telling all beans that an HTTP request              has been serviced. This event is published              after the request is complete. This event is              only applicable to web applications using Spring\'s              DispatcherServlet.    \n\r    \n\r\n\rYou can also create and publish your own custom events. This example      demonstrates a simple class that extends Spring\'s      ApplicationEvent base class:    public class BlackListEvent extends ApplicationEvent {  private final String address;  private final String test;  public BlackListEvent(Object source, String address, String test) {      super(source);      this.address = address;      this.test = test;  }  // accessor and other methods...}    \n\r\n\rTo publish a custom ApplicationEvent, call the      publishEvent() method on an      ApplicationEventPublisher. Typically this      is done by creating a class that implements      ApplicationEventPublisherAware and      registering it as a Spring bean. The following example demonstrates such a      class:    public class EmailService implements ApplicationEventPublisherAware {  private List&lt;String&gt; blackList;  private ApplicationEventPublisher publisher;  public void setBlackList(List&lt;String&gt; blackList) {      this.blackList = blackList;  }  public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {      this.publisher = publisher;  }  public void sendEmail(String address, String text) {      if (blackList.contains(address)) {          BlackListEvent event = new BlackListEvent(this, address, text);          publisher.publishEvent(event);          return;      }      // send email...  }}    \n\r\n\rAt configuration time, the Spring container will detect that      EmailService implements      ApplicationEventPublisherAware and will      automatically call      setApplicationEventPublisher(). In reality, the      parameter passed in will be the Spring container itself; you\'re simply      interacting with the application context via its      ApplicationEventPublisher interface.    \n\r\n\rTo receive the custom ApplicationEvent, create      a class that implements ApplicationListener      and register it as a Spring bean. The following example demonstrates such      a class:    public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; {  private String notificationAddress;  public void setNotificationAddress(String notificationAddress) {      this.notificationAddress = notificationAddress;  }  public void onApplicationEvent(BlackListEvent event) {        // notify appropriate parties via notificationAddress...  }}    \n\r\n\rNotice that ApplicationListener is      generically parameterized with the type of your custom event,      BlackListEvent. This means that the      onApplicationEvent() method can remain type-safe,      avoiding any need for downcasting. You may register as many event      listeners as you wish, but note that by default event listeners receive      events synchronously. This means the      publishEvent() method blocks until all listeners      have finished processing the event. One advantage of this synchronous and      single-threaded approach is that when a listener receives an event, it      operates inside the transaction context of the publisher if a transaction      context is available. If another strategy for event publication becomes      necessary, refer to the JavaDoc for Spring\'s      ApplicationEventMulticaster      interface.    \n\r\n\rThe following example shows the bean definitions used to      register and configure each of the classes above:    &lt;bean id=\"emailService\" class=\"example.EmailService\"&gt;  &lt;property name=\"blackList\"&gt;      &lt;list&gt;          &lt;value&gt;known.spammer@example.org&lt;/value&gt;          &lt;value&gt;known.hacker@example.org&lt;/value&gt;          &lt;value&gt;john.doe@example.org&lt;/value&gt;      &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"blackListNotifier\" class=\"example.BlackListNotifier\"&gt;  &lt;property name=\"notificationAddress\" value=\"blacklist@example.org\"/&gt;&lt;/bean&gt;    \n\r\n\rPutting it all together, when the sendEmail()      method of the emailService bean is called, if there are      any emails that should be blacklisted, a custom event of type      BlackListEvent is published. The      blackListNotifier bean is registered as an      ApplicationListener and thus receives the      BlackListEvent, at which point it can notify      appropriate parties.    Note      \n\r\n\rSpring\'s eventing mechanism is designed for simple communication        between Spring beans within the same application context. However, for        more sophisticated enterprise integration needs, the        separately-maintained Spring        Integration project provides complete support for building        lightweight, pattern-oriented, event-driven architectures that build upon        the well-known Spring programming model.        5.14.3&nbsp;Convenient access to low-level resources        \n\r\n\rFor optimal usage and understanding of application contexts, users      should generally familiarize themselves with Spring\'s      Resource abstraction, as described in the      chapter Chapter&nbsp;6, Resources.    \n\r\n\rAn application context is a      ResourceLoader, which can be used to load      Resources. A      Resource is essentially a more feature rich      version of the JDK class java.net.URL, in fact, the      implementations of the Resource wrap an      instance of java.net.URL where appropriate. A      Resource can obtain low-level resources      from almost any location in a transparent fashion, including from the      classpath, a filesystem location, anywhere describable with a standard      URL, and some other variations. If the resource location string is a      simple path without any special prefixes, where those resources come from      is specific and appropriate to the actual application context type.    \n\r\n\rYou can configure a bean deployed into the application context to      implement the special callback interface,      ResourceLoaderAware, to be automatically      called back at initialization time with the application context itself      passed in as the ResourceLoader. You can      also expose properties of type Resource, to      be used to access static resources; they will be injected into it like any      other properties. You can specify those      Resource properties as simple String paths,      and rely on a special JavaBean      PropertyEditor that is automatically      registered by the context, to convert those text strings to actual      Resource objects when the bean is      deployed.    \n\r\n\rThe location path or paths supplied to an      ApplicationContext constructor are actually      resource strings, and in simple form are treated appropriately to the      specific context implementation.      ClassPathXmlApplicationContext treats a simple      location path as a classpath location. You can also use location paths      (resource strings) with special prefixes to force loading of definitions      from the classpath or a URL, regardless of the actual context type.    5.14.4&nbsp;Convenient ApplicationContext      instantiation for web applications        \n\r\n\rYou can create ApplicationContext      instances declaratively by using, for example, a      ContextLoader. Of course you can also create      ApplicationContext instances      programmatically by using one of the      ApplicationContext implementations.    \n\r\n\rThe ContextLoader mechanism comes in two      flavors: the ContextLoaderListener and the      ContextLoaderServlet. They have the same      functionality but differ in that the listener version is not reliable in      Servlet 2.3 containers. In the Servlet 2.4 specification, Servlet context      listeners must execute immediately after the Servlet context for the web      application is created and is available to service the first request (and      also when the Servlet context is about to be shut down). As such a Servlet      context listener is an ideal place to initialize the Spring      ApplicationContext. All things being equal,      you should probably prefer ContextLoaderListener;      for more information on compatibility, have a look at the Javadoc for the      ContextLoaderServlet.    \n\r\n\rYou can register an ApplicationContext      using the ContextLoaderListener as follows:    &lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- or use the ContextLoaderServlet instead of the above listener&lt;servlet&gt;&lt;servlet-name&gt;context&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;--&gt;    \n\r\n\rThe listener inspects the contextConfigLocation      parameter. If the parameter does not exist, the listener uses      /WEB-INF/applicationContext.xml as a default. When the      parameter does exist, the listener separates the      String by using predefined delimiters (comma, semicolon and whitespace)      and uses the values as locations where application contexts will be      searched. Ant-style path patterns are supported as well. Examples are      /WEB-INF/*Context.xml for all files with names ending      with \"Context.xml\", residing in the \"WEB-INF\" directory, and      /WEB-INF/**/*Context.xml, for all such files in any      subdirectory of \"WEB-INF\".    \n\r\n\rYou can use ContextLoaderServlet instead of      ContextLoaderListener. The Servlet uses the      contextConfigLocation parameter just as the listener      does.    5.14.5&nbsp;Deploying a Spring ApplicationContext as a J2EE RAR file        \n\r\n\rIn Spring 2.5 and later, it is possible to deploy a Spring      ApplicationContext as a RAR file, encapsulating the context and all of its      required bean classes and library JARs in a J2EE RAR deployment unit. This      is the equivalent of bootstrapping a standalone ApplicationContext, just      hosted in J2EE environment, being able to access the J2EE servers      facilities. RAR deployment is a more natural alternative to scenario of      deploying a headless WAR file, in effect, a WAR file without any HTTP      entry points that is used only for bootstrapping a Spring      ApplicationContext in a J2EE environment.    \n\r\n\rRAR deployment is ideal for application contexts that do not need HTTP      entry points but rather consist only of message endpoints and scheduled      jobs. Beans in such a context can use application server resources such as      the JTA transaction manager and JNDI-bound JDBC DataSources and JMS      ConnectionFactory instances, and may also register with the platform\'s JMX      server - all through Spring\'s standard transaction management and JNDI and      JMX support facilities. Application components can also interact with the      application server\'s JCA WorkManager through Spring\'s      TaskExecutor abstraction.    \n\r\n\rCheck out the JavaDoc of the SpringContextResourceAdapter class for the configuration details      involved in RAR deployment.    \n\r\n\rFor a simple deployment of a Spring ApplicationContext as a      J2EE RAR file: package all application classes into a RAR file,      which is a standard JAR file with a different file extension. Add all      required library JARs into the root of the RAR archive. Add a      \"META-INF/ra.xml\" deployment descriptor (as shown in      SpringContextResourceAdapters JavaDoc) and the      corresponding Spring XML bean definition file(s) (typically      \"META-INF/applicationContext.xml\"), and drop the resulting RAR file into      your application server\'s deployment directory.    Note      \n\r\n\rSuch RAR deployment units are usually self-contained; they do not        expose components to the outside world, not even to other modules of the        same application. Interaction with a RAR-based ApplicationContext        usually occurs through JMS destinations that it shares with other        modules. A RAR-based ApplicationContext may also, for example, schedule        some jobs, reacting to new files in the file system (or the like). If it        needs to allow synchronous access from the outside, it could for example        export RMI endpoints, which of course may be used by other application        modules on the same machine.        5.15&nbsp;The BeanFactory        \n\r\n\rThe BeanFactory provides the underlying basis      for Spring\'s IoC functionality but it is only used directly in integration      with other third-party frameworks and is now largely historical in nature      for most users of Spring. The BeanFactory and      related interfaces, such as BeanFactoryAware,      InitializingBean,      DisposableBean, are still present in Spring for the      purposes of backward compatibility with the large number of third-party      frameworks that integrate with Spring. Often third-party components that      can not use more modern equivalents such as @PostConstruct or      @PreDestroy in order to remain compatible with JDK 1.4 or to      avoid a dependency on JSR-250.    \n\r\n\rThis section provides additional background into the differences      between the BeanFactory and      ApplicationContext and how one might access      the IoC container directly through a classic singleton lookup.    5.15.1&nbsp;BeanFactory or        ApplicationContext?            \n\r\n\rUse an ApplicationContext unless you        have a good reason for not doing so.      \n\r\n\rBecause the ApplicationContext        includes all functionality of the        BeanFactory, it is generally recommended        over the BeanFactory, except for a few        situations such as in an Applet where memory        consumption might be critical and a few extra kilobytes might make a        difference. However, for most typical enterprise applications and        systems, the ApplicationContext is what        you will want to use. Spring 2.0 and later makes        heavy use of the BeanPostProcessor extension point        (to effect proxying and so on). If you use only a plain        BeanFactory, a fair amount of support        such as transactions and AOP will not take effect, at least not without        some extra steps on your part. This situation could be confusing because        nothing is actually wrong with the configuration.      \n\r\n\rThe following table lists features provided by the        BeanFactory and        ApplicationContext interfaces and        implementations.      \n\r\n\rTable&nbsp;5.8.&nbsp;Feature Matrix                FeatureBeanFactoryApplicationContext\n\r\n\rBean instantiation/wiring\n\r\n\rYes\n\r\n\rYes\n\r\n\rAutomatic                BeanPostProcessor                registration\n\r\n\rNo\n\r\n\rYes\n\r\n\rAutomatic                BeanFactoryPostProcessor                registration\n\r\n\rNo\n\r\n\rYes\n\r\n\rConvenient                MessageSource access (for                i18n)\n\r\n\rNo\n\r\n\rYes\n\r\n\rApplicationEvent                publication\n\r\n\rNo\n\r\n\rYes      \n\r      \n\r\n\rTo explicitly register a bean post-processor with a        BeanFactory implementation, you must        write code like this:      ConfigurableBeanFactory factory = new XmlBeanFactory(...);// now register any needed BeanPostProcessor instancesMyBeanPostProcessor postProcessor = new MyBeanPostProcessor();factory.addBeanPostProcessor(postProcessor);// now start using the factory      \n\r\n\rTo explicitly register a        BeanFactoryPostProcessor when using a        BeanFactory implementation, you must        write code like this:      XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource(\"beans.xml\"));// bring in some property values from a Properties filePropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();cfg.setLocation(new FileSystemResource(\"jdbc.properties\"));// now actually do the replacementcfg.postProcessBeanFactory(factory);      \n\r\n\rIn both cases, the explicit registration step is inconvenient, which        is one reason why the various        ApplicationContext implementations are        preferred above plain BeanFactory        implementations in the vast majority of Spring-backed applications,        especially when using BeanFactoryPostProcessors and        BeanPostProcessors. These mechanisms implement        important functionality such as property placeholder replacement and        AOP.        5.15.2&nbsp;Glue code and the evil singleton            \n\r\n\rIt is best to write most application code in a dependency-injection        (DI) style, where that code is served out of a Spring IoC container, has        its own dependencies supplied by the container when it is created, and        is completely unaware of the container. However, for the small glue        layers of code that are sometimes needed to tie other code together, you        sometimes need a singleton (or quasi-singleton) style access to a Spring        IoC container. For example, third-party code may try to construct new        objects directly (Class.forName() style), without the        ability to get these objects out of a Spring IoC container.        If        the object constructed by the third-party code is a small stub or proxy,        which then uses a singleton style access to a Spring IoC container to        get a real object to delegate to, then inversion of control has still        been achieved for the majority of the code (the object coming out of the        container). Thus most code is still unaware of the container or how it        is accessed, and remains decoupled from other code, with all ensuing        benefits. EJBs may also use this stub/proxy approach to delegate to a        plain Java implementation object, retrieved from a Spring IoC container.        While the Spring IoC container itself ideally does not have to be a        singleton, it may be unrealistic in terms of memory usage or        initialization times (when using beans in the Spring IoC container such        as a Hibernate SessionFactory) for each        bean to use its own, non-singleton Spring IoC container.      \n\r\n\rLooking up the application context in a service locator style is        sometimes the only option for accessing shared Spring-managed        components, such as in an EJB 2.1 environment, or when you want to share        a single ApplicationContext as a parent to WebApplicationContexts across        WAR files. In this case you should look into using the utility class        ContextSingletonBeanFactoryLocator        locator that is described in this SpringSource team blog entry.      \n\r      \n\r\n\r[1] See Background            \n\r\n\r[2] See Section&nbsp;5.4.1, &#8220;Dependency injection&#8221;      Prev&nbsp;Up&nbsp;NextPart&nbsp;III.&nbsp;Core Technologies&nbsp;Home&nbsp;6.&nbsp;Resources","5. The IoC container","scr\\beans.html","         29.&nbsp;Cache AbstractionPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next29.&nbsp;Cache Abstraction        29.1&nbsp;Introduction                \n\r\n\rSince version 3.1, Spring Framework provides support for transparently        adding caching into an existing Spring application. Similar to the transaction        support, the caching abstraction allows consistent use of various caching        solutions with minimal impact on the code.        29.2&nbsp;Understanding the cache abstraction        \n\r\n\rCache vs Buffer        \n\r\n\rThe terms \"buffer\" and \"cache\" tend to be used interchangeably; note however they represent different things.    A buffer is used traditionally as an intermediate temporary store for data between a fast and a slow entity. As one    party would have to wait for the other affecting performance, the buffer alleviates this by    allowing entire blocks of data to move at once rather then in small chunks. The data is written and read only once from    the buffer. Furthermore, the buffers are visible to at least one party which is aware of it.    \n\r\n\rA cache on the other hand by definition is hidden and neither party is aware that caching occurs.It as well improves    performance but does that by allowing the same data to be read multiple times in a fast fashion.    \n\r\n\rA further explanation of the differences between two can be found    here.        \n\r\n\rAt its core, the abstraction applies caching to Java methods, reducing thus the number of executions based on the    information available in the cache. That is, each time a targeted method is invoked, the abstraction    will apply a caching behavior checking whether the method has been already executed for the given arguments. If it has,    then the cached result is returned without having to execute the actual method; if it has not, then method is executed, the    result cached and returned to the user so that, the next time the method is invoked, the cached result is returned.    This way, expensive methods (whether CPU or IO bound) can be executed only once for a given set of parameters and the result    reused without having to actually execute the method again. The caching logic is applied transparently without any interference    to the invoker.    Important\n\r\n\rObviously this approach works only for methods that are guaranteed to return the same output (result) for a given input    (or arguments) no matter how many times it is being executed.    \n\r\n\rTo use the cache abstraction, the developer needs to take care of two aspects:    \n\r\n\r\n\rcaching declaration - identify the methods that need to be cached and their policy\n\r\n\r\n\rcache configuration - the backing cache where the data is stored and read from\n\r\n\r\n\r        \n\r\n\rNote that just like other services in Spring Framework, the caching service is an abstraction (not a cache implementation) and requires    the use of an actual storage to store the cache data - that is, the abstraction frees the developer from having to write the caching    logic but does not provide the actual stores. There are two integrations available out of the box, for JDK java.util.concurrent.ConcurrentMap    and EhCache - see Section&nbsp;29.6, &#8220;Plugging-in different back-end caches&#8221; for more information on plugging in other cache stores/providers.        29.3&nbsp;Declarative annotation-based caching        \n\r\n\rFor caching declaration, the abstraction provides two Java annotations: @Cacheable and @CacheEvict which allow methods    to trigger cache population or cache eviction. Let us take a closer look at each annotation:    29.3.1&nbsp;@Cacheable annotation                \n\r\n\rAs the name implies, @Cacheable is used to demarcate methods that are cacheable - that is, methods for whom the result is stored into the cache        so on subsequent invocations (with the same arguments), the value in the cache is returned without having to actually execute the method. In its simplest form,        the annotation declaration requires the name of the cache associated with the annotated method:        @Cacheable(\"books\")public Book findBook(ISBN isbn) {...}        \n\r\n\rIn the snippet above, the method findBook is associated with the cache named books. Each time the method is called, the cache        is checked to see whether the invocation has been already executed and does not have to be repeated. While in most cases, only one cache is declared, the annotation allows multiple        names to be specified so that more then one cache are being used. In this case, each of the caches will be checked before executing the method - if at least one cache is hit,        then the associated value will be returned:        Note\n\r\n\rAll the other caches that do not contain the method will be updated as well even though the cached method was not actually        executed.        @Cacheable({ \"books\", \"isbns\" })public Book findBook(ISBN isbn) {...}        Default Key Generation                        \n\r\n\rSince caches are essentially key-value stores, each invocation of a cached method needs to be translated into a suitable key for cache access.            Out of the box, the caching abstraction uses a simple KeyGenerator based on the following algorithm:            \n\r\n\r\n\rIf no params are given, return 0.\n\r\n\r\n\rIf only one param is given, return that instance.\n\r\n\r\n\rIf more the one param is given, return a key computed from the hashes of all parameters.\n\r            \n\r\n\r            This approach works well for objects with natural keys as long as the hashCode() reflects that. If that is not the case then            for distributed or persistent environments, the strategy needs to be changed as the objects hashCode is not preserved.            In fact, depending on the JVM implementation or running conditions, the same hashCode can be reused for different objects, in the same VM instance.            \n\r\n\rTo provide a different default key generator, one needs to implement the org.springframework.cache.KeyGenerator interface.            Once configured, the generator will be used for each declaration that does not specify its own key generation strategy (see below).                            Custom Key Generation Declaration                        \n\r\n\rSince caching is generic, it is quite likely the target methods have various signatures that cannot be simply mapped on top of the cache structure. This tends to become            obvious when the target method has multiple arguments out of which only some are suitable for caching (while the rest are used only by the method logic). For example:            @Cacheable(\"books\")public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed            \n\r\n\rAt first glance, while the two boolean arguments influence the way the book is found, they are no use for the cache. Further more what if only one of the two            is important while the other is not?            \n\r\n\rFor such cases, the @Cacheable annotation allows the user to specify how the key is generated through its key attribute.            The developer can use SpEL to pick the arguments of interest (or their nested properties), perform operations or even invoke arbitrary methods without            having to write any code or implement any interface. This is the recommended approach over the default generator since            methods tend to be quite different in signatures as the code base grows; while the default strategy might work for some methods, it rarely does for all methods.            \n\r\n\r            Below are some examples of various SpEL declarations - if you are not familiar with it, do yourself a favour and read Chapter&nbsp;8, Spring Expression Language (SpEL):                        @Cacheable(value=\"books\", key=\"#isbn\"public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)@Cacheable(value=\"books\", key=\"#isbn.rawNumber\")public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)@Cacheable(value=\"books\", key=\"T(someType).hash(#isbn)\")public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)            \n\r\n\rThe snippets above, show how easy it is to select a certain argument, one of its properties or even an arbitrary (static) method.                Conditional caching                        \n\r\n\rSometimes, a method might not be suitable for caching all the time (for example, it might depend on the given arguments). The cache annotations support such functionality            through the conditional parameter which takes a SpEL expression that is evaluated to either true or false.            If true, the method is cached - if not, it behaves as if the method is not cached, that is executed every since time no matter what values are in the cache or what            arguments are used. A quick example - the following method will be cached, only if the argument name has a length shorter then 32:            @Cacheable(value=\"book\", condition=\"#name.length &lt; 32\")public Book findBook(String name)            \n\r\n\rIn addition the conditional parameter, the unless parameter can be used to veto the adding of a value to the cache. Unlike            conditional, unless SpEL expressions are evalulated after the method has been called. Expanding            on the previous example - perhaps we only want to cache paperback books:            @Cacheable(value=\"book\", condition=\"#name.length &lt; 32\", unless=\"#result.hardback\")public Book findBook(String name)                Available caching SpEL evaluation context                        \n\r\n\rEach SpEL expression evaluates again a dedicated context. In addition            to the build in parameters, the framework provides dedicated caching related metadata such as the argument names. The next table lists the items made available to the context            so one can use them for key and conditional(see next section) computations:            \n\r\n\rTable&nbsp;29.1.&nbsp;Cache SpEL available metadata                                        NameLocationDescriptionExamplemethodNameroot objectThe name of the method being invoked#root.methodNamemethodroot objectThe method being invoked#root.method.nametargetroot objectThe target object being invoked#root.targettargetClassroot objectThe class of the target being invoked#root.targetClassargsroot objectThe arguments (as array) used for invoking the target#root.args[0]cachesroot objectCollection of caches against which the current method is executed#root.caches[0].nameargument nameevaluation contextName of any of the method argument. If for some reason the names are not available (ex: no debug information),                            the argument names are also available under the a&lt;#arg&gt; where                            #arg stands for the argument index (starting from 0).iban or a0 (one can also use p0 or p&lt;#arg&gt; notation as an alias).resultevaluation contextThe result of the method call (the value to be cached). Only available in \'unless\' expressions and \'cache evict\'                            expression (when beforeInvocation is false).#result            \n\r                29.3.2&nbsp;@CachePut annotation                \n\r\n\rFor cases where the cache needs to be updated without interfering with the method execution, one can use the @CachePut annotation. That is, the method will always        be executed and its result placed into the cache (according to the @CachePut options). It supports the same options as @Cacheable and should be used        for cache population rather then method flow optimization.        \n\r\n\rNote that using @CachePut and @Cacheable annotations on the same method is generally discouraged because they have different behaviors. While the latter        causes the method execution to be skipped by using the cache, the former forces the execution in order to execute a cache update. This leads to unexpected behavior and with the exception of specific        corner-cases (such as annotations having conditions that exclude them from each other), such declarations should be avoided.        29.3.3&nbsp;@CacheEvict annotation                \n\r\n\rThe cache abstraction allows not just population of a cache store but also eviction. This process is useful for removing stale or unused data from the cache. Opposed to        @Cacheable, annotation @CacheEvict demarcates methods that perform cache eviction, that is methods that act as triggers        for removing data from the cache. Just like its sibling, @CacheEvict requires one to specify one (or multiple) caches that are affected by the action, allows a        key or a condition to be specified but in addition, features an extra parameter allEntries which indicates whether a cache-wide eviction needs to be performed        rather then just an entry one (based on the key):        @CacheEvict(value = \"books\", allEntries=true)public void loadBooks(InputStream batch)        \n\r\n\rThis option comes in handy when an entire cache region needs to be cleared out - rather then evicting each entry (which would take a long time since it is inefficient),        all the entires are removed in one operation as shown above. Note that the framework will ignore any key specified in this scenario as it does not apply (the entire cache is evicted not just        one entry).        \n\r\n\rOne can also indicate whether the eviction should occur after (the default) or before the method executes through the beforeInvocation attribute.        The former provides the same semantics as the rest of the annotations - once the method completes successfully, an action (in this case eviction) on the cache is executed. If the method does not        execute (as it might be cached) or an exception is thrown, the eviction does not occur. The latter (beforeInvocation=true) causes the eviction to occur always, before the method        is invoked - this is useful in cases where the eviction does not need to be tied to the method outcome.        \n\r\n\rIt is important to note that void methods can be used with @CacheEvict - as the methods act as triggers, the return values are ignored (as they don\'t interact with        the cache) - this is not the case with @Cacheable which adds/update data into the cache and thus requires a result.        29.3.4&nbsp;@Caching annotation                \n\r\n\rThere are cases when multiple annotations of the same type, such as @CacheEvict or @CachePut need to be specified, for example because the condition or the key        expression is different between different caches. Unfortunately Java does not support such declarations however there is a workaround - using a enclosing annotation, in this case,        @Caching. @Caching allows multiple nested @Cacheable, @CachePut and @CacheEvict to be used on the same method:        @Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(value = \"secondary\", key = \"#p0\") })public Book importBooks(String deposit, Date date)        29.3.5&nbsp;Enable caching annotations                \n\r\n\rIt is important to note that even though declaring the cache annotations does not automatically triggers their actions - like many things in Spring, the feature has to be declaratively        enabled (which means if you ever suspect caching is to blame, you can disable it by removing only one configuration line rather then all the annotations in your code).        \n\r\n\rTo enable caching annotations add the annotation @EnableCaching to one of your @Configuration classes:        @Configuration@EnableCachingpublic class AppConfig {}        \n\r\n\rAlternatively for XML configuration use the cache:annotation-driven element:        &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:cache=\"http://www.springframework.org/schema/cache\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd\"&gt;    &lt;cache:annotation-driven /&gt;&lt;/beans&gt;        \n\r\n\rBoth the cache:annotation-driven element and @EnableCaching annotation allow various options to be specified that influence the way the        caching behavior is added to the application through AOP. The configuration is intentionally similar        with that of @Transactional:                \n\r\n\rTable&nbsp;29.2.&nbsp;Cache annotation settings                        XML AttributeAnnotation AttributeDefaultDescriptioncache-managerN/A (See CachingConfigurer Javadoc)cacheManager\n\r\n\rName of cache manager to use. Only required                if the name of the cache manager is not                cacheManager, as in the example                above.modemodeproxy\n\r\n\rThe default mode \"proxy\" processes annotated                beans to be proxied using Spring\'s AOP framework (following                proxy semantics, as discussed above, applying to method calls                coming in through the proxy only). The alternative mode                \"aspectj\" instead weaves the affected classes with Spring\'s                AspectJ caching aspect, modifying the target class byte                code to apply to any kind of method call. AspectJ weaving                requires spring-aspects.jar in the classpath as well as                load-time weaving (or compile-time weaving) enabled. (See                the section called &#8220;Spring configuration&#8221; for details on how to set                up load-time weaving.)proxy-target-classproxyTargetClassfalse\n\r\n\rApplies to proxy mode only. Controls what type of                caching proxies are created for classes annotated with                the @Cacheable or @CacheEvict annotations.                If the proxy-target-class attribute is set                to true, then class-based proxies are                created. If proxy-target-class is                false or if the attribute is omitted, then                standard JDK interface-based proxies are created. (See Section&nbsp;9.6, &#8220;Proxying mechanisms&#8221; for a detailed examination of the                different proxy types.)orderorderOrdered.LOWEST_PRECEDENCE\n\r\n\rDefines the order of the cache advice that                is applied to beans annotated with                @Cacheable or @CacheEvict.                (For more                information about the rules related to ordering of AOP advice,                see the section called &#8220;Advice ordering&#8221;.) No                specified ordering means that the AOP subsystem determines the                order of the advice.        \n\r\n\r\n\r        Note        \n\r\n\r&lt;cache:annotation-driven/&gt; only looks for        @Cacheable/@CacheEvict on beans in the same        application context it is defined in. This means that, if you put        &lt;cache:annotation-driven/&gt; in a        WebApplicationContext for a        DispatcherServlet, it only checks for        @Cacheable/@CacheEvict beans in your        controllers, and not your services. See Section&nbsp;17.2, &#8220;The DispatcherServlet&#8221; for more information.                \n\r\n\rMethod visibility and        @Cacheable/@CachePut/@CacheEvict                \n\r\n\rWhen using proxies, you should apply the        @Cache* annotations only to        methods with public visibility. If you do        annotate protected, private or package-visible methods with these annotations,        no error is raised, but the annotated method does not exhibit the configured        caching settings. Consider the use of AspectJ (see below) if you        need to annotate non-public methods as it changes the bytecode itself.                Tip            \n\r\n\rSpring recommends that you only annotate concrete classes (and            methods of concrete classes) with the            @Cache* annotation, as opposed            to annotating interfaces. You certainly can place the            @Cache* annotation on an            interface (or an interface method), but this works only as you would            expect it to if you are using interface-based proxies. The fact that            Java annotations are not inherited from interfaces            means that if you are using class-based proxies            (proxy-target-class=\"true\") or the weaving-based            aspect (mode=\"aspectj\"), then the caching            settings are not recognized by the proxying and weaving            infrastructure, and the object will not be wrapped in a            caching proxy, which would be decidedly            bad.                Note        \n\r\n\rIn proxy mode (which is the default), only external method calls        coming in through the proxy are intercepted. This means that        self-invocation, in effect, a method within the target object calling        another method of the target object, will not lead to an actual        caching at runtime even if the invoked method is marked with        @Cacheable - considering using the aspectj mode in this case.                29.3.6&nbsp;Using custom annotations                \n\r\n\rThe caching abstraction allows one to use her own annotations to identify what method trigger cache population or eviction. This is quite handy as a template mechanism as it eliminates        the need to duplicate cache annotation declarations (especially useful if the key or condition are specified) or if the foreign imports (org.springframework) are not allowed        in your code base. Similar to the rest of the stereotype annotations, both @Cacheable and @CacheEvict        can be used as meta-annotations, that is annotations that can annotate other annotations. To wit, let us replace a common @Cacheable declaration with our own, custom        annotation:                @Retention(RetentionPolicy.RUNTIME)@Target({ElementType.METHOD})@Cacheable(value=&#8220;books&#8221;, key=\"#isbn\")public @interface SlowService {}        \n\r\n\rAbove, we have defined our own SlowService annotation which itself is annotated with @Cacheable - now we can replace the following code:        @Cacheable(value=\"books\", key=\"#isbn\")public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)        \n\r\n\rwith:        @SlowServicepublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)        \n\r\n\rEven though @SlowService is not a Spring annotation, the container automatically picks up its declaration at runtime and understands its meaning. Note that as        mentioned above, the annotation-driven behavior needs to be enabled.            29.4&nbsp;Declarative XML-based caching                \n\r\n\rIf annotations are not an option (no access to the sources or no external code), one can use XML for declarative caching. So instead of annotating the methods for caching, one specifies        the target method and the caching directives externally (similar to the declarative transaction management advice). The previous example        can be translated into:        &lt;!-- the service we want to make cacheable --&gt;&lt;bean id=\"bookService\" class=\"x.y.service.DefaultBookService\"/&gt;&lt;!-- cache definitions --&gt;&lt;cache:advice id=\"cacheAdvice\" cache-manager=\"cacheManager\"&gt;    &lt;cache:caching cache=\"books\"&gt;        &lt;cache:cacheable method=\"findBook\" key=\"#isbn\"/&gt;        &lt;cache:cache-evict method=\"loadBooks\" all-entries=\"true\"/&gt;    &lt;/cache:caching&gt;&lt;/cache:advice&gt;&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;&lt;aop:config&gt;    &lt;aop:advisor advice-ref=\"cacheAdvice\" pointcut=\"execution(* x.y.BookService.*(..))\"/&gt;&lt;/aop:config&gt;...// cache manager definition omitted                \n\r\n\rIn the configuration above, the bookService is made cacheable. The caching semantics to apply are encapsulated in the cache:advice definition which        instructs method findBooks to be used for putting data into the cache while method loadBooks for evicting data. Both definitions are working against the        books cache.        \n\r\n\rThe aop:config definition applies the cache advice to the appropriate points in the program by using the AspectJ pointcut expression (more information is available        in Chapter&nbsp;9, Aspect Oriented Programming with Spring). In the example above, all methods from the BookService are considered and the cache advice applied to them.        \n\r\n\rThe declarative XML caching supports all of the annotation-based model so moving between the two should be fairly easy - further more both can be used inside the same application.        The XML based approach does not touch the target code however it is inherently more verbose; when dealing with classes with overloaded methods that are targeted for caching, identifying the        proper methods does take an extra effort since the method argument is not a good discriminator - in these cases, the AspectJ pointcut can be used to cherry pick the target        methods and apply the appropriate caching functionality. However through XML, it is easier to apply a package/group/interface-wide caching (again due to the AspectJ pointcut) and to create        template-like definitions (as we did in the example above by defining the target cache through the cache:definitions cache attribute).                29.5&nbsp;Configuring the cache storage        \n\r\n\rOut of the box, the cache abstraction provides integration with two storages - one on top of the JDK ConcurrentMap and one    for ehcache library. To use them, one needs to simply declare an appropriate CacheManager - an entity that controls and manages    Caches and can be used to retrieve these for storage.    29.5.1&nbsp;JDK ConcurrentMap-based Cache                \n\r\n\rThe JDK-based Cache implementation resides under org.springframework.cache.concurrent package. It allows one to use         ConcurrentHashMap as a backing Cache store.    &lt;!-- generic cache manager --&gt;&lt;bean id=\"cacheManager\" class=\"org.springframework.cache.support.SimpleCacheManager\"&gt;    &lt;property name=\"caches\"&gt;    &lt;set&gt;        &lt;bean class=\"org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean\" p:name=\"default\"/&gt;        &lt;bean class=\"org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean\" p:name=\"books\"/&gt;    &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;        \n\r\n\rThe snippet above uses the SimpleCacheManager to create a CacheManager for the two, nested Concurrent        Cache implementations named default and books.        Note that the names are configured directly for each cache.        \n\r\n\rAs the cache is created by the application, it is bound to its lifecycle, making it suitable for basic use cases, tests or simple applications. The cache scales well and is very fast        but it does not provide any management or persistence capabilities nor eviction contracts.        29.5.2&nbsp;EhCache-based Cache                \n\r\n\rThe EhCache implementation is located under org.springframework.cache.ehcache package. Again, to use it, one simply needs to declare the appropriate        CacheManager:        &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\" p:cache-manager-ref=\"ehcache\"/&gt;&lt;!-- EhCache library setup --&gt;&lt;bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\" p:config-location=\"ehcache.xml\"/&gt;        \n\r\n\rThis setup bootstraps ehcache library inside Spring IoC (through bean ehcache) which is then wired into the dedicated CacheManager        implementation. Note the entire ehcache-specific configuration is read from the resource ehcache.xml.        29.5.3&nbsp;GemFire-based Cache                \n\r\n\rGemFire is a memory-oriented/disk-backed, elastically scalable, continuously available, active (with built-in pattern-based subscription notifications),        globally replicated database and provides fully-featured edge caching. For further information on how to use GemFire as a CacheManager (and more), please refer        to the Spring GemFire reference documentation.        29.5.4&nbsp;Dealing with caches without a backing store                \n\r\n\rSometimes when switching environments or doing testing, one might have cache declarations without an actual backing cache configured. As this is an invalid configuration, at runtime an        exception will be through since the caching infrastructure is unable to find a suitable store. In situations like this, rather then removing the cache declarations (which can prove tedious),        one can wire in a simple, dummy cache that performs no caching - that is, forces the cached methods to be executed every time:        &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.support.CompositeCacheManager\"&gt;    &lt;property name=\"cacheManagers\"&gt;&lt;list&gt;        &lt;ref bean=\"jdkCache\"/&gt;        &lt;ref bean=\"gemfireCache\"/&gt;    &lt;/list&gt;&lt;/property&gt;    &lt;property name=\"fallbackToNoOpCache\" value=\"true\"/&gt;&lt;/bean&gt;        \n\r\n\rThe CompositeCacheManager above chains multiple CacheManagers and additionally, through the fallbackToNoOpCache flag, adds a        no op cache that for all the definitions not handled by the configured cache managers. That is, every cache definition not found in either jdkCache        or gemfireCache (configured above) will be handled by the no op cache, which will not store any information causing the target method to be executed every time.                    29.6&nbsp;Plugging-in different back-end caches        \n\r\n\rClearly there are plenty of caching products out there that can be used as a backing store. To plug them in, one needs to provide a CacheManager and    Cache implementation since unfortunately there is no available standard that we can use instead. This may sound harder then it is since in practice,    the classes tend to be simple adapters that map the caching abstraction framework on top of the storage API as the ehcache classes can show.    Most CacheManager classes can use the classes in org.springframework.cache.support package, such as AbstractCacheManager    which takes care of the boiler-plate code leaving only the actual mapping to be completed. We hope that in time, the libraries that provide integration with Spring    can fill in this small configuration gap.        29.7&nbsp;How can I set the TTL/TTI/Eviction policy/XXX feature?                \n\r\n\rDirectly through your cache provider. The cache abstraction is... well, an abstraction not a cache implementation. The solution you are using might support various data policies and different        topologies which other solutions do not (take for example the JDK ConcurrentHashMap) - exposing that in the cache abstraction would be useless simply because there would        no backing support. Such functionality should be controlled directly through the backing cache, when configuring it or through its native API.        Prev&nbsp;Up&nbsp;Next28.&nbsp;Dynamic language support&nbsp;Home&nbsp;Part&nbsp;VII.&nbsp;Appendices","29. Cache Abstraction","scr\\cache.html","         25.&nbsp;JCA CCIPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next25.&nbsp;JCA CCI    25.1&nbsp;Introduction        \n\r\n\rJava EE provides a specification to standardize access to enterprise    information systems (EIS): the JCA (J2EE Connector Architecture). This    specification is divided into several different parts:    \n\r        \n\r\n\rSPI (Service provider interfaces) that the connector provider        must implement. These interfaces constitute a resource adapter which        can be deployed on a Java EE application server. In such a scenario, the        server manages connection pooling, transaction and security (managed        mode). The application server is also responsible for managing the        configuration, which is held outside the client application. A        connector can be used without an application server as well; in this        case, the application must configure it directly (non-managed        mode).      \n\r        \n\r\n\rCCI (Common Client Interface) that an application can use to        interact with the connector and thus communicate with an EIS. An API        for local transaction demarcation is provided as well.      \n\r    \n\r\n\rThe aim of the Spring CCI support is to provide classes to access a    CCI connector in typical Spring style, leveraging the Spring Framework\'s    general resource and transaction management facilities.    Note      \n\r\n\rThe client side of connectors doesn\'t alway use CCI. Some      connectors expose their own APIs, only providing JCA resource adapter to      use the system contracts of a Java EE container (connection pooling, global      transactions, security). Spring does not offer special support for such      connector-specific APIs.        25.2&nbsp;Configuring CCI        25.2.1&nbsp;Connector configuration            \n\r\n\rThe base resource to use JCA CCI is the      ConnectionFactory interface. The      connector used must provide an implementation of this interface.      \n\r\n\rTo use your connector, you can deploy it on your application      server and fetch the ConnectionFactory      from the server\'s JNDI environment (managed mode). The connector must be      packaged as a RAR file (resource adapter archive) and contain a      ra.xml file to describe its deployment      characteristics. The actual name of the resource is specified when you      deploy it. To access it within Spring, simply use Spring\'s      JndiObjectFactoryBean /      &lt;jee:jndi-lookup&gt; fetch the factory by its JNDI      name.      \n\r\n\rAnother way to use a connector is to embed it in your application      (non-managed mode), not using an application server to deploy and      configure it. Spring offers the possibility to configure a connector as      a bean, through a provided FactoryBean      (LocalConnectionFactoryBean). In this manner, you      only need the connector library in the classpath (no RAR file and no      ra.xml descriptor needed). The library must be      extracted from the connector\'s RAR file, if necessary.      \n\r\n\rOnce you have got access to your      ConnectionFactory instance, you can      inject it into your components. These components can either be coded      against the plain CCI API or leverage Spring\'s support classes for CCI      access (e.g. CciTemplate).      Note        \n\r\n\rWhen you use a connector in non-managed mode, you can\'t use        global transactions because the resource is never enlisted / delisted        in the current global transaction of the current thread. The resource        is simply not aware of any global Java EE transactions that might be        running.              25.2.2&nbsp;ConnectionFactory configuration in      Spring            \n\r\n\rIn order to make connections to the EIS, you need to obtain a      ConnectionFactory from the application      server if you are in a managed mode, or directly from Spring if you are      in a non-managed mode.      \n\r\n\rIn a managed mode, you access a      ConnectionFactory from JNDI; its      properties will be configured in the application server.      &lt;jee:jndi-lookup id=\"eciConnectionFactory\" jndi-name=\"eis/cicseci\"/&gt;      \n\r\n\rIn non-managed mode, you must configure the      ConnectionFactory you want to use in the      configuration of Spring as a JavaBean. The      LocalConnectionFactoryBean class offers this      setup style, passing in the      ManagedConnectionFactory implementation of your      connector, exposing the application-level CCI      ConnectionFactory.      &lt;bean id=\"eciManagedConnectionFactory\" class=\"com.ibm.connector2.cics.ECIManagedConnectionFactory\"&gt;  &lt;property name=\"serverName\" value=\"TXSERIES\"/&gt;  &lt;property name=\"connectionURL\" value=\"tcp://localhost/\"/&gt;  &lt;property name=\"portNumber\" value=\"2006\"/&gt;&lt;/bean&gt;&lt;bean id=\"eciConnectionFactory\" class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"eciManagedConnectionFactory\"/&gt;&lt;/bean&gt;      Note        \n\r\n\rYou can\'t directly instantiate a specific        ConnectionFactory. You need to go        through the corresponding implementation of the        ManagedConnectionFactory interface for your        connector. This interface is part of the JCA SPI specification.              25.2.3&nbsp;Configuring CCI connections            \n\r\n\rJCA CCI allow the developer to configure the connections to the      EIS using the ConnectionSpec      implementation of your connector. In order to configure its properties,      you need to wrap the target connection factory with a dedicated adapter,      ConnectionSpecConnectionFactoryAdapter. So, the      dedicated ConnectionSpec can be      configured with the property connectionSpec (as an      inner bean).      \n\r\n\rThis property is not mandatory because the CCI      ConnectionFactory interface defines two      different methods to obtain a CCI connection. Some of the      ConnectionSpec properties can often be      configured in the application server (in managed mode) or on the      corresponding local ManagedConnectionFactory      implementation.      public interface ConnectionFactory implements Serializable, Referenceable {  ...  Connection getConnection() throws ResourceException;  Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;  ...}      \n\r\n\rSpring provides a      ConnectionSpecConnectionFactoryAdapter that      allows for specifying a ConnectionSpec      instance to use for all operations on a given factory. If the adapter\'s      connectionSpec property is specified, the adapter      uses the getConnection variant with the      ConnectionSpec argument, otherwise	  the variant without argument.      &lt;bean id=\"managedConnectionFactory\"    class=\"com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory\"&gt;  &lt;property name=\"connectionURL\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/&gt;  &lt;property name=\"driverName\" value=\"org.hsqldb.jdbcDriver\"/&gt;&lt;/bean&gt;&lt;bean id=\"targetConnectionFactory\"    class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"managedConnectionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"connectionFactory\"    class=\"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter\"&gt;  &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt;  &lt;property name=\"connectionSpec\"&gt;    &lt;bean class=\"com.sun.connector.cciblackbox.CciConnectionSpec\"&gt;      &lt;property name=\"user\" value=\"sa\"/&gt;      &lt;property name=\"password\" value=\"\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;        25.2.4&nbsp;Using a single CCI connection            \n\r\n\rIf you want to use a single CCI connection, Spring provides a      further ConnectionFactory adapter to      manage this. The SingleConnectionFactory adapter      class will open a single connection lazily and close it when this bean      is destroyed at application shutdown. This class will expose special      Connection proxies that behave      accordingly, all sharing the same underlying physical connection.      &lt;bean id=\"eciManagedConnectionFactory\"    class=\"com.ibm.connector2.cics.ECIManagedConnectionFactory\"&gt;  &lt;property name=\"serverName\" value=\"TEST\"/&gt;  &lt;property name=\"connectionURL\" value=\"tcp://localhost/\"/&gt;  &lt;property name=\"portNumber\" value=\"2006\"/&gt;&lt;/bean&gt;&lt;bean id=\"targetEciConnectionFactory\"    class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"eciManagedConnectionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"eciConnectionFactory\"    class=\"org.springframework.jca.cci.connection.SingleConnectionFactory\"&gt;  &lt;property name=\"targetConnectionFactory\" ref=\"targetEciConnectionFactory\"/&gt;&lt;/bean&gt;      Note        \n\r\n\rThis ConnectionFactory adapter        cannot directly be configured with a        ConnectionSpec. Use an intermediary        ConnectionSpecConnectionFactoryAdapter that the        SingleConnectionFactory talks to if you require        a single connection for a specific        ConnectionSpec.              25.3&nbsp;Using Spring\'s CCI access support        25.3.1&nbsp;Record conversion            \n\r\n\rOne of the aims of the JCA CCI support is to provide convenient      facilities for manipulating CCI records. The developer can specify the      strategy to create records and extract datas from records, for use with      Spring\'s CciTemplate. The following interfaces      will configure the strategy to use input and output records if you don\'t      want to work with records directly in your application.      \n\r\n\rIn order to create an input Record,      the developer can use a dedicated implementation of the      RecordCreator interface.      public interface RecordCreator {  Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;}      \n\r\n\rAs you can see, the createRecord(..) method      receives a RecordFactory instance as      parameter, which corresponds to the      RecordFactory of the      ConnectionFactory used. This reference      can be used to create IndexedRecord or      MappedRecord instances. The following      sample shows how to use the RecordCreator      interface and indexed/mapped records.      public class MyRecordCreator implements RecordCreator {  public Record createRecord(RecordFactory recordFactory) throws ResourceException {    IndexedRecord input = recordFactory.createIndexedRecord(\"input\");    input.add(new Integer(id));    return input;  }}      \n\r\n\rAn output Record can be used to      receive data back from the EIS. Hence, a specific implementation of the      RecordExtractor interface can be passed      to Spring\'s CciTemplate for extracting data from      the output Record.      public interface RecordExtractor {  Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;}      \n\r\n\rThe following sample shows how to use the      RecordExtractor interface.      public class MyRecordExtractor implements RecordExtractor {  public Object extractData(Record record) throws ResourceException {    CommAreaRecord commAreaRecord = (CommAreaRecord) record;    String str = new String(commAreaRecord.toByteArray());    String field1 = string.substring(0,6);    String field2 = string.substring(6,1);    return new OutputObject(Long.parseLong(field1), field2);  }}        25.3.2&nbsp;The CciTemplate            \n\r\n\rThe CciTemplate is the central class of the      core CCI support package      (org.springframework.jca.cci.core). It simplifies the      use of CCI since it handles the creation and release of resources. This      helps to avoid common errors like forgetting to always close the      connection. It cares for the lifecycle of connection and interaction      objects, letting application code focus on generating input records from      application data and extracting application data from output      records.      \n\r\n\rThe JCA CCI specification defines two distinct methods to call      operations on an EIS. The CCI Interaction      interface provides two execute method signatures:      public interface javax.resource.cci.Interaction {  ...  boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;  Record execute(InteractionSpec spec, Record input) throws ResourceException;  ...}      \n\r\n\rDepending on the template method called,      CciTemplate will know which      execute method to call on the interaction. In any      case, a correctly initialized      InteractionSpec instance is      mandatory.      \n\r\n\rCciTemplate.execute(..) can be used in two      ways:      \n\r          \n\r\n\rWith direct Record arguments.          In this case, you simply need to pass the CCI input record in, and          the returned object be the corresponding CCI output record.        \n\r          \n\r\n\rWith application objects, using record mapping. In this case,          you need to provide corresponding          RecordCreator and          RecordExtractor instances.        \n\r      \n\r\n\rWith the first approach, the following methods of the template      will be used. These methods directly correspond to those on the      Interaction interface.      public class CciTemplate implements CciOperations {  public Record execute(InteractionSpec spec, Record inputRecord)      throws DataAccessException { ... }  public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)      throws DataAccessException { ... }}      \n\r\n\rWith the second approach, we need to specify the record creation      and record extraction strategies as arguments. The interfaces used are      those describe in the previous section on record conversion. The      corresponding CciTemplate methods are the      following:      public class CciTemplate implements CciOperations {  public Record execute(InteractionSpec spec, RecordCreator inputCreator)      throws DataAccessException { ... }  public Object execute(InteractionSpec spec, Record inputRecord, RecordExtractor outputExtractor)      throws DataAccessException { ... }  public Object execute(InteractionSpec spec, RecordCreator creator, RecordExtractor extractor)      throws DataAccessException { ... }}      \n\r\n\rUnless the outputRecordCreator property is set      on the template (see the following section), every method will call the      corresponding execute method of the CCI      Interaction with two parameters:      InteractionSpec and input      Record, receiving an output      Record as return value.      \n\r\n\rCciTemplate also provides methods to create      IndexRecord and MappedRecord      outside a RecordCreator implementation,      through its createIndexRecord(..) and      createMappedRecord(..) methods. This can be used      within DAO implementations to create      Record instances to pass into      corresponding CciTemplate.execute(..) methods.      public class CciTemplate implements CciOperations {  public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }  public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }}        25.3.3&nbsp;DAO support            \n\r\n\rSpring\'s CCI support provides a abstract class for DAOs,      supporting injection of a      ConnectionFactory or a      CciTemplate instances. The name of the class is      CciDaoSupport: It provides simple      setConnectionFactory and      setCciTemplate methods. Internally, this class will      create a CciTemplate instance for a passed-in      ConnectionFactory, exposing it to      concrete data access implementations in subclasses.      public abstract class CciDaoSupport {  public void setConnectionFactory(ConnectionFactory connectionFactory) { ... }  public ConnectionFactory getConnectionFactory() { ... }  public void setCciTemplate(CciTemplate cciTemplate) { ... }  public CciTemplate getCciTemplate() { ... }}        25.3.4&nbsp;Automatic output record generation            \n\r\n\rIf the connector used only supports the      Interaction.execute(..) method with input and      output records as parameters (that is, it requires the desired output      record to be passed in instead of returning an appropriate output      record), you can set the outputRecordCreator property      of the CciTemplate to automatically generate an      output record to be filled by the JCA connector when the response is      received. This record will be then returned to the caller of the      template.      \n\r\n\rThis property simply holds an implementation of the      RecordCreator interface, used for that      purpose. The RecordCreator interface has      already been discussed in Section&nbsp;25.3.1, &#8220;Record conversion&#8221;. The      outputRecordCreator property must be directly      specified on the CciTemplate. This could be done      in the application code like so:      cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());      \n\r\n\rOr (recommended) in the Spring configuration, if the      CciTemplate is configured as a dedicated bean      instance:      &lt;bean id=\"eciOutputRecordCreator\" class=\"eci.EciOutputRecordCreator\"/&gt;&lt;bean id=\"cciTemplate\" class=\"org.springframework.jca.cci.core.CciTemplate\"&gt;  &lt;property name=\"connectionFactory\" ref=\"eciConnectionFactory\"/&gt;  &lt;property name=\"outputRecordCreator\" ref=\"eciOutputRecordCreator\"/&gt;&lt;/bean&gt;      Note        \n\r\n\rAs the CciTemplate class is thread-safe,        it will usually be configured as a shared instance.              25.3.5&nbsp;Summary            \n\r\n\rThe following table summarizes the mechanisms of the      CciTemplate class and the corresponding methods      called on the CCI Interaction      interface:\n\r\n\rTable&nbsp;25.1.&nbsp;Usage of Interaction execute          methods                    CciTemplate method signatureCciTemplate outputRecordCreator                propertyexecute method called on the CCI                InteractionRecord execute(InteractionSpec,                Record)not setRecord execute(InteractionSpec,                Record)Record execute(InteractionSpec,                Record)setboolean execute(InteractionSpec, Record,                Record)void execute(InteractionSpec, Record,                Record)not setvoid execute(InteractionSpec, Record,                Record)void execute(InteractionSpec, Record,                Record)setvoid execute(InteractionSpec, Record,                Record)Record execute(InteractionSpec,                RecordCreator)not setRecord execute(InteractionSpec,                Record)Record execute(InteractionSpec,                RecordCreator)setvoid execute(InteractionSpec, Record,                Record)Record execute(InteractionSpec, Record,                RecordExtractor)not setRecord execute(InteractionSpec,                Record)Record execute(InteractionSpec, Record,                RecordExtractor)setvoid execute(InteractionSpec, Record,                Record)Record execute(InteractionSpec,                RecordCreator, RecordExtractor)not setRecord execute(InteractionSpec,                Record)Record execute(InteractionSpec,                RecordCreator, RecordExtractor)setvoid execute(InteractionSpec, Record,                Record)        \n\r\n\r\n\r        25.3.6&nbsp;Using a CCI Connection and      Interaction directly            \n\r\n\rCciTemplate also offers the possibility to      work directly with CCI connections and interactions, in the same manner      as JdbcTemplate and      JmsTemplate. This is useful when you want to      perform multiple operations on a CCI connection or interaction, for      example.      \n\r\n\rThe interface ConnectionCallback      provides a CCI Connection as argument, in      order to perform custom operations on it, plus the CCI      ConnectionFactory which the      Connection was created with. The latter      can be useful for example to get an associated      RecordFactory instance and create      indexed/mapped records, for example.      public interface ConnectionCallback {  Object doInConnection(Connection connection, ConnectionFactory connectionFactory)      throws ResourceException, SQLException, DataAccessException;}      \n\r\n\rThe interface InteractionCallback      provides the CCI Interaction, in order to      perform custom operations on it, plus the corresponding CCI      ConnectionFactory.      public interface InteractionCallback {  Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)      throws ResourceException, SQLException, DataAccessException;}      Note        \n\r\n\rInteractionSpec objects can        either be shared across multiple template calls or newly created        inside every callback method. This is completely up to the DAO        implementation.              25.3.7&nbsp;Example for CciTemplate usage            \n\r\n\rIn this section, the usage of the      CciTemplate will be shown to acces to a CICS with      ECI mode, with the IBM CICS ECI connector.      \n\r\n\rFirstly, some initializations on the CCI      InteractionSpec must be done to specify      which CICS program to access and how to interact with it.      ECIInteractionSpec interactionSpec = new ECIInteractionSpec();interactionSpec.setFunctionName(\"MYPROG\");interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);      \n\r\n\rThen the program can use CCI via Spring\'s template and specify      mappings between custom objects and CCI      Records.      public class MyDaoImpl extends CciDaoSupport implements MyDao {  public OutputObject getData(InputObject input) {    ECIInteractionSpec interactionSpec = ...;    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,        new RecordCreator() {          public Record createRecord(RecordFactory recordFactory) throws ResourceException {            return new CommAreaRecord(input.toString().getBytes());          }        },        new RecordExtractor() {          public Object extractData(Record record) throws ResourceException {            CommAreaRecord commAreaRecord = (CommAreaRecord)record;            String str = new String(commAreaRecord.toByteArray());            String field1 = string.substring(0,6);            String field2 = string.substring(6,1);            return new OutputObject(Long.parseLong(field1), field2);          }        });    return output;  }}      \n\r\n\rAs discussed previously, callbacks can be used to work directly on      CCI connections or interactions.      public class MyDaoImpl extends CciDaoSupport implements MyDao {  public OutputObject getData(InputObject input) {    ObjectOutput output = (ObjectOutput) getCciTemplate().execute(        new ConnectionCallback() {          public Object doInConnection(Connection connection, ConnectionFactory factory)              throws ResourceException {            // do something...          }        });    }    return output;  }}      Note        \n\r\n\rWith a ConnectionCallback, the        Connection used will be managed and        closed by the CciTemplate, but any interactions        created on the connection must be managed by the callback        implementation.            \n\r\n\rFor a more specific callback, you can implement an      InteractionCallback. The passed-in      Interaction will be managed and closed by      the CciTemplate in this case.      public class MyDaoImpl extends CciDaoSupport implements MyDao {  public String getData(String input) {    ECIInteractionSpec interactionSpec = ...;    String output = (String) getCciTemplate().execute(interactionSpec,        new InteractionCallback() {          public Object doInInteraction(Interaction interaction, ConnectionFactory factory)              throws ResourceException {            Record input = new CommAreaRecord(inputString.getBytes());            Record output = new CommAreaRecord();            interaction.execute(holder.getInteractionSpec(), input, output);            return new String(output.toByteArray());          }        });    return output;  }}      \n\r\n\rFor the examples above, the corresponding configuration of the      involved Spring beans could look like this in non-managed mode:      &lt;bean id=\"managedConnectionFactory\" class=\"com.ibm.connector2.cics.ECIManagedConnectionFactory\"&gt;  &lt;property name=\"serverName\" value=\"TXSERIES\"/&gt;  &lt;property name=\"connectionURL\" value=\"local:\"/&gt;  &lt;property name=\"userName\" value=\"CICSUSER\"/&gt;  &lt;property name=\"password\" value=\"CICS\"/&gt;&lt;/bean&gt;&lt;bean id=\"connectionFactory\" class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"managedConnectionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"component\" class=\"mypackage.MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;      \n\r\n\rIn managed mode (that is, in a Java EE environment), the      configuration could look as follows:      &lt;jee:jndi-lookup id=\"connectionFactory\" jndi-name=\"eis/cicseci\"/&gt;&lt;bean id=\"component\" class=\"MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;        25.4&nbsp;Modeling CCI access as operation objects        \n\r\n\rThe org.springframework.jca.cci.object package    contains support classes that allow you to access the EIS in a different    style: through reusable operation objects, analogous to Spring\'s JDBC    operation objects (see JDBC chapter). This will usually encapsulate the    CCI API: an application-level input object will be passed to the operation    object, so it can construct the input record and then convert the received    record data to an application-level output object and return it.    \n\r\n\rNote: This approach is internally based on the    CciTemplate class and the    RecordCreator /    RecordExtractor interfaces, reusing the    machinery of Spring\'s core CCI support.    25.4.1&nbsp;MappingRecordOperation            \n\r\n\rMappingRecordOperation essentially performs      the same work as CciTemplate, but represents a      specific, pre-configured operation as an object. It provides two      template methods to specify how to convert an input object to a input      record, and how to convert an output record to an output object (record      mapping):      \n\r          \n\r\n\rcreateInputRecord(..) to specify how to          convert an input object to an input          Record        \n\r          \n\r\n\rextractOutputData(..) to specify how to          extract an output object from an output          Record        \n\r      \n\r\n\rHere are the signatures of these methods:      public abstract class MappingRecordOperation extends EisOperation {  ...  protected abstract Record createInputRecord(RecordFactory recordFactory, Object inputObject)      throws ResourceException, DataAccessException { ... }  protected abstract Object extractOutputData(Record outputRecord)      throws ResourceException, SQLException, DataAccessException { ... }  ...}      \n\r\n\rThereafter, in order to execute an EIS operation, you need to use      a single execute method, passing in an application-level input object      and receiving an application-level output object as result:      public abstract class MappingRecordOperation extends EisOperation {  ...  public Object execute(Object inputObject) throws DataAccessException {  ...}      \n\r\n\rAs you can see, contrary to the CciTemplate      class, this execute(..) method does not have an      InteractionSpec as argument. Instead, the      InteractionSpec is global to the      operation. The following constructor must be used to instantiate an      operation object with a specific      InteractionSpec:      InteractionSpec spec = ...;MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);...        25.4.2&nbsp;MappingCommAreaOperation            \n\r\n\rSome connectors use records based on a COMMAREA which represents      an array of bytes containing parameters to send to the EIS and data      returned by it. Spring provides a special operation class for working      directly on COMMAREA rather than on records. The      MappingCommAreaOperation class extends the      MappingRecordOperation class to provide such      special COMMAREA support. It implicitly uses the      CommAreaRecord class as input and output record      type, and provides two new methods to convert an input object into an      input COMMAREA and the output COMMAREA into an output object.      public abstract class MappingCommAreaOperation extends MappingRecordOperation {  ...  protected abstract byte[] objectToBytes(Object inObject)      throws IOException, DataAccessException;  protected abstract Object bytesToObject(byte[] bytes)      throws IOException, DataAccessException;  ...}        25.4.3&nbsp;Automatic output record generation            \n\r\n\rAs every MappingRecordOperation subclass is      based on CciTemplate internally, the same way to automatically generate      output records as with CciTemplate is available.      Every operation object provides a corresponding      setOutputRecordCreator(..) method. For further      information, see Section&nbsp;25.3.4, &#8220;Automatic output record generation&#8221;.        25.4.4&nbsp;Summary            \n\r\n\rThe operation object approach uses records in the same manner as      the CciTemplate class.      \n\r\n\rTable&nbsp;25.2.&nbsp;Usage of Interaction execute methods                MappingRecordOperation              method signatureMappingRecordOperation              outputRecordCreator propertyexecute method called on the CCI              InteractionObject execute(Object)not setRecord execute(InteractionSpec,              Record)Object execute(Object)setboolean execute(InteractionSpec, Record,              Record)      \n\r        25.4.5&nbsp;Example for MappingRecordOperation      usage            \n\r\n\rIn this section, the usage of the      MappingRecordOperation will be shown to access a      database with the Blackbox CCI connector.      Note        \n\r\n\rThe original version of this connector is provided by the Java EE        SDK (version 1.3), available from Sun.            \n\r\n\rFirstly, some initializations on the CCI      InteractionSpec must be done to specify      which SQL request to execute. In this sample, we directly define the way      to convert the parameters of the request to a CCI record and the way to      convert the CCI result record to an instance of the      Person class.      public class PersonMappingOperation extends MappingRecordOperation {  public PersonMappingOperation(ConnectionFactory connectionFactory) {    setConnectionFactory(connectionFactory);    CciInteractionSpec interactionSpec = new CciConnectionSpec();    interactionSpec.setSql(\"select * from person where person_id=?\");    setInteractionSpec(interactionSpec);  }  protected Record createInputRecord(RecordFactory recordFactory, Object inputObject)      throws ResourceException {    Integer id = (Integer) inputObject;    IndexedRecord input = recordFactory.createIndexedRecord(\"input\");    input.add(new Integer(id));    return input;  }  protected Object extractOutputData(Record outputRecord)      throws ResourceException, SQLException {    ResultSet rs = (ResultSet) outputRecord;    Person person = null;    if (rs.next()) {      Person person = new Person();      person.setId(rs.getInt(\"person_id\"));      person.setLastName(rs.getString(\"person_last_name\"));      person.setFirstName(rs.getString(\"person_first_name\"));    }    return person;  }}      \n\r\n\rThen the application can execute the operation object, with the      person identifier as argument. Note that operation object could be set      up as shared instance, as it is thread-safe.      public class MyDaoImpl extends CciDaoSupport implements MyDao {  public Person getPerson(int id) {    PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());    Person person = (Person) query.execute(new Integer(id));    return person;  }}      \n\r\n\rThe corresponding configuration of Spring beans could look as      follows in non-managed mode:      &lt;bean id=\"managedConnectionFactory\"    class=\"com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory\"&gt;  &lt;property name=\"connectionURL\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/&gt;  &lt;property name=\"driverName\" value=\"org.hsqldb.jdbcDriver\"/&gt;&lt;/bean&gt;&lt;bean id=\"targetConnectionFactory\"    class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"managedConnectionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"connectionFactory\"    class=\"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter\"&gt;  &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt;  &lt;property name=\"connectionSpec\"&gt;    &lt;bean class=\"com.sun.connector.cciblackbox.CciConnectionSpec\"&gt;      &lt;property name=\"user\" value=\"sa\"/&gt;      &lt;property name=\"password\" value=\"\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"component\" class=\"MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;      \n\r\n\rIn managed mode (that is, in a Java EE environment), the      configuration could look as follows:      &lt;jee:jndi-lookup id=\"targetConnectionFactory\" jndi-name=\"eis/blackbox\"/&gt;&lt;bean id=\"connectionFactory\"    class=\"org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter\"&gt;  &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt;  &lt;property name=\"connectionSpec\"&gt;    &lt;bean class=\"com.sun.connector.cciblackbox.CciConnectionSpec\"&gt;      &lt;property name=\"user\" value=\"sa\"/&gt;      &lt;property name=\"password\" value=\"\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"component\" class=\"MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;        25.4.6&nbsp;Example for MappingCommAreaOperation      usage            \n\r\n\rIn this section, the usage of the      MappingCommAreaOperation will be shown: accessing      a CICS with ECI mode with the IBM CICS ECI connector.      \n\r\n\rFirstly, the CCI InteractionSpec      needs to be initialized to specify which CICS program to access and how      to interact with it.      public abstract class EciMappingOperation extends MappingCommAreaOperation {  public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {    setConnectionFactory(connectionFactory);    ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),    interactionSpec.setFunctionName(programName);    interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);    interactionSpec.setCommareaLength(30);    setInteractionSpec(interactionSpec);    setOutputRecordCreator(new EciOutputRecordCreator());  }  private static class EciOutputRecordCreator implements RecordCreator {    public Record createRecord(RecordFactory recordFactory) throws ResourceException {      return new CommAreaRecord();    }  }}      \n\r\n\rThe abstract EciMappingOperation class can      then be subclassed to specify mappings between custom objects and      Records.      public class MyDaoImpl extends CciDaoSupport implements MyDao {  public OutputObject getData(Integer id) {    EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), \"MYPROG\") {      protected abstract byte[] objectToBytes(Object inObject) throws IOException {        Integer id = (Integer) inObject;        return String.valueOf(id);      }      protected abstract Object bytesToObject(byte[] bytes) throws IOException;        String str = new String(bytes);        String field1 = str.substring(0,6);        String field2 = str.substring(6,1);        String field3 = str.substring(7,1);        return new OutputObject(field1, field2, field3);      }    });    return (OutputObject) query.execute(new Integer(id));  }}      \n\r\n\rThe corresponding configuration of Spring beans could look as      follows in non-managed mode:      &lt;bean id=\"managedConnectionFactory\" class=\"com.ibm.connector2.cics.ECIManagedConnectionFactory\"&gt;  &lt;property name=\"serverName\" value=\"TXSERIES\"/&gt;  &lt;property name=\"connectionURL\" value=\"local:\"/&gt;  &lt;property name=\"userName\" value=\"CICSUSER\"/&gt;  &lt;property name=\"password\" value=\"CICS\"/&gt;&lt;/bean&gt;&lt;bean id=\"connectionFactory\" class=\"org.springframework.jca.support.LocalConnectionFactoryBean\"&gt;  &lt;property name=\"managedConnectionFactory\" ref=\"managedConnectionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"component\" class=\"MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;      \n\r\n\rIn managed mode (that is, in a Java EE environment), the      configuration could look as follows:      &lt;jee:jndi-lookup id=\"connectionFactory\" jndi-name=\"eis/cicseci\"/&gt;&lt;bean id=\"component\" class=\"MyDaoImpl\"&gt;  &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;&lt;/bean&gt;        25.5&nbsp;Transactions        \n\r\n\rJCA specifies several levels of transaction support for resource    adapters. The kind of transactions that your resource adapter supports is    specified in its ra.xml file. There are essentially    three options: none (for example with CICS EPI connector), local    transactions (for example with a CICS ECI connector), global transactions    (for example with an IMS connector).    &lt;connector&gt;  &lt;resourceadapter&gt;    &lt;!-- &lt;transaction-support&gt;NoTransaction&lt;/transaction-support&gt; --&gt;    &lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt; --&gt;    &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;  &lt;resourceadapter&gt;&lt;connector&gt;    \n\r\n\rFor global transactions, you can use Spring\'s generic transaction    infrastructure to demarcate transactions, with    JtaTransactionManager as backend (delegating to the    Java EE server\'s distributed transaction coordinator underneath).    \n\r\n\rFor local transactions on a single CCI    ConnectionFactory, Spring provides a    specific transaction management strategy for CCI, analogous to the    DataSourceTransactionManager for JDBC. The CCI API    defines a local transaction object and corresponding local transaction    demarcation methods. Spring\'s    CciLocalTransactionManager executes such local CCI    transactions, fully compliant with Spring\'s generic    PlatformTransactionManager    abstraction.    &lt;jee:jndi-lookup id=\"eciConnectionFactory\" jndi-name=\"eis/cicseci\"/&gt;&lt;bean id=\"eciTransactionManager\"    class=\"org.springframework.jca.cci.connection.CciLocalTransactionManager\"&gt;  &lt;property name=\"connectionFactory\" ref=\"eciConnectionFactory\"/&gt;&lt;/bean&gt;    \n\r\n\rBoth transaction strategies can be used with any of Spring\'s    transaction demarcation facilities, be it declarative or programmatic.    This is a consequence of Spring\'s generic    PlatformTransactionManager abstraction,    which decouples transaction demarcation from the actual execution    strategy. Simply switch between    JtaTransactionManager and    CciLocalTransactionManager as needed, keeping your    transaction demarcation as-is.    \n\r\n\rFor more information on Spring\'s transaction facilities, see the    chapter entitled Chapter&nbsp;12, Transaction Management.  Prev&nbsp;Up&nbsp;Next24.&nbsp;JMX&nbsp;Home&nbsp;26.&nbsp;Email","25. JCA CCI","scr\\cci.html","         Appendix&nbsp;B.&nbsp;Classic Spring AOP UsagePrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;B.&nbsp;Classic Spring AOP Usage    \n\r\n\rIn this appendix we discuss    the lower-level Spring AOP APIs and the AOP support used in Spring 1.2 applications.    For new applications, we recommend the use of the Spring 2.0 AOP support    described in the AOP chapter, but when working with existing applications,    or when reading books and articles, you may come across Spring 1.2 style examples.    Spring 2.0 is fully backwards compatible with Spring 1.2 and everything described    in this appendix is fully supported in Spring 2.0.  B.1&nbsp;Pointcut API in Spring        \n\r\n\rLet\'s look at how Spring handles the crucial pointcut concept.    B.1.1&nbsp;Concepts            \n\r\n\rSpring\'s pointcut model enables pointcut reuse independent of      advice types. It\'s possible to target different advice using the same      pointcut.      \n\r\n\rThe org.springframework.aop.Pointcut interface      is the central interface, used to target advices to particular classes      and methods. The complete interface is shown below:      public interface Pointcut {    ClassFilter getClassFilter();    MethodMatcher getMethodMatcher();}      \n\r\n\rSplitting the Pointcut interface into two parts      allows reuse of class and method matching parts, and fine-grained      composition operations (such as performing a \"union\" with another method      matcher).      \n\r\n\rThe ClassFilter interface is used to restrict      the pointcut to a given set of target classes. If the      matches() method always returns true, all target      classes will be matched:      public interface ClassFilter {    boolean matches(Class clazz);}      \n\r\n\rThe MethodMatcher interface is normally more      important. The complete interface is shown below:      public interface MethodMatcher {    boolean matches(Method m, Class targetClass);    boolean isRuntime();    boolean matches(Method m, Class targetClass, Object[] args);}      \n\r\n\rThe matches(Method, Class) method is used to      test whether this pointcut will ever match a given method on a target      class. This evaluation can be performed when an AOP proxy is created, to      avoid the need for a test on every method invocation. If the 2-argument      matches method returns true for a given method, and the      isRuntime() method for the MethodMatcher returns      true, the 3-argument matches method will be invoked on every method      invocation. This enables a pointcut to look at the arguments passed to      the method invocation immediately before the target advice is to      execute.      \n\r\n\rMost MethodMatchers are static, meaning that their      isRuntime() method returns false. In this case, the      3-argument matches method will never be invoked.            Tip                \n\r\n\rIf possible, try to make pointcuts static, allowing the AOP                framework to cache the results of pointcut evaluation when an AOP proxy                is created.                    B.1.2&nbsp;Operations on pointcuts            \n\r\n\rSpring supports operations on pointcuts: notably,      union and intersection.            \n\r                    \n\r\n\rUnion means the methods that either pointcut matches.                \n\r                    \n\r\n\rIntersection means the methods that both pointcuts match.                \n\r                    \n\r\n\rUnion is usually more useful.                \n\r                    \n\r\n\rPointcuts can be composed using the static methods in the                    org.springframework.aop.support.Pointcuts class, or                    using the ComposablePointcut class in the same                    package. However, using AspectJ pointcut expressions is usually a                    simpler approach.                \n\r        B.1.3&nbsp;AspectJ expression pointcuts            \n\r\n\rSince 2.0, the most important type of pointcut used by Spring is      org.springframework.aop.aspectj.AspectJExpressionPointcut.      This is a pointcut that uses an AspectJ supplied library to parse an AspectJ      pointcut expression string.      \n\r\n\rSee the previous chapter for a discussion of supported AspectJ pointcut      primitives.              B.1.4&nbsp;Convenience pointcut implementations            \n\r\n\rSpring provides several convenient pointcut implementations. Some      can be used out of the box; others are intended to be subclassed in      application-specific pointcuts.      Static pointcuts                \n\r\n\rStatic pointcuts are based on method and target class, and        cannot take into account the method\'s arguments. Static pointcuts are        sufficient - and best - for most usages. It\'s possible for Spring to        evaluate a static pointcut only once, when a method is first invoked:        after that, there is no need to evaluate the pointcut again with each        method invocation.        \n\r\n\rLet\'s consider some static pointcut implementations included        with Spring.        Regular expression pointcuts                    \n\r\n\rOne obvious way to specify static pointcuts is regular          expressions. Several AOP frameworks besides Spring make this          possible.          org.springframework.aop.support.Perl5RegexpMethodPointcut          is a generic regular expression pointcut, using Perl 5 regular          expression syntax. The Perl5RegexpMethodPointcut          class depends on Jakarta ORO for regular expression matching. Spring          also provides the JdkRegexpMethodPointcut class          that uses the regular expression support in JDK 1.4+.          \n\r\n\rUsing the Perl5RegexpMethodPointcut class,          you can provide a list of pattern Strings. If any of these is a          match, the pointcut will evaluate to true. (So the result is          effectively the union of these pointcuts.)          \n\r\n\rThe usage is shown below:          &lt;bean id=\"settersAndAbsquatulatePointcut\"    class=\"org.springframework.aop.support.Perl5RegexpMethodPointcut\"&gt;    &lt;property name=\"patterns\"&gt;        &lt;list&gt;            &lt;value&gt;.*set.*&lt;/value&gt;            &lt;value&gt;.*absquatulate&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;          \n\r\n\rSpring provides a convenience class,          RegexpMethodPointcutAdvisor, that allows us to          also reference an Advice (remember that an Advice can be an          interceptor, before advice, throws advice etc.). Behind the scenes,          Spring will use a JdkRegexpMethodPointcut. Using          RegexpMethodPointcutAdvisor simplifies wiring,          as the one bean encapsulates both pointcut and advice, as shown          below:          &lt;bean id=\"settersAndAbsquatulateAdvisor\"    class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\"&gt;    &lt;property name=\"advice\"&gt;        &lt;ref local=\"beanNameOfAopAllianceInterceptor\"/&gt;    &lt;/property&gt;    &lt;property name=\"patterns\"&gt;        &lt;list&gt;            &lt;value&gt;.*set.*&lt;/value&gt;            &lt;value&gt;.*absquatulate&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;          \n\r\n\rRegexpMethodPointcutAdvisor can be used          with any Advice type.                Attribute-driven pointcuts                    \n\r\n\rAn important type of static pointcut is a          metadata-driven pointcut. This uses the values          of metadata attributes: typically, source-level metadata.                    Dynamic pointcuts                \n\r\n\rDynamic pointcuts are costlier to evaluate than static        pointcuts. They take into account method        arguments, as well as static information. This        means that they must be evaluated with every method invocation; the        result cannot be cached, as arguments will vary.        \n\r\n\rThe main example is the control flow        pointcut.        Control flow pointcuts                    \n\r\n\rSpring control flow pointcuts are conceptually similar to          AspectJ cflow pointcuts, although less          powerful. (There is currently no way to specify that a pointcut          executes below a join point matched by another pointcut.)          A control flow pointcut matches          the current call stack. For example, it might fire if the join point          was invoked by a method in the com.mycompany.web          package, or by the SomeCaller class. Control flow          pointcuts are specified using the          org.springframework.aop.support.ControlFlowPointcut          class.Note              \n\r\n\rControl flow pointcuts are significantly more expensive to              evaluate at runtime than even other dynamic pointcuts. In Java 1.4,              the cost is about 5 times that of other dynamic pointcuts.                                  B.1.5&nbsp;Pointcut superclasses            \n\r\n\rSpring provides useful pointcut superclasses to help you to      implement your own pointcuts.      \n\r\n\rBecause static pointcuts are most useful, you\'ll probably subclass      StaticMethodMatcherPointcut, as shown below. This requires implementing      just one abstract method (although it\'s possible to override other      methods to customize behavior):      class TestStaticPointcut extends StaticMethodMatcherPointcut {    public boolean matches(Method m, Class targetClass) {        // return true if custom criteria match    }}\n\r\n\rThere are also superclasses for dynamic pointcuts.      \n\r\n\rYou can use custom pointcuts with any advice type in Spring 1.0      RC2 and above.        B.1.6&nbsp;Custom pointcuts            \n\r\n\rBecause pointcuts in Spring AOP are Java classes, rather than      language features (as in AspectJ) it\'s possible to declare custom      pointcuts, whether static or dynamic. Custom pointcuts in Spring can be      arbitrarily complex. However, using the AspectJ pointcut expression      language is recommended if possible.      Note                \n\r\n\rLater versions of Spring may offer support for \"semantic                pointcuts\" as offered by JAC: for example, \"all methods that change                instance variables in the target object.\"                    B.2&nbsp;Advice API in Spring        \n\r\n\rLet\'s now look at how Spring AOP handles advice.    B.2.1&nbsp;Advice lifecycles            \n\r\n\rEach advice is a Spring bean. An advice instance can be shared across all      advised objects, or unique      to each advised object. This corresponds to      per-class or per-instance      advice.      \n\r\n\rPer-class advice is used most often. It is appropriate for generic      advice such as transaction advisors. These do not depend on the state of      the proxied object or add new state; they merely act on the method and      arguments.      \n\r\n\rPer-instance advice is appropriate for introductions, to support      mixins. In this case, the advice adds state to the proxied      object.      \n\r\n\rIt\'s possible to use a mix of shared and per-instance advice in      the same AOP proxy.        B.2.2&nbsp;Advice types in Spring            \n\r\n\rSpring provides several advice types out of the box, and is      extensible to support arbitrary advice types. Let us look at the basic      concepts and standard advice types.      Interception around advice                \n\r\n\rThe most fundamental advice type in Spring is        interception around advice.        \n\r\n\rSpring is compliant with the AOP Alliance interface for around        advice using method interception. MethodInterceptors implementing        around advice should implement the following interface:        public interface MethodInterceptor extends Interceptor {    Object invoke(MethodInvocation invocation) throws Throwable;}        \n\r\n\rThe MethodInvocation argument to the        invoke() method exposes the method being invoked;        the target join point; the AOP proxy; and the arguments to the method.        The invoke() method should return the        invocation\'s result: the return value of the join point.        \n\r\n\rA simple MethodInterceptor implementation        looks as follows:        public class DebugInterceptor implements MethodInterceptor {    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println(\"Before: invocation=[\" + invocation + \"]\");        Object rval = invocation.proceed();        System.out.println(\"Invocation returned\");        return rval;    }}        \n\r\n\rNote the call to the MethodInvocation\'s        proceed() method. This proceeds down the        interceptor chain towards the join point. Most interceptors will invoke        this method, and return its return value. However, a        MethodInterceptor, like any around advice, can return a different        value or throw an exception rather than invoke the proceed method.        However, you don\'t want to do this without good reason!        Note\n\r\n\rMethodInterceptors offer interoperability with other AOP        Alliance-compliant AOP implementations. The other advice types        discussed in the remainder of this section implement common AOP        concepts, but in a Spring-specific way. While there is an advantage in        using the most specific advice type, stick with MethodInterceptor        around advice if you are likely to want to run the aspect in another        AOP framework. Note that pointcuts are not currently interoperable        between frameworks, and the AOP Alliance does not currently define        pointcut interfaces.            Before advice                \n\r\n\rA simpler advice type is a before        advice. This does not need a        MethodInvocation object, since it will only be        called before entering the method.        \n\r\n\rThe main advantage of a before advice is that there is no need        to invoke the proceed() method, and therefore no        possibility of inadvertently failing to proceed down the interceptor        chain.        \n\r\n\rThe MethodBeforeAdvice interface is shown        below. (Spring\'s API design would allow for field before advice,        although the usual objects apply to field interception and it\'s        unlikely that Spring will ever implement it).        public interface MethodBeforeAdvice extends BeforeAdvice {    void before(Method m, Object[] args, Object target) throws Throwable;}        \n\r\n\rNote the return type is void. Before        advice can insert custom behavior before the join point executes, but        cannot change the return value. If a before advice throws an        exception, this will abort further execution of the interceptor chain.        The exception will propagate back up the interceptor chain. If it is        unchecked, or on the signature of the invoked method, it will be        passed directly to the client; otherwise it will be wrapped in an        unchecked exception by the AOP proxy.        \n\r\n\rAn example of a before advice in Spring, which counts all method        invocations:        public class CountingBeforeAdvice implements MethodBeforeAdvice {    private int count;    public void before(Method m, Object[] args, Object target) throws Throwable {        ++count;    }    public int getCount() {        return count;    }}        Tip\n\r\n\rBefore advice can be used with any pointcut.            Throws advice                \n\r\n\rThrows advice is invoked after        the return of the join point if the join point threw an exception.        Spring offers typed throws advice. Note that this means that the        org.springframework.aop.ThrowsAdvice interface does        not contain any methods: It is a tag interface identifying that the        given object implements one or more typed throws advice methods. These        should be in the form of:        afterThrowing([Method, args, target], subclassOfThrowable)         \n\r\n\rOnly the last argument is required. The method signatures may        have either one or four arguments, depending on whether the advice        method is interested in the method and arguments. The following        classes are examples of throws advice.        \n\r\n\rThe advice below is invoked if a RemoteException            is thrown (including subclasses):        public class RemoteThrowsAdvice implements ThrowsAdvice {    public void afterThrowing(RemoteException ex) throws Throwable {        // Do something with remote exception    }}        \n\r\n\rThe following advice is invoked if a        ServletException is thrown. Unlike the above        advice, it declares 4 arguments, so that it has access to the invoked        method, method arguments and target object:        public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {        // Do something with all arguments    }}        \n\r\n\rThe final example illustrates how these two methods could be        used in a single class, which handles both        RemoteException and        ServletException. Any number of throws advice        methods can be combined in a single class.        public static class CombinedThrowsAdvice implements ThrowsAdvice {    public void afterThrowing(RemoteException ex) throws Throwable {        // Do something with remote exception    }    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {        // Do something with all arguments    }}        \n\r\n\rNote: If a throws-advice method throws an exception itself,        it will override the original exception (i.e. change the exception thrown to the user).        The overriding exception will typically be a RuntimeException; this is compatible with        any method signature. However, if a throws-advice method throws a checked exception,        it will have to match the declared exceptions of the target method and is hence to some        degree coupled to specific target method signatures. Do not throw an undeclared        checked exception that is incompatible with the target method\'s signature!                Tip\n\r\n\rThrows advice can be used with any pointcut.            After Returning advice                \n\r\n\rAn after returning advice in Spring must implement the        org.springframework.aop.AfterReturningAdvice        interface, shown below:        public interface AfterReturningAdvice extends Advice {    void afterReturning(Object returnValue, Method m, Object[] args, Object target)            throws Throwable;}        \n\r\n\rAn after returning advice has access to the return value (which        it cannot modify), invoked method, methods arguments and        target.        \n\r\n\rThe following after returning advice counts all successful        method invocations that have not thrown exceptions:        public class CountingAfterReturningAdvice implements AfterReturningAdvice {    private int count;    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)            throws Throwable {        ++count;    }    public int getCount() {        return count;    }}        \n\r\n\rThis advice doesn\'t change the execution path. If it throws an        exception, this will be thrown up the interceptor chain instead of the        return value.                Tip\n\r\n\rAfter returning advice can be used with any pointcut.            Introduction advice                \n\r\n\rSpring treats introduction advice as a special kind of        interception advice.        \n\r\n\rIntroduction requires an IntroductionAdvisor,        and an IntroductionInterceptor, implementing the        following interface:        public interface IntroductionInterceptor extends MethodInterceptor {    boolean implementsInterface(Class intf);}        \n\r\n\rThe invoke() method inherited from the AOP        Alliance MethodInterceptor interface must implement        the introduction: that is, if the invoked method is on an introduced        interface, the introduction interceptor is responsible for handling        the method call - it cannot invoke proceed().        \n\r\n\rIntroduction advice cannot be used with any pointcut, as it        applies only at class, rather than method, level. You can only use        introduction advice with the IntroductionAdvisor,        which has the following methods:        public interface IntroductionAdvisor extends Advisor, IntroductionInfo {    ClassFilter getClassFilter();    void validateInterfaces() throws IllegalArgumentException;}public interface IntroductionInfo {    Class[] getInterfaces();}        \n\r\n\rThere is no MethodMatcher, and hence no        Pointcut, associated with introduction advice. Only        class filtering is logical.        \n\r\n\rThe getInterfaces() method returns the        interfaces introduced by this advisor.        \n\r\n\rThe validateInterfaces() method is used internally to        see whether or not the introduced interfaces can be implemented by the configured        IntroductionInterceptor.        \n\r\n\rLet\'s look at a simple example from the Spring test suite. Let\'s        suppose we want to introduce the following interface to one or more        objects:        \n\r\n\r          public interface Lockable {    void lock();    void unlock();    boolean locked();}\n\r\n\r                \n\r\n\rThis illustrates a mixin. We        want to be able to cast advised objects to Lockable, whatever their        type, and call lock and unlock methods. If we call the lock() method,        we want all setter methods to throw a        LockedException. Thus we can add an aspect that        provides the ability to make objects immutable, without them having        any knowledge of it: a good example of AOP.        \n\r\n\rFirstly, we\'ll need an        IntroductionInterceptor that does the heavy        lifting. In this case, we extend the        org.springframework.aop.support.DelegatingIntroductionInterceptor        convenience class. We could implement IntroductionInterceptor        directly, but using        DelegatingIntroductionInterceptor is best for most        cases.        \n\r\n\rThe DelegatingIntroductionInterceptor is        designed to delegate an introduction to an actual implementation of        the introduced interface(s), concealing the use of interception to do        so. The delegate can be set to any object using a constructor        argument; the default delegate (when the no-arg constructor is used)        is this. Thus in the example below, the delegate is the        LockMixin subclass of        DelegatingIntroductionInterceptor. Given a delegate        (by default itself), a        DelegatingIntroductionInterceptor instance looks        for all interfaces implemented by the delegate (other than        IntroductionInterceptor), and will support introductions against any        of them. It\'s possible for subclasses such as        LockMixin to call the        suppressInterface(Class intf) method to suppress        interfaces that should not be exposed. However, no matter how many        interfaces an IntroductionInterceptor is prepared        to support, the IntroductionAdvisor used will        control which interfaces are actually exposed. An introduced interface        will conceal any implementation of the same interface by the        target.        \n\r\n\rThus LockMixin subclasses        DelegatingIntroductionInterceptor and implements        Lockable itself. The superclass automatically picks up that Lockable        can be supported for introduction, so we don\'t need to specify that.        We could introduce any number of interfaces in this way.        \n\r\n\rNote the use of the locked instance variable.        This effectively adds additional state to that held in the target        object.        \n\r\n\r          public class LockMixin extends DelegatingIntroductionInterceptor    implements Lockable {    private boolean locked;    public void lock() {        this.locked = true;    }    public void unlock() {        this.locked = false;    }    public boolean locked() {        return this.locked;    }    public Object invoke(MethodInvocation invocation) throws Throwable {        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf(\"set\") == 0)            throw new LockedException();        return super.invoke(invocation);    }}\n\r\n\r                \n\r\n\rOften it isn\'t necessary to override the invoke()        method: the        DelegatingIntroductionInterceptor        implementation - which calls the delegate method if the method is        introduced, otherwise proceeds towards the join point - is usually        sufficient. In the present case, we need to add a check: no setter        method can be invoked if in locked mode.        \n\r\n\rThe introduction advisor required is simple. All it needs to do        is hold a distinct LockMixin instance, and specify        the introduced interfaces - in this case, just        Lockable. A more complex example might take a        reference to the introduction interceptor (which would be defined as a        prototype): in this case, there\'s no configuration relevant for a        LockMixin, so we simply create it using        new.        \n\r\n\r          public class LockMixinAdvisor extends DefaultIntroductionAdvisor {    public LockMixinAdvisor() {        super(new LockMixin(), Lockable.class);    }}\n\r\n\r                \n\r\n\rWe can apply this advisor very simply: it requires no        configuration. (However, it is necessary: It\'s        impossible to use an IntroductionInterceptor        without an IntroductionAdvisor.) As usual with        introductions, the advisor must be per-instance, as it is stateful. We        need a different instance of LockMixinAdvisor, and        hence LockMixin, for each advised object. The        advisor comprises part of the advised object\'s state.        \n\r\n\rWe can apply this advisor programmatically, using the        Advised.addAdvisor() method, or (the recommended        way) in XML configuration, like any other advisor. All proxy creation        choices discussed below, including \"auto proxy creators,\" correctly        handle introductions and stateful mixins.              B.3&nbsp;Advisor API in Spring        \n\r\n\rIn Spring, an Advisor is an aspect that contains just a single advice    object associated with a pointcut expression.    \n\r\n\rApart from the special case of introductions, any advisor can be    used with any advice.    org.springframework.aop.support.DefaultPointcutAdvisor    is the most commonly used advisor class. For example, it can be used with    a MethodInterceptor, BeforeAdvice or    ThrowsAdvice.    \n\r\n\rIt is possible to mix advisor and advice types in Spring in the same    AOP proxy. For example, you could use a interception around advice, throws    advice and before advice in one proxy configuration: Spring will    automatically create the necessary interceptor chain.    B.4&nbsp;Using the ProxyFactoryBean to create AOP proxies        \n\r\n\rIf you\'re using the Spring IoC container (an ApplicationContext or    BeanFactory) for your business objects - and you should be! - you will want    to use one of Spring\'s AOP FactoryBeans. (Remember that a factory bean    introduces a layer of indirection, enabling it to create objects of a    different type.)        Note            \n\r\n\rThe Spring 2.0 AOP support also uses factory beans under the covers.        \n\r\n\rThe basic way to create an AOP proxy in Spring is to use the    org.springframework.aop.framework.ProxyFactoryBean.    This gives complete control over the pointcuts and advice that will apply,    and their ordering. However, there are simpler options that are preferable    if you don\'t need such control.    B.4.1&nbsp;Basics            \n\r\n\rThe ProxyFactoryBean, like other Spring      FactoryBean implementations, introduces a level of      indirection. If you define a ProxyFactoryBean with      name foo, what objects referencing      foo see is not the      ProxyFactoryBean instance itself, but an object      created by the ProxyFactoryBean\'s implementation of      the getObject() method. This method will create an      AOP proxy wrapping a target object.      \n\r\n\rOne of the most important benefits of using a      ProxyFactoryBean or another IoC-aware class to create      AOP proxies, is that it means that advices and pointcuts can also be      managed by IoC. This is a powerful feature, enabling certain approaches      that are hard to achieve with other AOP frameworks. For example, an      advice may itself reference application objects (besides the target,      which should be available in any AOP framework), benefiting from all the      pluggability provided by Dependency Injection.        B.4.2&nbsp;JavaBean properties            \n\r\n\r        In common with most FactoryBean implementations        provided with Spring, the ProxyFactoryBean class is        itself a JavaBean. Its properties are used to:            \n\r          \n\r\n\rSpecify the target you want to proxy.        \n\r          \n\r\n\rSpecify whether to use CGLIB (see below and also            Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).        \n\r      \n\r\n\r        Some key properties are inherited from        org.springframework.aop.framework.ProxyConfig (the        superclass for all AOP proxy factories in Spring). These key properties include:            \n\r          \n\r\n\r            proxyTargetClass: true if the            target class is to be proxied, rather than the target class\' interfaces.            If this property value is set to true, then CGLIB proxies            will be created (but see also below Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).                  \n\r          \n\r\n\r            optimize: controls whether or not aggressive            optimizations are applied to proxies created via CGLIB.            One should not blithely use this setting unless one fully understands            how the relevant AOP proxy handles optimization. This is currently used only            for CGLIB proxies; it has no effect with JDK dynamic proxies.                  \n\r            \n\r\n\rfrozen: if a proxy configuration is frozen,            then changes to the configuration are no longer allowed. This is useful both as            a slight optimization and for those cases when you don\'t want callers to be able            to manipulate the proxy (via the Advised interface)            after the proxy has been created. The default value of this property is            false, so changes such as adding additional advice are allowed.        \n\r          \n\r\n\r            exposeProxy: determines whether or not the current            proxy should be exposed in a ThreadLocal so that            it can be accessed by the target. If a target needs to obtain            the proxy and the exposeProxy property is set to            true, the target can use the            AopContext.currentProxy() method.                  \n\r          \n\r\n\r            aopProxyFactory: the implementation of            AopProxyFactory to use. Offers a way of            customizing whether to use dynamic proxies, CGLIB or any other proxy            strategy. The default implementation will choose dynamic proxies or            CGLIB appropriately. There should be no need to use this property;            it is intended to allow the addition of new proxy types in Spring 1.1.                  \n\r      \n\r\n\r        Other properties specific to ProxyFactoryBean include:            \n\r          \n\r\n\r            proxyInterfaces: array of String interface            names. If this isn\'t supplied, a CGLIB proxy for the target class            will be used (but see also below Section&nbsp;10.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;).                  \n\r          \n\r\n\r            interceptorNames: String array of            Advisor, interceptor or other advice            names to apply. Ordering is significant, on a first come-first served            basis. That is to say that the first interceptor in the list            will be the first to be able to intercept the invocation.                    \n\r\n\r            The names are bean names in the current factory, including            bean names from ancestor factories. You can\'t mention bean            references here since doing so would result in the            ProxyFactoryBean ignoring the singleton            setting of the advice.                    \n\r\n\r            You can append an interceptor name with an asterisk            (*). This will result in the application of all            advisor beans with names starting with the part before the asterisk            to be applied. An example of using this feature can be found in            Section&nbsp;10.5.6, &#8220;Using \'global\' advisors&#8221;.                  \n\r          \n\r\n\r            singleton: whether or not the factory should return a single            object, no matter how often the getObject()            method is called. Several FactoryBean            implementations offer such a method. The default value is            true. If you	want to use stateful advice -            for example, for stateful mixins - use	prototype advices along            with a singleton value of false.                  \n\r        B.4.3&nbsp;JDK- and CGLIB-based proxies                \n\r\n\r            This section serves as the definitive documentation on how the            ProxyFactoryBean chooses to create one of            either a JDK- and CGLIB-based proxy for a particular target object            (that is to be proxied).                Note            \n\r\n\r                The behavior of the ProxyFactoryBean with regard                to creating JDK- or CGLIB-based proxies changed between versions 1.2.x and                2.0 of Spring. The ProxyFactoryBean now                exhibits similar semantics with regard to auto-detecting interfaces                as those of the TransactionProxyFactoryBean class.                            \n\r\n\r            If the class of a target object that is to be proxied (hereafter simply            referred to as the target class) doesn\'t implement any interfaces, then            a CGLIB-based proxy will be created. This is the easiest scenario, because            JDK proxies are interface based, and no interfaces means JDK proxying            isn\'t even possible. One simply plugs in the target bean, and specifies the            list of interceptors via the interceptorNames property.            Note that a CGLIB-based proxy will be created even if the            proxyTargetClass property of the            ProxyFactoryBean has been set to false.            (Obviously this makes no sense, and is best removed from the bean            definition because it is at best redundant, and at worst confusing.)                \n\r\n\r            If the target class implements one (or more) interfaces, then the type of            proxy that is created depends on the configuration of the            ProxyFactoryBean.                \n\r\n\r            If the proxyTargetClass property of the            ProxyFactoryBean has been set to true,            then a CGLIB-based proxy will be created. This makes sense, and is in            keeping with the principle of least surprise. Even if the            proxyInterfaces property of the            ProxyFactoryBean has been set to one or more            fully qualified interface names, the fact that the            proxyTargetClass property is set to            true will cause            CGLIB-based proxying to be in effect.                \n\r\n\r            If the proxyInterfaces property of the            ProxyFactoryBean has been set to one or more            fully qualified interface names, then a JDK-based proxy will be created.            The created proxy will implement all of the interfaces that were specified            in the proxyInterfaces property; if the target class            happens to implement a whole lot more interfaces than those specified in            the proxyInterfaces property, that is all well and            good but those additional interfaces will not be implemented by the            returned proxy.                \n\r\n\r            If the proxyInterfaces property of the            ProxyFactoryBean has not been            set, but the target class does implement one (or more)            interfaces, then the ProxyFactoryBean will auto-detect            the fact that the target class does actually implement at least one interface,            and a JDK-based proxy will be created. The interfaces that are actually            proxied will be all of the interfaces that the target            class implements; in effect, this is the same as simply supplying a list            of each and every interface that the target class implements to the            proxyInterfaces property. However, it is significantly less            work, and less prone to typos.                B.4.4&nbsp;Proxying interfaces            \n\r\n\r        Let\'s look at a simple example of ProxyFactoryBean        in action. This example involves:            \n\r          \n\r\n\rA target bean that will be proxied. This          is the \"personTarget\" bean definition in the example below.        \n\r          \n\r\n\rAn Advisor and an Interceptor used to provide advice.        \n\r          \n\r\n\rAn AOP proxy bean definition specifying the target object (the          personTarget bean) and the interfaces to proxy, along with the          advices to apply.        \n\r      &lt;bean id=\"personTarget\" class=\"com.mycompany.PersonImpl\"&gt;    &lt;property name=\"name\"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;    &lt;property name=\"age\"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\"&gt;    &lt;property name=\"someProperty\"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"&gt;&lt;/bean&gt;&lt;bean id=\"person\"    class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;    &lt;property name=\"proxyInterfaces\"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;    &lt;property name=\"target\"&gt;&lt;ref local=\"personTarget\"/&gt;&lt;/property&gt;    &lt;property name=\"interceptorNames\"&gt;        &lt;list&gt;            &lt;value&gt;myAdvisor&lt;/value&gt;            &lt;value&gt;debugInterceptor&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rNote that the interceptorNames property takes a      list of String: the bean names of the interceptor or advisors in the      current factory. Advisors, interceptors, before, after returning and      throws advice objects can be used. The ordering of advisors is      significant.            Note                \n\r\n\rYou might be wondering why the list doesn\'t hold bean                references. The reason for this is that if the ProxyFactoryBean\'s                singleton property is set to false, it must be able to return                independent proxy instances. If any of the advisors is itself a                prototype, an independent instance would need to be returned, so it\'s                necessary to be able to obtain an instance of the prototype from the                factory; holding a reference isn\'t sufficient.                  \n\r\n\rThe \"person\" bean definition above can be used in place of a      Person implementation, as follows:      Person person = (Person) factory.getBean(\"person\");      \n\r\n\rOther beans in the same IoC context can express a strongly typed      dependency on it, as with an ordinary Java object:      &lt;bean id=\"personUser\" class=\"com.mycompany.PersonUser\"&gt;  &lt;property name=\"person\"&gt;&lt;ref local=\"person\" /&gt;&lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe PersonUser class in this example would      expose a property of type Person. As far as it\'s concerned, the AOP      proxy can be used transparently in place of a \"real\" person      implementation. However, its class would be a dynamic proxy class. It      would be possible to cast it to the Advised interface      (discussed below).      \n\r\n\rIt\'s possible to conceal the distinction between target and proxy      using an anonymous inner bean, as follows. Only the      ProxyFactoryBean definition is different; the advice      is included only for completeness:      &lt;bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\"&gt;  &lt;property name=\"someProperty\"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/&gt;&lt;bean id=\"person\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"proxyInterfaces\"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;  &lt;!-- Use inner bean, not local reference to target --&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"com.mycompany.PersonImpl\"&gt;      &lt;property name=\"name\"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;      &lt;property name=\"age\"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;    &lt;/bean&gt;  &lt;/property&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;myAdvisor&lt;/value&gt;      &lt;value&gt;debugInterceptor&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThis has the advantage that there\'s only one object of type      Person: useful if we want to prevent users of the      application context from obtaining a reference to the un-advised object, or      need to avoid any ambiguity with Spring IoC      autowiring. There\'s also arguably an advantage in      that the ProxyFactoryBean definition is self-contained. However, there      are times when being able to obtain the un-advised target from the      factory might actually be an advantage: for      example, in certain test scenarios.        B.4.5&nbsp;Proxying classes            \n\r\n\rWhat if you need to proxy a class, rather than one or more      interfaces?      \n\r\n\rImagine that in our example above, there was no      Person interface: we needed to advise a class called      Person that didn\'t implement any business interface.      In this case, you can configure Spring to use CGLIB proxying, rather      than dynamic proxies. Simply set the proxyTargetClass      property on the ProxyFactoryBean above to true. While it\'s best to      program to interfaces, rather than classes, the ability to advise      classes that don\'t implement interfaces can be useful when working with      legacy code. (In general, Spring isn\'t prescriptive. While it makes it      easy to apply good practices, it avoids forcing a particular      approach.)      \n\r\n\rIf you want to, you can force the use of CGLIB in any case, even if      you do have interfaces.      \n\r\n\rCGLIB proxying works by generating a subclass of the target class      at runtime. Spring configures this generated subclass to delegate method      calls to the original target: the subclass is used to implement the      Decorator pattern, weaving in the advice.      \n\r\n\rCGLIB proxying should generally be transparent to users. However,      there are some issues to consider:      \n\r          \n\r\n\rFinal methods can\'t be advised, as they          can\'t be overridden.        \n\r          \n\r\n\rAs of Spring 3.2 it is no longer required to add CGLIB to your          project classpath. CGLIB classes have been repackaged under          org.springframework and included directly in the spring-core JAR. This          is both for user convenience as well as to avoid potential conflicts          with other projects that have dependence on a differing version of          CGLIB.        \n\r      \n\r\n\rThere\'s little performance difference between CGLIB proxying and      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.      However, this may change in the future. Performance should not be a      decisive consideration in this case.        B.4.6&nbsp;Using \'global\' advisors            \n\r\n\rBy appending an asterisk to an interceptor name, all advisors with      bean names matching the part before the asterisk, will be added to the      advisor chain. This can come in handy if you need to add a standard set      of \'global\' advisors: &lt;bean id=\"proxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"target\" ref=\"service\"/&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;global*&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"global_debug\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/&gt;&lt;bean id=\"global_performance\" class=\"org.springframework.aop.interceptor.PerformanceMonitorInterceptor\"/&gt;        B.5&nbsp;Concise proxy definitions        \n\r\n\rEspecially when defining transactional proxies, you may end up with    many similar proxy definitions. The use of parent and child bean    definitions, along with inner bean definitions, can result in much cleaner    and more concise proxy definitions.    \n\r\n\rFirst a parent, template, bean definition is    created for the proxy:    &lt;bean id=\"txProxyTemplate\" abstract=\"true\"        class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributes\"&gt;    &lt;props&gt;      &lt;prop key=\"*\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;    &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rThis will never be instantiated itself, so may actually be    incomplete. Then each proxy which needs to be created is just a child bean    definition, which wraps the target of the proxy as an inner bean    definition, since the target will never be used on its own    anyway.&lt;bean id=\"myService\" parent=\"txProxyTemplate\"&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"org.springframework.samples.MyServiceImpl\"&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rIt is of course possible to override properties from the parent    template, such as in this case, the transaction propagation    settings:&lt;bean id=\"mySpecialService\" parent=\"txProxyTemplate\"&gt;  &lt;property name=\"target\"&gt;    &lt;bean class=\"org.springframework.samples.MySpecialServiceImpl\"&gt;    &lt;/bean&gt;  &lt;/property&gt;  &lt;property name=\"transactionAttributes\"&gt;    &lt;props&gt;      &lt;prop key=\"get*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"find*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"load*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;      &lt;prop key=\"store*\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;    &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rNote that in the example above, we have explicitly marked the parent    bean definition as abstract by using the    abstract attribute, as described previously, so that it may    not actually ever be instantiated. Application contexts (but not simple    bean factories) will by default pre-instantiate all singletons. It is therefore    important (at least for singleton beans) that if you have a (parent)    bean definition which you intend to use only as a template, and this    definition specifies a class, you must make sure to set the    abstract attribute to true,    otherwise the application context will actually try to pre-instantiate    it.    B.6&nbsp;Creating AOP proxies programmatically with the ProxyFactory        \n\r\n\rIt\'s easy to create AOP proxies programmatically using Spring. This    enables you to use Spring AOP without dependency on Spring IoC.    \n\r\n\rThe following listing shows creation of a proxy for a target object,    with one interceptor and one advisor. The interfaces implemented by the    target object will automatically be proxied:    ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);factory.addInterceptor(myMethodInterceptor);factory.addAdvisor(myAdvisor);MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();    \n\r\n\rThe first step is to construct an object of type    org.springframework.aop.framework.ProxyFactory. You can    create this with a target object, as in the above example, or specify the    interfaces to be proxied in an alternate constructor.    \n\r\n\rYou can add interceptors or advisors, and manipulate them for the    life of the ProxyFactory. If you add an    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement    additional interfaces.    \n\r\n\rThere are also convenience methods on ProxyFactory (inherited from    AdvisedSupport) which allow you to add other advice types        such as before and throws advice. AdvisedSupport is the superclass of both    ProxyFactory and ProxyFactoryBean.        Tip            \n\r\n\rIntegrating AOP proxy creation with the IoC framework is best            practice in most applications. We recommend that you externalize            configuration from Java code with AOP, as in general.            B.7&nbsp;Manipulating advised objects        \n\r\n\rHowever you create AOP proxies, you can manipulate them using the    org.springframework.aop.framework.Advised interface.    Any AOP proxy can be cast to this interface, whichever other interfaces it    implements. This interface includes the following methods:    Advisor[] getAdvisors();void addAdvice(Advice advice) throws AopConfigException;void addAdvice(int pos, Advice advice)        throws AopConfigException;void addAdvisor(Advisor advisor) throws AopConfigException;void addAdvisor(int pos, Advisor advisor) throws AopConfigException;int indexOf(Advisor advisor);boolean removeAdvisor(Advisor advisor) throws AopConfigException;void removeAdvisor(int index) throws AopConfigException;boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;boolean isFrozen();    \n\r\n\rThe getAdvisors() method will return an Advisor    for every advisor, interceptor or other advice type that has been added to    the factory. If you added an Advisor, the returned advisor at this index    will be the object that you added. If you added an interceptor or other    advice type, Spring will have wrapped this in an advisor with a pointcut    that always returns true. Thus if you added a    MethodInterceptor, the advisor returned for this index    will be an DefaultPointcutAdvisor returning your    MethodInterceptor and a pointcut that matches all    classes and methods.    \n\r\n\rThe addAdvisor() methods can be used to add any    Advisor. Usually the advisor holding pointcut and advice will be the    generic DefaultPointcutAdvisor, which can be used with    any advice or pointcut (but not for introductions).    \n\r\n\rBy default, it\'s possible to add or remove advisors or interceptors    even once a proxy has been created. The only restriction is that it\'s    impossible to add or remove an introduction advisor, as existing proxies    from the factory will not show the interface change. (You can obtain a new    proxy from the factory to avoid this problem.)    \n\r\n\rA simple example of casting an AOP proxy to the    Advised interface and examining and manipulating its    advice:    Advised advised = (Advised) myObject;Advisor[] advisors = advised.getAdvisors();int oldAdvisorCount = advisors.length;System.out.println(oldAdvisorCount + \" advisors\");// Add an advice like an interceptor without a pointcut// Will match all proxied methods// Can use for interceptors, before, after returning or throws adviceadvised.addAdvice(new DebugInterceptor());// Add selective advice using a pointcutadvised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));assertEquals(\"Added two advisors\",     oldAdvisorCount + 2, advised.getAdvisors().length);        Note            \n\r\n\rIt\'s questionable whether it\'s advisable (no pun intended) to            modify advice on a business object in production, although there are no            doubt legitimate usage cases. However, it can be very useful in            development: for example, in tests. I have sometimes found it very useful            to be able to add test code in the form of an interceptor or other advice,            getting inside a method invocation I want to test. (For example, the            advice can get inside a transaction created for that method: for example,            to run SQL to check that a database was correctly updated, before marking            the transaction for roll back.)            \n\r\n\rDepending on how you created the proxy, you can usually set a    frozen flag, in which case the    Advised isFrozen() method will    return true, and any attempts to modify advice through addition or removal    will result in an AopConfigException. The ability to    freeze the state of an advised object is useful in some cases, for    example, to prevent calling code removing a security interceptor. It may    also be used in Spring 1.1 to allow aggressive optimization if runtime    advice modification is known not to be required.    B.8&nbsp;Using the \"autoproxy\" facility        \n\r\n\rSo far we\'ve considered explicit creation of AOP proxies using a    ProxyFactoryBean or similar factory bean.    \n\r\n\rSpring also allows us to use \"autoproxy\" bean definitions, which can    automatically proxy selected bean definitions. This is built on Spring    \"bean post processor\" infrastructure, which enables modification of any    bean definition as the container loads.    \n\r\n\rIn this model, you set up some special bean definitions in your XML    bean definition file to configure the auto proxy infrastructure. This    allows you just to declare the targets eligible for autoproxying: you    don\'t need to use ProxyFactoryBean.    \n\r\n\rThere are two ways to do this:    \n\r        \n\r\n\rUsing an autoproxy creator that refers to specific beans in the        current context.      \n\r        \n\r\n\rA special case of autoproxy creation that deserves to be        considered separately; autoproxy creation driven by source-level        metadata attributes.      \n\r    B.8.1&nbsp;Autoproxy bean definitions            \n\r\n\rThe org.springframework.aop.framework.autoproxy      package provides the following standard autoproxy creators.      BeanNameAutoProxyCreator                \n\r\n\rThe BeanNameAutoProxyCreator class is a        BeanPostProcessor that automatically creates AOP proxies        for beans with names matching literal values or wildcards.        &lt;bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\"&gt;  &lt;property name=\"beanNames\"&gt;&lt;value&gt;jdk*,onlyJdk&lt;/value&gt;&lt;/property&gt;  &lt;property name=\"interceptorNames\"&gt;    &lt;list&gt;      &lt;value&gt;myInterceptor&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;        \n\r\n\rAs with ProxyFactoryBean, there is an        interceptorNames property rather than a list of interceptors, to allow        correct behavior for prototype advisors. Named \"interceptors\" can be        advisors or any advice type.        \n\r\n\rAs with auto proxying in general, the main point of using        BeanNameAutoProxyCreator is to apply the same        configuration consistently to multiple objects, with minimal        volume of configuration. It is a popular choice for applying        declarative transactions to multiple objects.        \n\r\n\rBean definitions whose names match, such as \"jdkMyBean\" and        \"onlyJdk\" in the above example, are plain old bean definitions with        the target class. An AOP proxy will be created automatically by the        BeanNameAutoProxyCreator. The same advice will be        applied to all matching beans. Note that if advisors are used (rather        than the interceptor in the above example), the pointcuts may apply        differently to different beans.            DefaultAdvisorAutoProxyCreator                \n\r\n\rA more general and extremely powerful auto proxy creator is        DefaultAdvisorAutoProxyCreator. This will        automagically apply eligible advisors in the current context, without        the need to include specific bean names in the autoproxy advisor\'s        bean definition. It offers the same merit of consistent configuration        and avoidance of duplication as        BeanNameAutoProxyCreator.        \n\r\n\rUsing this mechanism involves:        \n\r            \n\r\n\rSpecifying a            DefaultAdvisorAutoProxyCreator bean            definition.          \n\r            \n\r\n\rSpecifying any number of Advisors in the same or related            contexts. Note that these must be Advisors,            not just interceptors or other advices. This is necessary because            there must be a pointcut to evaluate, to check the eligibility of            each advice to candidate bean definitions.          \n\r        \n\r\n\rThe DefaultAdvisorAutoProxyCreator will        automatically evaluate the pointcut contained in each advisor, to see        what (if any) advice it should apply to each business object (such as        \"businessObject1\" and \"businessObject2\" in the example).        \n\r\n\rThis means that any number of advisors can be applied        automatically to each business object. If no pointcut in any of the        advisors matches any method in a business object, the object will not        be proxied. As bean definitions are added for new business objects,        they will automatically be proxied if necessary.        \n\r\n\rAutoproxying in general has the advantage of making it        impossible for callers or dependencies to obtain an un-advised object.        Calling getBean(\"businessObject1\") on this ApplicationContext will        return an AOP proxy, not the target business object. (The \"inner bean\"        idiom shown earlier also offers this benefit.)        &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"customAdvisor\" class=\"com.mycompany.MyAdvisor\"/&gt;&lt;bean id=\"businessObject1\" class=\"com.mycompany.BusinessObject1\"&gt;  &lt;!-- Properties omitted --&gt;&lt;/bean&gt;&lt;bean id=\"businessObject2\" class=\"com.mycompany.BusinessObject2\"/&gt;        \n\r\n\rThe DefaultAdvisorAutoProxyCreator is very        useful if you want to apply the same advice consistently to many        business objects. Once the infrastructure definitions are in place,        you can simply add new business objects without including specific        proxy configuration. You can also drop in additional aspects very        easily - for example, tracing or performance monitoring aspects - with        minimal change to configuration.        \n\r\n\rThe DefaultAdvisorAutoProxyCreator offers support for filtering        (using a naming convention so that only certain advisors are        evaluated, allowing use of multiple, differently configured,        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors        can implement the org.springframework.core.Ordered        interface to ensure correct ordering if this is an issue. The        TransactionAttributeSourceAdvisor used in the above example has a        configurable order value; the default setting is unordered.            AbstractAdvisorAutoProxyCreator                \n\r\n\rThis is the superclass of DefaultAdvisorAutoProxyCreator. You        can create your own autoproxy creators by subclassing this class, in        the unlikely event that advisor definitions offer insufficient        customization to the behavior of the framework        DefaultAdvisorAutoProxyCreator.              B.8.2&nbsp;Using metadata-driven auto-proxying            \n\r\n\rA particularly important type of autoproxying is driven by      metadata. This produces a similar programming model to .NET      ServicedComponents. Instead of using XML deployment      descriptors as in EJB, configuration for transaction management and      other enterprise services is held in source-level attributes.      \n\r\n\rIn this case, you use the      DefaultAdvisorAutoProxyCreator, in combination with      Advisors that understand metadata attributes. The metadata specifics are      held in the pointcut part of the candidate advisors, rather than in the      autoproxy creation class itself.      \n\r\n\rThis is really a special case of the      DefaultAdvisorAutoProxyCreator, but deserves      consideration on its own. (The metadata-aware code is in the pointcuts      contained in the advisors, not the AOP framework itself.)      \n\r\n\rThe /attributes directory of the JPetStore      sample application shows the use of attribute-driven autoproxying. In      this case, there\'s no need to use the      TransactionProxyFactoryBean. Simply defining      transactional attributes on business objects is sufficient, because of      the use of metadata-aware pointcuts. The bean definitions include the      following code, in /WEB-INF/declarativeServices.xml.      Note that this is generic, and can be used outside the JPetStore:      &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"transactionInterceptor\"    class=\"org.springframework.transaction.interceptor.TransactionInterceptor\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributeSource\"&gt;    &lt;bean class=\"org.springframework.transaction.interceptor.AttributesTransactionAttributeSource\"&gt;      &lt;property name=\"attributes\" ref=\"attributes\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"attributes\" class=\"org.springframework.metadata.commons.CommonsAttributes\"/&gt;      \n\r\n\rThe DefaultAdvisorAutoProxyCreator bean      definition (the name is not significant, hence it can even be omitted)      will pick up all eligible pointcuts in the current application context.      In this case, the \"transactionAdvisor\" bean definition, of type      TransactionAttributeSourceAdvisor, will apply to      classes or methods carrying a transaction attribute. The      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,      via constructor dependency. The example resolves this via autowiring.      The AttributesTransactionAttributeSource depends on      an implementation of the      org.springframework.metadata.Attributes interface. In      this fragment, the \"attributes\" bean satisfies this, using the Jakarta      Commons Attributes API to obtain attribute information. (The application      code must have been compiled using the Commons Attributes compilation      task.)      \n\r\n\rThe /annotation directory of the JPetStore      sample application contains an analogous example for auto-proxying      driven by JDK 1.5+ annotations. The following configuration enables      automatic detection of Spring\'s Transactional      annotation, leading to implicit proxies for beans containing that      annotation:      &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\"&gt;  &lt;property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"transactionInterceptor\"    class=\"org.springframework.transaction.interceptor.TransactionInterceptor\"&gt;  &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;  &lt;property name=\"transactionAttributeSource\"&gt;    &lt;bean class=\"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\"/&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe TransactionInterceptor defined here depends      on a PlatformTransactionManager definition, which is      not included in this generic file (although it could be) because it will      be specific to the application\'s transaction requirements (typically      JTA, as in this example, or Hibernate, JDO or JDBC):      &lt;bean id=\"transactionManager\"    class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;            Tip                \n\r\n\rIf you require only declarative transaction management, using                these generic XML definitions will result in Spring automatically                proxying all classes or methods with transaction attributes. You won\'t                need to work directly with AOP, and the programming model is similar to                that of .NET ServicedComponents.                  \n\r\n\rThis mechanism is extensible. It\'s possible to do autoproxying      based on custom attributes. You need to:      \n\r          \n\r\n\rDefine your custom attribute.        \n\r          \n\r\n\rSpecify an Advisor with the necessary advice, including a          pointcut that is triggered by the presence of the custom attribute          on a class or method. You may be able to use an existing advice,          merely implementing a static pointcut that picks up the custom          attribute.        \n\r      \n\r\n\rIt\'s possible for such advisors to be unique to each advised class      (for example, mixins): they simply need to be defined as prototype,      rather than singleton, bean definitions. For example, the      LockMixin introduction interceptor from the Spring      test suite, shown above, could be used in conjunction with an      attribute-driven pointcut to target a mixin, as shown here. We use the      generic DefaultPointcutAdvisor, configured using      JavaBean properties:      &lt;bean id=\"lockMixin\" class=\"org.springframework.aop.LockMixin\"    scope=\"prototype\"/&gt;&lt;bean id=\"lockableAdvisor\" class=\"org.springframework.aop.support.DefaultPointcutAdvisor\"    scope=\"prototype\"&gt;  &lt;property name=\"pointcut\" ref=\"myAttributeAwarePointcut\"/&gt;  &lt;property name=\"advice\" ref=\"lockMixin\"/&gt;&lt;/bean&gt;&lt;bean id=\"anyBean\" class=\"anyclass\" ...      \n\r\n\rIf the attribute aware pointcut matches any methods in the      anyBean or other bean definitions, the mixin will be      applied. Note that both lockMixin and      lockableAdvisor definitions are prototypes. The      myAttributeAwarePointcut pointcut can be a singleton      definition, as it doesn\'t hold state for individual advised      objects.        B.9&nbsp;Using TargetSources        \n\r\n\rSpring offers the concept of a TargetSource,    expressed in the org.springframework.aop.TargetSource    interface. This interface is responsible for returning the \"target object\"    implementing the join point. The TargetSource    implementation is asked for a target instance each time the AOP proxy    handles a method invocation.    \n\r\n\rDevelopers using Spring AOP don\'t normally need to work directly    with TargetSources, but this provides a powerful means of supporting    pooling, hot swappable and other sophisticated targets. For example, a    pooling TargetSource can return a different target instance for each    invocation, using a pool to manage instances.    \n\r\n\rIf you do not specify a TargetSource, a default implementation is    used that wraps a local object. The same target is returned for each    invocation (as you would expect).    \n\r\n\rLet\'s look at the standard target sources provided with Spring, and    how you can use them.        Tip            \n\r\n\rWhen using a custom target source, your target will usually need            to be a prototype rather than a singleton bean definition. This allows            Spring to create a new target instance when required.            B.9.1&nbsp;Hot swappable target sources            \n\r\n\rThe      org.springframework.aop.target.HotSwappableTargetSource      exists to allow the target of an AOP proxy to be switched while allowing      callers to keep their references to it.      \n\r\n\rChanging the target source\'s target takes effect immediately. The      HotSwappableTargetSource is threadsafe.      \n\r\n\rYou can change the target via the swap() method      on HotSwappableTargetSource as follows:      HotSwappableTargetSource swapper =    (HotSwappableTargetSource) beanFactory.getBean(\"swapper\");Object oldTarget = swapper.swap(newTarget);      \n\r\n\rThe XML definitions required look as follows:      &lt;bean id=\"initialTarget\" class=\"mycompany.OldTarget\"/&gt;&lt;bean id=\"swapper\" class=\"org.springframework.aop.target.HotSwappableTargetSource\"&gt;  &lt;constructor-arg ref=\"initialTarget\"/&gt;&lt;/bean&gt;&lt;bean id=\"swappable\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"targetSource\" ref=\"swapper\"/&gt;&lt;/bean&gt;      \n\r\n\rThe above swap() call changes the target of the      swappable bean. Clients who hold a reference to that bean will be      unaware of the change, but will immediately start hitting the new      target.      \n\r\n\rAlthough this example doesn\'t add any advice - and it\'s not      necessary to add advice to use a TargetSource - of      course any TargetSource can be used in conjunction      with arbitrary advice.        B.9.2&nbsp;Pooling target sources            \n\r\n\rUsing a pooling target source provides a similar programming model      to stateless session EJBs, in which a pool of identical instances is      maintained, with method invocations going to free objects in the      pool.      \n\r\n\rA crucial difference between Spring pooling and SLSB pooling is      that Spring pooling can be applied to any POJO. As with Spring in      general, this service can be applied in a non-invasive way.      \n\r\n\rSpring provides out-of-the-box support for Jakarta Commons Pool      1.3, which provides a fairly efficient pooling implementation. You\'ll      need the commons-pool Jar on your application\'s classpath to use this      feature. It\'s also possible to subclass      org.springframework.aop.target.AbstractPoolingTargetSource      to support any other pooling API.      \n\r\n\rSample configuration is shown below:      &lt;bean id=\"businessObjectTarget\" class=\"com.mycompany.MyBusinessObject\"    scope=\"prototype\"&gt;  ... properties omitted&lt;/bean&gt;&lt;bean id=\"poolTargetSource\" class=\"org.springframework.aop.target.CommonsPoolTargetSource\"&gt;  &lt;property name=\"targetBeanName\" value=\"businessObjectTarget\"/&gt;  &lt;property name=\"maxSize\" value=\"25\"/&gt;&lt;/bean&gt;&lt;bean id=\"businessObject\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;  &lt;property name=\"targetSource\" ref=\"poolTargetSource\"/&gt;  &lt;property name=\"interceptorNames\" value=\"myInterceptor\"/&gt;&lt;/bean&gt;      \n\r\n\rNote that the target object - \"businessObjectTarget\" in the      example - must be a prototype. This allows the      PoolingTargetSource implementation to create new      instances of the target to grow the pool as necessary. See the Javadoc      for AbstractPoolingTargetSource and the concrete      subclass you wish to use for information about its properties: \"maxSize\"      is the most basic, and always guaranteed to be present.      \n\r\n\rIn this case, \"myInterceptor\" is the name of an interceptor that      would need to be defined in the same IoC context. However, it isn\'t      necessary to specify interceptors to use pooling. If you want only      pooling, and no other advice, don\'t set the interceptorNames property at      all.      \n\r\n\rIt\'s possible to configure Spring so as to be able to cast any      pooled object to the      org.springframework.aop.target.PoolingConfig      interface, which exposes information about the configuration and current      size of the pool through an introduction. You\'ll need to define an      advisor like this:      &lt;bean id=\"poolConfigAdvisor\" class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"poolTargetSource\"/&gt;  &lt;property name=\"targetMethod\" value=\"getPoolingConfigMixin\"/&gt;&lt;/bean&gt;      \n\r\n\rThis advisor is obtained by calling a convenience method on the      AbstractPoolingTargetSource class, hence the use of      MethodInvokingFactoryBean. This advisor\'s name (\"poolConfigAdvisor\"      here) must be in the list of interceptors names in the ProxyFactoryBean      exposing the pooled object.      \n\r\n\rThe cast will look as follows:      PoolingConfig conf = (PoolingConfig) beanFactory.getBean(\"businessObject\");System.out.println(\"Max pool size is \" + conf.getMaxSize());            Note                \n\r\n\rPooling stateless service objects is not usually necessary. We                don\'t believe it should be the default choice, as most stateless objects                are naturally thread safe, and instance pooling is problematic if                resources are cached.                  \n\r\n\rSimpler pooling is available using autoproxying. It\'s possible to      set the TargetSources used by any autoproxy creator.        B.9.3&nbsp;Prototype target sources            \n\r\n\rSetting up a \"prototype\" target source is similar to a pooling      TargetSource. In this case, a new instance of the target will be created      on every method invocation. Although the cost of creating a new object      isn\'t high in a modern JVM, the cost of wiring up the new object      (satisfying its IoC dependencies) may be more expensive. Thus you      shouldn\'t use this approach without very good reason.      \n\r\n\rTo do this, you could modify the      poolTargetSource definition shown above as follows.      (I\'ve also changed the name, for clarity.)      &lt;bean id=\"prototypeTargetSource\" class=\"org.springframework.aop.target.PrototypeTargetSource\"&gt;  &lt;property name=\"targetBeanName\" ref=\"businessObjectTarget\"/&gt;&lt;/bean&gt;      \n\r\n\rThere\'s only one property: the name of the target bean.      Inheritance is used in the TargetSource implementations to ensure      consistent naming. As with the pooling target source, the target bean      must be a prototype bean definition.        B.9.4&nbsp;ThreadLocal target sources            \n\r\n\rThreadLocal target sources are useful if you need an object to be      created for each incoming request (per thread that is). The concept of a      ThreadLocal provide a JDK-wide facility to      transparently store resource alongside a thread. Setting up a      ThreadLocalTargetSource is pretty much the same as was explained for the      other types of target source:      &lt;bean id=\"threadlocalTargetSource\" class=\"org.springframework.aop.target.ThreadLocalTargetSource\"&gt;  &lt;property name=\"targetBeanName\" value=\"businessObjectTarget\"/&gt;&lt;/bean&gt;            Note                \n\r\n\rThreadLocals come with serious issues (potentially                resulting in memory leaks) when incorrectly using them in a                multi-threaded and multi-classloader environments. One should always                consider wrapping a threadlocal in some other class and never directly                use the ThreadLocal itself (except of course in the wrapper class).                Also, one should always remember to correctly set and unset (where the                latter simply involved a call to ThreadLocal.set(null)) the resource                local to the thread. Unsetting should be done in any case since not                unsetting it might result in problematic behavior. Spring\'s ThreadLocal                support does this for you and should always be considered in favor                of using ThreadLocals without other proper handling                code.                    B.10&nbsp;Defining new Advice types        \n\r\n\rSpring AOP is designed to be extensible. While the interception    implementation strategy is presently used internally, it is possible to    support arbitrary advice types in addition to the out-of-the-box interception around advice,    before, throws advice and after returning advice.    \n\r\n\rThe org.springframework.aop.framework.adapter    package is an SPI package allowing support for new custom advice types to    be added without changing the core framework. The only constraint on a    custom Advice type is that it must implement the    org.aopalliance.aop.Advice tag interface.    \n\r\n\rPlease refer to the    org.springframework.aop.framework.adapter package\'s    Javadocs for further information.    B.11&nbsp;Further resources        \n\r\n\rPlease refer to the Spring sample applications for further examples    of Spring AOP:    \n\r        \n\r\n\rThe JPetStore\'s default configuration illustrates the use of the        TransactionProxyFactoryBean for declarative transaction        management.      \n\r        \n\r\n\rThe /attributes directory of the JPetStore        illustrates the use of attribute-driven declarative transaction management.      \n\r   Prev&nbsp;Up&nbsp;NextAppendix&nbsp;A.&nbsp;Classic Spring Usage&nbsp;Home&nbsp;Appendix&nbsp;C.&nbsp;Migrating to Spring Framework 3.1","B. Classic Spring AOP Usage","scr\\classic-aop-spring.html","         Appendix&nbsp;A.&nbsp;Classic Spring UsagePrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;A.&nbsp;Classic Spring Usage    \n\r\n\rThis appendix discusses some classic Spring usage patterns as a  reference for developers maintaining legacy Spring applications. These usage  patterns no longer reflect the recommended way of using these features and  the current recommended usage is covered in the respective sections of the  reference manual.  A.1&nbsp;Classic ORM usage        \n\r\n\rThis section documents the classic usage patterns that you might    encounter in a legacy Spring application. For the currently recommended    usage patterns, please refer to the Chapter&nbsp;15, Object Relational Mapping (ORM) Data Access chapter.    A.1.1&nbsp;Hibernate            \n\r\n\rFor the currently recommended usage patterns for Hibernate see      Section&nbsp;15.3, &#8220;Hibernate&#8221;      The HibernateTemplate                \n\r\n\rThe basic programming model for templating looks as follows, for        methods that can be part of any custom data access object or business        service. There are no restrictions on the implementation of the        surrounding object at all, it just needs to provide a Hibernate        SessionFactory. It can get the latter        from anywhere, but preferably as bean reference from a Spring IoC        container - via a simple        setSessionFactory(..) bean property setter.        The following snippets show a DAO definition in a Spring container,        referencing the above defined        SessionFactory, and an example for a        DAO method implementation.        &lt;beans&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"sessionFactory\" ref=\"mySessionFactory\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        public class ProductDaoImpl implements ProductDao {    private HibernateTemplate hibernateTemplate;    public void setSessionFactory(SessionFactory sessionFactory) {        this.hibernateTemplate = new HibernateTemplate(sessionFactory);    }    public Collection loadProductsByCategory(String category) throws DataAccessException {        return this.hibernateTemplate.find(\"from test.Product product where product.category=?\", category);    }}        \n\r\n\rThe HibernateTemplate class provides many        methods that mirror the methods exposed on the Hibernate        Session interface, in addition to a        number of convenience methods such as the one shown above. If you need        access to the Session to invoke methods        that are not exposed on the HibernateTemplate,        you can always drop down to a callback-based approach like so.        public class ProductDaoImpl implements ProductDao {    private HibernateTemplate hibernateTemplate;    public void setSessionFactory(SessionFactory sessionFactory) {        this.hibernateTemplate = new HibernateTemplate(sessionFactory);    }    public Collection loadProductsByCategory(final String category) throws DataAccessException {        return this.hibernateTemplate.execute(new HibernateCallback() {            public Object doInHibernate(Session session) {                Criteria criteria = session.createCriteria(Product.class);                criteria.add(Expression.eq(\"category\", category));                criteria.setMaxResults(6);                return criteria.list();            }        };    }}        \n\r\n\rA callback implementation effectively can be used for any        Hibernate data access. HibernateTemplate will        ensure that Session instances are        properly opened and closed, and automatically participate in        transactions. The template instances are thread-safe and reusable,        they can thus be kept as instance variables of the surrounding class.        For simple single step actions like a single find, load, saveOrUpdate,        or delete call, HibernateTemplate offers        alternative convenience methods that can replace such one line        callback implementations. Furthermore, Spring provides a convenient        HibernateDaoSupport base class that provides a        setSessionFactory(..) method for receiving a        SessionFactory, and        getSessionFactory() and        getHibernateTemplate()for use by subclasses.        In combination, this allows for very simple DAO implementations for        typical requirements:        public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {    public Collection loadProductsByCategory(String category) throws DataAccessException {        return this.getHibernateTemplate().find(            \"from test.Product product where product.category=?\", category);    }}            Implementing Spring-based DAOs without callbacks                \n\r\n\rAs alternative to using Spring\'s        HibernateTemplate to implement DAOs, data        access code can also be written in a more traditional fashion, without        wrapping the Hibernate access code in a callback, while still        respecting and participating in Spring\'s generic        DataAccessException hierarchy. The        HibernateDaoSupport base class offers methods        to access the current transactional        Session and to convert exceptions in        such a scenario; similar methods are also available as static helpers        on the SessionFactoryUtils class. Note that        such code will usually pass \'false\' as the value of        the getSession(..) methods        \'allowCreate\' argument, to enforce running within a        transaction (which avoids the need to close the returned        Session, as its lifecycle is managed by        the transaction).        public class HibernateProductDao extends HibernateDaoSupport implements ProductDao {    public Collection loadProductsByCategory(String category) throws DataAccessException, MyException {        Session session = getSession(false);        try {            Query query = session.createQuery(\"from test.Product product where product.category=?\");            query.setString(0, category);            List result = query.list();            if (result == null) {                throw new MyException(\"No search results.\");            }            return result;        }        catch (HibernateException ex) {            throw convertHibernateAccessException(ex);        }    }}        \n\r\n\rThe advantage of such direct Hibernate access code is that it        allows any checked application exception to be        thrown within the data access code; contrast this to the        HibernateTemplate class which is restricted to        throwing only unchecked exceptions within the callback. Note that you        can often defer the corresponding checks and the throwing of        application exceptions to after the callback, which still allows        working with HibernateTemplate. In general, the        HibernateTemplate class\' convenience methods        are simpler and more convenient for many scenarios.              A.1.2&nbsp;JDO            \n\r\n\rFor the currently recommended usage patterns for JDO see Section&nbsp;15.4, &#8220;JDO&#8221;      JdoTemplate and        JdoDaoSupport                \n\r\n\rEach JDO-based DAO will then receive the        PersistenceManagerFactory through        dependency injection. Such a DAO could be coded against plain JDO API,        working with the given        PersistenceManagerFactory, but will        usually rather be used with the Spring Framework\'s        JdoTemplate:        &lt;beans&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"persistenceManagerFactory\" ref=\"myPmf\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        public class ProductDaoImpl implements ProductDao {    private JdoTemplate jdoTemplate;    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {        this.jdoTemplate = new JdoTemplate(pmf);    }    public Collection loadProductsByCategory(final String category) throws DataAccessException {        return (Collection) this.jdoTemplate.execute(new JdoCallback() {            public Object doInJdo(PersistenceManager pm) throws JDOException {                Query query = pm.newQuery(Product.class, \"category = pCategory\");                query.declareParameters(\"String pCategory\");                List result = query.execute(category);                // do some further stuff with the result list                return result;            }        });    }}        \n\r\n\rA callback implementation can effectively be used for any JDO        data access. JdoTemplate will ensure that        PersistenceManagers are properly opened and        closed, and automatically participate in transactions. The template        instances are thread-safe and reusable, they can thus be kept as        instance variables of the surrounding class. For simple single-step        actions such as a single find,        load, makePersistent, or        delete call, JdoTemplate        offers alternative convenience methods that can replace such one line        callback implementations. Furthermore, Spring provides a convenient        JdoDaoSupport base class that provides a        setPersistenceManagerFactory(..) method for        receiving a PersistenceManagerFactory, and        getPersistenceManagerFactory() and        getJdoTemplate() for use by subclasses. In        combination, this allows for very simple DAO implementations for        typical requirements:        public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {    public Collection loadProductsByCategory(String category) throws DataAccessException {        return getJdoTemplate().find(            Product.class, \"category = pCategory\", \"String category\", new Object[] {category});    }}        \n\r\n\rAs alternative to working with Spring\'s        JdoTemplate, you can also code Spring-based        DAOs at the JDO API level, explicitly opening and closing a        PersistenceManager. As elaborated in        the corresponding Hibernate section, the main advantage of this        approach is that your data access code is able to throw checked        exceptions. JdoDaoSupport offers a variety of        support methods for this scenario, for fetching and releasing a        transactional PersistenceManager as        well as for converting exceptions.              A.1.3&nbsp;JPA            \n\r\n\rFor the currently recommended usage patterns for JPA see Section&nbsp;15.5, &#8220;JPA&#8221;      JpaTemplate and        JpaDaoSupport                \n\r\n\rEach JPA-based DAO will then receive a        EntityManagerFactory via dependency        injection. Such a DAO can be coded against plain JPA and work with the        given EntityManagerFactory or through        Spring\'s JpaTemplate:        &lt;beans&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"entityManagerFactory\" ref=\"myEmf\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        public class JpaProductDao implements ProductDao {    private JpaTemplate jpaTemplate;    public void setEntityManagerFactory(EntityManagerFactory emf) {        this.jpaTemplate = new JpaTemplate(emf);    }    public Collection loadProductsByCategory(final String category) throws DataAccessException {        return (Collection) this.jpaTemplate.execute(new JpaCallback() {            public Object doInJpa(EntityManager em) throws PersistenceException {                Query query = em.createQuery(\"from Product as p where p.category = :category\");                query.setParameter(\"category\", category);                List result = query.getResultList();                // do some further processing with the result list                return result;            }        });    }}        \n\r\n\rThe JpaCallback implementation        allows any type of JPA data access. The        JpaTemplate will ensure that        EntityManagers are properly opened and        closed and automatically participate in transactions. Moreover, the        JpaTemplate properly handles exceptions, making        sure resources are cleaned up and the appropriate transactions rolled        back. The template instances are thread-safe and reusable and they can        be kept as instance variable of the enclosing class. Note that        JpaTemplate offers single-step actions such as        find, load, merge, etc along with alternative convenience methods that        can replace one line callback implementations.        \n\r\n\rFurthermore, Spring provides a convenient        JpaDaoSupport base class that provides the        get/setEntityManagerFactory and        getJpaTemplate() to be used by        subclasses:        public class ProductDaoImpl extends JpaDaoSupport implements ProductDao {    public Collection loadProductsByCategory(String category) throws DataAccessException {        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();        params.put(\"category\", category);        return getJpaTemplate().findByNamedParams(\"from Product as p where p.category = :category\", params);    }}        \n\r\n\rBesides working with Spring\'s        JpaTemplate, one can also code Spring-based        DAOs against the JPA, doing one\'s own explicit        EntityManager handling. As also        elaborated in the corresponding Hibernate section, the main advantage        of this approach is that your data access code is able to throw        checked exceptions. JpaDaoSupport offers a        variety of support methods for this scenario, for retrieving and        releasing a transaction EntityManager,        as well as for converting exceptions.        \n\r\n\rJpaTemplate mainly exists as a sibling of JdoTemplate        and HibernateTemplate, offering the same style for people used to        it.              A.2&nbsp;Classic Spring MVC        \n\r\n\r...    A.3&nbsp;JMS Usage        \n\r\n\rOne of the benefits of Spring\'s JMS support is to shield the user    from differences between the JMS 1.0.2 and 1.1 APIs. (For a description of    the differences between the two APIs see sidebar on Domain Unification).    Since it is now common to encounter only the JMS 1.1 API the use of    classes that are based on the JMS 1.0.2 API has been deprecated in Spring    3.0. This section describes Spring JMS support for the JMS 1.0.2    deprecated classes.     \n\r\n\rDomain Unification            \n\r\n\rThere are two major releases of the JMS specification, 1.0.2 and      1.1.      \n\r\n\rJMS 1.0.2 defined two types of messaging domains, point-to-point      (Queues) and publish/subscribe (Topics). The 1.0.2 API reflected these      two messaging domains by providing a parallel class hierarchy for each      domain. As a result, a client application became domain specific in its      use of the JMS API. JMS 1.1 introduced the concept of domain unification      that minimized both the functional differences and client API      differences between the two domains. As an example of a functional      difference that was removed, if you use a JMS 1.1 provider you can      transactionally consume a message from one domain and produce a message      on the other using the same      Session.      Note        \n\r\n\rThe JMS 1.1 specification was released in April 2002 and        incorporated as part of J2EE 1.4 in November 2003. As a result, common        J2EE 1.3 application servers which are still in widespread use (such        as BEA WebLogic 8.1 and IBM WebSphere 5.1) are based on JMS        1.0.2.              A.3.1&nbsp;JmsTemplate            \n\r\n\rLocated in the package      org.springframework.jms.core the class      JmsTemplate102 provides all of the features of      the JmsTemplate described the JMS chapter, but is      based on the JMS 1.0.2 API instead of the JMS 1.1 API. As a consequence,      if you are using JmsTemplate102 you need to set the boolean property      pubSubDomain to configure the      JmsTemplate with knowledge of what JMS domain is      being used. By default the value of this property is false, indicating      that the point-to-point domain, Queues, will be used.        A.3.2&nbsp;Asynchronous Message Reception             \n\r\n\rMessageListenerAdapter\'s      are used in conjunction with Spring\'s message      listener containers to support asynchronous message reception by      exposing almost any class as a Message-driven POJO. If you are using the      JMS 1.0.2 API, you will want to use the 1.0.2 specific classes such as      MessageListenerAdapter102,      SimpleMessageListenerContainer102, and      DefaultMessageListenerContainer102. These classes      provide the same functionality as the JMS 1.1 based counterparts but      rely only on the JMS 1.0.2 API.         A.3.3&nbsp;Connections            \n\r\n\rThe ConnectionFactory interface is part of      the JMS specification and serves as the entry point for working with      JMS. Spring provides an implementation of the      ConnectionFactory interface,      SingleConnectionFactory102, based on the JMS      1.0.2 API that will return the same Connection on      all createConnection() calls and ignore calls to      close(). You will need to set the boolean      property pubSubDomain to indicate which messaging      domain is used as SingleConnectionFactory102 will      always explicitly differentiate between a      javax.jms.QueueConnection and a      javax.jmsTopicConnection.        A.3.4&nbsp;Transaction Management            \n\r\n\rIn a JMS 1.0.2 environment the class      JmsTransactionManager102 provides support for      managing JMS transactions for a single Connection Factory. Please refer      to the reference documentation on JMS Transaction      Management for more information on this functionality.      Prev&nbsp;Up&nbsp;NextPart&nbsp;VII.&nbsp;Appendices&nbsp;Home&nbsp;Appendix&nbsp;B.&nbsp;Classic Spring AOP Usage","A. Classic Spring Usage","scr\\classic-spring.html","         13.&nbsp;DAO supportPrev&nbsp;Part&nbsp;IV.&nbsp;Data Access&nbsp;Next13.&nbsp;DAO support    13.1&nbsp;Introduction        \n\r\n\rThe Data Access Object (DAO) support in Spring is aimed at making it    easy to work with data access technologies like JDBC, Hibernate, JPA or    JDO in a consistent way. This allows one to switch between the    aforementioned persistence technologies fairly easily and it also allows    one to code without worrying about catching exceptions that are specific    to each technology.    13.2&nbsp;Consistent exception hierarchy        \n\r\n\rSpring provides a convenient translation from technology-specific    exceptions like SQLException to its own exception    class hierarchy with the DataAccessException as the    root exception. These exceptions wrap the original exception so there is    never any risk that one might lose any information as to what might have    gone wrong.    \n\r\n\rIn addition to JDBC exceptions, Spring can also wrap    Hibernate-specific exceptions, converting them from proprietary, checked    exceptions (in the case of versions of Hibernate prior to Hibernate 3.0),    to a set of focused runtime exceptions (the same is true for JDO and JPA    exceptions). This allows one to handle most persistence exceptions, which    are non-recoverable, only in the appropriate layers, without having    annoying boilerplate catch-and-throw blocks and exception declarations in    one\'s DAOs. (One can still trap and handle exceptions anywhere one needs    to though.) As mentioned above, JDBC exceptions (including    database-specific dialects) are also converted to the same hierarchy,    meaning that one can perform some operations with JDBC within a consistent    programming model.    \n\r\n\rThe above holds true for the various template classes in Springs    support for various ORM frameworks. If one uses the interceptor-based    classes then the application must care about handling    HibernateExceptions and    JDOExceptions itself, preferably via delegating to    SessionFactoryUtils\'    convertHibernateAccessException(..) or    convertJdoAccessException() methods respectively.    These methods convert the exceptions to ones that are compatible with the    exceptions in the org.springframework.dao exception    hierarchy. As JDOExceptions are unchecked, they can    simply get thrown too, sacrificing generic DAO abstraction in terms of    exceptions though.    \n\r\n\rThe exception hierarchy that Spring provides can be seen below.    (Please note that the class hierarchy detailed in the image shows only a    subset of the entire DataAccessException    hierarchy.)        13.3&nbsp;Annotations used for configuring DAO or Repository classes        \n\r\n\rThe best way to guarantee that your Data Access Objects (DAOs) or    repositories provide exception translation is to use the    @Repository annotation. This annotation    also allows the component scanning support to find and configure your DAOs    and repositories without having to provide XML configuration entries for    them.    @Repositorypublic class SomeMovieFinder implements MovieFinder {    // ...}    \n\r\n\rAny DAO or repository implementation will need to access to a    persistence resource, depending on the persistence technology used; for    example, a JDBC-based repository will need access to a JDBC    DataSource; a JPA-based repository will need    access to an EntityManager. The easiest way    to accomplish this is to have this resource dependency injected using one of    the @Autowired,, @Inject,    @Resource or    @PersistenceContext annotations. Here is an    example for a JPA repository:    @Repositorypublic class JpaMovieFinder implements MovieFinder {    @PersistenceContext    private EntityManager entityManager;    // ...}    \n\r\n\rIf you are using the classic Hibernate APIs than you can inject the    SessionFactory:    @Repositorypublic class HibernateMovieFinder implements MovieFinder {    private SessionFactory sessionFactory;    @Autowired    public void setSessionFactory(SessionFactory sessionFactory) {        this.sessionFactory = sessionFactory;    }    // ...}    \n\r\n\rLast example we will show here is for typical JDBC support. You    would have the DataSource injected into an    initialization method where you would create a    JdbcTemplate and other data access support classes    like SimpleJdbcCall etc using this    DataSource.    @Repositorypublic class JdbcMovieFinder implements MovieFinder {    private JdbcTemplate jdbcTemplate;    @Autowired    public void init(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    // ...}    Note      \n\r\n\rPlease see the specific coverage of each persistence technology      for details on how to configure the application context to take      advantage of these annotations.        \n\r\n\r  Prev&nbsp;Up&nbsp;Next12.&nbsp;Transaction Management&nbsp;Home&nbsp;14.&nbsp;Data access with JDBC","13. DAO support","scr\\dao.html","         28.&nbsp;Dynamic language supportPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next28.&nbsp;Dynamic language support    28.1&nbsp;Introduction        \n\r\n\rWhy only these languages?            \n\r\n\r        The supported languages were chosen because a) the languages        have a lot of traction in the Java enterprise community, b) no requests were made        for other languages within the Spring 2.0 development timeframe, and        c) the Spring developers were most familiar with them.            \n\r\n\r        There is nothing stopping the inclusion of further languages though. If you want        to see support for &lt;insert your favourite dynamic language here&gt;,        you can always raise an issue on Spring\'s        JIRA        page (or implement such support yourself).              \n\r\n\rSpring 2.0 introduces comprehensive support for using classes and objects that have    been defined using a dynamic language (such as JRuby) with Spring.    This support allows you to write any number of classes in a supported dynamic language,    and have the Spring container transparently instantiate, configure and dependency inject the    resulting objects.    \n\r\n\rThe dynamic languages currently supported are:    \n\r        \n\r\n\rJRuby 0.9 / 1.0      \n\r        \n\r\n\rGroovy 1.0 / 1.5      \n\r        \n\r\n\rBeanShell 2.0      \n\r    \n\r\n\r      Fully working examples of where this dynamic language support can be immediately useful      are described in Section&nbsp;28.4, &#8220;Scenarios&#8221;.        \n\r\n\r      Note: Only the specific versions as listed above are supported      in Spring 2.5. In particular, JRuby 1.1 (which introduced many incompatible API      changes) is not supported at this point of time.        28.2&nbsp;A first example        \n\r\n\r      This bulk of this chapter is concerned with describing the dynamic language support      in detail. Before diving into all of the ins and outs of the dynamic language support,      let\'s look at a quick example of a bean defined in a dynamic language.      The dynamic language for this first bean is Groovy (the basis of this example      was taken from the Spring test suite, so if you want to see equivalent examples      in any of the other supported languages, take a look at the source code).        \n\r\n\r      Find below the Messenger interface that the      Groovy bean is going to be implementing, and note that this interface is defined      in plain Java. Dependent objects that are injected with a reference to the      Messenger won\'t know that the underlying      implementation is a Groovy script.        package org.springframework.scripting;public interface Messenger {    String getMessage();}    \n\r\n\r      Here is the definition of a class that has a dependency on the      Messenger interface.        package org.springframework.scripting;public class DefaultBookingService implements BookingService {    private Messenger messenger;    public void setMessenger(Messenger messenger) {        this.messenger = messenger;    }    public void processBooking() {        // use the injected Messenger object...    }}    \n\r\n\rHere is an implementation of the Messenger interface    in Groovy.    // from the file \'Messenger.groovy\'package org.springframework.scripting.groovy;// import the Messenger interface (written in Java) that is to be implementedimport org.springframework.scripting.Messenger// define the implementation in Groovyclass GroovyMessenger implements Messenger {    String message}    \n\r\n\r      Finally, here are the bean definitions that will effect the injection of the      Groovy-defined Messenger implementation into      an instance of the DefaultBookingService class.        Note      \n\r\n\r        To use the custom dynamic language tags to define dynamic-language-backed beans,        you need to have the XML Schema preamble at the top of your Spring XML        configuration file. You also need to be using a Spring        ApplicationContext implementation as your        IoC container. Using the dynamic-language-backed beans with a plain        BeanFactory implementation is supported,        but you have to manage the plumbing of the Spring internals to do so.            \n\r\n\rFor more information on schema-based configuration, see Appendix&nbsp;E, XML Schema-based configuration.        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:lang=\"http://www.springframework.org/schema/lang\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd\"&gt;    &lt;!-- this is the bean definition for the Groovy-backed Messenger implementation --&gt;    &lt;lang:groovy id=\"messenger\" script-source=\"classpath:Messenger.groovy\"&gt;        &lt;lang:property name=\"message\" value=\"I Can Do The Frug\" /&gt;    &lt;/lang:groovy&gt;    &lt;!-- an otherwise normal bean that will be injected by the Groovy-backed Messenger --&gt;    &lt;bean id=\"bookingService\" class=\"x.y.DefaultBookingService\"&gt;        &lt;property name=\"messenger\" ref=\"messenger\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;    \n\r\n\r      The bookingService bean (a      DefaultBookingService) can now use its private      messenger member variable as normal because the      Messenger instance that was injected      into it is a Messenger      instance. There is nothing special going on here, just plain Java and      plain Groovy.        \n\r\n\r      Hopefully the above XML snippet is self-explanatory, but don\'t worry      unduly if it isn\'t. Keep reading for the in-depth detail on the whys      and wherefores of the above configuration.        28.3&nbsp;Defining beans that are backed by dynamic languages        \n\r\n\r      This section describes exactly how you define Spring managed beans in      any of the supported dynamic languages.        \n\r\n\r      Please note that this chapter does not attempt to explain the syntax and      idioms of the supported dynamic languages. For example, if you want to      use Groovy to write certain of the classes in your application, then the      assumption is that you already know Groovy. If you need further details      about the dynamic languages themselves, please consult      Section&nbsp;28.6, &#8220;Further Resources&#8221; at the end of this chapter.        28.3.1&nbsp;Common concepts            \n\r\n\rThe steps involved in using dynamic-language-backed beans are as follows:      \n\r          \n\r\n\rWrite the test for the dynamic language source code (naturally)        \n\r          \n\r\n\rThen write the dynamic language source code itself :)        \n\r          \n\r\n\r            Define your dynamic-language-backed beans using the appropriate            &lt;lang:language/&gt; element in the XML            configuration (you can of course define such beans programmatically            using the Spring API - although you will have to consult the source            code for directions on how to do this as this type of advanced            configuration is not covered in this chapter). Note this is an iterative            step. You will need at least one bean definition per dynamic            language source file (although the same dynamic language source            file can of course be referenced by multiple bean definitions).                  \n\r      \n\r\n\r        The first two steps (testing and writing your dynamic language source files)        are beyond the scope of this chapter. Refer to the language specification        and / or reference manual for your chosen dynamic language and crack on with        developing your dynamic language source files. You will        first want to read the rest of this chapter though, as Spring\'s dynamic language        support does make some (small) assumptions about the contents of your dynamic        language source files.            The &lt;lang:language/&gt; element                \n\r\n\rXML Schema                    \n\r\n\r            All of the configuration examples in this chapter make use of the            new XML Schema support that was added in Spring 2.0.                    \n\r\n\rIt is possible to forego the use of XML Schema and stick with the old-style          DTD based validation of your Spring XML files, but then you lose out          on the convenience offered by the &lt;lang:language/&gt;          element. See the Spring test suite for examples of the older style          configuration that doesn\'t require XML Schema-based validation          (it is quite verbose and doesn\'t hide any of the underlying Spring          implementation from you).                \n\r\n\r          The final step involves defining dynamic-language-backed bean definitions,          one for each bean that you want to configure (this is no different from          normal JavaBean configuration). However, instead of specifying the          fully qualified classname of the class that is to be instantiated and          configured by the container, you use the &lt;lang:language/&gt;          element to define the dynamic language-backed bean.                \n\r\n\r          Each of the supported languages has a corresponding          &lt;lang:language/&gt; element:                \n\r            \n\r\n\r&lt;lang:jruby/&gt; (JRuby)          \n\r            \n\r\n\r&lt;lang:groovy/&gt; (Groovy)          \n\r            \n\r\n\r&lt;lang:bsh/&gt; (BeanShell)          \n\r        \n\r\n\r          The exact attributes and child elements that are available for          configuration depends on exactly which language the bean has been          defined in (the language-specific sections below provide the full          lowdown on this).                    Refreshable beans                \n\r\n\r          One of the (if not the) most compelling value adds          of the dynamic language support in Spring is the          \'refreshable bean\' feature.                \n\r\n\r          A refreshable bean is a dynamic-language-backed bean that with a small          amount of configuration, a dynamic-language-backed bean can monitor          changes in its underlying source file resource, and then reload itself          when the dynamic language source file is changed (for example when a          developer edits and saves changes to the file on the filesystem).                \n\r\n\r          This allows a developer to deploy any number of dynamic language source          files as part of an application, configure the Spring container to create          beans backed by dynamic language source files (using the mechanisms          described in this chapter), and then later, as requirements change or          some other external factor comes into play, simply edit a dynamic language          source file and have any change they make reflected in the bean that is          backed by the changed dynamic language source file. There is no need to          shut down a running application (or redeploy in the case of a web application).          The dynamic-language-backed bean so amended will pick up the new state          and logic from the changed dynamic language source file.                Note          \n\r\n\rPlease note that this feature is off by default.                \n\r\n\r          Let\'s take a look at an example to see just how easy it is to start using          refreshable beans. To turn on the refreshable beans          feature, you simply have to specify exactly one          additional attribute on the &lt;lang:language/&gt; element          of your bean definition. So if we stick with          the example from earlier          in this chapter, here\'s what we would change in the Spring XML configuration          to effect refreshable beans:                &lt;beans&gt;    &lt;!-- this bean is now \'refreshable\' due to the presence of the \'refresh-check-delay\' attribute --&gt;    &lt;lang:groovy id=\"messenger\"          refresh-check-delay=\"5000\" &lt;!-- switches refreshing on with 5 seconds between checks --&gt;          script-source=\"classpath:Messenger.groovy\"&gt;        &lt;lang:property name=\"message\" value=\"I Can Do The Frug\" /&gt;    &lt;/lang:groovy&gt;    &lt;bean id=\"bookingService\" class=\"x.y.DefaultBookingService\"&gt;        &lt;property name=\"messenger\" ref=\"messenger\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\r          That really is all you have to do. The \'refresh-check-delay\'          attribute defined on the \'messenger\' bean definition          is the number of milliseconds after which the bean will be refreshed with          any changes made to the underlying dynamic language source file.          You can turn off the refresh behavior by assigning a negative value          to the \'refresh-check-delay\' attribute.          Remember that, by default, the refresh behavior is disabled. If you don\'t          want the refresh behavior, then simply don\'t define the attribute.                \n\r\n\r          If we then run the following application we can exercise the refreshable feature;          please do excuse the \'jumping-through-hoops-to-pause-the-execution\'          shenanigans in this next slice of code. The System.in.read()          call is only there so that the execution of the program pauses while I (the author)          go off and edit the underlying dynamic language source file so that the refresh will          trigger on the dynamic-language-backed bean when the program resumes execution.        import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.scripting.Messenger;public final class Boot {    public static void main(final String[] args) throws Exception {        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");        Messenger messenger = (Messenger) ctx.getBean(\"messenger\");        System.out.println(messenger.getMessage());        // pause execution while I go off and make changes to the source file...        System.in.read();        System.out.println(messenger.getMessage());    }}        \n\r\n\r          Let\'s assume then, for the purposes of this example, that all          calls to the getMessage() method of          Messenger implementations have to be          changed such that the message is surrounded by quotes.          Below are the changes that I (the author) make to the          Messenger.groovy source file when the execution of          the program is paused.                package org.springframework.scriptingclass GroovyMessenger implements Messenger {    private String message = \"Bingo\"    public String getMessage() {        // change the implementation to surround the message in quotes        return \"\'\" + this.message + \"\'\"    }    public void setMessage(String message) {        this.message = message    }}        \n\r\n\r          When the program executes, the output before the input pause will be          I Can Do The Frug. After the change          to the source file is made and saved, and the program resumes execution,          the result of calling the getMessage() method on the          dynamic-language-backed Messenger implementation          will be \'I Can Do The Frug\' (notice          the inclusion of the additional quotes).                \n\r\n\r          It is important to understand that changes to a script will          not trigger a refresh if the changes occur          within the window of the \'refresh-check-delay\' value.          It is equally important to understand that changes to the script are          not actually \'picked up\' until a method is called          on the dynamic-language-backed bean. It is only when a method is called on a          dynamic-language-backed bean that it checks to see if its underlying script          source has changed. Any exceptions relating to refreshing the script          (such as encountering a compilation error, or finding that the script          file has been deleted) will result in a fatal          exception being propagated to the calling code.                \n\r\n\r          The refreshable bean behavior described above does          not apply to dynamic language source files          defined using the &lt;lang:inline-script/&gt; element          notation (see the section called &#8220;Inline dynamic language source files&#8221;).          Additionally, it only applies to beans where          changes to the underlying source file can actually be detected;          for example, by code that checks the last modified date of a          dynamic language source file that exists on the filesystem.                    Inline dynamic language source files                \n\r\n\r          The dynamic language support can also cater for dynamic language          source files that are embedded directly in Spring bean definitions.          More specifically, the &lt;lang:inline-script/&gt;          element allows you to define dynamic language source immediately          inside a Spring configuration file. An example will perhaps make the          inline script feature crystal clear:                &lt;lang:groovy id=\"messenger\"&gt;    &lt;lang:inline-script&gt;package org.springframework.scripting.groovy;import org.springframework.scripting.Messengerclass GroovyMessenger implements Messenger {    String message}    &lt;/lang:inline-script&gt;    &lt;lang:property name=\"message\" value=\"I Can Do The Frug\" /&gt;&lt;/lang:groovy&gt;        \n\r\n\r          If we put to one side the issues surrounding whether it is good practice          to define dynamic language source inside a Spring configuration file, the          &lt;lang:inline-script/&gt; element can be useful in          some scenarios. For instance, we might want to quickly add a Spring          Validator implementation to a Spring MVC          Controller. This is but a moment\'s work          using inline source. (See Section&nbsp;28.4.2, &#8220;Scripted Validators&#8221;          for such an example.)                \n\r\n\r          Find below an example of defining the source for a JRuby-based bean          directly in a Spring XML configuration file using the          inline: notation. (Notice the use of the &amp;lt;          characters to denote a \'&lt;\' character. In such a case          surrounding the inline source in a &lt;![CDATA[]]&gt; region might be better.)                &lt;lang:jruby id=\"messenger\" script-interfaces=\"org.springframework.scripting.Messenger\"&gt;    &lt;lang:inline-script&gt;require \'java\'include_class \'org.springframework.scripting.Messenger\'class RubyMessenger &amp;lt; Messenger def setMessage(message)  @@message = message end def getMessage  @@message endend    &lt;/lang:inline-script&gt;    &lt;lang:property name=\"message\" value=\"Hello World!\" /&gt;&lt;/lang:jruby&gt;            Understanding Constructor Injection in the context of dynamic-language-backed beans                \n\r\n\r          There is one very important thing to be aware of          with regard to Spring\'s dynamic language support. Namely, it is not (currently)          possible to supply constructor arguments to dynamic-language-backed beans (and hence          constructor-injection is not available for dynamic-language-backed beans).          In the interests of making this special handling of constructors and          properties 100% clear, the following mixture of code and configuration          will not work.                // from the file \'Messenger.groovy\'package org.springframework.scripting.groovy;import org.springframework.scripting.Messengerclass GroovyMessenger implements Messenger {    GroovyMessenger() {}    // this constructor is not available for Constructor Injection    GroovyMessenger(String message) {        this.message = message;    }    String message    String anotherMessage}        &lt;lang:groovy id=\"badMessenger\"    script-source=\"classpath:Messenger.groovy\"&gt;    &lt;!-- this next constructor argument will *not* be injected into the GroovyMessenger --&gt;    &lt;!--     in fact, this isn\'t even allowed according to the schema --&gt;    &lt;constructor-arg value=\"This will *not* work\" /&gt;    &lt;!-- only property values are injected into the dynamic-language-backed object --&gt;    &lt;lang:property name=\"anotherMessage\" value=\"Passed straight through to the dynamic-language-backed object\" /&gt;&lt;/lang&gt;        \n\r\n\r          In practice this limitation is not as significant as it first appears since          setter injection is the injection style favored by the overwhelming majority          of developers anyway (let\'s leave the discussion as to whether that is a good          thing to another day).                      28.3.2&nbsp;JRuby beans            \n\r\n\rThe JRuby library dependencies                \n\r\n\r          The JRuby scripting support in Spring requires the following          libraries to be on the classpath of your application.                \n\r            \n\r\n\rjruby.jar          \n\r            \n\r\n\rFrom the JRuby homepage...      \n\r\n\r      &#8220;        JRuby is an 100% pure-Java implementation of the Ruby programming language.      &#8221;            \n\r\n\r        In keeping with the Spring philosophy of offering choice, Spring\'s        dynamic language support also supports beans defined in the JRuby        language. The JRuby language is based on the quite intuitive        Ruby language, and has support for inline regular expressions, blocks        (closures), and a whole host of other features that do make solutions        for some domain problems a whole lot easier to develop.            \n\r\n\r        The implementation of the JRuby dynamic language support in Spring is        interesting in that what happens is this: Spring creates a JDK dynamic        proxy implementing all of the interfaces that are specified in the        \'script-interfaces\' attribute value of the        &lt;lang:ruby&gt; element (this is why        you must supply at least one interface in the value        of the attribute, and (accordingly) program to interfaces when using        JRuby-backed beans).            \n\r\n\r        Let us look at a fully working example of using a JRuby-based bean. Here is        the JRuby implementation of the Messenger        interface that was defined earlier in this chapter (for your convenience it        is repeated below).            package org.springframework.scripting;public interface Messenger {    String getMessage();}      require \'java\'class RubyMessenger    include org.springframework.scripting.Messenger    def setMessage(message)        @@message = message    end    def getMessage        @@message    endend# this last line is not essential (but see below)RubyMessenger.new      \n\r\n\r        And here is the Spring XML that defines an instance of the        RubyMessenger JRuby bean.            &lt;lang:jruby id=\"messageService\"            script-interfaces=\"org.springframework.scripting.Messenger\"            script-source=\"classpath:RubyMessenger.rb\"&gt;    &lt;lang:property name=\"message\" value=\"Hello World!\" /&gt;&lt;/lang:jruby&gt;      \n\r\n\r        Take note of the last line of that JRuby source (\'RubyMessenger.new\').        When using JRuby in the context of Spring\'s dynamic language support, you are encouraged        to instantiate and return a new instance of the JRuby class that you want to use as a        dynamic-language-backed bean as the result of the execution of your JRuby source. You        can achieve this by simply instantiating a new instance of your JRuby class on the last        line of the source file like so:            require \'java\'include_class \'org.springframework.scripting.Messenger\'# class definition same as above...# instantiate and return a new instance of the RubyMessenger classRubyMessenger.new      \n\r\n\r        If you forget to do this, it is not the end of the world; this will however result in        Spring having to trawl (reflectively) through the type representation of your JRuby class        looking for a class to instantiate. In the grand scheme of things this will be so fast        that you\'ll never notice it, but it is something that can be avoided by simply        having a line such as the one above as the last line of your JRuby script. If you don\'t        supply such a line, or if Spring cannot find a JRuby class in your script to instantiate        then an opaque ScriptCompilationException        will be thrown immediately after the source is executed by the JRuby        interpreter. The key text that identifies this as the root cause of an        exception can be found immediately below (so if your Spring container        throws the following exception when creating your dynamic-language-backed bean        and the following text is there in the corresponding stacktrace, this will hopefully        allow you to identify and then easily rectify the issue):            \n\r\n\r      org.springframework.scripting.ScriptCompilationException: Compilation of JRuby script returned \'\'            \n\r\n\r        To rectify this, simply instantiate a new instance of whichever class        you want to expose as a JRuby-dynamic-language-backed bean (as shown above). Please        also note that you can actually define as many classes and objects        as you want in your JRuby script; what is important is that the        source file as a whole must return an object (for Spring to configure).            \n\r\n\r        See Section&nbsp;28.4, &#8220;Scenarios&#8221; for some        scenarios where you might want to use JRuby-based beans.              28.3.3&nbsp;Groovy beans            \n\r\n\rThe Groovy library dependencies                \n\r\n\r          The Groovy scripting support in Spring requires the following          libraries to be on the classpath of your application.                \n\r            \n\r\n\rgroovy-1.5.5.jar          \n\r            \n\r\n\rasm-2.2.2.jar          \n\r            \n\r\n\rantlr-2.7.6.jar          \n\r            \n\r\n\rFrom the Groovy homepage...      \n\r\n\r      &#8220;        Groovy is an agile dynamic language for the Java 2 Platform that has        many of the  features that people like so much in languages like Python, Ruby        and Smalltalk, making them available to Java developers using a Java-like syntax.              &#8221;            \n\r\n\r        If you have read this chapter straight from the top, you will already have        seen an example of a        Groovy-dynamic-language-backed bean. Let\'s look at another example (again        using an example from the Spring test suite).            package org.springframework.scripting;public interface Calculator {    int add(int x, int y);}      \n\r\n\r        Here is an implementation of the Calculator        interface in Groovy.            // from the file \'calculator.groovy\'package org.springframework.scripting.groovyclass GroovyCalculator implements Calculator {    int add(int x, int y) {        x + y    }}      &lt;-- from the file \'beans.xml\' --&gt;&lt;beans&gt;    &lt;lang:groovy id=\"calculator\" script-source=\"classpath:calculator.groovy\"/&gt;&lt;/beans&gt;      \n\r\n\r        Lastly, here is a small application to exercise the above configuration.            package org.springframework.scripting;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main {    public static void Main(String[] args) {        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");        Calculator calc = (Calculator) ctx.getBean(\"calculator\");        System.out.println(calc.add(2, 8));    }}      \n\r\n\r        The resulting output from running the above program will be        (unsurprisingly) 10.        (Exciting example, huh? Remember that the intent is to illustrate the        concept. Please consult the dynamic language showcase project for a        more complex example, or indeed Section&nbsp;28.4, &#8220;Scenarios&#8221;        later in this chapter).            \n\r\n\r        It is important that you do not define more than one        class per Groovy source file. While this is perfectly legal in Groovy, it        is (arguably) a bad practice: in the interests of a consistent approach,        you should (in the opinion of this author) respect the standard Java        conventions of one (public) class per source file.            Customising Groovy objects via a callback                \n\r\n\r          The GroovyObjectCustomizer          interface is a callback that allows you to hook additional          creation logic into the process of creating a Groovy-backed bean.          For example, implementations of this interface could invoke          any required initialization method(s), or set some default property          values, or specify a custom MetaClass.                public interface GroovyObjectCustomizer {   void customize(GroovyObject goo);}        \n\r\n\r          The Spring Framework will instantiate an instance of your Groovy-backed          bean, and will then pass the created GroovyObject          to the specified GroovyObjectCustomizer          if one has been defined. You can do whatever you like with the supplied          GroovyObject reference: it is expected          that the setting of a custom MetaClass is what most          folks will want to do with this callback, and you can see an example          of doing that below.                public final class SimpleMethodTracingCustomizer implements GroovyObjectCustomizer {   public void customize(GroovyObject goo) {      DelegatingMetaClass metaClass = new DelegatingMetaClass(goo.getMetaClass()) {         public Object invokeMethod(Object object, String methodName, Object[] arguments) {            System.out.println(\"Invoking \'\" + methodName + \"\'.\");            return super.invokeMethod(object, methodName, arguments);         }      };      metaClass.initialize();      goo.setMetaClass(metaClass);   }}        \n\r\n\r          A full discussion of meta-programming in Groovy is beyond the scope of the          Spring reference manual. Consult the relevant section of the Groovy          reference manual, or do a search online: there are plenty of articles          concerning this topic.          Actually making use of a GroovyObjectCustomizer          is easy if you are using the Spring 2.0 namespace support.                &lt;!-- define the GroovyObjectCustomizer just like any other bean --&gt;&lt;bean id=\"tracingCustomizer\" class=\"example.SimpleMethodTracingCustomizer\" /&gt;   &lt;!-- ... and plug it into the desired Groovy bean via the \'customizer-ref\' attribute --&gt;   &lt;lang:groovy id=\"calculator\"      script-source=\"classpath:org/springframework/scripting/groovy/Calculator.groovy\"      customizer-ref=\"tracingCustomizer\" /&gt;        \n\r\n\r          If you are not using the Spring 2.0 namespace support, you can still          use the GroovyObjectCustomizer functionality.                &lt;bean id=\"calculator\" class=\"org.springframework.scripting.groovy.GroovyScriptFactory\"&gt;      &lt;constructor-arg value=\"classpath:org/springframework/scripting/groovy/Calculator.groovy\"/&gt;      &lt;!-- define the GroovyObjectCustomizer (as an inner bean) --&gt;      &lt;constructor-arg&gt;         &lt;bean id=\"tracingCustomizer\" class=\"example.SimpleMethodTracingCustomizer\" /&gt;      &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.scripting.support.ScriptFactoryPostProcessor\"/&gt;              28.3.4&nbsp;BeanShell beans            \n\r\n\rThe BeanShell library dependencies                \n\r\n\r          The BeanShell scripting support in Spring requires the following          libraries to be on the classpath of your application.                \n\r            \n\r\n\rbsh-2.0b4.jar          \n\r            \n\r\n\rFrom the BeanShell homepage...      \n\r\n\r      &#8220;        BeanShell is a small, free, embeddable Java source interpreter        with dynamic language features, written in Java. BeanShell dynamically        executes standard Java syntax and extends it with common scripting        conveniences such as loose types, commands, and method closures like those        in Perl and JavaScript.      &#8221;            \n\r\n\r        In contrast to Groovy, BeanShell-backed bean definitions require some (small)        additional configuration. The implementation of the BeanShell dynamic language        support in Spring is interesting in that what happens is this: Spring creates        a JDK dynamic proxy implementing all of the interfaces that are specified in the        \'script-interfaces\' attribute value of the        &lt;lang:bsh&gt; element (this is why        you must supply at least one interface in the value        of the attribute, and (accordingly) program to interfaces when using        BeanShell-backed beans). This means that every method call on a BeanShell-backed        object is going through the JDK dynamic proxy invocation mechanism.            \n\r\n\r        Let\'s look at a fully working example of using a BeanShell-based bean        that implements the Messenger interface        that was defined earlier in this chapter (repeated below for your        convenience).            package org.springframework.scripting;public interface Messenger {    String getMessage();}      \n\r\n\rHere is the BeanShell \'implementation\' (the term is used loosely here) of the          Messenger interface.      String message;String getMessage() {    return message;}void setMessage(String aMessage) {    message = aMessage;}      \n\r\n\r        And here is the Spring XML that defines an \'instance\' of the above \'class\'        (again, the term is used very loosely here).            &lt;lang:bsh id=\"messageService\" script-source=\"classpath:BshMessenger.bsh\"    script-interfaces=\"org.springframework.scripting.Messenger\"&gt;    &lt;lang:property name=\"message\" value=\"Hello World!\" /&gt;&lt;/lang:bsh&gt;      \n\r\n\rSee Section&nbsp;28.4, &#8220;Scenarios&#8221; for some      scenarios where you might want to use BeanShell-based beans.        28.4&nbsp;Scenarios        \n\r\n\r      The possible scenarios where defining Spring managed beans in a scripting      language would be beneficial are, of course, many and varied. This section      describes two possible use cases for the dynamic language support in Spring.        28.4.1&nbsp;Scripted Spring MVC Controllers            \n\r\n\r        One group of classes that may benefit from using dynamic-language-backed        beans is that of Spring MVC controllers. In pure Spring MVC applications,        the  navigational flow through a web application is to a large extent        determined by code encapsulated within your Spring MVC controllers.        As the navigational flow and other presentation layer logic of a web        application needs to be updated to respond to support issues or changing        business requirements, it may well be easier to effect any such required        changes  by editing one or more dynamic language source files and seeing        those changes being immediately reflected in the state of a running        application.            \n\r\n\r        Remember that in the lightweight architectural model espoused by projects        such as Spring, you are typically aiming to have a really        thin presentation layer, with all the meaty business        logic of an application being contained in the domain and service layer        classes. Developing Spring MVC controllers as dynamic-language-backed beans        allows you to change presentation layer logic by simply editing and saving        text files; any changes to such dynamic language source files will (depending        on the configuration) automatically be reflected in the beans that are backed              by dynamic language source files.            Note        \n\r\n\r          In order to effect this automatic \'pickup\' of any changes          to dynamic-language-backed beans, you will have had to enable the          \'refreshable beans\' functionality. See           the section called &#8220;Refreshable beans&#8221; for a full treatment           of this feature.                    \n\r\n\r        Find below an example of an        org.springframework.web.servlet.mvc.Controller        implemented using the Groovy dynamic language.            // from the file \'/WEB-INF/groovy/FortuneController.groovy\'package org.springframework.showcase.fortune.webimport org.springframework.showcase.fortune.service.FortuneServiceimport org.springframework.showcase.fortune.domain.Fortuneimport org.springframework.web.servlet.ModelAndViewimport org.springframework.web.servlet.mvc.Controllerimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponseclass FortuneController implements Controller {    @Property FortuneService fortuneService    ModelAndView handleRequest(            HttpServletRequest request, HttpServletResponse httpServletResponse) {        return new ModelAndView(\"tell\", \"fortune\", this.fortuneService.tellFortune())    }}      &lt;lang:groovy id=\"fortune\"             refresh-check-delay=\"3000\"             script-source=\"/WEB-INF/groovy/FortuneController.groovy\"&gt;    &lt;lang:property name=\"fortuneService\" ref=\"fortuneService\"/&gt;&lt;/lang:groovy&gt;        28.4.2&nbsp;Scripted Validators            \n\r\n\r        Another area of application development with Spring that may benefit        from the flexibility afforded by dynamic-language-backed beans is that of        validation. It may be easier to express complex validation        logic using a loosely typed dynamic language (that may also have support        for inline regular expressions) as opposed to regular Java.            \n\r\n\r        Again, developing validators as dynamic-language-backed beans allows you to change        validation logic by simply editing and saving a simple text file; any such        changes will (depending on the configuration) automatically be reflected        in the execution of a running application and would not require the restart        of an application.            Note        \n\r\n\r          Please note that in order to effect the automatic \'pickup\' of any changes          to dynamic-language-backed beans, you will have had to enable the          \'refreshable beans\' feature. See          the section called &#8220;Refreshable beans&#8221; for a full and          detailed treatment of this feature.                    \n\r\n\r        Find below an example of a Spring        org.springframework.validation.Validator        implemented using the Groovy dynamic language. (See Section&nbsp;7.2, &#8220;Validation using Spring\'s Validator      interface&#8221;        for a discussion of the Validator interface.)            import org.springframework.validation.Validatorimport org.springframework.validation.Errorsimport org.springframework.beans.TestBeanclass TestBeanValidator implements Validator {    boolean supports(Class clazz) {        return TestBean.class.isAssignableFrom(clazz)    }    void validate(Object bean, Errors errors) {        if(bean.name?.trim()?.size() &gt; 0) {            return        }        errors.reject(\"whitespace\", \"Cannot be composed wholly of whitespace.\")    }}        28.5&nbsp;Bits and bobs        \n\r\n\r      This last section contains some bits and bobs related to the dynamic language      support.        28.5.1&nbsp;AOP - advising scripted beans            \n\r\n\r        It is possible to use the Spring AOP framework to advise scripted beans.        The Spring AOP framework actually is unaware that a bean that is being        advised might be a scripted bean, so all of the AOP use cases and functionality        that you may be using or aim to use will work with scripted beans. There is        just one (small) thing that you need to be aware of when advising scripted        beans... you cannot use class-based proxies, you must use        interface-based proxies.            \n\r\n\r        You are of course not just limited to advising scripted beans... you can        also write aspects themselves in a supported dynamic language and use such        beans to advise other Spring beans. This really would be an advanced use of        the dynamic language support though.              28.5.2&nbsp;Scoping            \n\r\n\r        In case it is not immediately obvious, scripted beans can of course be scoped        just like any other bean. The scope attribute on the        various &lt;lang:language/&gt; elements allows you to        control the scope of the underlying scripted bean, just as it does with a        regular bean. (The default scope is        singleton, just as it        is with \'regular\' beans.)            \n\r\n\r        Find below an example of using the scope attribute        to define a Groovy bean scoped as a        prototype.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:lang=\"http://www.springframework.org/schema/lang\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd\"&gt;    &lt;lang:groovy id=\"messenger\" script-source=\"classpath:Messenger.groovy\" scope=\"prototype\"&gt;        &lt;lang:property name=\"message\" value=\"I Can Do The RoboCop\" /&gt;    &lt;/lang:groovy&gt;    &lt;bean id=\"bookingService\" class=\"x.y.DefaultBookingService\"&gt;        &lt;property name=\"messenger\" ref=\"messenger\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\r        See Section&nbsp;5.5, &#8220;Bean scopes&#8221; in Chapter&nbsp;5, The IoC container        for a fuller discussion of the scoping support in the Spring Framework.              28.6&nbsp;Further Resources        \n\r\n\r      Find below links to further resources about the various dynamic languages described      in this chapter.        \n\r        \n\r\n\rThe JRuby homepage      \n\r        \n\r\n\rThe Groovy homepage      \n\r        \n\r\n\rThe BeanShell homepage      \n\r    \n\r\n\r      Some of the more active members of the Spring community have also added support for      a number of additional dynamic languages above and beyond the ones covered in this      chapter. While it is possible that such third party contributions may be added to the      list of languages supported by the main Spring distribution, your best bet for seeing      if your favourite scripting language is supported is the      Spring Modules project.      Prev&nbsp;Up&nbsp;Next27.&nbsp;Task Execution and Scheduling&nbsp;Home&nbsp;29.&nbsp;Cache Abstraction","28. Dynamic language support","scr\\dynamic-language.html","         22.&nbsp;Enterprise JavaBeans (EJB) integrationPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next22.&nbsp;Enterprise JavaBeans (EJB) integration        22.1&nbsp;Introduction        \n\r\n\r      As a lightweight container, Spring is often considered an EJB      replacement. We do believe that for many if not most applications and use      cases, Spring as a container, combined with its rich supporting      functionality in the area of transactions, ORM and JDBC access, is a better      choice than implementing equivalent functionality via an EJB container and      EJBs.          \n\r\n\r      However, it is important to note that using Spring does not prevent      you from using EJBs. In fact, Spring makes it much easier to access EJBs and      implement EJBs and functionality within them. Additionally, using Spring to      access services provided by EJBs allows the implementation of those services      to later transparently be switched between local EJB, remote EJB, or POJO      (plain old Java object) variants, without the client code having to      be changed.          \n\r\n\r      In this chapter, we look at how Spring can help you access and      implement EJBs. Spring provides particular value when accessing stateless      session beans (SLSBs), so we\'ll begin by discussing this.            22.2&nbsp;Accessing EJBs                22.2.1&nbsp;Concepts                        \n\r\n\r                To invoke a method on a local or remote stateless session bean,                client code must normally perform a JNDI lookup to obtain the (local or                remote) EJB Home object, then use a \'create\' method call on that object                to obtain the actual (local or remote) EJB object. One or more methods                are then invoked on the EJB.                  \n\r\n\r                To avoid repeated low-level code, many EJB applications use the                Service Locator and Business Delegate patterns. These are better than                spraying JNDI lookups throughout client code, but their usual                implementations have significant disadvantages. For example:                        \n\r                    \n\r\n\r                        Typically code using EJBs depends on Service Locator or                        Business Delegate singletons, making it hard to test.                                    \n\r                    \n\r\n\r                        In the case of the Service Locator pattern used without a                        Business Delegate, application code still ends up having to invoke                        the create() method on an EJB home, and deal with the resulting                        exceptions. Thus it remains tied to the EJB API and the complexity                        of the EJB programming model.                                    \n\r                    \n\r\n\r                        Implementing the Business Delegate pattern typically results                        in significant code duplication, where we have to write numerous                        methods that simply call the same method on the EJB.                                    \n\r            \n\r\n\r                The Spring approach is to allow the creation and use of proxy objects,                normally configured inside a Spring container, which act as codeless                business delegates. You do not need	to write another Service Locator, another                JNDI lookup, or duplicate methods in a hand-coded Business Delegate unless                you are actually adding real value in such code.                            22.2.2&nbsp;Accessing local SLSBs                        \n\r\n\r                Assume that we have a web controller that needs to use a local                EJB. We&#8217;ll follow best practice and use the EJB Business Methods                Interface pattern, so that the EJB&#8217;s local interface extends a non                EJB-specific business methods interface. Let&#8217;s call this business                methods interface MyComponent.                        public interface MyComponent {    ...}            \n\r\n\r                One of the main reasons to use the Business Methods Interface pattern                is to ensure that synchronization between method signatures in local                interface and bean implementation class is automatic. Another reason is                that it later makes it much easier for us to switch to a POJO (plain old                Java object) implementation of the service if it makes sense to do so.                Of course we&#8217;ll also need to implement the local home interface and                provide an implementation class that implements SessionBean                and the MyComponent business methods interface. Now the                only Java coding we&#8217;ll  need to do to hook up our web tier controller to the                EJB implementation is to expose a setter method of type MyComponent                on the controller. This will save the reference as an instance variable in the                controller:                        private MyComponent myComponent;public void setMyComponent(MyComponent myComponent) {    this.myComponent = myComponent;}            \n\r\n\r                We can subsequently use this instance variable in any business                method in the controller. Now assuming we are obtaining our controller                object out of a Spring container, we can (in the same context) configure a                LocalStatelessSessionProxyFactoryBean instance, which                will be the EJB proxy object. The configuration of the proxy, and setting of                the myComponent property of the controller is done                with a configuration entry such as:                        &lt;bean id=\"myComponent\"      class=\"org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"ejb/myBean\"/&gt;  &lt;property name=\"businessInterface\" value=\"com.mycom.MyComponent\"/&gt;&lt;/bean&gt;&lt;bean id=\"myController\" class=\"com.mycom.myController\"&gt;  &lt;property name=\"myComponent\" ref=\"myComponent\"/&gt;&lt;/bean&gt;            \n\r\n\r                There&#8217;s a lot of work happening behind the scenes, courtesy of                the Spring AOP framework, although you aren&#8217;t forced to work with AOP                concepts to enjoy the results. The myComponent bean                definition creates a proxy for the EJB, which implements the business                method interface. The EJB local home is cached on startup, so there&#8217;s                only a single JNDI lookup. Each time the EJB is invoked, the proxy                invokes the classname method on the local EJB and                invokes the	corresponding business method on the EJB.                        \n\r\n\r                The myController bean definition sets the                myComponent property of the controller class to the                EJB proxy.                  \n\r\n\r        Alternatively (and preferably in case of many such proxy definitions),        consider using the &lt;jee:local-slsb&gt;        configuration element in Spring\'s \"jee\" namespace:            &lt;jee:local-slsb id=\"myComponent\" jndi-name=\"ejb/myBean\"      business-interface=\"com.mycom.MyComponent\"/&gt;&lt;bean id=\"myController\" class=\"com.mycom.myController\"&gt;  &lt;property name=\"myComponent\" ref=\"myComponent\"/&gt;&lt;/bean&gt;            \n\r\n\r                This EJB access mechanism delivers huge simplification of                application code: the web tier code (or other EJB client code) has no                dependence on the use of EJB. If we want to replace this EJB reference                with a POJO or a mock object or other test stub, we could simply change                the myComponent bean definition without changing a                line of Java code. Additionally, we haven&#8217;t had to write a single line of                JNDI lookup or other EJB plumbing code as part of our application.                        \n\r\n\r                Benchmarks and experience in real applications indicate that the                performance overhead of this approach (which involves reflective                invocation of the target EJB) is minimal, and is typically undetectable                in typical use. Remember that we don&#8217;t want to make fine-grained calls                to EJBs anyway, as there&#8217;s a cost associated with the EJB infrastructure                in the application server.                        \n\r\n\r                There is one caveat with regards to the JNDI lookup. In a bean                container, this class is normally best used as a singleton (there simply                is no reason to make it a prototype). However, if that bean container                pre-instantiates singletons (as do the various XML                ApplicationContext variants)                you may have a problem if the bean container is loaded before the EJB                container loads the target EJB. That is because the JNDI lookup will be                performed in the init() method of this class and then                cached, but the EJB will not have been bound at the target location yet.                The solution is to not pre-instantiate this factory object, but allow it                to be created on first use. In the XML containers, this is controlled via                the lazy-init attribute.                        \n\r\n\r                Although this will not be of interest to the majority of Spring                users, those doing programmatic AOP work with EJBs may want to look at                LocalSlsbInvokerInterceptor.                            22.2.3&nbsp;Accessing remote SLSBs                        \n\r\n\r                Accessing remote EJBs is essentially identical to accessing local                EJBs, except that the                SimpleRemoteStatelessSessionProxyFactoryBean or        &lt;jee:remote-slsb&gt; configuration element is used.                Of course, with or without Spring, remote invocation semantics apply; a                call to a method on an object in another VM in another computer does                sometimes have to be treated differently in terms of usage scenarios and                failure handling.                        \n\r\n\r                Spring\'s EJB client support adds one more advantage over the                non-Spring approach. Normally it is problematic for EJB client code to                be easily switched back and forth between calling EJBs locally or                remotely. This is because the remote interface methods must declare that                they throw RemoteException, and client code must deal                with this, while the local interface methods don\'t. Client code                written for local EJBs which needs to be moved to remote EJBs                typically has to be modified to add handling for the remote exceptions,                and client code written for remote EJBs which needs to be moved to local                EJBs, can either stay the same but do a lot of unnecessary handling of                remote exceptions, or needs to be modified to remove that code. With the                Spring remote EJB proxy, you can instead not declare any thrown                RemoteException in your Business Method Interface and                implementing EJB code, have a remote interface which is identical except                that it does throw RemoteException, and rely on the                proxy to dynamically treat the two interfaces as if they were the same.                That is, client code does not have to deal with the checked                RemoteException class. Any actual                RemoteException that is thrown during the EJB                invocation will be re-thrown as the non-checked                RemoteAccessException class, which is a subclass of                RuntimeException. The target service can then be                switched at will between a local EJB or remote EJB (or even plain Java                object) implementation, without the client code knowing or caring. Of                course, this is optional; there is nothing stopping you from declaring                RemoteExceptions in your business interface.                        22.2.4&nbsp;Accessing EJB 2.x SLSBs versus EJB 3 SLSBs            \n\r\n\r        Accessing EJB 2.x Session Beans and EJB 3 Session Beans via Spring        is largely transparent. Spring\'s EJB accessors, including the        &lt;jee:local-slsb&gt; and &lt;jee:remote-slsb&gt;        facilities, transparently adapt to the actual component at runtime.        They handle a home interface if found (EJB 2.x style), or perform straight        component invocations if no home interface is available (EJB 3 style).            \n\r\n\r        Note: For EJB 3 Session Beans, you could effectively use a        JndiObjectFactoryBean / &lt;jee:jndi-lookup&gt;        as well, since fully usable component references are exposed for plain        JNDI lookups there. Defining explicit &lt;jee:local-slsb&gt;        / &lt;jee:remote-slsb&gt; lookups simply provides        consistent and more explicit EJB access configuration.                  22.3&nbsp;Using Spring\'s EJB implementation support classes            22.3.1&nbsp;EJB 2.x base classes            \n\r\n\r        Spring provides convenience classes to help you implement EJBs.        These are designed to encourage the good practice of putting business        logic behind EJBs in POJOs, leaving EJBs responsible for transaction        demarcation and (optionally) remoting.            \n\r\n\r        To implement a Stateless or Stateful session bean, or a Message Driven        bean, you need only derive your implementation class from        AbstractStatelessSessionBean,        AbstractStatefulSessionBean, and        AbstractMessageDrivenBean/AbstractJmsMessageDrivenBean,        respectively.            \n\r\n\r        Consider an example Stateless Session bean which actually delegates        the implementation to a plain java service object. We have the business        interface:            public interface MyComponent {    public void myMethod(...);    ...}      \n\r\n\rWe also have the plain Java implementation object:      public class MyComponentImpl implements MyComponent {    public String myMethod(...) {        ...    }    ...}      \n\r\n\rAnd finally the Stateless Session Bean itself:      public class MyFacadeEJB extends AbstractStatelessSessionBean        implements MyFacadeLocal {    private MyComponent myComp;    /**     * Obtain our POJO service object from the BeanFactory/ApplicationContext     * @see org.springframework.ejb.support.AbstractStatelessSessionBean#onEjbCreate()     */    protected void onEjbCreate() throws CreateException {        myComp = (MyComponent) getBeanFactory().getBean(            ServicesConstants.CONTEXT_MYCOMP_ID);    }    // for business method, delegate to POJO service impl.    public String myFacadeMethod(...) {        return myComp.myMethod(...);    }    ...}      \n\r\n\r        The Spring EJB support base classes will by default create and load        a Spring IoC container as part of their lifecycle, which is then available        to the EJB (for example, as used in the code above to obtain the POJO        service object). The loading is	done via a strategy object which is a subclass of        BeanFactoryLocator. The actual implementation of        BeanFactoryLocator used by default is        ContextJndiBeanFactoryLocator, which creates the        ApplicationContext from a resource locations specified as a JNDI        environment variable (in the case of the EJB classes, at        java:comp/env/ejb/BeanFactoryPath). If there is a need        to change the BeanFactory/ApplicationContext loading strategy, the default        BeanFactoryLocator implementation used may be overridden        by calling the setBeanFactoryLocator() method, either        in setSessionContext(), or in the actual constructor of        the EJB. Please see the Javadocs for more details.            \n\r\n\r        As described in the Javadocs, Stateful Session beans expecting to be        passivated and reactivated as part of their lifecycle, and which use a        non-serializable container instance (which is the normal case) will have        to manually call unloadBeanFactory() and        loadBeanFactory() from ejbPassivate()        and ejbActivate(), respectively, to unload and reload the        BeanFactory on passivation and activation, since it can not be saved by        the EJB container.            \n\r\n\r        The default behavior of the        ContextJndiBeanFactoryLocator class is to load an        ApplicationContext for use by an EJB, and is        adequate for some situations. However, it is problematic when the        ApplicationContext is loading a number of beans,        or the initialization of those beans is time consuming or memory        intensive (such as a Hibernate SessionFactory        initialization, for example), since every EJB will have their own copy.        In this case, the user may want to override the default        ContextJndiBeanFactoryLocator usage and use        another BeanFactoryLocator variant, such as the        ContextSingletonBeanFactoryLocator which can load        and use a shared container to be used by multiple EJBs or other clients.        Doing this is relatively simple, by adding code similar to this to the        EJB:               /**    * Override default BeanFactoryLocator implementation    * @see javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)    */   public void setSessionContext(SessionContext sessionContext) {       super.setSessionContext(sessionContext);       setBeanFactoryLocator(ContextSingletonBeanFactoryLocator.getInstance());       setBeanFactoryLocatorKey(ServicesConstants.PRIMARY_CONTEXT_ID);   }      \n\r\n\r        You would then need to create a bean definition file named beanRefContext.xml.        This file defines all bean factories (usually in the form of application contexts) that may be used        in the EJB. In many cases, this file will only contain a single bean definition such as this (where        businessApplicationContext.xml contains the bean	definitions for all business        service POJOs):            &lt;beans&gt;    &lt;bean id=\"businessBeanFactory\" class=\"org.springframework.context.support.ClassPathXmlApplicationContext\"&gt;        &lt;constructor-arg value=\"businessApplicationContext.xml\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\r        In the above example, the ServicesConstants.PRIMARY_CONTEXT_ID constant        would be defined as follows:                public static final String ServicesConstants.PRIMARY_CONTEXT_ID = \"businessBeanFactory\";        \n\r\n\r        Please see the respective Javadocs for the BeanFactoryLocator and        ContextSingletonBeanFactoryLocator classes for more information on        their usage.              22.3.2&nbsp;EJB 3 injection interceptor            \n\r\n\r        For EJB 3 Session Beans and Message-Driven Beans, Spring provides a convenient        interceptor that resolves Spring 2.5\'s @Autowired annotation        in the EJB component class:        org.springframework.ejb.interceptor.SpringBeanAutowiringInterceptor.        This interceptor can be applied through an @Interceptors annotation        in the EJB component class, or through an interceptor-binding        XML element in the EJB deployment descriptor.            @Stateless@Interceptors(SpringBeanAutowiringInterceptor.class)public class MyFacadeEJB implements MyFacadeLocal {    // automatically injected with a matching Spring bean    @Autowired    private MyComponent myComp;    // for business method, delegate to POJO service impl.    public String myFacadeMethod(...) {        return myComp.myMethod(...);    }    ...}      \n\r\n\r        SpringBeanAutowiringInterceptor by default obtains target        beans from a ContextSingletonBeanFactoryLocator, with the        context defined in a bean definition file named beanRefContext.xml.        By default, a single context definition is expected, which is obtained by type rather        than by name. However, if you need to choose between multiple context definitions,        a specific locator key is required. The locator key (i.e. the name of the context        definition in beanRefContext.xml) can be explicitly specified        either through overriding the getBeanFactoryLocatorKey method        in a custom SpringBeanAutowiringInterceptor subclass.            \n\r\n\r        Alternatively, consider overriding SpringBeanAutowiringInterceptor\'s        getBeanFactory method, e.g. obtaining a shared        ApplicationContext from a custom holder class.              Prev&nbsp;Up&nbsp;Next21.&nbsp;Remoting and web services using Spring&nbsp;Home&nbsp;23.&nbsp;JMS (Java Message Service)","22. Enterprise JavaBeans (EJB) integration","scr\\ejb.html","         8.&nbsp;Spring Expression Language (SpEL)Prev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next8.&nbsp;Spring Expression Language (SpEL)    8.1&nbsp;Introduction        \n\r\n\rThe Spring Expression Language (SpEL for short) is a powerful    expression language that supports querying and manipulating an object    graph at runtime. The language syntax is similar to Unified EL but offers    additional features, most notably method invocation and basic string    templating functionality.    \n\r\n\rWhile there are several other Java expression languages available,    OGNL, MVEL, and JBoss EL, to name a few, the Spring Expression Language    was created to provide the Spring community with a single well supported    expression language that can be used across all the products in the Spring    portfolio. Its language features are driven by the requirements of the    projects in the Spring portfolio, including tooling requirements for code    completion support within the eclipse based SpringSource Tool Suite. That    said, SpEL is based on a technology agnostic API allowing other    expression language implementations to be integrated should the need    arise.    \n\r\n\rWhile SpEL serves as the foundation for expression evaluation within    the Spring portfolio, it is not directly tied to Spring and can be used    independently. In order to be self contained, many of the examples in this    chapter use SpEL as if it were an independent expression language. This    requires creating a few bootstrapping infrastructure classes such as the    parser. Most Spring users will not need to deal with this infrastructure    and will instead only author expression strings for evaluation. An example    of this typical use is the integration of SpEL into creating XML or    annotated based bean definitions as shown in the section Expression support for defining bean    definitions.    \n\r\n\rThis chapter covers the features of the expression language, its    API, and its language syntax. In several places an Inventor and Inventor\'s    Society class are used as the target objects for expression evaluation.    These class declarations and the data used to populate them are listed at    the end of the chapter.    8.2&nbsp;Feature Overview        \n\r\n\rThe expression language supports the following functionality    \n\r        \n\r\n\rLiteral expressions      \n\r        \n\r\n\rBoolean and relational operators      \n\r        \n\r\n\rRegular expressions      \n\r        \n\r\n\rClass expressions      \n\r        \n\r\n\rAccessing properties, arrays, lists, maps      \n\r        \n\r\n\rMethod invocation      \n\r        \n\r\n\rRelational operators      \n\r        \n\r\n\rAssignment      \n\r        \n\r\n\rCalling constructors      \n\r        \n\r\n\rBean references      \n\r        \n\r\n\rArray construction      \n\r        \n\r\n\rInline lists      \n\r        \n\r\n\rTernary operator      \n\r        \n\r\n\rVariables      \n\r        \n\r\n\rUser defined functions      \n\r        \n\r\n\rCollection projection      \n\r        \n\r\n\rCollection selection      \n\r        \n\r\n\rTemplated expressions      \n\r    8.3&nbsp;Expression Evaluation using Spring\'s Expression Interface        \n\r\n\rThis section introduces the simple use of SpEL interfaces and its    expression language. The complete language reference can be found in the    section Language    Reference.    \n\r\n\rThe following code introduces the SpEL API to evaluate the literal    string expression \'Hello World\'.    ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"\'Hello World\'\");String message = (String) exp.getValue();\n\r\n\rThe value of the    message variable is simply \'Hello World\'.    \n\r\n\rThe SpEL classes and interfaces you are most likely to use are    located in the packages org.springframework.expression    and its sub packages and spel.support.    \n\r\n\rThe interface ExpressionParser is    responsible for parsing an expression string. In this example the    expression string is a string literal denoted by the surrounding single    quotes. The interface Expression is    responsible for evaluating the previously defined expression string. There    are two exceptions that can be thrown,    ParseException and    EvaluationException when calling    \'parser.parseExpression\' and    \'exp.getValue\' respectively.    \n\r\n\rSpEL supports a wide range of features, such as calling methods,    accessing properties, and calling constructors.    \n\r\n\rAs an example of method invocation, we call the \'concat\' method on    the string literal.    ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"\'Hello World\'.concat(\'!\')\");String message = (String) exp.getValue();    \n\r\n\rThe value of message is now \'Hello World!\'.    \n\r\n\rAs an example of calling a JavaBean property, the String property    \'Bytes\' can be called as shown below.    ExpressionParser parser = new SpelExpressionParser();// invokes \'getBytes()\'Expression exp = parser.parseExpression(\"\'Hello World\'.bytes\");byte[] bytes = (byte[]) exp.getValue();    \n\r\n\rSpEL also supports nested properties using standard \'dot\' notation,    i.e. prop1.prop2.prop3 and the setting of property values    \n\r\n\rPublic fields may also be accessed.    ExpressionParser parser = new SpelExpressionParser();// invokes \'getBytes().length\'Expression exp = parser.parseExpression(\"\'Hello World\'.bytes.length\");int length = (Integer) exp.getValue();    \n\r\n\rThe String\'s constructor can be called instead of using a string    literal.    ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"new String(\'hello world\').toUpperCase()\");String message = exp.getValue(String.class);    \n\r\n\rNote the use of the generic method public &lt;T&gt; T    getValue(Class&lt;T&gt; desiredResultType). Using this method    removes the need to cast the value of the expression to the desired result    type. An EvaluationException will be thrown if the    value cannot be cast to the type T or converted using    the registered type converter.    \n\r\n\rThe more common usage of SpEL is to provide an expression string that    is evaluated against a specific object instance (called the root object).    There are two options here and which to choose depends on whether the object    against which the expression is being evaluated will be changing with each    call to evaluate the expression.  In the following example    we retrieve the name property from an instance of the    Inventor class.    // Create and set a calendarGregorianCalendar c = new GregorianCalendar();c.set(1856, 7, 9);//  The constructor arguments are name, birthday, and nationality.Inventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"name\");EvaluationContext context = new StandardEvaluationContext(tesla);String name = (String) exp.getValue(context);\n\r\n\rIn the last    line, the value of the string variable \'name\' will be set to \"Nikola    Tesla\". The class StandardEvaluationContext is where you can specify which    object the \"name\" property will be evaluated against.  This is the mechanism    to use if the root object is unlikely to change, it can simply be set once    in the evaluation context.  If the root object is likely to change    repeatedly, it can be supplied on each call to getValue,    as this next example shows:    / Create and set a calendarGregorianCalendar c = new GregorianCalendar();c.set(1856, 7, 9);//  The constructor arguments are name, birthday, and nationality.Inventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(\"name\");String name = (String) exp.getValue(tesla);    \n\r\n\rIn this case the inventor tesla has been    supplied directly to getValue and the expression    evaluation infrastructure creates and manages a default evaluation context    internally - it did not require one to be supplied.    \n\r\n\rThe StandardEvaluationContext is relatively expensive to construct and    during repeated usage it builds up cached state that enables subsequent    expression evaluations to be performed more quickly.  For this reason it is    better to cache and reuse them where possible, rather than construct a new    one for each expression evaluation.        \n\r\n\rIn some cases it can be desirable to use a configured evaluation context and    yet still supply a different root object on each call to getValue.    getValue allows both to be specified on the same call.    In these situations the root object passed on the call is considered to override    any (which maybe null) specified on the evaluation context.    \n\r\n\r    Note        \n\r\n\rIn standalone usage of SpEL there is a need to create the parser,        parse expressions and perhaps provide evaluation contexts and a root        context object. However, more common usage        is to provide only the SpEL expression string as part of a        configuration file, for example for Spring bean or Spring Web Flow        definitions. In this case, the parser, evaluation context, root object        and any predefined variables are all set up implicitly, requiring        the user to specify nothing other than the expressions.    \n\r\n\r    As a final introductory example, the use of a boolean operator is    shown using the Inventor object in the previous example.    Expression exp = parser.parseExpression(\"name == \'Nikola Tesla\'\");boolean result = exp.getValue(context, Boolean.class);  // evaluates to true    8.3.1&nbsp;The EvaluationContext interface            \n\r\n\rThe interface EvaluationContext is      used when evaluating an expression to resolve properties, methods,      fields, and to help perform type conversion. The out-of-the-box      implementation, StandardEvaluationContext, uses      reflection to manipulate the object, caching      java.lang.reflect\'s Method,      Field, and Constructor      instances for increased performance.      \n\r\n\rThe StandardEvaluationContext is where you      may specify the root object to evaluate against via the method      setRootObject() or passing the root object into      the constructor. You can also specify variables and functions that      will be used in the expression using the methods      setVariable() and      registerFunction(). The use of variables and      functions are described in the language reference sections Variables and Functions. The      StandardEvaluationContext is also where you can      register custom ConstructorResolvers,      MethodResolvers, and      PropertyAccessors to extend how SpEL evaluates      expressions. Please refer to the JavaDoc of these classes for more      details.      Type Conversion                \n\r\n\rBy default SpEL uses the conversion service available in Spring        core        (org.springframework.core.convert.ConversionService).        This conversion service comes with many converters built in for common        conversions but is also fully extensible so custom conversions between        types can be added. Additionally it has the key capability that it is        generics aware. This means that when working with generic types in        expressions, SpEL will attempt conversions to maintain type        correctness for any objects it encounters.        \n\r\n\rWhat does this mean in practice? Suppose assignment, using        setValue(), is being used to set a        List property. The type of the property is actually        List&lt;Boolean&gt;. SpEL will recognize that the        elements of the list need to be converted to        Boolean before being placed in it. A simple        example:        class Simple {    public List&lt;Boolean&gt; booleanList = new ArrayList&lt;Boolean&gt;();}Simple simple = new Simple();simple.booleanList.add(true);StandardEvaluationContext simpleContext = new StandardEvaluationContext(simple);// false is passed in here as a string.  SpEL and the conversion service will// correctly recognize that it needs to be a Boolean and convert itparser.parseExpression(\"booleanList[0]\").setValue(simpleContext, \"false\");// b will be falseBoolean b = simple.booleanList.get(0);                      8.4&nbsp;Expression support for defining bean definitions        \n\r\n\rSpEL expressions can be used with XML or annotation based    configuration metadata for defining BeanDefinitions. In both cases the    syntax to define the expression is of the form #{ &lt;expression    string&gt; }.    8.4.1&nbsp;XML based configuration            \n\r\n\rA property or constructor-arg value can be set using expressions      as shown below      &lt;bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"&gt;    &lt;property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/&gt;    &lt;!-- other properties --&gt;&lt;/bean&gt;      \n\r\n\rThe variable \'systemProperties\' is predefined, so you can use it      in your expressions as shown below. Note that you do not have to prefix      the predefined variable with the \'#\' symbol in this context.      &lt;bean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\"&gt;    &lt;property name=\"defaultLocale\" value=\"#{ systemProperties[\'user.region\'] }\"/&gt;    &lt;!-- other properties --&gt;&lt;/bean&gt;      \n\r\n\rYou can also refer to other bean properties by name, for      example.      &lt;bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"&gt;    &lt;property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/&gt;    &lt;!-- other properties --&gt;&lt;/bean&gt;&lt;bean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\"&gt;    &lt;property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/&gt;    &lt;!-- other properties --&gt;&lt;/bean&gt;        8.4.2&nbsp;Annotation-based configuration            \n\r\n\rThe @Value annotation can be placed on fields,      methods and method/constructor parameters to specify a default      value.      \n\r\n\rHere is an example to set the default value of a field      variable.      public static class FieldValueTestBean  @Value(\"#{ systemProperties[\'user.region\'] }\")  private String defaultLocale;  public void setDefaultLocale(String defaultLocale)  {    this.defaultLocale = defaultLocale;  }  public String getDefaultLocale()  {    return this.defaultLocale;  }}      \n\r\n\rThe equivalent but on a property setter method is shown      below.      public static class PropertyValueTestBean  private String defaultLocale;  @Value(\"#{ systemProperties[\'user.region\'] }\")  public void setDefaultLocale(String defaultLocale)  {    this.defaultLocale = defaultLocale;  }  public String getDefaultLocale()  {    return this.defaultLocale;  }}      \n\r\n\rAutowired methods and constructors can also use the      @Value annotation.      public class SimpleMovieLister {  private MovieFinder movieFinder;  private String defaultLocale;  @Autowired  public void configure(MovieFinder movieFinder,                        @Value(\"#{ systemProperties[\'user.region\'] }\"} String defaultLocale) {      this.movieFinder = movieFinder;      this.defaultLocale = defaultLocale;  }  // ...}      public class MovieRecommender {  private String defaultLocale;  private CustomerPreferenceDao customerPreferenceDao;  @Autowired  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,                          @Value(\"#{systemProperties[\'user.country\']}\"} String defaultLocale) {      this.customerPreferenceDao = customerPreferenceDao;      this.defaultLocale = defaultLocale;  }  // ...}        8.5&nbsp;Language Reference        8.5.1&nbsp;Literal expressions            \n\r\n\rThe types of literal expressions supported are strings, dates,      numeric values (int, real, and hex), boolean and null. Strings are      delimited by single quotes. To put a single quote itself in a string use      two single quote characters. The following listing shows simple usage of      literals. Typically they would not be used in isolation like this, but      as part of a more complex expression, for example using a literal on one      side of a logical comparison operator.      ExpressionParser parser = new SpelExpressionParser();// evals to \"Hello World\"String helloWorld = (String) parser.parseExpression(\"\'Hello World\'\").getValue();double avogadrosNumber  = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();// evals to 2147483647int maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();boolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();Object nullValue = parser.parseExpression(\"null\").getValue();      \n\r\n\rNumbers support the use of the negative sign, exponential      notation, and decimal points. By default real numbers are parsed using      Double.parseDouble().        8.5.2&nbsp;Properties, Arrays, Lists, Maps, Indexers            \n\r\n\rNavigating with property references is easy, just use a period to      indicate a nested property value. The instances of Inventor class, pupin      and tesla, were populated with data listed in the section Classes used in the      examples. To navigate \"down\" and get Tesla\'s year of birth and      Pupin\'s city of birth the following expressions are used.      // evals to 1856int year = (Integer) parser.parseExpression(\"Birthdate.Year + 1900\").getValue(context);String city = (String) parser.parseExpression(\"placeOfBirth.City\").getValue(context);      \n\r\n\rCase insensitivity is allowed for the first letter of property      names. The contents of arrays and lists are obtained using square      bracket notation.      ExpressionParser parser = new SpelExpressionParser();// Inventions ArrayStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);// evaluates to \"Induction motor\"String invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext,                                                                    String.class);// Members ListStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);// evaluates to \"Nikola Tesla\"String name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);// List and Array navigation// evaluates to \"Wireless communication\"String invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext,                                                                               String.class);      \n\r\n\rThe contents of maps are obtained by specifying the literal key      value within the brackets. In this case, because keys for the Officers      map are strings, we can specify string literals.      // Officer\'s DictionaryInventor pupin = parser.parseExpression(\"Officers[\'president\']\").getValue(societyContext,                                                                          Inventor.class);// evaluates to \"Idvor\"String city =    parser.parseExpression(\"Officers[\'president\'].PlaceOfBirth.City\").getValue(societyContext,                                                                               String.class);// setting valuesparser.parseExpression(\"Officers[\'advisors\'][0].PlaceOfBirth.Country\").setValue(societyContext,                                                                                \"Croatia\");        8.5.3&nbsp;Inline lists            \n\r\n\rLists can be expressed directly in an expression using {} notation.            // evaluates to a Java list containing the four numbersList numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context);List listOfLists = (List) parser.parseExpression(\"{{\'a\',\'b\'},{\'x\',\'y\'}}\").getValue(context);      \n\r\n\r{} by itself means an empty list.  For performance reasons, if the      list is itself entirely composed of fixed literals then a constant list is created      to represent the expression, rather than building a new list on each evaluation.        8.5.4&nbsp;Array construction            \n\r\n\rArrays can be built using the familiar Java syntax, optionally      supplying an initializer to have the array populated at construction time.            int[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context);// Array with initializerint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context);// Multi dimensional arrayint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);      \n\r\n\rIt is not currently allowed to supply an initializer when constructing      a multi-dimensional array.        8.5.5&nbsp;Methods            \n\r\n\rMethods are invoked using typical Java programming syntax. You may      also invoke methods on literals. Varargs are also supported.      // string literal, evaluates to \"bc\"String c = parser.parseExpression(\"\'abc\'.substring(2, 3)\").getValue(String.class);// evaluates to trueboolean isMember = parser.parseExpression(\"isMember(\'Mihajlo Pupin\')\").getValue(societyContext,                                                                                Boolean.class);        8.5.6&nbsp;Operators            Relational operators                \n\r\n\rThe relational operators; equal, not equal, less than, less than        or equal, greater than, and greater than or equal are supported using        standard operator notation.        // evaluates to trueboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);// evaluates to falseboolean falseValue = parser.parseExpression(\"2 &lt; -5.0\").getValue(Boolean.class);// evaluates to trueboolean trueValue = parser.parseExpression(\"\'black\' &lt; \'block\'\").getValue(Boolean.class);\n\r\n\r        In addition to standard relational operators SpEL supports the        \'instanceof\' and regular expression based \'matches\' operator.        // evaluates to falseboolean falseValue = parser.parseExpression(\"\'xyz\' instanceof T(int)\").getValue(Boolean.class);// evaluates to trueboolean trueValue =     parser.parseExpression(\"\'5.00\' matches \'^-?\\\\d+(\\\\.\\\\d{2})?$\'\").getValue(Boolean.class);//evaluates to falseboolean falseValue =     parser.parseExpression(\"\'5.0067\' matches \'^-?\\\\d+(\\\\.\\\\d{2})?$\'\").getValue(Boolean.class);      \n\r\n\rEach symbolic operator can also be specified as a purely alphabetic equivalent.  This avoids      problems where the symbols used have special meaning for the document type in which      the expression is embedded (eg. an XML document).  The textual equivalents are shown      here: lt (\'&lt;\'), gt (\'&gt;\'), le (\'&lt;=\'), ge (\'&gt;=\'),      eq (\'==\'), ne (\'!=\'), div (\'/\'), mod (\'%\'), not (\'!\').      These are case insensitive.            Logical operators                \n\r\n\rThe logical operators that are supported are and, or, and not.        Their use is demonstrated below.        // -- AND --// evaluates to falseboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);// evaluates to trueString expression =  \"isMember(\'Nikola Tesla\') and isMember(\'Mihajlo Pupin\')\";boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);// -- OR --// evaluates to trueboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);// evaluates to trueString expression =  \"isMember(\'Nikola Tesla\') or isMember(\'Albert Einstein\')\";boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);// -- NOT --// evaluates to falseboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);// -- AND and NOT --String expression =  \"isMember(\'Nikola Tesla\') and !isMember(\'Mihajlo Pupin\')\";boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);            Mathematical operators                \n\r\n\rThe addition operator can be used on numbers, strings and dates.        Subtraction can be used on numbers and dates. Multiplication and        division can be used only on numbers. Other mathematical operators        supported are modulus (%) and exponential power (^). Standard operator        precedence is enforced. These operators are demonstrated below.        // Additionint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2String testString =   parser.parseExpression(\"\'test\' + \' \' + \'string\'\").getValue(String.class);  // \'test string\'// Subtractionint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4double d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000// Multiplicationint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6double twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0// Divisionint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2double one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0// Modulusint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3int one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1// Operator precedenceint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21              8.5.7&nbsp;Assignment            \n\r\n\rSetting of a property is done by using the assignment operator.      This would typically be done within a call to      setValue but can also be done inside a call to      getValue.      Inventor inventor = new Inventor();StandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);parser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");// alternativelyString aleks = parser.parseExpression(\"Name = \'Alexandar Seovic\'\").getValue(inventorContext,                                                                            String.class);      \n\r\n\r        8.5.8&nbsp;Types            \n\r\n\rThe special \'T\' operator can be used to specify an instance of      java.lang.Class (the \'type\'). Static methods are invoked using this      operator as well. The StandardEvaluationContext      uses a TypeLocator to find types and the      StandardTypeLocator (which can be replaced) is      built with an understanding of the java.lang package. This means T()      references to types within java.lang do not need to be fully qualified,      but all other type references must be.      Class dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);Class stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);boolean trueValue =   parser.parseExpression(\"T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR\")  .getValue(Boolean.class);        8.5.9&nbsp;Constructors            \n\r\n\rConstructors can be invoked using the new operator. The fully      qualified class name should be used for all but the primitive type and      String (where int, float, etc, can be used).      Inventor einstein =  p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor(\'Albert Einstein\',                                                                   \'German\')\")                                                                   .getValue(Inventor.class);//create new inventor instance within add method of Listp.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor(\'Albert Einstein\',                                                                   \'German\'))\")                                                                   .getValue(societyContext);        8.5.10&nbsp;Variables            \n\r\n\rVariables can be referenced in the expression using the syntax      #variableName. Variables are set using the method setVariable on the      StandardEvaluationContext.      Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");StandardEvaluationContext context = new StandardEvaluationContext(tesla);context.setVariable(\"newName\", \"Mike Tesla\");parser.parseExpression(\"Name = #newName\").getValue(context);System.out.println(tesla.getName()) // \"Mike Tesla\"      The #this and #root variables                \n\r\n\rThe variable #this is always defined and refers to the current        evaluation object (against which unqualified references are resolved).        The variable #root is always defined and refers to the root        context object.  Although #this may vary as components of an expression        are evaluated, #root always refers to the root.        // create an array of integersList&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();primes.addAll(Arrays.asList(2,3,5,7,11,13,17));// create parser and set variable \'primes\' as the array of integersExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setVariable(\"primes\",primes);// all prime numbers &gt; 10 from the list (using selection ?{...})// evaluates to [11, 13, 17]List&lt;Integer&gt; primesGreaterThanTen =             (List&lt;Integer&gt;) parser.parseExpression(\"#primes.?[#this&gt;10]\").getValue(context);                    8.5.11&nbsp;Functions            \n\r\n\rYou can extend SpEL by registering user defined functions that can      be called within the expression string. The function is registered with      the StandardEvaluationContext using the      method.      public void registerFunction(String name, Method m)      \n\r\n\rA reference to a Java Method provides the implementation of the      function. For example, a utility method to reverse a string is shown      below.      public abstract class StringUtils {  public static String reverseString(String input) {    StringBuilder backwards = new StringBuilder();    for (int i = 0; i &lt; input.length(); i++)      backwards.append(input.charAt(input.length() - 1 - i));    }    return backwards.toString();  }}      \n\r\n\rThis method is then registered with the evaluation context and can      be used within an expression string.      ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.registerFunction(\"reverseString\",                         StringUtils.class.getDeclaredMethod(\"reverseString\",                                                             new Class[] { String.class }));String helloWorldReversed =          parser.parseExpression(\"#reverseString(\'hello\')\").getValue(context, String.class);        8.5.12&nbsp;Bean references                \n\r\n\rIf the evaluation context has been configured with a bean resolver it is possible to        lookup beans from an expression using the (@) symbol.              ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setBeanResolver(new MyBeanResolver());// This will end up calling resolve(context,\"foo\") on MyBeanResolver during evaluationObject bean = parser.parseExpression(\"@foo\").getValue(context);        8.5.13&nbsp;Ternary Operator (If-Then-Else)            \n\r\n\rYou can use the ternary operator for performing if-then-else      conditional logic inside the expression. A minimal example is:      String falseString =             parser.parseExpression(\"false ? \'trueExp\' : \'falseExp\'\").getValue(String.class);      \n\r\n\rIn this case, the boolean false results in returning the string      value \'falseExp\'. A more realistic example is shown below.      parser.parseExpression(\"Name\").setValue(societyContext, \"IEEE\");societyContext.setVariable(\"queryName\", \"Nikola Tesla\");expression = \"isMember(#queryName)? #queryName + \' is a member of the \' \" +             \"+ Name + \' Society\' : #queryName + \' is not a member of the \' + Name + \' Society\'\";String queryResultString =                    parser.parseExpression(expression).getValue(societyContext, String.class);// queryResultString = \"Nikola Tesla is a member of the IEEE Society\"      \n\r\n\rAlso see the next section on the Elvis operator for an even      shorter syntax for the ternary operator.        8.5.14&nbsp;The Elvis Operator            \n\r\n\rThe Elvis operator is a shortening of the ternary operator syntax      and is used in the Groovy      language. With the ternary operator syntax you usually have to repeat a      variable twice, for example:      String name = \"Elvis Presley\";String displayName = name != null ? name : \"Unknown\";      \n\r\n\rInstead you can use the Elvis operator, named for the resemblance      to Elvis\' hair style.      ExpressionParser parser = new SpelExpressionParser();String name = parser.parseExpression(\"null?:\'Unknown\'\").getValue(String.class);System.out.println(name);  // \'Unknown\'      \n\r\n\rHere is a more complex example.      ExpressionParser parser = new SpelExpressionParser();Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");StandardEvaluationContext context = new StandardEvaluationContext(tesla);String name = parser.parseExpression(\"Name?:\'Elvis Presley\'\").getValue(context, String.class);System.out.println(name); // Mike Teslatesla.setName(null);name = parser.parseExpression(\"Name?:\'Elvis Presley\'\").getValue(context, String.class);System.out.println(name); // Elvis Presley        8.5.15&nbsp;Safe Navigation operator            \n\r\n\rThe Safe Navigation operator is used to avoid a      NullPointerException and comes from the Groovy      language. Typically when you have a reference to an object you might      need to verify that it is not null before accessing methods or      properties of the object. To avoid this, the safe navigation operator      will simply return null instead of throwing an exception.      ExpressionParser parser = new SpelExpressionParser();Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");tesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));StandardEvaluationContext context = new StandardEvaluationContext(tesla);String city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);System.out.println(city); // Smiljantesla.setPlaceOfBirth(null);city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);System.out.println(city); // null - does not throw NullPointerException!!!      Note        \n\r\n\rThe Elvis operator can be used to apply default values in        expressions, e.g. in an @Value expression:        @Value(\"#{systemProperties[\'pop3.port\'] ?: 25}\")        \n\r\n\rThis will inject a system property pop3.port if it        is defined or 25 if not.              8.5.16&nbsp;Collection Selection            \n\r\n\rSelection is a powerful expression language feature that allows you      to transform some source collection into another by selecting from its      entries.      \n\r\n\rSelection uses the syntax      ?[selectionExpression]. This will filter the      collection and return a new collection containing a subset of the      original elements. For example, selection would allow us to easily get a      list of Serbian inventors:      List&lt;Inventor&gt; list = (List&lt;Inventor&gt;)      parser.parseExpression(\"Members.?[Nationality == \'Serbian\']\").getValue(societyContext);      \n\r\n\rSelection is possible upon both lists and maps. In the former case      the selection criteria is evaluated against each individual list element      whilst against a map the selection criteria is evaluated against each      map entry (objects of the Java type Map.Entry). Map      entries have their key and value accessible as properties for use in the      selection.      \n\r\n\rThis expression will return a new map consisting of those elements      of the original map where the entry value is less than 27.      Map newMap = parser.parseExpression(\"map.?[value&lt;27]\").getValue();      \n\r\n\rIn addition to returning all the selected elements, it is possible      to retrieve just the first or the last value. To obtain the first entry      matching the selection the syntax is ^[...] whilst to      obtain the last matching selection the syntax is      $[...].        8.5.17&nbsp;Collection Projection            \n\r\n\rProjection allows a collection to drive the evaluation of a      sub-expression and the result is a new collection. The syntax for      projection is ![projectionExpression]. Most easily      understood by example, suppose we have a list of inventors but want the      list of cities where they were born. Effectively we want to evaluate      \'placeOfBirth.city\' for every entry in the inventor list. Using      projection:      // returns [ \'Smiljan\', \'Idvor\' ]List placesOfBirth = (List)parser.parseExpression(\"Members.![placeOfBirth.city]\");      \n\r\n\rA map can also be used to drive projection and in this case the      projection expression is evaluated against each entry in the map      (represented as a Java Map.Entry). The result of a      projection across a map is a list consisting of the evaluation of the      projection expression against each map entry.        8.5.18&nbsp;Expression templating            \n\r\n\rExpression templates allow a mixing of literal text with one or      more evaluation blocks. Each evaluation block is delimited with prefix      and suffix characters that you can define, a common choice is to use      #{ } as the delimiters. For example,      String randomPhrase =   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\",                          new TemplateParserContext()).getValue(String.class);// evaluates to \"random number is 0.7038186818312008\"      \n\r\n\rThe string is evaluated by concatenating the literal text \'random      number is \' with the result of evaluating the expression inside the #{ }      delimiter, in this case the result of calling that random() method. The      second argument to the method parseExpression() is of      the type ParserContext. The      ParserContext interface is used to      influence how the expression is parsed in order to support the      expression templating functionality. The definition of      TemplateParserContext is shown below.      public class TemplateParserContext implements ParserContext {  public String getExpressionPrefix() {    return \"#{\";  }  public String getExpressionSuffix() {    return \"}\";  }  public boolean isTemplate() {    return true;  }}        8.6&nbsp;Classes used in the examples        \n\r\n\rInventor.java    package org.spring.samples.spel.inventor;import java.util.Date;import java.util.GregorianCalendar;public class Inventor {  private String name;  private String nationality;  private String[] inventions;  private Date birthdate;  private PlaceOfBirth placeOfBirth;  public Inventor(String name, String nationality)  {    GregorianCalendar c= new GregorianCalendar();    this.name = name;    this.nationality = nationality;    this.birthdate = c.getTime();  }  public Inventor(String name, Date birthdate, String nationality) {    this.name = name;    this.nationality = nationality;    this.birthdate = birthdate;  }  public Inventor() {  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }  public String getNationality() {    return nationality;  }  public void setNationality(String nationality) {    this.nationality = nationality;  }  public Date getBirthdate() {    return birthdate;  }  public void setBirthdate(Date birthdate) {    this.birthdate = birthdate;  }  public PlaceOfBirth getPlaceOfBirth() {    return placeOfBirth;  }  public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {    this.placeOfBirth = placeOfBirth;  }  public void setInventions(String[] inventions) {    this.inventions = inventions;  }  public String[] getInventions() {    return inventions;  }}    \n\r\n\rPlaceOfBirth.java    package org.spring.samples.spel.inventor;public class PlaceOfBirth {    private String city;    private String country;    public PlaceOfBirth(String city) {        this.city=city;    }    public PlaceOfBirth(String city, String country)    {        this(city);        this.country = country;    }    public String getCity() {        return city;    }    public void setCity(String s) {        this.city = s;    }    public String getCountry() {        return country;    }    public void setCountry(String country) {        this.country = country;    }}    \n\r\n\rSociety.java    package org.spring.samples.spel.inventor;import java.util.*;public class Society {    private String name;    public static String Advisors = \"advisors\";    public static String President = \"president\";    private List&lt;Inventor&gt; members = new ArrayList&lt;Inventor&gt;();    private Map officers = new HashMap();    public List getMembers() {        return members;    }    public Map getOfficers() {        return officers;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public boolean isMember(String name)    {        boolean found = false;        for (Inventor inventor : members) {            if (inventor.getName().equals(name))            {                found = true;                break;            }        }        return found;    }}  Prev&nbsp;Up&nbsp;Next7.&nbsp;Validation, Data Binding, and Type Conversion&nbsp;Home&nbsp;9.&nbsp;Aspect Oriented Programming with Spring","8. Spring Expression Language (SpEL)","scr\\expressions.html","         Appendix&nbsp;F.&nbsp;Extensible XML authoringPrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;F.&nbsp;Extensible XML authoring        F.1&nbsp;Introduction                \n\r\n\rSince version 2.0, Spring has featured a mechanism for schema-based extensions        to the basic Spring XML format for defining and configuring beans. This section is        devoted to detailing how you would go about writing your own custom XML bean definition        parsers and integrating such parsers into the Spring IoC container.        \n\r\n\rTo facilitate the authoring of configuration files using a schema-aware XML editor,        Spring\'s extensible XML configuration mechanism is based on XML Schema. If you are        not familiar with Spring\'s current XML configuration extensions that come with the        standard Spring distribution, please first read the appendix entitled        Appendix&nbsp;E, XML Schema-based configuration.        \n\r\n\rCreating new XML configuration extensions can be done by following these (relatively)        simple steps:        \n\r\n\r            \n\r                    \n\r\n\rAuthoring an XML schema to describe your custom element(s).                \n\r                    \n\r\n\rCoding a custom NamespaceHandler                    implementation (this is an easy step, don\'t worry).                \n\r                    \n\r\n\rCoding one or more BeanDefinitionParser                    implementations (this is where the real work is done).                \n\r                    \n\r\n\rRegistering the above artifacts with Spring (this too is an easy step).                \n\r\n\r\n\r                \n\r\n\rWhat follows is a description of each of these steps. For the example, we will create        an XML extension (a custom XML element) that allows us to configure objects of the type        SimpleDateFormat (from the java.text package)        in an easy manner. When we are done, we will be able to define bean definitions of type        SimpleDateFormat like this:        &lt;myns:dateformat id=\"dateFormat\"    pattern=\"yyyy-MM-dd HH:mm\"    lenient=\"true\"/&gt;        \n\r\n\r(Don\'t worry about the fact that this example is very simple; much more        detailed examples follow afterwards. The intent in this first simple example is to walk        you through the basic steps involved.)        F.2&nbsp;Authoring the schema                \n\r\n\rCreating an XML configuration extension for use with Spring\'s IoC container        starts with authoring an XML Schema to describe the extension. What follows        is the schema we\'ll use to configure SimpleDateFormat        objects.        &lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsd:schema xmlns=\"http://www.mycompany.com/schema/myns\"    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    targetNamespace=\"http://www.mycompany.com/schema/myns\"    elementFormDefault=\"qualified\"    attributeFormDefault=\"unqualified\"&gt;   &lt;xsd:import namespace=\"http://www.springframework.org/schema/beans\"/&gt;   &lt;xsd:element name=\"dateformat\"&gt;      &lt;xsd:complexType&gt;         &lt;xsd:complexContent&gt;            &lt;xsd:extension base=\"beans:identifiedType\"&gt;               &lt;xsd:attribute name=\"lenient\" type=\"xsd:boolean\"/&gt;               &lt;xsd:attribute name=\"pattern\" type=\"xsd:string\" use=\"required\"/&gt;            &lt;/xsd:extension&gt;         &lt;/xsd:complexContent&gt;      &lt;/xsd:complexType&gt;   &lt;/xsd:element&gt;&lt;/xsd:schema&gt;        \n\r\n\r(The emphasized line contains an extension base for all tags that        will be identifiable (meaning they have an id attribute        that will be used as the bean identifier in the container). We are able to use this        attribute because we imported the Spring-provided \'beans\'        namespace.)        \n\r\n\rThe above schema will be used to configure SimpleDateFormat        objects, directly in an XML application context file using the        &lt;myns:dateformat/&gt; element.        &lt;myns:dateformat id=\"dateFormat\"    pattern=\"yyyy-MM-dd HH:mm\"    lenient=\"true\"/&gt;        \n\r\n\rNote that after we\'ve created the infrastructure classes, the above snippet of XML        will essentially be exactly the same as the following XML snippet. In other words,        we\'re just creating a bean in the container, identified by the name        \'dateFormat\' of type SimpleDateFormat, with a        couple of properties set.        &lt;bean id=\"dateFormat\" class=\"java.text.SimpleDateFormat\"&gt;    &lt;constructor-arg value=\"yyyy-HH-dd HH:mm\"/&gt;    &lt;property name=\"lenient\" value=\"true\"/&gt;&lt;/bean&gt;        Note            \n\r\n\rThe schema-based approach to creating configuration format allows for            tight integration with an IDE that has a schema-aware XML editor. Using a properly            authored schema, you can use autocompletion to have a user choose between several            configuration options defined in the enumeration.                F.3&nbsp;Coding a NamespaceHandler                \n\r\n\rIn addition to the schema, we need a NamespaceHandler        that will parse all elements of this specific namespace Spring encounters        while parsing configuration files. The NamespaceHandler        should in our case take care of the parsing of the myns:dateformat        element.        \n\r\n\rThe NamespaceHandler interface is pretty simple in that        it features just three methods:        \n\r                \n\r\n\rinit() - allows for initialization of                the NamespaceHandler and will be called by Spring                before the handler is used            \n\r                \n\r\n\rBeanDefinition parse(Element, ParserContext) -                called when Spring encounters a top-level element (not nested inside a bean definition                or a different namespace). This method can register bean definitions itself and/or                return a bean definition.            \n\r                \n\r\n\rBeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext) -                called when Spring encounters an attribute or nested element of a different namespace.                The decoration of one or more bean definitions is used for example with the                out-of-the-box	scopes Spring 2.0 supports.                We\'ll start by highlighting a simple example, without using decoration, after which                we will	show decoration in a somewhat more advanced example.            \n\r        \n\r\n\rAlthough it is perfectly possible to code your own        NamespaceHandler for the entire namespace        (and hence provide code that parses each and every element in the namespace),        it is often the case that each top-level XML element in a Spring XML        configuration file results in a single bean definition (as in our        case, where a single &lt;myns:dateformat/&gt; element        results in a single SimpleDateFormat bean definition).        Spring features a number of convenience classes that support this scenario.        In this example, we\'ll make use the NamespaceHandlerSupport class:        package org.springframework.samples.xml;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;public class MyNamespaceHandler extends NamespaceHandlerSupport {    public void init() {        registerBeanDefinitionParser(\"dateformat\", new SimpleDateFormatBeanDefinitionParser());    }}        \n\r\n\rThe observant reader will notice that there isn\'t actually a whole lot of        parsing logic in this class. Indeed... the NamespaceHandlerSupport        class has a built in notion of delegation. It supports the registration of any number        of BeanDefinitionParser instances, to which it will delegate        to when it needs to parse an element in its namespace. This clean separation of concerns        allows a NamespaceHandler to handle the orchestration        of the parsing of all of the custom elements in its namespace,        while delegating to BeanDefinitionParsers to do the grunt work of the        XML parsing; this means that each BeanDefinitionParser will        contain just the logic for parsing a single custom element, as we can see in the next step        F.4&nbsp;Coding a BeanDefinitionParser                \n\r\n\rA BeanDefinitionParser will be used if the        NamespaceHandler encounters an XML element of the type        that has been mapped to the specific bean definition parser (which is \'dateformat\'        in this case). In other words, the BeanDefinitionParser is        responsible for parsing one distinct top-level XML element defined in the        schema. In the parser, we\'ll have access to the XML element (and thus its subelements too)        so that we can parse our custom XML content, as can be seen in the following example:        package org.springframework.samples.xml;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;import org.springframework.util.StringUtils;import org.w3c.dom.Element;import java.text.SimpleDateFormat;public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {    protected Class getBeanClass(Element element) {      return SimpleDateFormat.class;    }   protected void doParse(Element element, BeanDefinitionBuilder bean) {      // this will never be null since the schema explicitly requires that a value be supplied      String pattern = element.getAttribute(\"pattern\");      bean.addConstructorArg(pattern);      // this however is an optional property      String lenient = element.getAttribute(\"lenient\");      if (StringUtils.hasText(lenient)) {         bean.addPropertyValue(\"lenient\", Boolean.valueOf(lenient));      }   }}        \n\r\n\r                 \n\r\n\rWe use the Spring-provided AbstractSingleBeanDefinitionParser                to handle a lot of the basic grunt work of creating a single                BeanDefinition.            \n\r\n\r                 \n\r\n\rWe supply the AbstractSingleBeanDefinitionParser superclass                with the type that our single BeanDefinition will represent.                    \n\r\n\rIn this simple case, this is all that we need to do. The creation of our single        BeanDefinition is handled by the AbstractSingleBeanDefinitionParser        superclass, as is the extraction and setting of the bean definition\'s unique identifier.        F.5&nbsp;Registering the handler and the schema                \n\r\n\rThe coding is finished! All that remains to be done is to somehow make the Spring XML        parsing infrastructure aware of our custom element; we do this by registering our custom        namespaceHandler and custom XSD file in two special purpose        properties files. These properties files are both placed in a        \'META-INF\' directory in your application, and can, for        example, be distributed alongside your binary classes in a JAR file. The Spring XML parsing        infrastructure will automatically pick up your new extension by consuming these special        properties files, the formats of which are detailed below.        F.5.1&nbsp;\'META-INF/spring.handlers\'                        \n\r\n\rThe properties file called \'spring.handlers\' contains a mapping            of XML Schema URIs to namespace handler classes. So for our example, we need to write the            following:            http\\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler            \n\r\n\r(The \':\' character is a valid delimiter in the Java properties format,            and so the \':\' character in the URI needs to be escaped with a backslash.)            \n\r\n\rThe first part (the key) of the key-value pair is the URI associated with your custom namespace            extension, and needs to match exactly the value of the            \'targetNamespace\' attribute as specified in your custom XSD schema.                F.5.2&nbsp;\'META-INF/spring.schemas\'                        \n\r\n\rThe properties file called \'spring.schemas\' contains a mapping            of XML Schema locations (referred to along with the schema declaration in XML files            that use the schema as part of the \'xsi:schemaLocation\' attribute)            to classpath resources. This file is needed to prevent Spring from            absolutely having to use a default EntityResolver that requires            Internet access to retrieve the schema file. If you specify the mapping in this properties file,            Spring will search for the schema on the classpath (in this case \'myns.xsd\'            in the \'org.springframework.samples.xml\' package):            http\\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd            \n\r\n\rThe upshot of this is that you are encouraged to deploy your XSD file(s) right alongside            the NamespaceHandler and BeanDefinitionParser            classes on the classpath.                F.6&nbsp;Using a custom extension in your Spring XML configuration                \n\r\n\rUsing a custom extension that you yourself have implemented is no different from        using one of the \'custom\' extensions that Spring provides straight out of the box. Find below        an example of using the custom &lt;dateformat/&gt; element developed in the        previous steps in a Spring XML configuration file.        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:myns=\"http://www.mycompany.com/schema/myns\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd\"&gt;   &lt;!-- as a top-level bean --&gt;   &lt;myns:dateformat id=\"defaultDateFormat\" pattern=\"yyyy-MM-dd HH:mm\" lenient=\"true\"/&gt;   &lt;bean id=\"jobDetailTemplate\" abstract=\"true\"&gt;      &lt;property name=\"dateFormat\"&gt;         &lt;!-- as an inner bean --&gt;         &lt;myns:dateformat pattern=\"HH:mm MM-dd-yyyy\"/&gt;      &lt;/property&gt;   &lt;/bean&gt;&lt;/beans&gt;        F.7&nbsp;Meatier examples                \n\r\n\rFind below some much meatier examples of custom XML extensions.        F.7.1&nbsp;Nesting custom tags within custom tags                        \n\r\n\rThis example illustrates how you might go about writing the various artifacts            required to satisfy a target of the following configuration:            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:foo=\"http://www.foo.com/schema/component\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd\"&gt;   &lt;foo:component id=\"bionic-family\" name=\"Bionic-1\"&gt;      &lt;foo:component name=\"Mother-1\"&gt;        &lt;foo:component name=\"Karate-1\"/&gt;        &lt;foo:component name=\"Sport-1\"/&gt;      &lt;/foo:component&gt;      &lt;foo:component name=\"Rock-1\"/&gt;   &lt;/foo:component&gt;&lt;/beans&gt;            \n\r\n\rThe above configuration actually nests custom extensions within each other. The class            that is actually configured by the above &lt;foo:component/&gt;            element is the Component class (shown directly below). Notice            how the Component class does not expose            a setter method for the \'components\' property; this makes it hard            (or rather impossible) to configure a bean definition for the Component            class using setter injection.            package com.foo;import java.util.ArrayList;import java.util.List;public class Component {   private String name;   private List&lt;Component&gt; components = new ArrayList&lt;Component&gt; ();   // mmm, there is no setter method for the \'components\'   public void addComponent(Component component) {      this.components.add(component);   }   public List&lt;Component&gt; getComponents() {      return components;   }   public String getName() {      return name;   }   public void setName(String name) {      this.name = name;   }}            \n\r\n\rThe typical solution to this issue is to create a custom FactoryBean            that exposes a setter property for the \'components\' property.            package com.foo;import org.springframework.beans.factory.FactoryBean;import java.util.List;public class ComponentFactoryBean implements FactoryBean&lt;Component&gt; {   private Component parent;   private List&lt;Component&gt; children;   public void setParent(Component parent) {      this.parent = parent;   }   public void setChildren(List&lt;Component&gt; children) {      this.children = children;   }   public Component getObject() throws Exception {      if (this.children != null &amp;&amp; this.children.size() &gt; 0) {         for (Component child : children) {            this.parent.addComponent(child);         }      }      return this.parent;   }   public Class&lt;Component&gt; getObjectType() {      return Component.class;   }   public boolean isSingleton() {      return true;   }}            \n\r\n\rThis is all very well, and does work nicely, but exposes a lot of Spring plumbing to the            end user. What we are going to do is write a custom extension that hides away all of this            Spring plumbing. If we stick to the steps described            previously, we\'ll start off by creating the XSD schema to define the structure of            our custom tag.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;xsd:schema xmlns=\"http://www.foo.com/schema/component\"         xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"         targetNamespace=\"http://www.foo.com/schema/component\"         elementFormDefault=\"qualified\"         attributeFormDefault=\"unqualified\"&gt;   &lt;xsd:element name=\"component\"&gt;      &lt;xsd:complexType&gt;         &lt;xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\"&gt;            &lt;xsd:element ref=\"component\"/&gt;         &lt;/xsd:choice&gt;         &lt;xsd:attribute name=\"id\" type=\"xsd:ID\"/&gt;         &lt;xsd:attribute name=\"name\" use=\"required\" type=\"xsd:string\"/&gt;      &lt;/xsd:complexType&gt;   &lt;/xsd:element&gt;&lt;/xsd:schema&gt;            \n\r\n\rWe\'ll then create a custom NamespaceHandler.            package com.foo;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;public class ComponentNamespaceHandler extends NamespaceHandlerSupport {   public void init() {      registerBeanDefinitionParser(\"component\", new ComponentBeanDefinitionParser());   }}            \n\r\n\rNext up is the custom BeanDefinitionParser. Remember            that what we are creating is a BeanDefinition describing            a ComponentFactoryBean.            package com.foo;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.support.ManagedList;import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.springframework.util.xml.DomUtils;import org.w3c.dom.Element;import java.util.List;public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {   protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {      return parseComponentElement(element);   }   private static AbstractBeanDefinition parseComponentElement(Element element) {      BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);      factory.addPropertyValue(\"parent\", parseComponent(element));      List&lt;Element&gt; childElements = DomUtils.getChildElementsByTagName(element, \"component\");      if (childElements != null &amp;&amp; childElements.size() &gt; 0) {         parseChildComponents(childElements, factory);      }      return factory.getBeanDefinition();   }   private static BeanDefinition parseComponent(Element element) {      BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);      component.addPropertyValue(\"name\", element.getAttribute(\"name\"));      return component.getBeanDefinition();   }   private static void parseChildComponents(List&lt;Element&gt; childElements, BeanDefinitionBuilder factory) {      ManagedList&lt;BeanDefinition&gt; children = new ManagedList&lt;BeanDefinition&gt;(childElements.size());      for (Element element : childElements) {         children.add(parseComponentElement(element));      }      factory.addPropertyValue(\"children\", children);   }}            \n\r\n\rLastly, the various artifacts need to be registered with the Spring XML infrastructure.            # in \'META-INF/spring.handlers\'http\\://www.foo.com/schema/component=com.foo.ComponentNamespaceHandler            # in \'META-INF/spring.schemas\'http\\://www.foo.com/schema/component/component.xsd=com/foo/component.xsd                F.7.2&nbsp;Custom attributes on \'normal\' elements                        \n\r\n\rWriting your own custom parser and the associated artifacts isn\'t hard, but sometimes it            is not the right thing to do. Consider the scenario where you need to add metadata to already            existing bean definitions. In this case you certainly don\'t want to have to go off and write            your own entire custom extension; rather you just want to add an additional attribute            to the existing bean definition element.            \n\r\n\rBy way of another example, let\'s say that the service class that you are defining a bean            definition for a service object that will (unknown to it) be accessing a clustered            JCache, and you want to ensure that            the named JCache instance is eagerly started within the surrounding cluster:            &lt;bean id=\"checkingAccountService\" class=\"com.foo.DefaultCheckingAccountService\"      jcache:cache-name=\"checking.account\"&gt;   &lt;!-- other dependencies here... --&gt;&lt;/bean&gt;            \n\r\n\rWhat we are going to do here is create another BeanDefinition            when the \'jcache:cache-name\' attribute is parsed; this            BeanDefinition will then initialize the named JCache            for us. We will also modify the existing BeanDefinition for the            \'checkingAccountService\' so that it will have a dependency on this            new JCache-initializing BeanDefinition.            package com.foo;public class JCacheInitializer {   private String name;   public JCacheInitializer(String name) {      this.name = name;   }   public void initialize() {      // lots of JCache API calls to initialize the named cache...   }}            \n\r\n\rNow onto the custom extension. Firstly, the authoring of the XSD schema describing the            custom attribute (quite easy in this case).            &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;xsd:schema xmlns=\"http://www.foo.com/schema/jcache\"            xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"            targetNamespace=\"http://www.foo.com/schema/jcache\"            elementFormDefault=\"qualified\"&gt;   &lt;xsd:attribute name=\"cache-name\" type=\"xsd:string\"/&gt;&lt;/xsd:schema&gt;            \n\r\n\rNext, the associated NamespaceHandler.            package com.foo;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;public class JCacheNamespaceHandler extends NamespaceHandlerSupport {   public void init() {      super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\",            new JCacheInitializingBeanDefinitionDecorator());   }}            \n\r\n\rNext, the parser. Note that in this case, because we are going to be parsing an XML            attribute, we write a BeanDefinitionDecorator rather than a            BeanDefinitionParser.            package com.foo;import org.springframework.beans.factory.config.BeanDefinitionHolder;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.xml.BeanDefinitionDecorator;import org.springframework.beans.factory.xml.ParserContext;import org.w3c.dom.Attr;import org.w3c.dom.Node;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {   private static final String[] EMPTY_STRING_ARRAY = new String[0];   public BeanDefinitionHolder decorate(         Node source, BeanDefinitionHolder holder, ParserContext ctx) {      String initializerBeanName = registerJCacheInitializer(source, ctx);      createDependencyOnJCacheInitializer(holder, initializerBeanName);      return holder;   }   private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder, String initializerBeanName) {      AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());      String[] dependsOn = definition.getDependsOn();      if (dependsOn == null) {         dependsOn = new String[]{initializerBeanName};      } else {         List dependencies = new ArrayList(Arrays.asList(dependsOn));         dependencies.add(initializerBeanName);         dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);      }      definition.setDependsOn(dependsOn);   }   private String registerJCacheInitializer(Node source, ParserContext ctx) {      String cacheName = ((Attr) source).getValue();      String beanName = cacheName + \"-initializer\";      if (!ctx.getRegistry().containsBeanDefinition(beanName)) {         BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);         initializer.addConstructorArg(cacheName);         ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());      }      return beanName;   }}            \n\r\n\rLastly, the various artifacts need to be registered with the Spring XML infrastructure.            # in \'META-INF/spring.handlers\'http\\://www.foo.com/schema/jcache=com.foo.JCacheNamespaceHandler            # in \'META-INF/spring.schemas\'http\\://www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd                F.8&nbsp;Further Resources                \n\r\n\rFind below links to further resources concerning XML Schema and the extensible XML support        described in this chapter.        \n\r                \n\r\n\rThe XML Schema Part 1: Structures Second Edition            \n\r                \n\r\n\rThe XML Schema Part 2: Datatypes Second Edition            \n\r    Prev&nbsp;Up&nbsp;NextAppendix&nbsp;E.&nbsp;XML Schema-based configuration&nbsp;Home&nbsp;Appendix&nbsp;G.&nbsp;spring.tld","F. Extensible XML authoring","scr\\extensible-xml.html","         Spring Framework Reference Documentation&nbsp;&nbsp;&nbsp;NextSpring Framework Reference DocumentationAuthors      Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb    \n\r\n\r3.2.4.RELEASE\n\r\n\rCopyright &copy; 2004-2013       \n\r\n\rCopies of this document may be made for your own use and for      distribution to others, provided that you do not charge any fee for such      copies and further provided that each copy contains this Copyright      Notice, whether distributed in print or electronically.    \n\r\n\rTable of ContentsI. Overview of Spring Framework1. Introduction to Spring Framework1.1. Dependency Injection and Inversion of Control1.2. Modules1.2.1. Core Container1.2.2. Data Access/Integration1.2.3. Web1.2.4. AOP and Instrumentation1.2.5. Test1.3. Usage scenarios1.3.1. Dependency Management and Naming ConventionsSpring Dependencies and Depending on SpringMaven Dependency ManagementIvy Dependency Management1.3.2. LoggingNot Using Commons LoggingUsing SLF4JUsing Log4JII. What\'s New in Spring 32. New Features and Enhancements in Spring Framework 3.02.1. Java 52.2. Improved documentation2.3. New articles and tutorials2.4. New module organization and build system2.5. Overview of new features2.5.1. Core APIs updated for Java 52.5.2. Spring Expression Language2.5.3. The Inversion of Control (IoC) containerJava based bean metadataDefining bean metadata within components2.5.4. General purpose type conversion system and field formatting      system2.5.5. The Data Tier2.5.6. The Web TierComprehensive REST support@MVC additions2.5.7. Declarative model validation2.5.8. Early support for Java EE 62.5.9. Support for embedded databases3. New Features and Enhancements in Spring Framework 3.13.1. Cache Abstraction3.2. Bean Definition Profiles3.3. Environment Abstraction3.4. PropertySource Abstraction3.5. Code equivalents for Spring\'s XML namespaces3.6. Support for Hibernate 4.x3.7. TestContext framework support for @Configuration classes and bean    definition profiles3.8. c: namespace for more concise constructor injection3.9. Support for injection against non-standard JavaBeans    setters3.10. Support for Servlet 3 code-based configuration of Servlet    Container3.11. Support for Servlet 3 MultipartResolver3.12. JPA EntityManagerFactory bootstrapping without    persistence.xml3.13. New HandlerMethod-based Support Classes For Annotated Controller    Processing3.14. \"consumes\" and \"produces\" conditions in    @RequestMapping3.15. Flash Attributes and    RedirectAttributes3.16. URI Template Variable Enhancements3.17. @Valid On    @RequestBody Controller Method Arguments3.18. @RequestPart Annotation On    Controller Method Arguments3.19. UriComponentsBuilder and UriComponents4. New Features and Enhancements in Spring Framework 3.24.1. Support for Servlet 3 based asynchronous request processing4.2. Spring MVC Test framework4.3. Content negotiation improvements4.4. @ControllerAdvice annotation4.5. Matrix variables4.6. Abstract base class for code-based Servlet 3+ container    initialization4.7. ResponseEntityExceptionHandler class4.8. Support for generic types in the    RestTemplate and in    @RequestBody arguments4.9. Jackson JSON 2 and related improvements4.10. Tiles 34.11. @RequestBody improvements4.12. HTTP PATCH method4.13. Excluded patterns in mapped interceptors4.14. Using meta-annotations for injection points and for bean definition methods4.15. Initial support for JCache 0.54.16. Support for @DateTimeFormat without    Joda Time4.17. Global date &amp; time formatting4.18. New Testing Features4.19. Concurrency refinements across the framework4.20. New Gradle-based build and move to GitHub4.21. Refined Java SE 7 / OpenJDK 7 supportIII. Core Technologies5. The IoC container5.1. Introduction to the Spring IoC container and beans5.2. Container overview5.2.1. Configuration metadata5.2.2. Instantiating a containerComposing XML-based configuration metadata5.2.3. Using the container5.3. Bean overview5.3.1. Naming beansAliasing a bean outside the bean definition5.3.2. Instantiating beansInstantiation with a constructorInstantiation with a static factory methodInstantiation using an instance factory method5.4. Dependencies5.4.1. Dependency injectionConstructor-based dependency injectionSetter-based dependency injectionDependency resolution processExamples of dependency injection5.4.2. Dependencies and configuration in detailStraight values (primitives, Strings, and so        on)References to other beans (collaborators)Inner beansCollectionsNull and empty string valuesXML shortcut with the p-namespaceXML shortcut with the c-namespaceCompound property names5.4.3. Using depends-on5.4.4. Lazy-initialized      beans5.4.5. Autowiring collaboratorsLimitations and disadvantages of autowiringExcluding a bean from autowiring5.4.6. Method injectionLookup method injectionArbitrary method replacement5.5. Bean scopes5.5.1. The singleton scope5.5.2. The prototype scope5.5.3. Singleton beans with prototype-bean dependencies5.5.4. Request, session, and global session scopesInitial web configurationRequest scopeSession scopeGlobal session scopeScoped beans as dependencies5.5.5. Custom scopesCreating a custom scopeUsing a custom scope5.6. Customizing the nature of a bean5.6.1. Lifecycle callbacksInitialization callbacksDestruction callbacksDefault initialization and destroy methodsCombining lifecycle mechanismsStartup and shutdown callbacksShutting down the Spring IoC container gracefully in non-web        applications5.6.2. ApplicationContextAware and      BeanNameAware5.6.3. Other Aware interfaces5.7. Bean definition inheritance5.8. Container Extension Points5.8.1. Customizing beans using a      BeanPostProcessorExample: Hello World,        BeanPostProcessor-styleExample: The        RequiredAnnotationBeanPostProcessor5.8.2. Customizing configuration metadata with a      BeanFactoryPostProcessorExample: the        PropertyPlaceholderConfigurerExample: the        PropertyOverrideConfigurer5.8.3. Customizing instantiation logic with a      FactoryBean5.9. Annotation-based container configuration5.9.1. @Required5.9.2. @Autowired5.9.3. Fine-tuning annotation-based autowiring with qualifiers5.9.4. CustomAutowireConfigurer5.9.5. @Resource5.9.6. @PostConstruct and      @PreDestroy5.10. Classpath scanning and managed components5.10.1. @Component and further stereotype      annotations5.10.2. Automatically detecting classes and registering bean      definitions5.10.3. Using filters to customize scanning5.10.4. Defining bean metadata within components5.10.5. Naming autodetected components5.10.6. Providing a scope for autodetected components5.10.7. Providing qualifier metadata with annotations5.11. Using JSR 330 Standard Annotations5.11.1. Dependency Injection with @Inject and @Named5.11.2. @Named: a standard equivalent to the @Component annotation5.11.3. Limitations of the standard approach5.12. Java-based container configuration5.12.1. Basic concepts: @Bean and @Configuration5.12.2. Instantiating the Spring container using      AnnotationConfigApplicationContextSimple constructionBuilding the container programmatically using        register(Class&lt;?&gt;...)Enabling component scanning with        scan(String...)Support for web applications with        AnnotationConfigWebApplicationContext5.12.3. Using the @Bean annotationDeclaring a beanReceiving lifecycle callbacksSpecifying bean scopeCustomizing bean namingBean aliasing5.12.4. Using the @Configuration annotationInjecting inter-bean dependenciesLookup method injectionFurther information about how Java-based configuration works      internally5.12.5. Composing Java-based configurationsUsing the @Import annotationCombining Java and XML configuration5.13. Registering a LoadTimeWeaver5.14. Additional Capabilities of the    ApplicationContext5.14.1. Internationalization using      MessageSource5.14.2. Standard and Custom Events5.14.3. Convenient access to low-level resources5.14.4. Convenient ApplicationContext      instantiation for web applications5.14.5. Deploying a Spring ApplicationContext as a J2EE RAR file5.15. The BeanFactory5.15.1. BeanFactory or        ApplicationContext?5.15.2. Glue code and the evil singleton6. Resources6.1. Introduction6.2. The Resource interface6.3. Built-in Resource implementations6.3.1. UrlResource6.3.2. ClassPathResource6.3.3. FileSystemResource6.3.4. ServletContextResource6.3.5. InputStreamResource6.3.6. ByteArrayResource6.4. The ResourceLoader6.5. The ResourceLoaderAware interface6.6. Resources as dependencies6.7. Application contexts and Resource paths6.7.1. Constructing application contextsConstructing ClassPathXmlApplicationContext instances - shortcuts6.7.2. Wildcards in application context constructor resource pathsAnt-style PatternsThe classpath*: prefixOther notes relating to wildcards6.7.3. FileSystemResource caveats7. Validation, Data Binding, and Type Conversion7.1. Introduction7.2. Validation using Spring\'s Validator      interface7.3. Resolving codes to error messages7.4. Bean manipulation and the      BeanWrapper7.4.1. Setting and getting basic and nested properties7.4.2. Built-in PropertyEditor        implementationsRegistering additional custom          PropertyEditors7.5. Spring 3 Type Conversion7.5.1. Converter SPI7.5.2. ConverterFactory7.5.3. GenericConverterConditionalGenericConverter7.5.4. ConversionService API7.5.5. Configuring a ConversionService7.5.6. Using a ConversionService programmatically7.6. Spring 3 Field Formatting7.6.1. Formatter SPI7.6.2. Annotation-driven FormattingFormat Annotation API7.6.3. FormatterRegistry SPI7.6.4. FormatterRegistrar SPI7.6.5. Configuring Formatting in Spring MVC7.7. Configuring a global date &amp; time format7.8. Spring 3 Validation7.8.1. Overview of the JSR-303 Bean Validation API7.8.2. Configuring a Bean Validation ImplementationInjecting a ValidatorConfiguring Custom ConstraintsAdditional Configuration Options7.8.3. Configuring a DataBinder7.8.4. Spring MVC 3 ValidationTriggering @Controller Input ValidationConfiguring a Validator for use by Spring MVCConfiguring a JSR-303 Validator for use by Spring MVC8. Spring Expression Language (SpEL)8.1. Introduction8.2. Feature Overview8.3. Expression Evaluation using Spring\'s Expression Interface8.3.1. The EvaluationContext interfaceType Conversion8.4. Expression support for defining bean definitions8.4.1. XML based configuration8.4.2. Annotation-based configuration8.5. Language Reference8.5.1. Literal expressions8.5.2. Properties, Arrays, Lists, Maps, Indexers8.5.3. Inline lists8.5.4. Array construction8.5.5. Methods8.5.6. OperatorsRelational operatorsLogical operatorsMathematical operators8.5.7. Assignment8.5.8. Types8.5.9. Constructors8.5.10. VariablesThe #this and #root variables8.5.11. Functions8.5.12. Bean references8.5.13. Ternary Operator (If-Then-Else)8.5.14. The Elvis Operator8.5.15. Safe Navigation operator8.5.16. Collection Selection8.5.17. Collection Projection8.5.18. Expression templating8.6. Classes used in the examples9. Aspect Oriented Programming with Spring9.1. Introduction9.1.1. AOP concepts9.1.2. Spring AOP capabilities and goals9.1.3. AOP Proxies9.2. @AspectJ support9.2.1. Enabling @AspectJ SupportEnabling @AspectJ Support with Java configurationEnabling @AspectJ Support with XML configuration9.2.2. Declaring an aspect9.2.3. Declaring a pointcutSupported Pointcut DesignatorsCombining pointcut expressionsSharing common pointcut definitionsExamplesWriting good pointcuts9.2.4. Declaring adviceBefore adviceAfter returning adviceAfter throwing adviceAfter (finally) adviceAround adviceAdvice parametersAdvice ordering9.2.5. Introductions9.2.6. Aspect instantiation models9.2.7. Example9.3. Schema-based AOP support9.3.1. Declaring an aspect9.3.2. Declaring a pointcut9.3.3. Declaring adviceBefore adviceAfter returning adviceAfter throwing adviceAfter (finally) adviceAround adviceAdvice parametersAdvice ordering9.3.4. Introductions9.3.5. Aspect instantiation models9.3.6. Advisors9.3.7. Example9.4. Choosing which AOP declaration style to use9.4.1. Spring AOP or full AspectJ?9.4.2. @AspectJ or XML for Spring AOP?9.5. Mixing aspect types9.6. Proxying mechanisms9.6.1. Understanding AOP proxies9.7. Programmatic creation of @AspectJ Proxies9.8. Using AspectJ with Spring applications9.8.1. Using AspectJ to dependency inject domain objects with      SpringUnit testing @Configurable        objectsWorking with multiple application contexts9.8.2. Other Spring aspects for AspectJ9.8.3. Configuring AspectJ aspects using Spring IoC9.8.4. Load-time weaving with AspectJ in the Spring FrameworkA first exampleAspects\'META-INF/aop.xml\'Required libraries (JARS)Spring configurationEnvironment-specific configuration9.9. Further Resources10. Spring AOP APIs10.1. Introduction10.2. Pointcut API in Spring10.2.1. Concepts10.2.2. Operations on pointcuts10.2.3. AspectJ expression pointcuts10.2.4. Convenience pointcut implementationsStatic pointcutsDynamic pointcuts10.2.5. Pointcut superclasses10.2.6. Custom pointcuts10.3. Advice API in Spring10.3.1. Advice lifecycles10.3.2. Advice types in SpringInterception around adviceBefore adviceThrows adviceAfter Returning adviceIntroduction advice10.4. Advisor API in Spring10.5. Using the ProxyFactoryBean to create AOP proxies10.5.1. Basics10.5.2. JavaBean properties10.5.3. JDK- and CGLIB-based proxies10.5.4. Proxying interfaces10.5.5. Proxying classes10.5.6. Using \'global\' advisors10.6. Concise proxy definitions10.7. Creating AOP proxies programmatically with the ProxyFactory10.8. Manipulating advised objects10.9. Using the \"auto-proxy\" facility10.9.1. Autoproxy bean definitionsBeanNameAutoProxyCreatorDefaultAdvisorAutoProxyCreatorAbstractAdvisorAutoProxyCreator10.9.2. Using metadata-driven auto-proxying10.10. Using TargetSources10.10.1. Hot swappable target sources10.10.2. Pooling target sources10.10.3. Prototype target sources10.10.4. ThreadLocal target sources10.11. Defining new Advice types10.12. Further resources11. Testing11.1. Introduction to Spring Testing11.2. Unit Testing11.2.1. Mock ObjectsEnvironmentJNDIServlet APIPortlet API11.2.2. Unit Testing support ClassesGeneral utilitiesSpring MVC11.3. Integration Testing11.3.1. Overview11.3.2. Goals of Integration TestingContext management and cachingDependency Injection of test fixturesTransaction managementSupport classes for integration testing11.3.3. JDBC Testing Support11.3.4. AnnotationsSpring Testing AnnotationsStandard Annotation SupportSpring JUnit Testing Annotations11.3.5. Spring TestContext FrameworkKey abstractionsContext managementDependency injection of test fixturesTesting request and session scoped beansTransaction managementTestContext Framework support classes11.3.6. Spring MVC Test FrameworkServer-Side TestsClient-Side REST Tests11.3.7. PetClinic Example11.4. Further ResourcesIV. Data Access12. Transaction Management12.1. Introduction to Spring Framework transaction management12.2. Advantages of the Spring Framework\'s transaction support model12.2.1. Global transactions12.2.2. Local transactions12.2.3. Spring Framework\'s consistent programming model12.3. Understanding the Spring Framework transaction abstraction12.4. Synchronizing resources with transactions12.4.1. High-level synchronization approach12.4.2. Low-level synchronization approach12.4.3. TransactionAwareDataSourceProxy12.5. Declarative transaction management12.5.1. Understanding the Spring Framework\'s declarative transaction      implementation12.5.2. Example of declarative transaction implementation12.5.3. Rolling back a declarative transaction12.5.4. Configuring different transactional semantics for different      beans12.5.5. &lt;tx:advice/&gt; settings12.5.6. Using @Transactional@Transactional settingsMultiple Transaction Managers with @TransactionalCustom shortcut annotations12.5.7. Transaction propagationRequiredRequiresNewNested12.5.8. Advising transactional operations12.5.9. Using @Transactional with      AspectJ12.6. Programmatic transaction management12.6.1. Using the TransactionTemplateSpecifying transaction settings12.6.2. Using the      PlatformTransactionManager12.7. Choosing between programmatic and declarative transaction    management12.8. Application server-specific integration12.8.1. IBM WebSphere12.8.2. BEA WebLogic Server12.8.3. Oracle OC4J12.9. Solutions to common problems12.9.1. Use of the wrong transaction manager for a specific      DataSource12.10. Further Resources13. DAO support13.1. Introduction13.2. Consistent exception hierarchy13.3. Annotations used for configuring DAO or Repository classes14. Data access with JDBC14.1. Introduction to Spring Framework JDBC14.1.1. Choosing an approach for JDBC database access14.1.2. Package hierarchy14.2. Using the JDBC core classes to control basic JDBC processing and    error handling14.2.1. JdbcTemplateExamples of JdbcTemplate class usageJdbcTemplate best practices14.2.2. NamedParameterJdbcTemplate14.2.3. SQLExceptionTranslator14.2.4. Executing statements14.2.5. Running queries14.2.6. Updating the database14.2.7. Retrieving auto-generated keys14.3. Controlling database connections14.3.1. DataSource14.3.2. DataSourceUtils14.3.3. SmartDataSource14.3.4. AbstractDataSource14.3.5. SingleConnectionDataSource14.3.6. DriverManagerDataSource14.3.7. TransactionAwareDataSourceProxy14.3.8. DataSourceTransactionManager14.3.9. NativeJdbcExtractor14.4. JDBC batch operations14.4.1. Basic batch operations with the JdbcTemplate14.4.2. Batch operations with a List of objects14.4.3. Batch operations with multiple batches14.5. Simplifying JDBC operations with the SimpleJdbc classes14.5.1. Inserting data using SimpleJdbcInsert14.5.2. Retrieving auto-generated keys using SimpleJdbcInsert14.5.3. Specifying columns for a SimpleJdbcInsert14.5.4. Using SqlParameterSource to provide parameter values14.5.5. Calling a stored procedure with SimpleJdbcCall14.5.6. Explicitly declaring parameters to use for a      SimpleJdbcCall14.5.7. How to define SqlParameters14.5.8. Calling a stored function using SimpleJdbcCall14.5.9. Returning ResultSet/REF Cursor from a SimpleJdbcCall14.6. Modeling JDBC operations as Java objects14.6.1. SqlQuery14.6.2. MappingSqlQuery14.6.3. SqlUpdate14.6.4. StoredProcedure14.7. Common problems with parameter and data value handling14.7.1. Providing SQL type information for parameters14.7.2. Handling BLOB and CLOB objects14.7.3. Passing in lists of values for IN clause14.7.4. Handling complex types for stored procedure calls14.8. Embedded database support14.8.1. Why use an embedded database?14.8.2. Creating an embedded database instance using Spring XML14.8.3. Creating an embedded database instance programmatically14.8.4. Extending the embedded database support14.8.5. Using HSQL14.8.6. Using H214.8.7. Using Derby14.8.8. Testing data access logic with an embedded database14.9. Initializing a DataSource14.9.1. Initializing a database instance using Spring XMLInitialization of Other Components that Depend on the        Database15. Object Relational Mapping (ORM) Data Access15.1. Introduction to ORM with Spring15.2. General ORM integration considerations15.2.1. Resource and transaction management15.2.2. Exception translation15.3. Hibernate15.3.1. SessionFactory setup in a Spring      container15.3.2. Implementing DAOs based on plain Hibernate 3 API15.3.3. Declarative transaction demarcation15.3.4. Programmatic transaction demarcation15.3.5. Transaction management strategies15.3.6. Comparing container-managed and locally defined resources15.3.7. Spurious application server warnings with Hibernate15.4. JDO15.4.1. PersistenceManagerFactory      setup15.4.2. Implementing DAOs based on the plain JDO API15.4.3. Transaction management15.4.4. JdoDialect15.5. JPA15.5.1. Three options for JPA setup in a Spring environmentLocalEntityManagerFactoryBeanObtaining an EntityManagerFactory from        JNDILocalContainerEntityManagerFactoryBeanDealing with multiple persistence units15.5.2. Implementing DAOs based on plain JPA15.5.3. Transaction Management15.5.4. JpaDialect15.6. iBATIS SQL Maps15.6.1. Setting up the SqlMapClient15.6.2. Using SqlMapClientTemplate and      SqlMapClientDaoSupport15.6.3. Implementing DAOs based on plain iBATIS API16. Marshalling XML using O/X Mappers16.1. Introduction16.2. Marshaller and Unmarshaller16.2.1. Marshaller16.2.2. Unmarshaller16.2.3. XmlMappingException16.3. Using Marshaller and Unmarshaller16.4. XML Schema-based Configuration16.5. JAXB16.5.1. Jaxb2MarshallerXML Schema-based Configuration16.6. Castor16.6.1. CastorMarshaller16.6.2. MappingXML Schema-based Configuration16.7. XMLBeans16.7.1. XmlBeansMarshallerXML Schema-based Configuration16.8. JiBX16.8.1. JibxMarshallerXML Schema-based Configuration16.9. XStream16.9.1. XStreamMarshallerV. The Web17. Web MVC framework17.1. Introduction to Spring Web MVC framework17.1.1. Features of Spring Web MVC17.1.2. Pluggability of other MVC implementations17.2. The DispatcherServlet17.2.1. Special Bean Types In the WebApplicationContext17.2.2. Default DispatcherServlet Configuration17.2.3. DispatcherServlet Processing Sequence17.3. Implementing Controllers17.3.1. Defining a controller with      @Controller17.3.2. Mapping Requests With      @RequestMappingNew Support Classes for @RequestMapping methods in Spring MVC 3.1URI Template PatternsURI Template Patterns with Regular ExpressionsPath PatternsPatterns with PlaceholdersMatrix VariablesConsumable Media TypesProducible Media TypesRequest Parameters and Header Values17.3.3. Defining @RequestMapping handler      methodsSupported method argument typesSupported method return typesBinding request parameters to method parameters with        @RequestParamMapping the request body with the @RequestBody        annotationMapping the response body with the        @ResponseBody annotationUsing HttpEntity&lt;?&gt;Using @ModelAttribute on a        methodUsing @ModelAttribute on a        method argumentUsing @SessionAttributes to store model        attributes in the HTTP session between requestsSpecifying redirect and flash attributesWorking with        \"application/x-www-form-urlencoded\" dataMapping cookie values with the @CookieValue annotationMapping request header attributes with the @RequestHeader        annotationMethod Parameters And Type ConversionCustomizing WebDataBinder        initializationSupport for the \'Last-Modified\' Response Header To Facilitate        Content Caching17.3.4. Asynchronous Request ProcessingException Handling for Async RequestsIntercepting Async RequestsConfiguration for Async Request Processing17.3.5. Testing Controllers17.4. Handler mappings17.4.1. Intercepting requests with a      HandlerInterceptor17.5. Resolving views17.5.1. Resolving views with the      ViewResolver interface17.5.2. Chaining ViewResolvers17.5.3. Redirecting to viewsRedirectViewThe redirect: prefixThe forward: prefix17.5.4. ContentNegotiatingViewResolver17.6. Using flash attributes17.7. Building URIs17.8. Using locales17.8.1. AcceptHeaderLocaleResolver17.8.2. CookieLocaleResolver17.8.3. SessionLocaleResolver17.8.4. LocaleChangeInterceptor17.9. Using themes17.9.1. Overview of themes17.9.2. Defining themes17.9.3. Theme resolvers17.10. Spring\'s multipart (file upload) support17.10.1. Introduction17.10.2. Using a MultipartResolver with      Commons FileUpload17.10.3. Using a MultipartResolver with      Servlet 3.017.10.4. Handling a file upload in a form17.10.5. Handling a file upload request from programmatic clients17.11. Handling exceptions17.11.1. HandlerExceptionResolver17.11.2. @ExceptionHandler17.11.3. Handling Standard Spring MVC Exceptions17.11.4. Annotating Business Exceptions With @ResponseStatus17.11.5. Customizing the Default Servlet Container Error Page17.12. Convention over configuration support17.12.1. The Controller      ControllerClassNameHandlerMapping17.12.2. The Model ModelMap      (ModelAndView)17.12.3. The View -      RequestToViewNameTranslator17.13. ETag support17.14. Code-based Servlet container initialization17.15. Configuring Spring MVC17.15.1. Enabling the MVC Java Config or the MVC XML Namespace17.15.2. Customizing the Provided Configuration17.15.3. Configuring Interceptors17.15.4. Configuring Content Negotiation17.15.5. Configuring View Controllers17.15.6. Configuring Serving of Resources17.15.7. mvc:default-servlet-handler17.15.8. More Spring Web MVC Resources17.15.9. Advanced Customizations with MVC Java Config17.15.10. Advanced Customizations with the MVC Namespace18. View technologies18.1. Introduction18.2. JSP &amp; JSTL18.2.1. View resolvers18.2.2. \'Plain-old\' JSPs versus JSTL18.2.3. Additional tags facilitating development18.2.4. Using Spring\'s form tag libraryConfigurationThe form tagThe input tagThe checkbox tagThe checkboxes tagThe radiobutton tagThe radiobuttons tagThe password tagThe select tagThe option tagThe options tagThe textarea tagThe hidden tagThe errors tagHTTP Method ConversionHTML5 Tags18.3. Tiles18.3.1. Dependencies18.3.2. How to integrate Tiles          UrlBasedViewResolver                  ResourceBundleViewResolver        SimpleSpringPreparerFactory and        SpringBeanPreparerFactory18.4. Velocity &amp; FreeMarker18.4.1. Dependencies18.4.2. Context configuration18.4.3. Creating templates18.4.4. Advanced configurationvelocity.propertiesFreeMarker18.4.5. Bind support and form handlingThe bind macrosSimple bindingForm input generation macrosHTML escaping and XHTML compliance18.5. XSLT18.5.1. My First WordsBean definitionsStandard MVC controller codeConvert the model data to XMLDefining the view propertiesDocument transformation18.5.2. Summary18.6. Document views (PDF/Excel)18.6.1. Introduction18.6.2. Configuration and setupDocument view definitionsController codeSubclassing for Excel viewsSubclassing for PDF views18.7. JasperReports18.7.1. Dependencies18.7.2. ConfigurationConfiguring the        ViewResolverConfiguring the ViewsAbout Report FilesUsing        JasperReportsMultiFormatView18.7.3. Populating the ModelAndView18.7.4. Working with Sub-ReportsConfiguring Sub-Report FilesConfiguring Sub-Report Data Sources18.7.5. Configuring Exporter Parameters18.8. Feed Views18.9. XML Marshalling View18.10. JSON Mapping View19. Integrating with other web frameworks19.1. Introduction19.2. Common configuration19.3. JavaServer Faces 1.1 and 1.219.3.1. DelegatingVariableResolver (JSF 1.1/1.2)19.3.2. SpringBeanVariableResolver (JSF 1.1/1.2)19.3.3. SpringBeanFacesELResolver (JSF 1.2+)19.3.4. FacesContextUtils19.4. Apache Struts 1.x and 2.x19.4.1. ContextLoaderPluginDelegatingRequestProcessorDelegatingActionProxy19.4.2. ActionSupport Classes19.5. WebWork 2.x19.6. Tapestry 3.x and 4.x19.6.1. Injecting Spring-managed beansDependency Injecting Spring Beans into Tapestry pagesComponent definition filesAdding abstract accessorsDependency Injecting Spring Beans into Tapestry pages -        Tapestry 4.x style19.7. Further Resources20. Portlet MVC Framework20.1. Introduction20.1.1. Controllers - The C in MVC20.1.2. Views - The V in MVC20.1.3. Web-scoped beans20.2. The DispatcherPortlet20.3. The ViewRendererServlet20.4. Controllers20.4.1. AbstractController and PortletContentGenerator20.4.2. Other simple controllers20.4.3. Command Controllers20.4.4. PortletWrappingController20.5. Handler mappings20.5.1. PortletModeHandlerMapping20.5.2. ParameterHandlerMapping20.5.3. PortletModeParameterHandlerMapping20.5.4. Adding HandlerInterceptors20.5.5. HandlerInterceptorAdapter20.5.6. ParameterMappingInterceptor20.6. Views and resolving them20.7. Multipart (file upload) support20.7.1. Using the PortletMultipartResolver20.7.2. Handling a file upload in a form20.8. Handling exceptions20.9. Annotation-based controller configuration20.9.1. Setting up the dispatcher for annotation support20.9.2. Defining a controller with      @Controller20.9.3. Mapping requests with      @RequestMapping20.9.4. Supported handler method arguments20.9.5. Binding request parameters to method parameters with      @RequestParam20.9.6. Providing a link to data from the model with      @ModelAttribute20.9.7. Specifying attributes to store in a Session with      @SessionAttributes20.9.8. Customizing WebDataBinder      initializationCustomizing data binding with        @InitBinderConfiguring a custom        WebBindingInitializer20.10. Portlet application deploymentVI. Integration21. Remoting and web services using Spring21.1. Introduction21.2. Exposing services using RMI21.2.1. Exporting the service using the      RmiServiceExporter21.2.2. Linking in the service at the client21.3. Using Hessian or Burlap to remotely call services via HTTP21.3.1. Wiring up the DispatcherServlet for      Hessian and co.21.3.2. Exposing your beans by using the      HessianServiceExporter21.3.3. Linking in the service on the client21.3.4. Using Burlap21.3.5. Applying HTTP basic authentication to a service exposed through      Hessian or Burlap21.4. Exposing services using HTTP invokers21.4.1. Exposing the service object21.4.2. Linking in the service at the client21.5. Web services21.5.1. Exposing servlet-based web services using JAX-RPC21.5.2. Accessing web services using JAX-RPC21.5.3. Registering JAX-RPC Bean Mappings21.5.4. Registering your own JAX-RPC Handler21.5.5. Exposing servlet-based web services using JAX-WS21.5.6. Exporting standalone web services using JAX-WS21.5.7. Exporting web services using the JAX-WS RI\'s Spring      support21.5.8. Accessing web services using JAX-WS21.6. JMS21.6.1. Server-side configuration21.6.2. Client-side configuration21.7. Auto-detection is not implemented for remote interfaces21.8. Considerations when choosing a technology21.9. Accessing RESTful services on the Client21.9.1. RestTemplateWorking with the URIDealing with request and response headers21.9.2. HTTP Message ConversionStringHttpMessageConverterFormHttpMessageConverterByteArrayHttpMessageConverterMarshallingHttpMessageConverterMappingJackson2HttpMessageConverter (or MappingJacksonHttpMessageConverter with Jackson 1.x)SourceHttpMessageConverterBufferedImageHttpMessageConverter22. Enterprise JavaBeans (EJB) integration22.1. Introduction22.2. Accessing EJBs22.2.1. Concepts22.2.2. Accessing local SLSBs22.2.3. Accessing remote SLSBs22.2.4. Accessing EJB 2.x SLSBs versus EJB 3 SLSBs22.3. Using Spring\'s EJB implementation support classes22.3.1. EJB 2.x base classes22.3.2. EJB 3 injection interceptor23. JMS (Java Message Service)23.1. Introduction23.2. Using Spring JMS23.2.1. JmsTemplate23.2.2. ConnectionsCaching Messaging ResourcesSingleConnectionFactoryCachingConnectionFactory23.2.3. Destination Management23.2.4. Message Listener ContainersSimpleMessageListenerContainerDefaultMessageListenerContainer23.2.5. Transaction management23.3. Sending a Message23.3.1. Using Message Converters23.3.2. SessionCallback and      ProducerCallback23.4. Receiving a message23.4.1. Synchronous Reception23.4.2. Asynchronous Reception - Message-Driven POJOs23.4.3. The SessionAwareMessageListener      interface23.4.4. The MessageListenerAdapter23.4.5. Processing messages within transactions23.5. Support for JCA Message Endpoints23.6. JMS Namespace Support24. JMX24.1. Introduction24.2. Exporting your beans to JMX24.2.1. Creating an MBeanServer24.2.2. Reusing an existing MBeanServer24.2.3. Lazy-initialized MBeans24.2.4. Automatic registration of MBeans24.2.5. Controlling the registration behavior24.3. Controlling the management interface of your beans24.3.1. The MBeanInfoAssembler      Interface24.3.2. Using Source-Level Metadata (JDK 5.0 annotations)24.3.3. Source-Level Metadata Types24.3.4. The AutodetectCapableMBeanInfoAssembler      interface24.3.5. Defining management interfaces using Java interfaces24.3.6. Using      MethodNameBasedMBeanInfoAssembler24.4. Controlling the ObjectNames for your beans24.4.1. Reading ObjectNames from Properties24.4.2. Using the MetadataNamingStrategy24.4.3. Configuring annotation based MBean export24.5. JSR-160 Connectors24.5.1. Server-side Connectors24.5.2. Client-side Connectors24.5.3. JMX over Burlap/Hessian/SOAP24.6. Accessing MBeans via Proxies24.7. Notifications24.7.1. Registering Listeners for Notifications24.7.2. Publishing Notifications24.8. Further Resources25. JCA CCI25.1. Introduction25.2. Configuring CCI25.2.1. Connector configuration25.2.2. ConnectionFactory configuration in      Spring25.2.3. Configuring CCI connections25.2.4. Using a single CCI connection25.3. Using Spring\'s CCI access support25.3.1. Record conversion25.3.2. The CciTemplate25.3.3. DAO support25.3.4. Automatic output record generation25.3.5. Summary25.3.6. Using a CCI Connection and      Interaction directly25.3.7. Example for CciTemplate usage25.4. Modeling CCI access as operation objects25.4.1. MappingRecordOperation25.4.2. MappingCommAreaOperation25.4.3. Automatic output record generation25.4.4. Summary25.4.5. Example for MappingRecordOperation      usage25.4.6. Example for MappingCommAreaOperation      usage25.5. Transactions26. Email26.1. Introduction26.2. Usage26.2.1. Basic MailSender and SimpleMailMessage usage26.2.2. Using the JavaMailSender and the MimeMessagePreparator26.3. Using the JavaMail MimeMessageHelper26.3.1. Sending attachments and inline resourcesAttachmentsInline resources26.3.2. Creating email content using a templating libraryA Velocity-based example27. Task Execution and Scheduling27.1. Introduction27.2. The Spring TaskExecutor    abstraction27.2.1. TaskExecutor types27.2.2. Using a TaskExecutor27.3. The Spring TaskScheduler    abstraction27.3.1. The Trigger interface27.3.2. Trigger implementations27.3.3. TaskScheduler      implementations27.4. Annotation Support for Scheduling and Asynchronous    Execution27.4.1. Enable scheduling annotations27.4.2. The @Scheduled Annotation27.4.3. The @Async Annotation27.4.4. Executor qualification with @Async27.5. The Task Namespace27.5.1. The \'scheduler\' element27.5.2. The \'executor\' element27.5.3. The \'scheduled-tasks\' element27.6. Using the Quartz Scheduler27.6.1. Using the JobDetailBean27.6.2. Using the      MethodInvokingJobDetailFactoryBean27.6.3. Wiring up jobs using triggers and the      SchedulerFactoryBean28. Dynamic language support28.1. Introduction28.2. A first example28.3. Defining beans that are backed by dynamic languages28.3.1. Common conceptsThe &lt;lang:language/&gt; elementRefreshable beansInline dynamic language source filesUnderstanding Constructor Injection in the context of dynamic-language-backed beans28.3.2. JRuby beans28.3.3. Groovy beansCustomising Groovy objects via a callback28.3.4. BeanShell beans28.4. Scenarios28.4.1. Scripted Spring MVC Controllers28.4.2. Scripted Validators28.5. Bits and bobs28.5.1. AOP - advising scripted beans28.5.2. Scoping28.6. Further Resources29. Cache Abstraction29.1. Introduction29.2. Understanding the cache abstraction29.3. Declarative annotation-based caching29.3.1. @Cacheable annotationDefault Key GenerationCustom Key Generation DeclarationConditional cachingAvailable caching SpEL evaluation context29.3.2. @CachePut annotation29.3.3. @CacheEvict annotation29.3.4. @Caching annotation29.3.5. Enable caching annotations29.3.6. Using custom annotations29.4. Declarative XML-based caching29.5. Configuring the cache storage29.5.1. JDK ConcurrentMap-based Cache29.5.2. EhCache-based Cache29.5.3. GemFire-based Cache29.5.4. Dealing with caches without a backing store29.6. Plugging-in different back-end caches29.7. How can I set the TTL/TTI/Eviction policy/XXX feature?VII. AppendicesA. Classic Spring UsageA.1. Classic ORM usageA.1.1. HibernateThe HibernateTemplateImplementing Spring-based DAOs without callbacksA.1.2. JDOJdoTemplate and        JdoDaoSupportA.1.3. JPAJpaTemplate and        JpaDaoSupportA.2. Classic Spring MVCA.3. JMS UsageA.3.1. JmsTemplateA.3.2. Asynchronous Message Reception A.3.3. ConnectionsA.3.4. Transaction ManagementB. Classic Spring AOP UsageB.1. Pointcut API in SpringB.1.1. ConceptsB.1.2. Operations on pointcutsB.1.3. AspectJ expression pointcutsB.1.4. Convenience pointcut implementationsStatic pointcutsDynamic pointcutsB.1.5. Pointcut superclassesB.1.6. Custom pointcutsB.2. Advice API in SpringB.2.1. Advice lifecyclesB.2.2. Advice types in SpringInterception around adviceBefore adviceThrows adviceAfter Returning adviceIntroduction adviceB.3. Advisor API in SpringB.4. Using the ProxyFactoryBean to create AOP proxiesB.4.1. BasicsB.4.2. JavaBean propertiesB.4.3. JDK- and CGLIB-based proxiesB.4.4. Proxying interfacesB.4.5. Proxying classesB.4.6. Using \'global\' advisorsB.5. Concise proxy definitionsB.6. Creating AOP proxies programmatically with the ProxyFactoryB.7. Manipulating advised objectsB.8. Using the \"autoproxy\" facilityB.8.1. Autoproxy bean definitionsBeanNameAutoProxyCreatorDefaultAdvisorAutoProxyCreatorAbstractAdvisorAutoProxyCreatorB.8.2. Using metadata-driven auto-proxyingB.9. Using TargetSourcesB.9.1. Hot swappable target sourcesB.9.2. Pooling target sourcesB.9.3. Prototype target sourcesB.9.4. ThreadLocal target sourcesB.10. Defining new Advice typesB.11. Further resourcesC. Migrating to Spring Framework 3.1C.1. Component scanning against the \"org\" base packageD. Migrating to Spring Framework 3.2D.1. Newly optional dependenciesD.2. EHCache support moved to spring-context-supportD.3. Inlining of spring-asm jarD.4. Explicit CGLIB dependency no longer requiredD.5. For OSGi usersD.6. MVC Java Config and MVC NamespaceD.7. Decoding of URI Variable ValuesD.8. HTTP PATCH methodD.9. Tiles 3D.10. Spring MVC Test standalone projectD.11. Spring Test DependenciesD.12. Public API changesD.12.1. JDiff reportsD.12.2. DeprecationsE. XML Schema-based configurationE.1. IntroductionE.2. XML Schema-based configurationE.2.1. Referencing the schemasE.2.2. The util schema&lt;util:constant/&gt;&lt;util:property-path/&gt;&lt;util:properties/&gt;&lt;util:list/&gt;&lt;util:map/&gt;&lt;util:set/&gt;E.2.3. The jee schema&lt;jee:jndi-lookup/&gt; (simple)&lt;jee:jndi-lookup/&gt; (with single JNDI environment setting)&lt;jee:jndi-lookup/&gt; (with multiple JNDI environment settings)&lt;jee:jndi-lookup/&gt; (complex)&lt;jee:local-slsb/&gt; (simple)&lt;jee:local-slsb/&gt; (complex)&lt;jee:remote-slsb/&gt;E.2.4. The lang schemaE.2.5. The jms schemaE.2.6. The tx (transaction) schemaE.2.7. The aop schemaE.2.8. The context schema&lt;property-placeholder/&gt;&lt;annotation-config/&gt;&lt;component-scan/&gt;&lt;load-time-weaver/&gt;&lt;spring-configured/&gt;&lt;mbean-export/&gt;E.2.9. The tool schemaE.2.10. The jdbc schemaE.2.11. The cache schemaE.2.12. The beans schemaF. Extensible XML authoringF.1. IntroductionF.2. Authoring the schemaF.3. Coding a NamespaceHandlerF.4. Coding a BeanDefinitionParserF.5. Registering the handler and the schemaF.5.1. \'META-INF/spring.handlers\'F.5.2. \'META-INF/spring.schemas\'F.6. Using a custom extension in your Spring XML configurationF.7. Meatier examplesF.7.1. Nesting custom tags within custom tagsF.7.2. Custom attributes on \'normal\' elementsF.8. Further ResourcesG. spring.tldG.1. IntroductionG.2. The bind tagG.3. The escapeBody tagG.4. The hasBindErrors tagG.5. The htmlEscape tagG.6. The message tagG.7. The nestedPath tagG.8. The theme tagG.9. The transform tagG.10. The url tagG.11. The eval tagH. spring-form.tldH.1. IntroductionH.2. The checkbox tagH.3. The checkboxes tagH.4. The errors tagH.5. The form tagH.6. The hidden tagH.7. The input tagH.8. The label tagH.9. The option tagH.10. The options tagH.11. The password tagH.12. The radiobutton tagH.13. The radiobuttons tagH.14. The select tagH.15. The textarea tag                    &nbsp;&nbsp;&nbsp;Next&nbsp;&nbsp;&nbsp;Part&nbsp;I.&nbsp;Overview of Spring Framework","Spring Framework Reference Documentation","scr\\index.html","         14.&nbsp;Data access with JDBCPrev&nbsp;Part&nbsp;IV.&nbsp;Data Access&nbsp;Next14.&nbsp;Data access with JDBC    14.1&nbsp;Introduction to Spring Framework JDBC        \n\r\n\rThe value-add provided by the Spring Framework JDBC abstraction is    perhaps best shown by the sequence of actions outlined in the table below.    The table shows what actions Spring will take care of and which actions    are the responsibility of you, the application developer.    \n\r\n\rTable&nbsp;14.1.&nbsp;Spring JDBC - who does what?            ActionSpringYouDefine connection parameters.XOpen the connection.X&nbsp;Specify the SQL statement.&nbsp;XDeclare parameters and provide parameter values&nbsp;XPrepare and execute the statement.X&nbsp;Set up the loop to iterate through the results (if            any).X&nbsp;Do the work for each iteration.&nbsp;XProcess any exception.X&nbsp;Handle transactions.X&nbsp;Close the connection, statement and resultset.X&nbsp;    \n\r    \n\r\n\rThe Spring Framework takes care of all the low-level details that    can make JDBC such a tedious API to develop with.    14.1.1&nbsp;Choosing an approach for JDBC database access            \n\r\n\rYou can choose among several approaches to form the basis for your      JDBC database access. In addition to three flavors of the JdbcTemplate,      a new SimpleJdbcInsert and SimplejdbcCall approach optimizes database      metadata, and the RDBMS Object style takes a more object-oriented      approach similar to that of JDO Query design. Once you start using one      of these approaches, you can still mix and match to include a feature      from a different approach. All approaches require a JDBC 2.0-compliant      driver, and some advanced features require a JDBC 3.0 driver.      Note        \n\r\n\rSpring 3.0 updates all of the following approaches with Java 5        support such as generics and varargs.            \n\r          \n\r\n\rJdbcTemplate is the classic          Spring JDBC approach and the most popular. This \"lowest level\"          approach and all others use a JdbcTemplate under the covers, and all          are updated with Java 5 support such as generics and varargs.        \n\r          \n\r\n\rNamedParameterJdbcTemplate          wraps a JdbcTemplate to provide named parameters          instead of the traditional JDBC \"?\" placeholders. This approach          provides better documentation and ease of use when you have multiple          parameters for an SQL statement.        \n\r          \n\r\n\rSimpleJdbcInsert and          SimpleJdbcCall optimize database metadata to limit the          amount of necessary configuration. This approach simplifies coding          so that you only need to provide the name of the table or procedure          and provide a map of parameters matching the column names.          This only works if the database provides adequate metadata. If the          database doesn\'t provide this metadata, you will have to provide          explicit configuration of the parameters.        \n\r          \n\r\n\rRDBMS Objects including MappingSqlQuery,          SqlUpdate and StoredProcedure requires you to create          reusable and thread-safe objects during initialization of your data          access layer. This approach is modeled after JDO Query wherein you          define your query string, declare parameters, and compile the query.          Once you do that, execute methods can be called multiple times with          various parameter values passed in.        \n\r        14.1.2&nbsp;Package hierarchy            \n\r\n\rThe Spring Framework\'s JDBC abstraction framework consists of four      different packages, namely core,      datasource, object, and      support.      \n\r\n\rThe org.springframework.jdbc.core package      contains the JdbcTemplate class and its various      callback interfaces, plus a variety of related classes. A subpackage      named org.springframework.jdbc.core.simple contains      the SimpleJdbcInsert and      SimpleJdbcCall classes. Another subpackage named      org.springframework.jdbc.core.namedparam contains the      NamedParameterJdbcTemplate class and the related      support classes. See Section&nbsp;14.2, &#8220;Using the JDBC core classes to control basic JDBC processing and    error handling&#8221;, Section&nbsp;14.4, &#8220;JDBC batch operations&#8221;, and Section&nbsp;14.5, &#8220;Simplifying JDBC operations with the SimpleJdbc classes&#8221;      \n\r\n\rThe org.springframework.jdbc.datasource package      contains a utility class for easy      DataSource access, and various simple      DataSource implementations that can be      used for testing and running unmodified JDBC code outside of a Java EE      container. A subpackage named      org.springfamework.jdbc.datasource.embedded provides      support for creating in-memory database instances using Java database      engines such as HSQL and H2. See Section&nbsp;14.3, &#8220;Controlling database connections&#8221; and      Section&nbsp;14.8, &#8220;Embedded database support&#8221;      \n\r\n\rThe org.springframework.jdbc.object package      contains classes that represent RDBMS queries, updates, and stored      procedures as thread safe, reusable objects. See Section&nbsp;14.6, &#8220;Modeling JDBC operations as Java objects&#8221;.This approach is modeled by JDO, although of      course objects returned by queries are &#8220;disconnected&#8221; from      the database. This higher level of JDBC abstraction depends on the      lower-level abstraction in the      org.springframework.jdbc.core package.      \n\r\n\rThe      org.springframework.jdbc.support package provides      SQLException translation functionality and some      utility classes. Exceptions thrown during JDBC processing are translated      to exceptions defined in the org.springframework.dao      package. This means that code using the Spring JDBC abstraction layer      does not need to implement JDBC or RDBMS-specific error handling. All      translated exceptions are unchecked, which gives you the option of      catching the exceptions from which you can recover while allowing other      exceptions to be propagated to the caller. See Section&nbsp;14.2.3, &#8220;SQLExceptionTranslator&#8221;.        14.2&nbsp;Using the JDBC core classes to control basic JDBC processing and    error handling        14.2.1&nbsp;JdbcTemplate            \n\r\n\rThe JdbcTemplate class is the central class      in the JDBC core package. It handles the creation and release of      resources, which helps you avoid common errors such as forgetting to      close the connection. It performs the basic tasks of the core JDBC      workflow such as statement creation and execution, leaving application      code to provide SQL and extract results. The      JdbcTemplate class executes SQL queries, update      statements and stored procedure calls, performs iteration over      ResultSets and extraction of returned      parameter values.      It also catches JDBC exceptions and translates them to the generic, more      informative, exception hierarchy defined in the      org.springframework.dao package.      \n\r\n\rWhen you use the JdbcTemplate for your      code, you only need to implement callback interfaces, giving them a      clearly defined contract. The      PreparedStatementCreator callback      interface creates a prepared statement given a      Connection provided by this class,      providing SQL and any necessary parameters. The same is true for the      CallableStatementCreator interface, which      creates callable statements. The      RowCallbackHandler interface extracts      values from each row of a      ResultSet.            \n\r\n\rThe JdbcTemplate can be used within a DAO      implementation through direct instantiation with a      DataSource reference, or be configured in      a Spring IoC container and given to DAOs as a bean reference. Note          \n\r\n\rThe DataSource should always be          configured as a bean in the Spring IoC container. In the first case          the bean is given to the service directly; in the second case it is          given to the prepared template.              \n\r\n\rAll SQL issued by this class is logged at the      DEBUG level under the category corresponding to the      fully qualified class name of the template instance (typically      JdbcTemplate, but it may be different if you are      using a custom subclass of the JdbcTemplate      class).      Examples of JdbcTemplate class usage                \n\r\n\rThis section provides some examples of        JdbcTemplate class usage. These examples are        not an exhaustive list of all of the functionality exposed by the        JdbcTemplate; see the attendant Javadocs for        that.        Querying (SELECT)                    \n\r\n\rHere is a simple query for getting the number of rows in a          relation:          int rowCount = this.jdbcTemplate.queryForObject(\"select count(*) from t_actor\", int.class);          \n\r\n\rA simple query using a bind variable:          int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(        \"select count(*) from t_actor where first_name = ?\", int.class, \"Joe\");          \n\r\n\rQuerying for a String:          String lastName = this.jdbcTemplate.queryForObject(        \"select last_name from t_actor where id = ?\",        new Object[]{1212L}, String.class);          \n\r\n\rQuerying and populating a single domain          object:          Actor actor = this.jdbcTemplate.queryForObject(        \"select first_name, last_name from t_actor where id = ?\",        new Object[]{1212L},        new RowMapper&lt;Actor&gt;() {            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {                Actor actor = new Actor();                actor.setFirstName(rs.getString(\"first_name\"));                actor.setLastName(rs.getString(\"last_name\"));                return actor;            }        });          \n\r\n\rQuerying and populating a number of domain objects:          List&lt;Actor&gt; actors = this.jdbcTemplate.query(        \"select first_name, last_name from t_actor\",        new RowMapper&lt;Actor&gt;() {            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {                Actor actor = new Actor();                actor.setFirstName(rs.getString(\"first_name\"));                actor.setLastName(rs.getString(\"last_name\"));                return actor;            }        });          \n\r\n\rIf the last two snippets of code actually existed in the same          application, it would make sense to remove the duplication present          in the two RowMapper anonymous inner          classes, and extract them out into a single class (typically a          static inner class) that can then be referenced          by DAO methods as needed. For example, it may be better to write the          last code snippet as follows:          public List&lt;Actor&gt; findAllActors() {    return this.jdbcTemplate.query( \"select first_name, last_name from t_actor\", new ActorMapper());}private static final class ActorMapper implements RowMapper&lt;Actor&gt; {    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {        Actor actor = new Actor();        actor.setFirstName(rs.getString(\"first_name\"));        actor.setLastName(rs.getString(\"last_name\"));        return actor;    }}                Updating (INSERT/UPDATE/DELETE) with jdbcTemplate                    \n\r\n\rYou use the update(..) method to          perform insert, update and delete operations. Parameter values are          usually provided as var args or alternatively as an object          array.          this.jdbcTemplate.update(        \"insert into t_actor (first_name, last_name) values (?, ?)\",        \"Leonor\", \"Watling\");          this.jdbcTemplate.update(        \"update t_actor set last_name = ? where id = ?\",        \"Banjo\", 5276L);          this.jdbcTemplate.update(        \"delete from actor where id = ?\",        Long.valueOf(actorId));                Other jdbcTemplate operations                    \n\r\n\rYou can use the execute(..) method to          execute any arbitrary SQL, and as such the method is often used for          DDL statements. It is heavily overloaded with variants taking          callback interfaces, binding variable arrays, and so on.          this.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\");          \n\r\n\rThe following example invokes a simple stored procedure. More          sophisticated stored procedure support is covered later.          this.jdbcTemplate.update(        \"call SUPPORT.REFRESH_ACTORS_SUMMARY(?)\",        Long.valueOf(unionId));                    JdbcTemplate best practices                \n\r\n\rInstances of the JdbcTemplate class are        threadsafe once configured. This is important        because it means that you can configure a single instance of a        JdbcTemplate and then safely inject this        shared reference into multiple DAOs (or        repositories). The JdbcTemplate is stateful, in        that it maintains a reference to a        DataSource, but this state is        not conversational state.        \n\r\n\rA common practice when using the        JdbcTemplate class (and the associated NamedParameterJdbcTemplate        classes) is to configure a DataSource        in your Spring configuration file, and then dependency-inject that        shared DataSource bean into your DAO        classes; the JdbcTemplate is created in the        setter for the DataSource. This leads        to DAOs that look in part like the following:        public class JdbcCorporateEventDao implements CorporateEventDao {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    // JDBC-backed implementations of the methods on the CorporateEventDao follow...}        \n\r\n\rThe corresponding configuration might look like this.        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;bean id=\"corporateEventDao\" class=\"com.example.JdbcCorporateEventDao\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;    &lt;/bean&gt;    &lt;context:property-placeholder location=\"jdbc.properties\"/&gt;&lt;/beans&gt;        \n\r\n\rAn alternative to explicit configuration is to use        component-scanning and annotation support for dependency injection. In        this case you annotate the class with        @Repository (which makes it a candidate        for component-scanning) and annotate the        DataSource setter method with        @Autowired.        @Repositorypublic class JdbcCorporateEventDao implements CorporateEventDao {    private JdbcTemplate jdbcTemplate;    @Autowired    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    // JDBC-backed implementations of the methods on the CorporateEventDao follow...}        \n\r\n\rThe corresponding XML configuration file would        look like the following:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- Scans within the base package of the application for @Components to configure as beans --&gt;    &lt;context:component-scan base-package=\"org.springframework.docs.test\" /&gt;    &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;    &lt;/bean&gt;    &lt;context:property-placeholder location=\"jdbc.properties\"/&gt;&lt;/beans&gt;\n\r\n\rIf you are using Spring\'s        JdbcDaoSupport class, and your various        JDBC-backed DAO classes extend from it, then your sub-class inherits a        setDataSource(..) method from the        JdbcDaoSupport class. You        can choose whether to inherit from this class. The        JdbcDaoSupport class is provided as a        convenience only.        \n\r\n\rRegardless of which of the above template initialization styles        you choose to use (or not), it is seldom necessary to create a new        instance of a JdbcTemplate class each time you        want to execute SQL. Once configured, a        JdbcTemplate instance is threadsafe. You may        want multiple JdbcTemplate instances if your        application accesses multiple databases, which requires multiple        DataSources, and subsequently multiple        differently configured JdbcTemplates.              14.2.2&nbsp;NamedParameterJdbcTemplate            \n\r\n\rThe NamedParameterJdbcTemplate class adds      support for programming JDBC statements using named parameters, as      opposed to programming JDBC statements using only classic placeholder      (\'?\') arguments. The      NamedParameterJdbcTemplate class wraps a      JdbcTemplate, and delegates to the wrapped      JdbcTemplate to do much of its work. This section      describes only those areas of the      NamedParameterJdbcTemplate class that differ from      the JdbcTemplate itself; namely, programming JDBC      statements using named parameters.      // some JDBC-backed DAO class...private NamedParameterJdbcTemplate namedParameterJdbcTemplate;public void setDataSource(DataSource dataSource) {    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);}public int countOfActorsByFirstName(String firstName) {    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";    SqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);    return this.namedParameterJdbcTemplate.queryForObject(sql, int.class, namedParameters);}      \n\r\n\rNotice the use of the named parameter notation in the value      assigned to the sql variable, and the corresponding      value that is plugged into the namedParameters      variable (of type MapSqlParameterSource).      \n\r\n\rAlternatively, you can pass along named parameters and their      corresponding values to a      NamedParameterJdbcTemplate instance by using the      Map-based style.The      remaining methods exposed by the      NamedParameterJdbcOperations and      implemented by the NamedParameterJdbcTemplate      class follow a similar pattern and are not covered here.      \n\r\n\rThe following example shows the use of the      Map-based style.      // some JDBC-backed DAO class...private NamedParameterJdbcTemplate namedParameterJdbcTemplate;public void setDataSource(DataSource dataSource) {    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);}public int countOfActorsByFirstName(String firstName) {    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";    Map&lt;String, String&gt; namedParameters = Collections.singletonMap(\"first_name\", firstName);    return this.namedParameterJdbcTemplate.queryForObject(sql, int.class, namedParameters);}      \n\r\n\rOne nice feature related to the      NamedParameterJdbcTemplate (and existing in the      same Java package) is the SqlParameterSource      interface. You have already seen an example of an implementation of this      interface in one of the previous code snippet (the      MapSqlParameterSource class).            An SqlParameterSource is a source of      named parameter values to a      NamedParameterJdbcTemplate. The      MapSqlParameterSource class is a very simple      implementation that is simply an adapter around a      java.util.Map, where the keys are the      parameter names and the values are the parameter values.      \n\r\n\rAnother SqlParameterSource      implementation is the      BeanPropertySqlParameterSource class. This class      wraps an arbitrary JavaBean (that is, an instance of a class that      adheres to the JavaBean      conventions), and uses the properties of the wrapped JavaBean as      the source of named parameter values.      public class Actor {    private Long id;    private String firstName;    private String lastName;    public String getFirstName() {        return this.firstName;    }    public String getLastName() {        return this.lastName;    }    public Long getId() {        return this.id;    }    // setters omitted...}      // some JDBC-backed DAO class...private NamedParameterJdbcTemplate namedParameterJdbcTemplate;public void setDataSource(DataSource dataSource) {    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);}public int countOfActors(Actor exampleActor) {    // notice how the named parameters match the properties of the above \'Actor\' class    String sql =        \"select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName\";    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);    return this.namedParameterJdbcTemplate.queryForObject(sql, int.class, namedParameters);}      \n\r\n\rRemember that the      NamedParameterJdbcTemplate class      wraps a classic JdbcTemplate      template; if you need access to the wrapped      JdbcTemplate instance to access functionality      only present in the JdbcTemplate class, you can      use the getJdbcOperations() method to access      the wrapped JdbcTemplate through the      JdbcOperations interface.      \n\r\n\rSee also the section called &#8220;JdbcTemplate best practices&#8221; for      guidelines on using the      NamedParameterJdbcTemplate class in the context      of an application.        14.2.3&nbsp;SQLExceptionTranslator            \n\r\n\rSQLExceptionTranslator is an      interface to be implemented by classes that can translate between      SQLExceptions and Spring\'s own      org.springframework.dao.DataAccessException,      which is agnostic in regard to data access strategy. Implementations can      be generic (for example, using SQLState codes for JDBC) or proprietary      (for example, using Oracle error codes) for greater precision.      \n\r\n\rSQLErrorCodeSQLExceptionTranslator is the      implementation of SQLExceptionTranslator      that is used by default. This implementation uses specific vendor codes.      It is more precise than the SQLState implementation.      The error code translations are based on codes held in a JavaBean type      class called SQLErrorCodes. This class is created      and populated by an SQLErrorCodesFactory which as      the name suggests is a factory for creating      SQLErrorCodes based on the contents of a      configuration file named sql-error-codes.xml. This file is      populated with vendor codes and based on the      DatabaseProductName taken from the      DatabaseMetaData. The codes for the actual      database you are using are used.      \n\r\n\rThe SQLErrorCodeSQLExceptionTranslator      applies matching rules in the following sequence: Note            \n\r\n\rThe SQLErrorCodesFactory is used by            default to define Error codes and custom exception translations.            They are looked up in a file named            sql-error-codes.xml from the classpath and            the matching SQLErrorCodes instance is            located based on the database name from the database metadata of            the database in use.          \n\r            \n\r\n\rAny custom translation implemented by a subclass. Normally            the provided concrete            SQLErrorCodeSQLExceptionTranslator is used            so this rule does not apply. It only applies if you have actually            provided a subclass implementation.          \n\r            \n\r\n\rAny custom implementation of the            SQLExceptionTranslator interface that is            provided as the            customSqlExceptionTranslator property of            the SQLErrorCodes class.          \n\r            \n\r\n\rThe list of instances of the            CustomSQLErrorCodesTranslation class,            provided for the customTranslations            property of the SQLErrorCodes class, are            searched for a match.          \n\r            \n\r\n\rError code matching is applied.          \n\r            \n\r\n\rUse the fallback translator.            SQLExceptionSubclassTranslator is the            default fallback translator. If this translation is not available            then the next fallback translator is the            SQLStateSQLExceptionTranslator.          \n\r      \n\r\n\rYou can extend      SQLErrorCodeSQLExceptionTranslator:      public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {        if (sqlex.getErrorCode() == -12345) {            return new DeadlockLoserDataAccessException(task, sqlex);        }        return null;    }}      \n\r\n\rIn this example, the specific error code -12345      is translated and other errors are left to be translated by the default      translator implementation. To use this custom translator, it is      necessary to pass it to the JdbcTemplate through      the method setExceptionTranslator and to use this      JdbcTemplate for all of the data access      processing where this translator is needed. Here is an example of how      this custom translator can be used:      private JdbcTemplate jdbcTemplate;public void setDataSource(DataSource dataSource) {    // create a JdbcTemplate and set data source    this.jdbcTemplate = new JdbcTemplate();    this.jdbcTemplate.setDataSource(dataSource);    // create a custom translator and set the DataSource for the default translation lookup    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();    tr.setDataSource(dataSource);    this.jdbcTemplate.setExceptionTranslator(tr);}public void updateShippingCharge(long orderId, long pct) {    // use the prepared JdbcTemplate for this update    this.jdbcTemplate.update(        \"update orders\" +            \" set shipping_charge = shipping_charge * ? / 100\" +            \" where id = ?\"        pct, orderId);}      \n\r\n\rThe custom translator is passed a data source in order to look up      the error codes in sql-error-codes.xml.        14.2.4&nbsp;Executing statements            \n\r\n\rExecuting an SQL statement requires very little code. You need a      DataSource and a      JdbcTemplate, including the convenience      methods      that are provided with the JdbcTemplate. The      following example shows what you need to include for a minimal but fully      functional class that creates a new table:      import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;public class ExecuteAStatement {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public void doExecute() {        this.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\");    }}        14.2.5&nbsp;Running queries            \n\r\n\rSome query methods return a single value. To retrieve a count or      a specific value from one row, use      queryForObject(..). The latter converts the      returned JDBC Type to the Java class that is      passed in as an argument. If the type conversion is invalid, then an      InvalidDataAccessApiUsageException is      thrown. Here is an example that contains two query methods, one for an      int and one that queries for a      String.      import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;public class RunAQuery {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public int getCount() {        return this.jdbcTemplate.queryForObject(\"select count(*) from mytable\", int.class);    }    public String getName() {        return this.jdbcTemplate.queryForObject(\"select name from mytable\", String.class);    }    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }}      \n\r\n\rIn addition to the single result query methods, several methods      return a list with an entry for each row that the query returned. The      most generic method is queryForList(..) which      returns a List where each entry is a      Map with each entry in the map      representing the column value for that row. If you add a method to the      above example to retrieve a list of all the rows, it would look like      this:      private JdbcTemplate jdbcTemplate;public void setDataSource(DataSource dataSource) {    this.jdbcTemplate = new JdbcTemplate(dataSource);}public List&lt;Map&lt;String, Object&gt;&gt; getList() {    return this.jdbcTemplate.queryForList(\"select * from mytable\");}      \n\r\n\rThe list returned would look something like this:      [{name=Bob, id=1}, {name=Mary, id=2}]        14.2.6&nbsp;Updating the database            \n\r\n\rThe following example shows a column updated for a certain primary      key. In this example, an SQL statement has placeholders for row      parameters. The parameter values can be passed in as varargs or      alternatively as an array of objects. Thus primitives should be wrapped      in the primitive wrapper classes explicitly or using auto-boxing.      import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;public class ExecuteAnUpdate {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public void setName(int id, String name) {        this.jdbcTemplate.update(                \"update mytable set name = ? where id = ?\",                name, id);    }}        14.2.7&nbsp;Retrieving auto-generated keys            \n\r\n\rAn update() convenience method      supports the retrieval of primary keys generated      by the database. This support is part of the JDBC 3.0 standard; see      Chapter 13.6 of the specification for details. The method takes a      PreparedStatementCreator as its first argument,      and this is the way the required insert statement is specified. The      other argument is a KeyHolder, which contains the      generated key on successful return from the update. There is not a      standard single way to create an appropriate      PreparedStatement (which explains why the method      signature is the way it is). The following example works on Oracle but      may not work on other platforms:      final String INSERT_SQL = \"insert into my_test (name) values(?)\";final String name = \"Rob\";KeyHolder keyHolder = new GeneratedKeyHolder();jdbcTemplate.update(    new PreparedStatementCreator() {        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {            PreparedStatement ps =                connection.prepareStatement(INSERT_SQL, new String[] {\"id\"});            ps.setString(1, name);            return ps;        }    },    keyHolder);// keyHolder.getKey() now contains the generated key        14.3&nbsp;Controlling database connections        14.3.1&nbsp;DataSource            \n\r\n\rSpring obtains a connection to the database through a      DataSource. A      DataSource is part of the JDBC      specification and is a generalized connection factory. It allows a      container or a framework to hide connection pooling and transaction      management issues from the application code. As a developer, you need      not know details about how to connect to the database; that is the      responsibility of the administrator that sets up the datasource. You      most likely fill both roles as you develop and test code, but you do not      necessarily have to know how the production data source is      configured.      \n\r\n\rWhen using Spring\'s JDBC layer, you obtain a data source from JNDI      or you configure your own with a connection pool implementation provided      by a third party. Popular implementations are Apache Jakarta Commons      DBCP and C3P0. Implementations in the Spring distribution are meant only      for testing purposes and do not provide pooling.      \n\r\n\rThis section uses Spring\'s      DriverManagerDataSource implementation, and      several additional implementations are covered later.      Note          \n\r\n\rOnly use the DriverManagerDataSource          class should only be used for testing purposes since it does not          provide pooling and will perform poorly when multiple requests for a          connection are made.        \n\r\n\rYou obtain a connection with      DriverManagerDataSource as you typically obtain a      JDBC connection. Specify the fully qualified classname of the JDBC      driver so that the DriverManager can load the      driver class. Next, provide a URL that varies between JDBC drivers.      (Consult the documentation for your driver for the correct value.) Then      provide a username and a password to connect to the database. Here is an      example of how to configure a      DriverManagerDataSource in Java code:      DriverManagerDataSource dataSource = new DriverManagerDataSource();dataSource.setDriverClassName(\"org.hsqldb.jdbcDriver\");dataSource.setUrl(\"jdbc:hsqldb:hsql://localhost:\");dataSource.setUsername(\"sa\");dataSource.setPassword(\"\");      \n\r\n\rHere is the corresponding XML configuration:      &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;    &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;    &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;    &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=\"jdbc.properties\"/&gt;      \n\r\n\rThe following examples show the basic connectivity and      configuration for DBCP and C3P0. To learn about more options that help      control the pooling features, see the product documentation for the      respective connection pooling implementations.      \n\r\n\rDBCP configuration:      &lt;bean id=\"dataSource\"        class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;    &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;    &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;    &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=\"jdbc.properties\"/&gt;      \n\r\n\rC3P0 configuration:      &lt;bean id=\"dataSource\"        class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt;    &lt;property name=\"driverClass\" value=\"${jdbc.driverClassName}\"/&gt;    &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt;    &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt;    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=\"jdbc.properties\"/&gt;        14.3.2&nbsp;DataSourceUtils            \n\r\n\rThe DataSourceUtils class is a convenient      and powerful helper class that provides static      methods to obtain connections from JNDI and close connections if      necessary. It supports thread-bound connections with, for example,      DataSourceTransactionManager.        14.3.3&nbsp;SmartDataSource            \n\r\n\rThe SmartDataSource interface      should be implemented by classes that can provide a connection to a      relational database. It extends the      DataSource interface to allow classes      using it to query whether the connection should be closed after a given      operation. This usage is efficient when you know that you will reuse a      connection.        14.3.4&nbsp;AbstractDataSource            \n\r\n\rAbstractDataSource is an      abstract base class for      Spring\'s DataSource implementations that      implements code that is common to all DataSource      implementations.      You extend the AbstractDataSource class if you      are writing your own DataSource      implementation.        14.3.5&nbsp;SingleConnectionDataSource            \n\r\n\rThe SingleConnectionDataSource class is an      implementation of the SmartDataSource      interface that wraps a single      Connection that is      not closed after each use. Obviously, this is not      multi-threading capable.      \n\r\n\rIf any client code calls close in the      assumption of a pooled connection, as when using persistence tools, set      the suppressClose property to      true. This      setting returns a close-suppressing proxy wrapping the physical      connection. Be aware that you will not be able to cast this      to a native Oracle Connection or the like      anymore.      \n\r\n\rThis is primarily a test class. For example, it enables easy      testing of code outside an application server, in conjunction with a      simple JNDI environment. In contrast to      DriverManagerDataSource, it reuses the same      connection all the time, avoiding excessive creation of physical      connections.        14.3.6&nbsp;DriverManagerDataSource            \n\r\n\rThe DriverManagerDataSource class is an      implementation of the standard DataSource      interface that configures a plain JDBC driver through bean properties,      and returns a new Connection every      time.      \n\r\n\rThis implementation is useful for test and stand-alone      environments outside of a Java EE container, either as a      DataSource bean in a Spring IoC      container, or in conjunction with a simple JNDI environment.      Pool-assuming Connection.close() calls will simply      close the connection, so any      DataSource-aware persistence code should      work. However, using JavaBean-style connection pools such as      commons-dbcp is so easy, even in a test environment, that      it is almost always preferable to use such a connection pool over      DriverManagerDataSource.        14.3.7&nbsp;TransactionAwareDataSourceProxy            \n\r\n\rTransactionAwareDataSourceProxy is a proxy      for a target DataSource, which wraps that      target DataSource to add awareness of      Spring-managed transactions. In this respect, it is similar to a      transactional JNDI DataSource as provided      by a Java EE server.      Note        \n\r\n\rIt is rarely desirable to use this class, except when already        existing code that must be called and passed a standard JDBC        DataSource interface implementation. In        this case, it\'s possible to still have this code be usable, and at the        same time have this code participating in Spring managed transactions.        It        is generally preferable to write your own new code using the higher        level abstractions for resource management, such as        JdbcTemplate or        DataSourceUtils.            \n\r\n\r(See the      TransactionAwareDataSourceProxy Javadocs for more      details.)        14.3.8&nbsp;DataSourceTransactionManager            \n\r\n\rThe DataSourceTransactionManager class is a      PlatformTransactionManager implementation      for single JDBC datasources. It binds a JDBC connection from the      specified data source to the currently executing thread, potentially      allowing for one thread connection per data source.      \n\r\n\rApplication code is required to      retrieve the JDBC connection through      DataSourceUtils.getConnection(DataSource) instead of      Java EE\'s standard DataSource.getConnection. It      throws unchecked org.springframework.dao exceptions      instead of checked SQLExceptions. All      framework classes like JdbcTemplate use this      strategy implicitly. If not used with this transaction manager, the      lookup strategy behaves exactly like the common one - it can thus be      used in any case.      \n\r\n\rThe DataSourceTransactionManager class      supports custom isolation levels, and timeouts that get applied as      appropriate JDBC statement query timeouts. To support the latter,      application code must either use JdbcTemplate or      call the DataSourceUtils.applyTransactionTimeout(..)      method for each created statement.      \n\r\n\rThis implementation can be used instead of      JtaTransactionManager in the single resource      case, as it does not require the container to support JTA. Switching      between both is just a matter of configuration, if you stick to the      required connection lookup pattern. JTA does not support custom      isolation levels!        14.3.9&nbsp;NativeJdbcExtractor            \n\r\n\rSometimes you need to access vendor specific JDBC methods that      differ from the standard JDBC API. This can be problematic if you are      running in an application server or with a      DataSource that wraps the      Connection, Statement and      ResultSet objects with its own wrapper objects.      To gain access to the native objects you can configure your      JdbcTemplate or      OracleLobHandler with a      NativeJdbcExtractor.      \n\r\n\rThe NativeJdbcExtractor comes in a variety of flavors      to match your execution environment:      \n\r          \n\r\n\rSimpleNativeJdbcExtractor        \n\r          \n\r\n\rC3P0NativeJdbcExtractor        \n\r          \n\r\n\rCommonsDbcpNativeJdbcExtractor        \n\r          \n\r\n\rJBossNativeJdbcExtractor        \n\r          \n\r\n\rWebLogicNativeJdbcExtractor        \n\r          \n\r\n\rWebSphereNativeJdbcExtractor        \n\r          \n\r\n\rXAPoolNativeJdbcExtractor        \n\r      \n\r\n\rUsually the SimpleNativeJdbcExtractor is      sufficient for unwrapping a Connection object in      most environments. See the Javadocs for more details.        14.4&nbsp;JDBC batch operations        \n\r\n\rMost JDBC drivers provide improved performance if you batch multiple    calls to the same prepared statement. By grouping updates into batches you    limit the number of round trips to the database.    14.4.1&nbsp;Basic batch operations with the JdbcTemplate            \n\r\n\rYou accomplish JdbcTemplate batch      processing by implementing two methods of a special interface,      BatchPreparedStatementSetter, and passing that in      as the second parameter in your batchUpdate      method call. Use the getBatchSize method to      provide the size of the current batch. Use the      setValues method to set the values for the      parameters of the prepared statement. This method will be called the      number of times that you specified in the      getBatchSize call. The following example updates      the actor table based on entries in a list. The entire list is used as      the batch in this example:      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public int[] batchUpdate(final List&lt;Actor&gt; actors) {        int[] updateCounts = jdbcTemplate.batchUpdate(                \"update t_actor set first_name = ?, last_name = ? where id = ?\",                new BatchPreparedStatementSetter() {                    public void setValues(PreparedStatement ps, int i) throws SQLException {                        ps.setString(1, actors.get(i).getFirstName());                        ps.setString(2, actors.get(i).getLastName());                        ps.setLong(3, actors.get(i).getId().longValue());                    }                    public int getBatchSize() {                        return actors.size();                    }                } );        return updateCounts;    }    //  ... additional methods}\n\r\n\rIf you are processing a stream of updates or reading from a      file, then you might have a preferred batch size, but the last batch      might not have that number of entries. In this case you can use the      InterruptibleBatchPreparedStatementSetter      interface, which allows you to interrupt a batch once the input source      is exhausted. The isBatchExhausted method allows      you to signal the end of the batch.        14.4.2&nbsp;Batch operations with a List of objects            \n\r\n\rBoth the JdbcTemplate and the      NamedParameterJdbcTemplate provides an alternate      way of providing the batch update. Instead of implementing a special      batch interface, you provide all parameter values in the call as a list.      The framework loops over these values and uses an internal prepared      statement setter. The API varies depending on whether you use named      parameters. For the named parameters you provide an array of      SqlParameterSource, one entry for each member of      the batch. You can use the      SqlParameterSource.createBatch method to create      this array, passing in either an array of JavaBeans or an array of Maps      containing the parameter values.      \n\r\n\rThis example shows a batch update using named parameters:      public class JdbcActorDao implements ActorDao {    private NamedParameterTemplate namedParameterJdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);    }    public int[] batchUpdate(final List&lt;Actor&gt; actors) {        SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray());        int[] updateCounts = namedParameterJdbcTemplate.batchUpdate(            \"update t_actor set first_name = :firstName, last_name = :lastName where id = :id\",            batch);        return updateCounts;    }    //  ... additional methods}\n\r\n\rFor an SQL statement using the classic \"?\" placeholders, you      pass in a list containing an object array with the update values. This      object array must have one entry for each placeholder in the SQL      statement, and they must be in the same order as they are defined in the      SQL statement.      \n\r\n\rThe same example using classic JDBC \"?\" placeholders:      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public int[] batchUpdate(final List&lt;Actor&gt; actors) {        List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();        for (Actor actor : actors) {            Object[] values = new Object[] {                    actor.getFirstName(),                    actor.getLastName(),                    actor.getId()};            batch.add(values);        }        int[] updateCounts = jdbcTemplate.batchUpdate(                \"update t_actor set first_name = ?, last_name = ? where id = ?\",                batch);        return updateCounts;    }    //  ... additional methods}\n\r\n\rAll of the above batch update methods return an int array      containing the number of affected rows for each batch entry. This count      is reported by the JDBC driver. If the count is not available, the JDBC      driver returns a -2 value.        14.4.3&nbsp;Batch operations with multiple batches            \n\r\n\rThe last example of a batch update deals with batches that are so      large that you want to break them up into several smaller batches. You      can of course do this with the methods mentioned above by making      multiple calls to the batchUpdate method, but      there is now a more convenient method. This method takes, in addition to      the SQL statement, a Collection of objects containing the parameters,      the number of updates to make for each batch and a      ParameterizedPreparedStatementSetter to set the      values for the parameters of the prepared statement. The framework loops      over the provided values and breaks the update calls into batches of the      size specified.      \n\r\n\rThis example shows a batch update using a batch size of      100:      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) {        int[][] updateCounts = jdbcTemplate.batchUpdate(                \"update t_actor set first_name = ?, last_name = ? where id = ?\",                actors,                100,                new ParameterizedPreparedStatementSetter&lt;Actor&gt;() {                    public void setValues(PreparedStatement ps, Actor argument) throws SQLException {                        ps.setString(1, argument.getFirstName());                        ps.setString(2, argument.getLastName());                        ps.setLong(3, argument.getId().longValue());                     }                 } );        return updateCounts;    }    //  ... additional methods}\n\r\n\rThe batch update methods for this call returns an array of      int arrays containing an array entry for each batch with an array of the      number of affected rows for each update. The top level array\'s length      indicates the number of batches executed and the second level array\'s      length indicates the number of updates in that batch. The number of      updates in each batch should be the the batch size provided for all      batches except for the last one that might be less, depending on the      total number of update objects provided. The update count for each update      statement is the one reported by the JDBC driver. If the count is not      available, the JDBC driver returns a -2 value.        14.5&nbsp;Simplifying JDBC operations with the SimpleJdbc classes        \n\r\n\rThe SimpleJdbcInsert and    SimpleJdbcCall classes provide a simplified    configuration by taking advantage of database metadata that can be    retrieved through the JDBC driver. This means there is less to configure    up front, although you can override or turn off the metadata processing if    you prefer to provide all the details in your code.    14.5.1&nbsp;Inserting data using SimpleJdbcInsert            \n\r\n\rLet\'s start by looking at the      SimpleJdbcInsert class with the minimal amount of      configuration options. You should instantiate the      SimpleJdbcInsert in the data access layer\'s      initialization method. For this example, the initializing method is the      setDataSource method. You do not need to subclass      the SimpleJdbcInsert class; simply create a new      instance and set the table name using the      withTableName method. Configuration methods for      this class follow the \"fluid\" style that returns the instance of the      SimpleJdbcInsert, which allows you to chain all      configuration methods. This example uses only one configuration method;      you will see examples of multiple ones later.      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcInsert insertActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.insertActor =                new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\");    }    public void add(Actor actor) {        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3);        parameters.put(\"id\", actor.getId());        parameters.put(\"first_name\", actor.getFirstName());        parameters.put(\"last_name\", actor.getLastName());        insertActor.execute(parameters);    }    //  ... additional methods}      \n\r\n\rThe execute method used here takes a plain      java.utils.Map as its only parameter. The      important thing to note here is that the keys used for the Map must      match the column names of the table as defined in the database. This is      because we read the metadata in order to construct the actual insert      statement.        14.5.2&nbsp;Retrieving auto-generated keys using SimpleJdbcInsert            \n\r\n\rThis example uses the same insert as the preceding, but instead of      passing in the id it retrieves the auto-generated key and sets it on the      new Actor object. When you create the      SimpleJdbcInsert, in addition to specifying the      table name, you specify the name of the generated key column with the      usingGeneratedKeyColumns method.      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcInsert insertActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.insertActor =                new SimpleJdbcInsert(dataSource)                        .withTableName(\"t_actor\")                        .usingGeneratedKeyColumns(\"id\");    }    public void add(Actor actor) {        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);        parameters.put(\"first_name\", actor.getFirstName());        parameters.put(\"last_name\", actor.getLastName());        Number newId = insertActor.executeAndReturnKey(parameters);        actor.setId(newId.longValue());    }    //  ... additional methods}\n\r\n\rThe main difference when executing the insert by this second      approach is that you do not add the id to the Map and you call the      executeReturningKey method. This returns a      java.lang.Number object with which you can create an      instance of the numerical type that is used in our domain class.You      cannot rely on all databases to return a specific Java class here;      java.lang.Number is the base class that you can rely      on. If you have multiple auto-generated columns, or the generated values      are non-numeric, then you can use a KeyHolder that is      returned from the executeReturningKeyHolder      method.        14.5.3&nbsp;Specifying columns for a SimpleJdbcInsert            \n\r\n\rYou can limit the columns for an insert by specifying a list of      column names with the usingColumns method:      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcInsert insertActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.insertActor =                new SimpleJdbcInsert(dataSource)                        .withTableName(\"t_actor\")                        .usingColumns(\"first_name\", \"last_name\")                        .usingGeneratedKeyColumns(\"id\");    }    public void add(Actor actor) {        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);        parameters.put(\"first_name\", actor.getFirstName());        parameters.put(\"last_name\", actor.getLastName());        Number newId = insertActor.executeAndReturnKey(parameters);        actor.setId(newId.longValue());    }    //  ... additional methods}\n\r\n\rThe execution of the insert is the same as if you had relied      on the metadata to determine which columns to use.        14.5.4&nbsp;Using SqlParameterSource to provide parameter values            \n\r\n\rUsing a Map to provide parameter values      works fine, but it\'s not the most convenient class to use. Spring      provides a couple of implementations of the      SqlParameterSource interface that can be used      instead.The      first one is BeanPropertySqlParameterSource,      which is a very convenient class if you have a JavaBean-compliant class      that contains your values. It will use the corresponding getter method      to extract the parameter values. Here is an example:      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcInsert insertActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.insertActor =                new SimpleJdbcInsert(dataSource)                        .withTableName(\"t_actor\")                        .usingGeneratedKeyColumns(\"id\");    }    public void add(Actor actor) {        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);        Number newId = insertActor.executeAndReturnKey(parameters);        actor.setId(newId.longValue());    }    //  ... additional methods}\n\r\n\rAnother option is the      MapSqlParameterSource that resembles a Map but      provides a more convenient addValue method that      can be chained.      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcInsert insertActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.insertActor =                new SimpleJdbcInsert(dataSource)                        .withTableName(\"t_actor\")                        .usingGeneratedKeyColumns(\"id\");    }    public void add(Actor actor) {        SqlParameterSource parameters = new MapSqlParameterSource()                .addValue(\"first_name\", actor.getFirstName())                .addValue(\"last_name\", actor.getLastName());        Number newId = insertActor.executeAndReturnKey(parameters);        actor.setId(newId.longValue());    }    //  ... additional methods}\n\r\n\rAs you can see, the configuration is the same; only the      executing code has to change to use these alternative input      classes.        14.5.5&nbsp;Calling a stored procedure with SimpleJdbcCall            \n\r\n\rThe SimpleJdbcCall class leverages metadata      in the database to look up names of in and out      parameters, so that you do not have to declare them explicitly. You can      declare parameters if you prefer to do that, or if you have parameters      such as ARRAY or STRUCT that do not have an      automatic mapping to a Java class. The first example shows a simple      procedure that returns only scalar values in VARCHAR and      DATE format from a MySQL database. The example procedure      reads a specified actor entry and returns first_name,      last_name, and birth_date columns in the form      of out parameters.      CREATE PROCEDURE read_actor (  IN in_id INTEGER,  OUT out_first_name VARCHAR(100),  OUT out_last_name VARCHAR(100),  OUT out_birth_date DATE)BEGIN  SELECT first_name, last_name, birth_date  INTO out_first_name, out_last_name, out_birth_date  FROM t_actor where id = in_id;END;\n\r\n\rThe in_id parameter contains the      id of the actor you are looking up. The out      parameters return the data read from the table.      \n\r\n\rThe SimpleJdbcCall is declared in a similar      manner to the SimpleJdbcInsert. You should      instantiate and configure the class in the initialization method of your      data access layer. Compared to the StoredProcedure class, you don\'t have      to create a subclass and you don\'t have to declare parameters that can      be looked up in the database metadata. Following      is an example of a SimpleJdbcCall configuration using the above stored      procedure. The only configuration option, in addition to the      DataSource, is the name of the stored      procedure.      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcCall procReadActor;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        this.procReadActor =                new SimpleJdbcCall(dataSource)                        .withProcedureName(\"read_actor\");    }    public Actor readActor(Long id) {        SqlParameterSource in = new MapSqlParameterSource()                .addValue(\"in_id\", id);        Map out = procReadActor.execute(in);        Actor actor = new Actor();        actor.setId(id);        actor.setFirstName((String) out.get(\"out_first_name\"));        actor.setLastName((String) out.get(\"out_last_name\"));        actor.setBirthDate((Date) out.get(\"out_birth_date\"));        return actor;    }    //  ... additional methods}\n\r\n\rThe code you write for the execution of the call involves      creating an SqlParameterSource containing the IN      parameter. It\'s      important to match the name provided for the input value with that of      the parameter name declared      in the stored procedure. The case does not have to match because you use      metadata to determine how database objects should be referred to in a      stored procedure. What is specified in the source for the stored      procedure is not necessarily the way it is stored in the database. Some      databases transform names to all upper case while others use lower case      or use the case as specified.      \n\r\n\rThe execute method takes the IN parameters      and returns a Map containing any out parameters keyed by      the name as specified in the stored procedure. In this case they are      out_first_name, out_last_name and      out_birth_date.      \n\r\n\rThe last part of the execute method creates      an Actor instance to use to return the data retrieved. Again, it is      important to use the names of the out parameters as they      are declared in the stored procedure. Also,      the case in the names of the out parameters stored in the      results map matches that of the out parameter names in the      database, which could vary between databases. To      make your code more portable you should do a case-insensitive lookup or      instruct Spring to use a CaseInsensitiveMap from      the Jakarta Commons project. To do the latter, you create your own      JdbcTemplate and set the      setResultsMapCaseInsensitive property to      true. Then you pass this customized      JdbcTemplate instance into the constructor of      your SimpleJdbcCall. You must include the      commons-collections.jar in your classpath for      this to work. Here is an example of this configuration:      public class JdbcActorDao implements ActorDao {    private SimpleJdbcCall procReadActor;    public void setDataSource(DataSource dataSource) {        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        jdbcTemplate.setResultsMapCaseInsensitive(true);        this.procReadActor =                new SimpleJdbcCall(jdbcTemplate)                        .withProcedureName(\"read_actor\");    }    //  ... additional methods}\n\r\n\rBy taking this action, you avoid conflicts in the case used      for the names of your returned out parameters.        14.5.6&nbsp;Explicitly declaring parameters to use for a      SimpleJdbcCall            \n\r\n\rYou have seen how the parameters are deduced based on metadata,      but you can declare then explicitly if you wish. You do this by creating      and configuring SimpleJdbcCall with the      declareParameters method, which takes a variable      number of SqlParameter objects as input. See the      next section for details on how to define an      SqlParameter.      Note          \n\r\n\rExplicit declarations are necessary if the database you use is          not a Spring-supported database. Currently Spring supports metadata          lookup of stored procedure calls for the following databases: Apache          Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase. We also          support metadata lookup of stored functions for: MySQL, Microsoft          SQL Server, and Oracle.              \n\r\n\rYou can opt to declare one, some, or all the parameters      explicitly. The parameter metadata is still used where you do not      declare parameters explicitly. To      bypass all processing of metadata lookups for potential parameters and      only use the declared parameters, you call the method      withoutProcedureColumnMetaDataAccess as part of      the declaration. Suppose that you have two or more different call      signatures declared for a database function. In this case you call the      useInParameterNames to specify the list of IN      parameter names to include for a given signature.      \n\r\n\rThe following example shows a fully declared procedure call, using      the information from the preceding example.      public class JdbcActorDao implements ActorDao {    private SimpleJdbcCall procReadActor;    public void setDataSource(DataSource dataSource) {        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        jdbcTemplate.setResultsMapCaseInsensitive(true);        this.procReadActor =                new SimpleJdbcCall(jdbcTemplate)                        .withProcedureName(\"read_actor\")                        .withoutProcedureColumnMetaDataAccess()                        .useInParameterNames(\"in_id\")                        .declareParameters(                                new SqlParameter(\"in_id\", Types.NUMERIC),                                new SqlOutParameter(\"out_first_name\", Types.VARCHAR),                                new SqlOutParameter(\"out_last_name\", Types.VARCHAR),                                new SqlOutParameter(\"out_birth_date\", Types.DATE)                        );    }    //  ... additional methods}\n\r\n\rThe execution and end results of the two examples are the      same; this one specifies all details explicitly rather than relying on      metadata.        14.5.7&nbsp;How to define SqlParameters            \n\r\n\rTo define a parameter for the SimpleJdbc classes and also for the      RDBMS operations classes, covered in Section&nbsp;14.6, &#8220;Modeling JDBC operations as Java objects&#8221;,      you      use an SqlParameter or one of its subclasses. You      typically specify the parameter name and SQL type in the constructor.      The SQL type is specified using the      java.sql.Types constants. We have already seen      declarations like:         new SqlParameter(\"in_id\", Types.NUMERIC),   new SqlOutParameter(\"out_first_name\", Types.VARCHAR),      \n\r\n\rThe first line with the SqlParameter      declares an IN parameter. IN parameters can be used for both stored      procedure calls and for queries using the      SqlQuery and its subclasses covered in the      following section.      \n\r\n\rThe second line with the SqlOutParameter      declares an out parameter to be used in a stored procedure      call. There is also an SqlInOutParameter for      InOut parameters, parameters that provide an      IN value to the procedure and that also return a      value.      Note        \n\r\n\rOnly parameters declared as SqlParameter        and SqlInOutParameter will be used to provide        input values. This is different from the        StoredProcedure class, which for backwards        compatibility reasons allows input values to be provided for        parameters declared as SqlOutParameter.            \n\r\n\rFor IN parameters, in addition to the name and the SQL type, you      can specify a scale for numeric data or a type name for custom database      types. For out parameters, you can provide a      RowMapper to handle mapping of rows returned from      a REF cursor. Another option is to specify an      SqlReturnType that provides an opportunity to      define customized handling of the return values.        14.5.8&nbsp;Calling a stored function using SimpleJdbcCall            \n\r\n\rYou call a stored function in almost the same way as you call a      stored procedure, except that you provide a function name rather than a      procedure name. You use the withFunctionName      method as part of the configuration to indicate that we want to make a      call to a function, and the corresponding string for a function call is      generated. A specialized execute call,      executeFunction, is used to execute the function      and it returns the function return value as an object of a specified      type, which means you do not have to retrieve the return value from the      results map. A      similar convenience method named executeObject is      also available for stored procedures that only have one out      parameter. The following example is based on a stored function named      get_actor_name that returns an actor\'s full name.      Here is the MySQL source for this function:      CREATE FUNCTION get_actor_name (in_id INTEGER)RETURNS VARCHAR(200) READS SQL DATABEGIN  DECLARE out_name VARCHAR(200);  SELECT concat(first_name, \' \', last_name)    INTO out_name    FROM t_actor where id = in_id;  RETURN out_name;END;      \n\r\n\rTo call this function we again create a      SimpleJdbcCall in the initialization      method.      public class JdbcActorDao implements ActorDao {    private JdbcTemplate jdbcTemplate;    private SimpleJdbcCall funcGetActorName;    public void setDataSource(DataSource dataSource) {        this.jdbcTemplate = new JdbcTemplate(dataSource);        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        jdbcTemplate.setResultsMapCaseInsensitive(true);        this.funcGetActorName =                new SimpleJdbcCall(jdbcTemplate)                        .withFunctionName(\"get_actor_name\");    }    public String getActorName(Long id) {        SqlParameterSource in = new MapSqlParameterSource()                .addValue(\"in_id\", id);        String name = funcGetActorName.executeFunction(String.class, in);        return name;    }    //  ... additional methods}\n\r\n\rThe execute method used      returns a String containing the return value from      the function call.        14.5.9&nbsp;Returning ResultSet/REF Cursor from a SimpleJdbcCall            \n\r\n\rCalling a stored procedure or function that returns a result set      is a bit tricky. Some databases return result sets during the JDBC      results processing while others require an explicitly registered      out parameter of a specific type. Both approaches need      additional processing to loop over the result set and process the      returned rows. With the SimpleJdbcCall you use      the returningResultSet method and declare a      RowMapper implementation to be used for a      specific parameter. In the case where the result set is returned during      the results processing, there are no names defined, so the returned      results will have to match the order in which you declare the      RowMapper implementations. The name specified is      still used to store the processed list of results in the results map      that is returned from the execute statement.      \n\r\n\rThe next example uses a stored procedure that takes no IN      parameters and returns all rows from the t_actor table. Here is the      MySQL source for this procedure:      CREATE PROCEDURE read_all_actors()BEGIN SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;END;\n\r\n\rTo call this procedure you declare the      RowMapper. Because the class you want to map to      follows the JavaBean rules, you can use a      ParameterizedBeanPropertyRowMapper that is      created by passing in the required class to map to in the      newInstance method.      public class JdbcActorDao implements ActorDao {    private SimpleJdbcCall procReadAllActors;    public void setDataSource(DataSource dataSource) {        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        jdbcTemplate.setResultsMapCaseInsensitive(true);        this.procReadAllActors =                new SimpleJdbcCall(jdbcTemplate)                        .withProcedureName(\"read_all_actors\")                        .returningResultSet(\"actors\",                                ParameterizedBeanPropertyRowMapper.newInstance(Actor.class));    }    public List getActorsList() {        Map m = procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));        return (List) m.get(\"actors\");    }    //  ... additional methods}\n\r\n\rThe execute call passes in an empty Map because this call      does not take any parameters. The list of Actors is then retrieved from      the results map and returned to the caller.        14.6&nbsp;Modeling JDBC operations as Java objects        \n\r\n\rThe org.springframework.jdbc.object package    contains classes that allow you to access the database in a more    object-oriented manner. As an example, you can execute queries and get the    results back as a list containing business objects with the relational    column data mapped to the properties of the business object. You can also    execute stored procedures and run update, delete, and insert    statements.    Note      \n\r\n\rMany Spring developers believe that the various RDBMS operation      classes described below (with the exception of the StoredProcedure      class) can often be replaced with straight      JdbcTemplate calls. Often it is simpler to write      a DAO method that simply calls a method on a      JdbcTemplate directly (as opposed to      encapsulating a query as a full-blown class).      \n\r\n\rHowever, if you are getting measurable value from using the RDBMS      operation classes, continue using these classes.        14.6.1&nbsp;SqlQuery            \n\r\n\rSqlQuery is a reusable, threadsafe class      that encapsulates an SQL query. Subclasses must implement the      newRowMapper(..) method to provide a      RowMapper instance that can create one      object per row obtained from iterating over the      ResultSet that is created during the      execution of the query. The SqlQuery class is      rarely used directly because the MappingSqlQuery      subclass provides a much more convenient implementation for mapping rows      to Java classes. Other implementations that extend      SqlQuery are      MappingSqlQueryWithParameters and      UpdatableSqlQuery.        14.6.2&nbsp;MappingSqlQuery            \n\r\n\rMappingSqlQuery is a reusable query in      which concrete subclasses must implement the abstract      mapRow(..) method to convert each row of the      supplied ResultSet into an object of the      type specified. The following example shows a custom query that maps the      data from the t_actor relation to an instance of the      Actor class.      public class ActorMappingQuery extends MappingSqlQuery&lt;Actor&gt; {    public ActorMappingQuery(DataSource ds) {        super(ds, \"select id, first_name, last_name from t_actor where id = ?\");        super.declareParameter(new SqlParameter(\"id\", Types.INTEGER));        compile();    }    @Override    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {        Actor actor = new Actor();        actor.setId(rs.getLong(\"id\"));        actor.setFirstName(rs.getString(\"first_name\"));        actor.setLastName(rs.getString(\"last_name\"));        return actor;    }}      \n\r\n\rThe class extends MappingSqlQuery      parameterized with the Actor type. The      constructor for this customer query takes the      DataSource as the only parameter. In this      constructor you call the constructor on the superclass with the      DataSource and the SQL that should be      executed to retrieve the rows for this query. This SQL will be used to      create a PreparedStatement so it may      contain place holders for any parameters to be passed in during      execution.You      must declare each parameter using the      declareParameter method passing in an      SqlParameter. The      SqlParameter takes a name and the JDBC type as      defined in java.sql.Types. After you define all      parameters, you call the compile() method so the      statement can be prepared and later executed. This class is thread-safe      after it is compiled, so as long as these instances      are created when the DAO is initialized they can be kept as instance      variables and be reused.      private ActorMappingQuery actorMappingQuery;@Autowiredpublic void setDataSource(DataSource dataSource) {    this.actorMappingQuery = new ActorMappingQuery(dataSource);}public Customer getCustomer(Long id) {    return actorMappingQuery.findObject(id);}      \n\r\n\rThe method in this example retrieves the customer with the id that      is passed in as the only parameter. Since we only want one object      returned we simply call the convenience method findObject      with the id as parameter. If we had instead a query that returned a list      of objects and took additional parameters then we would use one of the      execute methods that takes an array of parameter values passed in as      varargs.      public List&lt;Actor&gt; searchForActors(int age, String namePattern) {    List&lt;Actor&gt; actors = actorSearchMappingQuery.execute(age, namePattern);    return actors;}        14.6.3&nbsp;SqlUpdate            \n\r\n\rThe SqlUpdate class encapsulates an SQL      update. Like a query, an update object is reusable, and like all      RdbmsOperation classes, an update can have      parameters and is defined in SQL. This class provides a number of      update(..) methods analogous to the      execute(..) methods of query objects. The      SQLUpdate class is concrete. It can be      subclassed, for example, to add a custom update method, as in the      following snippet where it\'s simply called      execute. However,      you don\'t have to subclass the SqlUpdate class      since it can easily be parameterized by setting SQL and declaring      parameters.      import java.sql.Types;import javax.sql.DataSource;import org.springframework.jdbc.core.SqlParameter;import org.springframework.jdbc.object.SqlUpdate;public class UpdateCreditRating extends SqlUpdate {    public UpdateCreditRating(DataSource ds) {        setDataSource(ds);        setSql(\"update customer set credit_rating = ? where id = ?\");        declareParameter(new SqlParameter(\"creditRating\", Types.NUMERIC));        declareParameter(new SqlParameter(\"id\", Types.NUMERIC));        compile();    }    /**     * @param id for the Customer to be updated     * @param rating the new value for credit rating     * @return number of rows updated     */    public int execute(int id, int rating) {        return update(rating, id);    }}        14.6.4&nbsp;StoredProcedure            \n\r\n\rThe StoredProcedure class is a superclass      for object abstractions of RDBMS stored procedures. This class is      abstract, and its various      execute(..) methods have protected      access, preventing use other than through a subclass that offers tighter      typing.      \n\r\n\rThe inherited sql property will be the name of      the stored procedure in the RDBMS.      \n\r\n\rTo define a parameter for the      StoredProcedure class, you use an      SqlParameter or one of its subclasses. You must      specify the parameter name and SQL type in the constructor like in the      following code snippet. The SQL type is specified using the      java.sql.Types constants.         new SqlParameter(\"in_id\", Types.NUMERIC),   new SqlOutParameter(\"out_first_name\", Types.VARCHAR),      \n\r\n\rThe first line with the SqlParameter      declares an IN parameter. IN parameters can be used for both stored      procedure calls and for queries using the      SqlQuery and its subclasses covered in the      following section.      \n\r\n\rThe second line with the SqlOutParameter      declares an out parameter to be used in the stored      procedure call. There is also an      SqlInOutParameter for      InOut parameters, parameters that provide an      in value to the procedure and that also return a      value.      \n\r\n\rFor in parameters, in addition to the      name and the SQL type, you can specify a scale for numeric data or a      type name for custom database types. For out parameters you      can provide a RowMapper to handle mapping of rows      returned from a REF cursor. Another option is to specify an      SqlReturnType that enables you to define      customized handling of the return values.      \n\r\n\rHere is an example of a simple DAO that uses a      StoredProcedure to call a function,      sysdate(),which comes with any Oracle database. To      use the stored procedure functionality you have to create a class that      extends StoredProcedure. In this example, the      StoredProcedure class is an inner class, but if      you need to reuse the StoredProcedure you declare      it as a top-level class. This example has no input parameters, but an      output parameter is declared as a date type using the class      SqlOutParameter. The execute()      method executes the procedure and extracts the returned date from the      results Map. The results      Map has an entry for each declared output      parameter, in this case only one, using the parameter name as the      key.      import java.sql.Types;import java.util.Date;import java.util.HashMap;import java.util.Map;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.SqlOutParameter;import org.springframework.jdbc.object.StoredProcedure;public class StoredProcedureDao {    private GetSysdateProcedure getSysdate;    @Autowired    public void init(DataSource dataSource) {        this.getSysdate = new GetSysdateProcedure(dataSource);    }    public Date getSysdate() {        return getSysdate.execute();    }    private class GetSysdateProcedure extends StoredProcedure {        private static final String SQL = \"sysdate\";        public GetSysdateProcedure(DataSource dataSource) {            setDataSource(dataSource);            setFunction(true);            setSql(SQL);            declareParameter(new SqlOutParameter(\"date\", Types.DATE));            compile();        }        public Date execute() {            // the \'sysdate\' sproc has no input parameters, so an empty Map is supplied...            Map&lt;String, Object&gt; results = execute(new HashMap&lt;String, Object&gt;());            Date sysdate = (Date) results.get(\"date\");            return sysdate;        }    }}      \n\r\n\rThe following example of a StoredProcedure      has two output parameters (in this case, Oracle REF cursors).      import oracle.jdbc.OracleTypes;import org.springframework.jdbc.core.SqlOutParameter;import org.springframework.jdbc.object.StoredProcedure;import javax.sql.DataSource;import java.util.HashMap;import java.util.Map;public class TitlesAndGenresStoredProcedure extends StoredProcedure {    private static final String SPROC_NAME = \"AllTitlesAndGenres\";    public TitlesAndGenresStoredProcedure(DataSource dataSource) {        super(dataSource, SPROC_NAME);        declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));        declareParameter(new SqlOutParameter(\"genres\", OracleTypes.CURSOR, new GenreMapper()));        compile();    }    public Map&lt;String, Object&gt; execute() {        // again, this sproc has no input parameters, so an empty Map is supplied        return super.execute(new HashMap&lt;String, Object&gt;());    }}      \n\r\n\rNotice how the overloaded variants of the      declareParameter(..) method that have been used in      the TitlesAndGenresStoredProcedure constructor      are passed RowMapper implementation      instances; this is a very convenient and powerful way to reuse existing      functionality. The code for the two      RowMapper implementations is provided      below.      \n\r\n\rThe TitleMapper class maps a      ResultSet to a      Title domain object for each row in the supplied      ResultSet:      import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import com.foo.domain.Title;public final class TitleMapper implements RowMapper&lt;Title&gt; {    public Title mapRow(ResultSet rs, int rowNum) throws SQLException {        Title title = new Title();        title.setId(rs.getLong(\"id\"));        title.setName(rs.getString(\"name\"));        return title;    }}      \n\r\n\rThe GenreMapper class maps a      ResultSet to a      Genre domain object for each row in the supplied      ResultSet.      import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import com.foo.domain.Genre;public final class GenreMapper implements RowMapper&lt;Genre&gt; {    public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {        return new Genre(rs.getString(\"name\"));    }}      \n\r\n\rTo pass parameters to a stored procedure that has one or more      input parameters in its definition in the RDBMS, you can code a strongly      typed execute(..) method that would delegate to the      superclass\' untyped execute(Map parameters) method      (which has protected access); for      example:      import oracle.jdbc.OracleTypes;import org.springframework.jdbc.core.SqlOutParameter;import org.springframework.jdbc.core.SqlParameter;import org.springframework.jdbc.object.StoredProcedure;import javax.sql.DataSource;import java.sql.Types;import java.util.Date;import java.util.HashMap;import java.util.Map;public class TitlesAfterDateStoredProcedure extends StoredProcedure {    private static final String SPROC_NAME = \"TitlesAfterDate\";    private static final String CUTOFF_DATE_PARAM = \"cutoffDate\";    public TitlesAfterDateStoredProcedure(DataSource dataSource) {        super(dataSource, SPROC_NAME);        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);        declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));        compile();    }    public Map&lt;String, Object&gt; execute(Date cutoffDate) {        Map&lt;String, Object&gt; inputs = new HashMap&lt;String, Object&gt;();        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);        return super.execute(inputs);    }}        14.7&nbsp;Common problems with parameter and data value handling        \n\r\n\rCommon problems with parameters and data values exist in the    different approaches provided by the Spring Framework JDBC.    14.7.1&nbsp;Providing SQL type information for parameters            \n\r\n\rUsually Spring determines the SQL type of the parameters based on      the type of parameter passed in. It is possible to explicitly provide      the SQL type to be used when setting parameter values. This is sometimes      necessary to correctly set NULL values.      \n\r\n\rYou can provide SQL type information in several ways:      \n\r          \n\r\n\rMany update and query methods of the          JdbcTemplate take an additional parameter in          the form of an int array. This array is used to          indicate the SQL type of the corresponding parameter using constant          values from the java.sql.Types class. Provide          one entry for each parameter.        \n\r      \n\r          \n\r\n\rYou can use the SqlParameterValue class          to wrap the parameter value that needs this additional information.          Create          a new instance for each value and pass in the SQL type and parameter          value in the constructor. You can also provide an optional scale          parameter for numeric values.        \n\r      \n\r          \n\r\n\rFor methods working with named parameters, use the          SqlParameterSource classes          BeanPropertySqlParameterSource or          MapSqlParameterSource. They both have methods          for registering the SQL type for any of the named parameter          values.        \n\r        14.7.2&nbsp;Handling BLOB and CLOB objects            \n\r\n\rYou can store images, other binary objects, and large chunks of      text. These large object are called BLOB for binary data and CLOB for      character data. In Spring you can handle these large objects by using      the JdbcTemplate directly and also when using the higher abstractions      provided by RDBMS Objects and the SimpleJdbc classes. All      of these approaches use an implementation of the      LobHandler interface for the actual management of      the LOB data. The LobHandler provides access to a      LobCreator class, through the      getLobCreator method, used for creating new LOB      objects to be inserted.      \n\r\n\rThe LobCreator/LobHandler provides the      following support for LOB input and output:      \n\r            \n\r\n\rBLOB            \n\r                \n\r\n\rbyte[] &#8211; getBlobAsBytes and setBlobAsBytes              \n\r                \n\r\n\rInputStream &#8211; getBlobAsBinaryStream and                setBlobAsBinaryStream              \n\r          \n\r\n\r            \n\r\n\rCLOB            \n\r                \n\r\n\rString &#8211; getClobAsString and setClobAsString              \n\r                \n\r\n\rInputStream &#8211; getClobAsAsciiStream and                setClobAsAsciiStream              \n\r                \n\r\n\rReader &#8211; getClobAsCharacterStream and                setClobAsCharacterStream              \n\r          \n\r      \n\r\n\rThe next example shows how to create and insert a BLOB. Later you      will see how to read it back from the database.      \n\r\n\rThis example uses a JdbcTemplate and an      implementation of the      AbstractLobCreatingPreparedStatementCallback.      It implements one method, setValues. This method provides a      LobCreator that you use to set the values for the LOB      columns in your SQL insert statement.      \n\r\n\rFor this example we assume that there is a variable,      lobHandler, that already is set to an instance      of a DefaultLobHandler. You typically set this      value through dependency injection.      final File blobIn = new File(\"spring2004.jpg\");final InputStream blobIs = new FileInputStream(blobIn);final File clobIn = new File(\"large.txt\");final InputStream clobIs = new FileInputStream(clobIn);final InputStreamReader clobReader = new InputStreamReader(clobIs);jdbcTemplate.execute(  \"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)\",  new AbstractLobCreatingPreparedStatementCallback(lobHandler) {      protected void setValues(PreparedStatement ps, LobCreator lobCreator)          throws SQLException {        ps.setLong(1, 1L);        lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());        lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());      }  });blobIs.close();clobReader.close();      \n\r\n\r           \n\r\n\rPass in the lobHandler that in this example is a plain          DefaultLobHandler        \n\r\n\r           \n\r\n\rUsing the method          setClobAsCharacterStream, pass in the          contents of the CLOB.        \n\r\n\r           \n\r\n\rUsing the method          setBlobAsBinaryStream, pass in the contents          of the BLOB.              \n\r\n\rNow it\'s time to read the LOB data from the database. Again, you      use a JdbcTemplate with the same instance variable      lobHandler and a reference to a      DefaultLobHandler.      \n\r\n\r        List&lt;Map&lt;String, Object&gt;&gt; l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\",        new RowMapper&lt;Map&lt;String, Object&gt;&gt;() {          public Map&lt;String, Object&gt; mapRow(ResultSet rs, int i) throws SQLException {            Map&lt;String, Object&gt; results = new HashMap&lt;String, Object&gt;();            String clobText = lobHandler.getClobAsString(rs, \"a_clob\");            results.put(\"CLOB\", clobText);            byte[] blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\");            results.put(\"BLOB\", blobBytes);            return results;          }        });\n\r\n\r        \n\r\n\r             \n\r\n\rUsing the method getClobAsString,            retrieve the contents of the CLOB.          \n\r\n\r             \n\r\n\rUsing the method getBlobAsBytes,            retrieve the contents of the BLOB.          \n\r\n\r              14.7.3&nbsp;Passing in lists of values for IN clause            \n\r\n\rThe SQL standard allows for selecting rows based on an expression      that includes a variable list of values. A typical example would be      select * from T_ACTOR where id in (1, 2, 3). This variable      list is not directly supported for prepared statements by the JDBC      standard; you cannot declare a variable number of placeholders. You need      a number of variations with the desired number of placeholders prepared,      or you need to generate the SQL string dynamically once you know how      many placeholders are required. The named parameter support provided in      the NamedParameterJdbcTemplate and      JdbcTemplate takes the latter approach.      Pass in the values as a java.util.List of      primitive objects. This list will be used to insert the required      placeholders and pass in the values during the statement      execution.      Note        \n\r\n\rBe careful when passing in many values. The JDBC standard does        not guarantee that you can use more than 100 values for an        in expression list. Various databases exceed this number,        but they usually have a hard limit for how many values are allowed.        Oracle\'s limit is 1000.            \n\r\n\rIn addition to the primitive values in the value list, you can      create a java.util.List of object arrays. This      list would support multiple expressions defined for the in      clause such as select * from T_ACTOR where (id, last_name) in ((1,      \'Johnson\'), (2, \'Harrop\')). This of course requires that your      database supports this syntax.        14.7.4&nbsp;Handling complex types for stored procedure calls            \n\r\n\rWhen you call stored procedures you can sometimes use complex      types specific to the database. To accommodate these types, Spring      provides a SqlReturnType for handling them when      they are returned from the stored procedure call and      SqlTypeValue when they are passed in as a      parameter to the stored procedure.      \n\r\n\rHere is an example of returning the value of an Oracle      STRUCT object of the user declared type      ITEM_TYPE. The SqlReturnType      interface has a single method named getTypeValue      that must be implemented. This interface is used as part of the      declaration of an SqlOutParameter.      final TestItem - new TestItem(123L, \"A test item\",        new SimpleDateFormat(\"yyyy-M-d\").parse(\"2010-12-31\"););declareParameter(new SqlOutParameter(\"item\", OracleTypes.STRUCT, \"ITEM_TYPE\",    new SqlReturnType() {      public Object getTypeValue(CallableStatement cs, int colIndx, int sqlType, String typeName)          throws SQLException {        STRUCT struct = (STRUCT)cs.getObject(colIndx);        Object[] attr = struct.getAttributes();        TestItem item = new TestItem();        item.setId(((Number) attr[0]).longValue());        item.setDescription((String)attr[1]);        item.setExpirationDate((java.util.Date)attr[2]);        return item;      }    }));\n\r\n\rYou use the SqlTypeValue to      pass in the value of a Java object like TestItem      into a stored procedure. The      SqlTypeValue interface has a single method named      createTypeValue that you must implement. The      active connection is passed in, and you can use it to create      database-specific objects such as      StructDescriptors, as shown in the following      example, or ArrayDescriptors.      final TestItem - new TestItem(123L, \"A test item\",        new SimpleDateFormat(\"yyyy-M-d\").parse(\"2010-12-31\"););SqlTypeValue value = new AbstractSqlTypeValue() {  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {    StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);    Struct item = new STRUCT(itemDescriptor, conn,        new Object[] {            testItem.getId(),            testItem.getDescription(),            new java.sql.Date(testItem.getExpirationDate().getTime())        });    return item;  }};\n\r\n\rThis SqlTypeValue can now be added      to the Map containing the input parameters for the execute call of the      stored procedure.      \n\r\n\rAnother use for the SqlTypeValue is passing      in an array of values to an Oracle stored procedure. Oracle has its own      internal ARRAY class that must be used in this      case, and you can use the SqlTypeValue to create      an instance of the Oracle ARRAY and populate it      with values from the Java ARRAY.      final Long[] ids = new Long[] {1L, 2L};SqlTypeValue value = new AbstractSqlTypeValue() {  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {    ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn);    ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids);    return idArray;  }};        14.8&nbsp;Embedded database support        \n\r\n\rThe org.springframework.jdbc.datasource.embedded    package provides support for embedded Java database engines. Support for    HSQL, H2, and Derby is provided natively. You    can also use an extensible API to plug in new embedded database types and    DataSource implementations.    14.8.1&nbsp;Why use an embedded database?            \n\r\n\rAn embedded database is useful during the development phase of a      project because of its lightweight nature. Benefits include ease of      configuration, quick startup time, testability, and the ability to      rapidly evolve SQL during development.        14.8.2&nbsp;Creating an embedded database instance using Spring XML            \n\r\n\rIf you want to expose an embedded database instance as a bean in a      Spring ApplicationContext, use the embedded-database tag in the      spring-jdbc namespace:     &lt;jdbc:embedded-database id=\"dataSource\"&gt;        &lt;jdbc:script location=\"classpath:schema.sql\"/&gt;        &lt;jdbc:script location=\"classpath:test-data.sql\"/&gt;    &lt;/jdbc:embedded-database&gt;      \n\r\n\rThe preceding configuration creates an embedded HSQL database      populated with SQL from schema.sql and testdata.sql resources in the      classpath. The database instance is made available to the Spring      container as a bean of type javax.sql.DataSource.      This bean can then be injected into data access objects as      needed.        14.8.3&nbsp;Creating an embedded database instance programmatically            \n\r\n\rThe EmbeddedDatabaseBuilder class provides      a fluent API for constructing an embedded database programmatically. Use      this when you need to create an embedded database instance in a      standalone environment, such as a data access object unit test:          EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();    EmbeddedDatabase db = builder.setType(H2).addScript(\"my-schema.sql\").addScript(\"my-test-data.sql\").build();    // do stuff against the db (EmbeddedDatabase extends javax.sql.DataSource)    db.shutdown()        14.8.4&nbsp;Extending the embedded database support            \n\r\n\rSpring JDBC embedded database support can be extended in two ways:      \n\r            \n\r\n\rImplement EmbeddedDatabaseConfigurer            to support a new embedded database type, such as Apache            Derby.          \n\r            \n\r\n\rImplement DataSourceFactory to            support a new DataSource implementation, such as a connection            pool, to manage embedded database connections.          \n\r      \n\r\n\rYou are encouraged to contribute back extensions to the Spring      community at jira.springframework.org.        14.8.5&nbsp;Using HSQL            \n\r\n\rSpring supports HSQL 1.8.0 and above. HSQL is the default embedded      database if no type is specified explicitly. To specify HSQL explicitly,      set the type attribute of the      embedded-database tag to HSQL. If      you are using the builder API, call the      setType(EmbeddedDatabaseType) method with      EmbeddedDatabaseType.HSQL.        14.8.6&nbsp;Using H2            \n\r\n\rSpring supports the H2 database as well. To enable H2, set the      type attribute of the      embedded-database tag to H2. If      you are using the builder API, call the      setType(EmbeddedDatabaseType) method with      EmbeddedDatabaseType.H2.        14.8.7&nbsp;Using Derby            \n\r\n\rSpring also supports Apache Derby 10.5 and above. To enable Derby,      set the type attribute of the      embedded-database tag to Derby. If      using the builder API, call the      setType(EmbeddedDatabaseType) method with      EmbeddedDatabaseType.Derby.        14.8.8&nbsp;Testing data access logic with an embedded database            \n\r\n\rEmbedded databases provide a lightweight way to test data access      code. The following is a data access unit test template that uses an      embedded database:      public class DataAccessUnitTestTemplate {    private EmbeddedDatabase db;    @Before    public void setUp() {        // creates an HSQL in-memory database populated from default scripts        // classpath:schema.sql and classpath:data.sql        db = new EmbeddedDatabaseBuilder().addDefaultScripts().build();    }    @Test    public void testDataAccess() {        JdbcTemplate template = new JdbcTemplate(db);        template.query(...);    }    @After    public void tearDown() {        db.shutdown();    }}        14.9&nbsp;Initializing a DataSource        \n\r\n\rThe org.springframework.jdbc.datasource.init    package provides support for initializing an existing    DataSource. The embedded database support provides    one option for creating and initializing a    DataSource for an application, but sometimes you    need to initialize an instance running on a server somewhere.    14.9.1&nbsp;Initializing a database instance using Spring XML            \n\r\n\rIf you want to initialize a database and you can provide a      reference to a DataSource bean, use the      initialize-database tag in the      spring-jdbc namespace:      &lt;jdbc:initialize-database data-source=\"dataSource\"&gt;  &lt;jdbc:script location=\"classpath:com/foo/sql/db-schema.sql\"/&gt;  &lt;jdbc:script location=\"classpath:com/foo/sql/db-test-data.sql\"/&gt;&lt;/jdbc:initialize-database&gt;      \n\r\n\rThe example above runs the two scripts specified against the      database: the first script is a schema creation, and the second is a      test data set insert. The script locations can also be patterns with      wildcards in the usual ant style used for resources in Spring (e.g.      classpath*:/com/foo/**/sql/*-data.sql). If a pattern is      used the scripts are executed in lexical order of their URL or      filename.      \n\r\n\rThe default behavior of the database initializer is to      unconditionally execute the scripts provided. This will not always be      what you want, for instance if running against an existing database that      already has test data in it. The likelihood of accidentally deleting      data is reduced by the commonest pattern (as shown above) that creates      the tables first and then inserts the data - the first step will fail if      the tables already exist.      \n\r\n\rHowever, to get more control over the creation and deletion of      existing data, the XML namespace provides a couple more options. The      first is flag to switch the initialization on and off. This can be set      according to the environment (e.g. to pull a boolean value from system      properties or an environment bean), e.g. &lt;jdbc:initialize-database data-source=\"dataSource\"    enabled=\"#{systemProperties.INITIALIZE_DATABASE}\"&gt;  &lt;jdbc:script location=\"...\"/&gt;&lt;/jdbc:initialize-database&gt;      \n\r\n\rThe second option to control what happens with existing data is to      be more tolerant of failures. To this end you can control the ability of      the initializer to ignore certain errors in the SQL it executes from the      scripts, e.g.      &lt;jdbc:initialize-database data-source=\"dataSource\" ignore-failures=\"DROPS\"&gt;  &lt;jdbc:script location=\"...\"/&gt;&lt;/jdbc:initialize-database&gt;\n\r\n\rIn this example we are      saying we expect that sometimes the scripts will be run against an empty      database and there are some DROP statements in the scripts which would      therefore fail. So failed SQL DROP statements will be      ignored, but other failures will cause an exception. This is useful if      your SQL dialect doesn\'t support DROP ... IF EXISTS (or      similar) but you want to unconditionally remove all test data before      re-creating it. In that case the first script is usually a set of drops,      followed by a set of CREATE statements.      \n\r\n\rThe ignore-failures option can be set to      NONE (the default), DROPS (ignore failed      drops) or ALL (ignore all failures).      \n\r\n\rIf you need more control than you get from the XML namespace, you      can simply use the DataSourceInitializer      directly, and define it as a component in your application.      Initialization of Other Components that Depend on the        Database                \n\r\n\rA large class of applications can just use the database        initializer with no further complications: those that do not use the        database until after the Spring context has started. If your        application is not one of those then you might        need to read the rest of this section.        \n\r\n\rThe database initializer depends on a data source instance and        runs the scripts provided in its initialization callback (c.f.        init-method in an XML bean definition or        InitializingBean). If other beans depend on the same data        source and also use the data source in an initialization callback then        there might be a problem because the data has not yet been        initialized. A common example of this is a cache that initializes        eagerly and loads up data from the database on application        startup.        \n\r\n\rTo get round this issue you two options: change your cache        initialization strategy to a later phase, or ensure that the database        initializer is initialized first.        \n\r\n\rThe first option might be easy if the application is in your        control, and not otherwise. Some suggestions for how to implement this        are\n\r              \n\r\n\rMake the cache initialize lazily on first usage, which              improves application startup time            \n\r              \n\r\n\rHave your cache or a separate component that initializes              the cache implement Lifecycle or              SmartLifecycle. When the application context starts              up a SmartLifecycle can be automatically started if              its autoStartup flag is set, and a              Lifecycle can be started manually by calling              ConfigurableApplicationContext.start() on the              enclosing context.            \n\r              \n\r\n\rUse a Spring ApplicationEvent or similar              custom observer mechanism to trigger the cache initialization.              ContextRefreshedEvent is always published by the              context when it is ready for use (after all beans have been              initialized), so that is often a useful hook (this is how the              SmartLifecycle works by default).            \n\r        \n\r\n\rThe second option can also be easy. Some suggestions on how to        implement this are\n\r              \n\r\n\rRely on Spring BeanFactory default behavior, which is              that beans are initialized in registration order. You can easily              arrange that by adopting the common practice of a set of              &lt;import/&gt; elements that order your application modules,              and ensure that the database and database initialization are              listed first            \n\r              \n\r\n\rSeparate the datasource and the business components that              use it and control their startup order by putting them in              separate ApplicationContext instances (e.g. parent has the              datasource and child has the business components). This              structure is common in Spring web applications, but can be more              generally applied.            \n\r              \n\r\n\rUse a modular runtime like SpringSource dm Server and              separate the data source and the components that depend on it.              E.g. specify the bundle start up order as datasource -&gt;              initializer -&gt; business components.            \n\r            Prev&nbsp;Up&nbsp;Next13.&nbsp;DAO support&nbsp;Home&nbsp;15.&nbsp;Object Relational Mapping (ORM) Data Access","14. Data access with JDBC","scr\\jdbc.html","         23.&nbsp;JMS (Java Message Service)Prev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next23.&nbsp;JMS (Java Message Service)    23.1&nbsp;Introduction        \n\r\n\rSpring provides a JMS integration framework that simplifies the use    of the JMS API much like Spring\'s integration does for the JDBC    API.    \n\r\n\rJMS can be roughly divided into two areas of functionality, namely    the production and consumption of messages. The    JmsTemplate class is used for message production    and synchronous message reception. For asynchronous reception similar to    Java EE\'s message-driven bean style, Spring provides a number of message    listener containers that are used to create Message-Driven POJOs    (MDPs).    \n\r\n\rThe package org.springframework.jms.core provides    the core functionality for using JMS. It contains JMS template classes    that simplify the use of the JMS by handling the creation and release of    resources, much like the JdbcTemplate does for    JDBC. The design principle common to Spring template classes is to provide    helper methods to perform common operations and for more sophisticated    usage, delegate the essence of the processing task to user implemented    callback interfaces. The JMS template follows the same design. The classes    offer various convenience methods for the sending of messages, consuming a    message synchronously, and exposing the JMS session and message producer    to the user.    \n\r\n\rThe package org.springframework.jms.support    provides JMSException translation functionality.    The translation converts the checked JMSException    hierarchy to a mirrored hierarchy of unchecked exceptions. If there are    any provider specific subclasses of the checked    javax.jms.JMSException, this exception is wrapped    in the unchecked UncategorizedJmsException.    \n\r\n\rThe package    org.springframework.jms.support.converter provides a    MessageConverter abstraction to convert    between Java objects and JMS messages.    \n\r\n\rThe package    org.springframework.jms.support.destination provides    various strategies for managing JMS destinations, such as providing a    service locator for destinations stored in JNDI.    \n\r\n\rFinally, the package    org.springframework.jms.connection provides an    implementation of the ConnectionFactory suitable    for use in standalone applications. It also contains an implementation of    Spring\'s PlatformTransactionManager for JMS    (the cunningly named JmsTransactionManager). This    allows for seamless integration of JMS as a transactional resource into    Spring\'s transaction management mechanisms.    23.2&nbsp;Using Spring JMS        23.2.1&nbsp;JmsTemplate            \n\r\n\rThe JmsTemplate class is the central class      in the JMS core package. It simplifies the use of JMS since it handles      the creation and release of resources when sending or synchronously      receiving messages.      \n\r\n\rCode that uses the JmsTemplate only needs      to implement callback interfaces giving them a clearly defined high      level contract. The MessageCreator callback      interface creates a message given a      Session provided by the calling code in      JmsTemplate. In order to allow for more complex      usage of the JMS API, the callback      SessionCallback provides the user with the JMS      session and the callback ProducerCallback exposes      a Session and      MessageProducer pair.      \n\r\n\rThe JMS API exposes two types of send methods, one that takes      delivery mode, priority, and time-to-live as Quality of Service (QOS)      parameters and one that takes no QOS parameters which uses default      values. Since there are many send methods in      JmsTemplate, the setting of the QOS parameters      have been exposed as bean properties to avoid duplication in the number      of send methods. Similarly, the timeout value for synchronous receive      calls is set using the property      setReceiveTimeout.      \n\r\n\rSome JMS providers allow the setting of default QOS values      administratively through the configuration of the ConnectionFactory.      This has the effect that a call to      MessageProducer\'s send method      send(Destination destination, Message message)      will use different QOS default values than those specified in the JMS      specification. In order to provide consistent management of QOS values,      the JmsTemplate must therefore be specifically      enabled to use its own QOS values by setting the boolean property      isExplicitQosEnabled to      true.      Note        \n\r\n\rInstances of the JmsTemplate class are        thread-safe once configured. This is important        because it means that you can configure a single instance of a        JmsTemplate and then safely inject this        shared reference into multiple collaborators. To        be clear, the JmsTemplate is stateful, in that        it maintains a reference to a        ConnectionFactory, but this state is        not conversational state.              23.2.2&nbsp;Connections            \n\r\n\rThe JmsTemplate requires a reference to a      ConnectionFactory. The      ConnectionFactory is part of the JMS      specification and serves as the entry point for working with JMS. It is      used by the client application as a factory to create connections with      the JMS provider and encapsulates various configuration parameters, many      of which are vendor specific such as SSL configuration options.      \n\r\n\rWhen using JMS inside an EJB, the vendor provides implementations      of the JMS interfaces so that they can participate in declarative      transaction management and perform pooling of connections and sessions.      In order to use this implementation, Java EE containers typically      require that you declare a JMS connection factory as a      resource-ref inside the EJB or servlet deployment      descriptors. To ensure the use of these features with the      JmsTemplate inside an EJB, the client application      should ensure that it references the managed implementation of the      ConnectionFactory.      Caching Messaging Resources                \n\r\n\rThe standard API involves creating many intermediate objects. To        send a message the following \'API\' walk is performed        ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send        \n\r\n\rBetween the ConnectionFactory and the Send operation there are        three intermediate objects that are created and destroyed. To optimise        the resource usage and increase performance two implementations of        IConnectionFactory are provided.            SingleConnectionFactory                \n\r\n\rSpring provides an implementation of the        ConnectionFactory interface,        SingleConnectionFactory, that will return the        same Connection on all        createConnection() calls and ignore calls to        close(). This is useful for testing and        standalone environments so that the same connection can be used for        multiple JmsTemplate calls that may span any        number of transactions. SingleConnectionFactory        takes a reference to a standard        ConnectionFactory that would typically come        from JNDI.            CachingConnectionFactory                \n\r\n\rThe CachingConnectionFactory extends the        functionality of SingleConnectionFactory and        adds the caching of Sessions, MessageProducers, and MessageConsumers.        The initial cache size is set to 1, use the property        SessionCacheSize to increase the number of cached        sessions. Note that the number of actual cached sessions will be more        than that number as sessions are cached based on their acknowledgment        mode, so there can be up to 4 cached session instances when        SessionCacheSize is set to one, one for each        AcknowledgementMode. MessageProducers and MessageConsumers are cached        within their owning session and also take into account the unique        properties of the producers and consumers when caching.        MessageProducers are cached based on their destination.        MessageConsumers are cached based on a key composed of the        destination, selector, noLocal delivery flag, and the durable        subscription name (if creating durable consumers).              23.2.3&nbsp;Destination Management            \n\r\n\rDestinations, like ConnectionFactories, are JMS administered      objects that can be stored and retrieved in JNDI. When configuring a      Spring application context you can use the JNDI factory class      JndiObjectFactoryBean /      &lt;jee:jndi-lookup&gt; to perform dependency      injection on your object\'s references to JMS destinations. However,      often this strategy is cumbersome if there are a large number of      destinations in the application or if there are advanced destination      management features unique to the JMS provider. Examples of such      advanced destination management would be the creation of dynamic      destinations or support for a hierarchical namespace of destinations.      The JmsTemplate delegates the resolution of a      destination name to a JMS destination object to an implementation of the      interface DestinationResolver.      DynamicDestinationResolver is the default      implementation used by JmsTemplate and      accommodates resolving dynamic destinations. A      JndiDestinationResolver is also provided that      acts as a service locator for destinations contained in JNDI and      optionally falls back to the behavior contained in      DynamicDestinationResolver.      \n\r\n\rQuite often the destinations used in a JMS application are only      known at runtime and therefore cannot be administratively created when      the application is deployed. This is often because there is shared      application logic between interacting system components that create      destinations at runtime according to a well-known naming convention.      Even though the creation of dynamic destinations is not part of the JMS      specification, most vendors have provided this functionality. Dynamic      destinations are created with a name defined by the user which      differentiates them from temporary destinations and are often not      registered in JNDI. The API used to create dynamic destinations varies      from provider to provider since the properties associated with the      destination are vendor specific. However, a simple implementation choice      that is sometimes made by vendors is to disregard the warnings in the      JMS specification and to use the TopicSession      method createTopic(String topicName) or the      QueueSession method      createQueue(String queueName) to create a new      destination with default destination properties. Depending on the vendor      implementation, DynamicDestinationResolver may      then also create a physical destination instead of only resolving      one.      \n\r\n\rThe boolean property pubSubDomain is used to      configure the JmsTemplate with knowledge of what      JMS domain is being used. By default the value of this property is      false, indicating that the point-to-point domain, Queues, will be used.      This property used by JmsTemplate determines the      behavior of dynamic destination resolution via implementations of the      DestinationResolver interface.      \n\r\n\rYou can also configure the JmsTemplate with      a default destination via the property      defaultDestination. The default destination will be      used with send and receive operations that do not refer to a specific      destination.        23.2.4&nbsp;Message Listener Containers            \n\r\n\rOne of the most common uses of JMS messages in the EJB world is to      drive message-driven beans (MDBs). Spring offers a solution to create      message-driven POJOs (MDPs) in a way that does not tie a user to an EJB      container. (See Section&nbsp;23.4.2, &#8220;Asynchronous Reception - Message-Driven POJOs&#8221;      for detailed coverage of Spring\'s MDP support.)      \n\r\n\rA message listener container is used to receive messages from a      JMS message queue and drive the MessageListener that is injected into      it. The listener container is responsible for all threading of message      reception and dispatches into the listener for processing. A message      listener container is the intermediary between an MDP and a messaging      provider, and takes care of registering to receive messages,      participating in transactions, resource acquisition and release,      exception conversion and suchlike. This allows you as an application      developer to write the (possibly complex) business logic associated with      receiving a message (and possibly responding to it), and delegates      boilerplate JMS infrastructure concerns to the framework.      \n\r\n\rThere are two standard JMS message listener containers packaged      with Spring, each with its specialised feature set.      SimpleMessageListenerContainer                \n\r\n\rThis message listener container is the simpler of the two        standard flavors. It creates a fixed number of JMS sessions and        consumers at startup, registers the listener using the standard JMS        MessageConsumer.setMessageListener() method,        and leaves it up the JMS provider to perform listener callbacks.        This variant does not allow for dynamic adaption to runtime demands or        for participation in externally managed transactions. Compatibility-wise,        it stays very close to the spirit of the standalone JMS specification        - but is generally not compatible with Java EE\'s JMS restrictions.            DefaultMessageListenerContainer                \n\r\n\rThis message listener container is the one used in most cases.        In contrast to SimpleMessageListenerContainer,        this container variant does allow for dynamic adaption to runtime        demands and is able to participate in externally managed transactions.        Each received message is registered with an XA transaction when        configured with a JtaTransactionManager; so        processing may take advantage of XA transaction semantics. This        listener container strikes a good balance between low requirements on        the JMS provider, advanced functionality such as transaction        participation, and compatibility with Java EE environments.              23.2.5&nbsp;Transaction management            \n\r\n\rSpring provides a JmsTransactionManager      that manages transactions for a single JMS      ConnectionFactory. This allows JMS applications      to leverage the managed transaction features of Spring as described in      Chapter&nbsp;12, Transaction Management. The      JmsTransactionManager performs local resource      transactions, binding a JMS Connection/Session pair from the specified      ConnectionFactory to the thread.      JmsTemplate automatically detects such      transactional resources and operates on them accordingly.      \n\r\n\rIn a Java EE environment, the      ConnectionFactory will pool Connections and      Sessions, so those resources are efficiently reused across transactions.      In a standalone environment, using Spring\'s      SingleConnectionFactory will result in a shared      JMS Connection, with each transaction having its      own independent Session. Alternatively, consider      the use of a provider-specific pooling adapter such as ActiveMQ\'s      PooledConnectionFactory class.      \n\r\n\rJmsTemplate can also be used with the      JtaTransactionManager and an XA-capable JMS      ConnectionFactory for performing distributed      transactions. Note that this requires the use of a JTA transaction      manager as well as a properly XA-configured ConnectionFactory! (Check      your Java EE server\'s / JMS provider\'s documentation.)      \n\r\n\rReusing code across a managed and unmanaged transactional      environment can be confusing when using the JMS API to create a      Session from a Connection.      This is because the JMS API has only one factory method to create a      Session and it requires values for the      transaction and acknowledgement modes. In a managed environment, setting      these values is the responsibility of the environment\'s transactional      infrastructure, so these values are ignored by the vendor\'s wrapper to      the JMS Connection. When using the JmsTemplate in      an unmanaged environment you can specify these values through the use of      the properties sessionTransacted and      sessionAcknowledgeMode. When using a      PlatformTransactionManager with      JmsTemplate, the template will always be given a      transactional JMS Session.        23.3&nbsp;Sending a Message        \n\r\n\rThe JmsTemplate contains many convenience    methods to send a message. There are send methods that specify the    destination using a javax.jms.Destination object    and those that specify the destination using a string for use in a JNDI    lookup. The send method that takes no destination argument uses the    default destination. Here is an example that sends a message to a queue    using the 1.0.2 implementation.    import javax.jms.ConnectionFactory;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Queue;import javax.jms.Session;import org.springframework.jms.core.MessageCreator;import org.springframework.jms.core.JmsTemplate;public class JmsQueueSender {    private JmsTemplate jmsTemplate;    private Queue queue;    public void setConnectionFactory(ConnectionFactory cf) {        this.jmsTemplate = new JmsTemplate(cf);    }    public void setQueue(Queue queue) {        this.queue = queue;    }    public void simpleSend() {        this.jmsTemplate.send(this.queue, new MessageCreator() {            public Message createMessage(Session session) throws JMSException {              return session.createTextMessage(\"hello queue world\");            }        });    }}    \n\r\n\rThis example uses the MessageCreator callback    to create a text message from the supplied Session    object. The JmsTemplate is constructed by passing a    reference to a ConnectionFactory. As an alternative,    a zero argument constructor and connectionFactory    is provided and can be used for constructing the instance in JavaBean style    (using a BeanFactory or plain Java code). Alternatively, consider deriving    from Spring\'s JmsGatewaySupport convenience base class,    which provides pre-built bean properties for JMS configuration.    \n\r\n\rThe method send(String destinationName, MessageCreator    creator) lets you send a message using the string name of    the destination. If these names are registered in JNDI, you should set the    destinationResolver property of the template to an    instance of JndiDestinationResolver.    \n\r\n\rIf you created the JmsTemplate and specified    a default destination, the send(MessageCreator c)    sends a message to that destination.    23.3.1&nbsp;Using Message Converters            \n\r\n\rIn order to facilitate the sending of domain model objects, the      JmsTemplate has various send methods that take a      Java object as an argument for a message\'s data content. The overloaded      methods convertAndSend() and      receiveAndConvert() in      JmsTemplate delegate the conversion process to an      instance of the MessageConverter interface. This      interface defines a simple contract to convert between Java objects and      JMS messages. The default implementation      SimpleMessageConverter supports conversion      between String and      TextMessage, byte[] and      BytesMesssage, and      java.util.Map and      MapMessage. By using the converter, you and your      application code can focus on the business object that is being sent or      received via JMS and not be concerned with the details of how it is      represented as a JMS message.      \n\r\n\rThe sandbox currently includes a      MapMessageConverter which uses reflection to      convert between a JavaBean and a MapMessage.      Other popular implementation choices you might implement yourself are      Converters that use an existing XML marshalling package, such as JAXB,      Castor, XMLBeans, or XStream, to create a      TextMessage representing the      object.      \n\r\n\rTo accommodate the setting of a message\'s properties, headers, and      body that can not be generically encapsulated inside a converter class,      the MessagePostProcessor interface gives      you access to the message after it has been converted, but before it is      sent. The example below demonstrates how to modify a message header and      a property after a java.util.Map is      converted to a message.      public void sendWithConversion() {    Map map = new HashMap();    map.put(\"Name\", \"Mark\");    map.put(\"Age\", new Integer(47));    jmsTemplate.convertAndSend(\"testQueue\", map, new MessagePostProcessor() {        public Message postProcessMessage(Message message) throws JMSException {            message.setIntProperty(\"AccountID\", 1234);            message.setJMSCorrelationID(\"123-00001\");            return message;        }    });}      \n\r\n\rThis results in a message of the form:      MapMessage={    Header={        ... standard headers ...        CorrelationID={123-00001}    }    Properties={        AccountID={Integer:1234}    }    Fields={        Name={String:Mark}        Age={Integer:47}    }}        23.3.2&nbsp;SessionCallback and      ProducerCallback            \n\r\n\rWhile the send operations cover many common usage scenarios, there      are cases when you want to perform multiple operations on a JMS      Session or      MessageProducer. The      SessionCallback and      ProducerCallback expose the JMS      Session and      Session /      MessageProducer pair respectively. The      execute() methods on      JmsTemplate execute these callback      methods.        23.4&nbsp;Receiving a message        23.4.1&nbsp;Synchronous Reception            \n\r\n\rWhile JMS is typically associated with asynchronous processing, it      is possible to consume messages synchronously. The overloaded      receive(..) methods provide this functionality.      During a synchronous receive, the calling thread blocks until a message      becomes available. This can be a dangerous operation since the calling      thread can potentially be blocked indefinitely. The property      receiveTimeout specifies how long the receiver      should wait before giving up waiting for a message.        23.4.2&nbsp;Asynchronous Reception - Message-Driven POJOs            \n\r\n\rIn a fashion similar to a Message-Driven Bean (MDB) in the EJB      world, the Message-Driven POJO (MDP) acts as a receiver for JMS      messages. The one restriction (but see also below for the discussion of      the MessageListenerAdapter class) on an MDP is      that it must implement the      javax.jms.MessageListener interface.      Please also be aware that in the case where your POJO will be receiving      messages on multiple threads, it is important to ensure that your      implementation is thread-safe.      \n\r\n\rBelow is a simple implementation of an MDP:      import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class ExampleListener implements MessageListener {    public void onMessage(Message message) {        if (message instanceof TextMessage) {            try {                System.out.println(((TextMessage) message).getText());            }            catch (JMSException ex) {                throw new RuntimeException(ex);            }        }        else {            throw new IllegalArgumentException(\"Message must be of type TextMessage\");        }    }}      \n\r\n\rOnce you\'ve implemented your      MessageListener, it\'s time to create a      message listener container.      \n\r\n\rFind below an example of how to define and configure one of the      message listener containers that ships with Spring (in this case the      DefaultMessageListenerContainer).      &lt;!-- this is the Message Driven POJO (MDP) --&gt;&lt;bean id=\"messageListener\" class=\"jmsexample.ExampleListener\" /&gt;&lt;!-- and this is the message listener container --&gt;&lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt;    &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;    &lt;property name=\"destination\" ref=\"destination\"/&gt;    &lt;property name=\"messageListener\" ref=\"messageListener\" /&gt;&lt;/bean&gt;      \n\r\n\rPlease refer to the Spring Javadoc of the various message listener      containers for a full description of the features supported by each      implementation.        23.4.3&nbsp;The SessionAwareMessageListener      interface            \n\r\n\rThe SessionAwareMessageListener      interface is a Spring-specific interface that provides a similar      contract to the JMS MessageListener      interface, but also provides the message handling method with access to      the JMS Session from which the      Message was received.      package org.springframework.jms.listener;public interface SessionAwareMessageListener {    void onMessage(Message message, Session session) throws JMSException;}      \n\r\n\rYou can choose to have your MDPs implement this interface (in      preference to the standard JMS      MessageListener interface) if you want      your MDPs to be able to respond to any received messages (using the      Session supplied in the      onMessage(Message, Session) method). All of the      message listener container implementations that ship with Spring have      support for MDPs that implement either the      MessageListener or      SessionAwareMessageListener interface.      Classes that implement the      SessionAwareMessageListener come with the      caveat that they are then tied to Spring through the interface. The      choice of whether or not to use it is left entirely up to you as an      application developer or architect.      \n\r\n\rPlease note that the \'onMessage(..)\' method of      the SessionAwareMessageListener interface      throws JMSException. In contrast to the standard      JMS MessageListener interface, when using      the SessionAwareMessageListener      interface, it is the responsibility of the client code to handle any      exceptions thrown.        23.4.4&nbsp;The MessageListenerAdapter            \n\r\n\rThe MessageListenerAdapter class is the      final component in Spring\'s asynchronous messaging support: in a      nutshell, it allows you to expose almost any class      as a MDP (there are of course some constraints).      \n\r\n\rConsider the following interface definition. Notice that although      the interface extends neither the      MessageListener nor      SessionAwareMessageListener interfaces,      it can still be used as a MDP via the use of the      MessageListenerAdapter class. Notice also how the      various message handling methods are strongly typed according to the      contents of the various      Message types that they can receive and      handle.      public interface MessageDelegate {    void handleMessage(String message);    void handleMessage(Map message);    void handleMessage(byte[] message);    void handleMessage(Serializable message);}      public class DefaultMessageDelegate implements MessageDelegate {    // implementation elided for clarity...}      \n\r\n\rIn particular, note how the above implementation of the      MessageDelegate interface (the above      DefaultMessageDelegate class) has      no JMS dependencies at all. It truly is a POJO that      we will make into an MDP via the following configuration.      &lt;!-- this is the Message Driven POJO (MDP) --&gt;&lt;bean id=\"messageListener\" class=\"org.springframework.jms.listener.adapter.MessageListenerAdapter\"&gt;    &lt;constructor-arg&gt;        &lt;bean class=\"jmsexample.DefaultMessageDelegate\"/&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- and this is the message listener container... --&gt;&lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt;    &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;    &lt;property name=\"destination\" ref=\"destination\"/&gt;    &lt;property name=\"messageListener\" ref=\"messageListener\" /&gt;&lt;/bean&gt;      \n\r\n\rBelow is an example of another MDP that can only handle the      receiving of JMS TextMessage messages.      Notice how the message handling method is actually called      \'receive\' (the name of the message handling method in      a MessageListenerAdapter defaults to      \'handleMessage\'), but it is configurable (as you will      see below). Notice also how the \'receive(..)\' method      is strongly typed to receive and respond only to JMS      TextMessage messages.      public interface TextMessageDelegate {    void receive(TextMessage message);}      public class DefaultTextMessageDelegate implements TextMessageDelegate {    // implementation elided for clarity...}      \n\r\n\rThe configuration of the attendant      MessageListenerAdapter would look like      this:      &lt;bean id=\"messageListener\" class=\"org.springframework.jms.listener.adapter.MessageListenerAdapter\"&gt;    &lt;constructor-arg&gt;        &lt;bean class=\"jmsexample.DefaultTextMessageDelegate\"/&gt;    &lt;/constructor-arg&gt;    &lt;property name=\"defaultListenerMethod\" value=\"receive\"/&gt;    &lt;!-- we don\'t want automatic message context extraction --&gt;    &lt;property name=\"messageConverter\"&gt;        &lt;null/&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rPlease note that if the above \'messageListener\'      receives a JMS Message of a type other      than TextMessage, an      IllegalStateException will be thrown (and      subsequently swallowed). Another of the capabilities of the      MessageListenerAdapter class is the ability to      automatically send back a response      Message if a handler method returns a      non-void value. Consider the interface and class:      public interface ResponsiveTextMessageDelegate {    // notice the return type...    String receive(TextMessage message);}      public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {    // implementation elided for clarity...}      \n\r\n\rIf the above      DefaultResponsiveTextMessageDelegate is used in      conjunction with a MessageListenerAdapter then      any non-null value that is returned from the execution of the      \'receive(..)\' method will (in the default      configuration) be converted into a      TextMessage. The resulting      TextMessage will then be sent to the      Destination (if one exists) defined in      the JMS Reply-To property of the original      Message, or the default      Destination set on the      MessageListenerAdapter (if one has been      configured); if no Destination is found      then an InvalidDestinationException will be      thrown (and please note that this exception will      not be swallowed and will propagate up      the call stack).        23.4.5&nbsp;Processing messages within transactions            \n\r\n\rInvoking a message listener within a transaction only requires      reconfiguration of the listener container.      \n\r\n\rLocal resource transactions can simply be activated through the      sessionTransacted flag on the listener container      definition. Each message listener invocation will then operate within an      active JMS transaction, with message reception rolled back in case of      listener execution failure. Sending a response message (via      SessionAwareMessageListener) will be part      of the same local transaction, but any other resource operations (such      as database access) will operate independently. This usually requires      duplicate message detection in the listener implementation, covering the      case where database processing has committed but message processing      failed to commit.      &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt;    &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;    &lt;property name=\"destination\" ref=\"destination\"/&gt;    &lt;property name=\"messageListener\" ref=\"messageListener\"/&gt;    &lt;property name=\"sessionTransacted\" value=\"true\"/&gt;&lt;/bean&gt;      \n\r\n\rFor participating in an externally managed transaction, you will      need to configure a transaction manager and use a listener container      which supports externally managed transactions: typically      DefaultMessageListenerContainer.      \n\r\n\rTo configure a message listener container for XA transaction      participation, you\'ll want to configure a      JtaTransactionManager (which, by default,      delegates to the Java EE server\'s transaction subsystem). Note that the      underlying JMS ConnectionFactory needs to be XA-capable and properly      registered with your JTA transaction coordinator! (Check your Java EE      server\'s configuration of JNDI resources.) This allows message reception      as well as e.g. database access to be part of the same transaction (with      unified commit semantics, at the expense of XA transaction log      overhead).      &lt;bean id=\"transactionManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;      \n\r\n\rThen you just need to add it to our earlier container      configuration. The container will take care of the rest.      &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt;    &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;    &lt;property name=\"destination\" ref=\"destination\"/&gt;    &lt;property name=\"messageListener\" ref=\"messageListener\"/&gt;    &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;&lt;/bean&gt;        23.5&nbsp;Support for JCA Message Endpoints        \n\r\n\rBeginning with version 2.5, Spring also provides support for a    JCA-based MessageListener container. The    JmsMessageEndpointManager will attempt to    automatically determine the ActivationSpec    class name from the provider\'s    ResourceAdapter class name. Therefore, it    is typically possible to just provide Spring\'s generic    JmsActivationSpecConfig as shown in the following    example.    &lt;bean class=\"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager\"&gt;    &lt;property name=\"resourceAdapter\" ref=\"resourceAdapter\"/&gt;    &lt;property name=\"activationSpecConfig\"&gt;        &lt;bean class=\"org.springframework.jms.listener.endpoint.JmsActivationSpecConfig\"&gt;            &lt;property name=\"destinationName\" value=\"myQueue\"/&gt;        &lt;/bean&gt;    &lt;/property&gt;    &lt;property name=\"messageListener\" ref=\"myMessageListener\"/&gt;&lt;/bean&gt;    \n\r\n\rAlternatively, you may set up a    JmsMessageEndpointManager with a given    ActivationSpec object. The    ActivationSpec object may also come from a    JNDI lookup (using &lt;jee:jndi-lookup&gt;).    &lt;bean class=\"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager\"&gt;    &lt;property name=\"resourceAdapter\" ref=\"resourceAdapter\"/&gt;    &lt;property name=\"activationSpec\"&gt;        &lt;bean class=\"org.apache.activemq.ra.ActiveMQActivationSpec\"&gt;            &lt;property name=\"destination\" value=\"myQueue\"/&gt;            &lt;property name=\"destinationType\" value=\"javax.jms.Queue\"/&gt;        &lt;/bean&gt;    &lt;/property&gt;    &lt;property name=\"messageListener\" ref=\"myMessageListener\"/&gt;&lt;/bean&gt;    \n\r\n\rUsing Spring\'s ResourceAdapterFactoryBean,    the target ResourceAdapter may be    configured locally as depicted in the following example.    &lt;bean id=\"resourceAdapter\" class=\"org.springframework.jca.support.ResourceAdapterFactoryBean\"&gt;    &lt;property name=\"resourceAdapter\"&gt;        &lt;bean class=\"org.apache.activemq.ra.ActiveMQResourceAdapter\"&gt;            &lt;property name=\"serverUrl\" value=\"tcp://localhost:61616\"/&gt;        &lt;/bean&gt;    &lt;/property&gt;    &lt;property name=\"workManager\"&gt;        &lt;bean class=\"org.springframework.jca.work.SimpleTaskWorkManager\"/&gt;    &lt;/property&gt;&lt;/bean&gt;    \n\r\n\rThe specified WorkManager may also    point to an environment-specific thread pool - typically through    SimpleTaskWorkManager\'s \"asyncTaskExecutor\"    property. Consider defining a shared thread pool for all your    ResourceAdapter instances if you happen to    use multiple adapters.    \n\r\n\rIn some environments (e.g. WebLogic 9 or above), the entire    ResourceAdapter object may be obtained from    JNDI instead (using &lt;jee:jndi-lookup&gt;). The    Spring-based message listeners can then interact with the server-hosted    ResourceAdapter, also using the server\'s    built-in WorkManager.    \n\r\n\rPlease consult the JavaDoc for    JmsMessageEndpointManager,    JmsActivationSpecConfig, and    ResourceAdapterFactoryBean for more details.    \n\r\n\rSpring also provides a generic JCA message endpoint manager which is    not tied to JMS:    org.springframework.jca.endpoint.GenericMessageEndpointManager.    This component allows for using any message listener type (e.g. a CCI    MessageListener) and any provider-specific ActivationSpec object. Check    out your JCA provider\'s documentation to find out about the actual    capabilities of your connector, and consult    GenericMessageEndpointManager\'s JavaDoc for the    Spring-specific configuration details.    Note      \n\r\n\rJCA-based message endpoint management is very analogous to EJB 2.1      Message-Driven Beans; it uses the same underlying resource provider      contract. Like with EJB 2.1 MDBs, any message listener interface      supported by your JCA provider can be used in the Spring context as      well. Spring nevertheless provides explicit \'convenience\' support for      JMS, simply because JMS is the most common endpoint API used with the      JCA endpoint management contract.        23.6&nbsp;JMS Namespace Support        \n\r\n\rSpring 2.5 introduces an XML namespace for simplifying JMS    configuration. To use the JMS namespace elements you will need to    reference the JMS schema:    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jms=\"http://www.springframework.org/schema/jms\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt;&lt;!-- &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt;    \n\r\n\rThe namespace consists of two top-level elements:    &lt;listener-container/&gt; and    &lt;jca-listener-container/&gt; both of which may    contain one or more &lt;listener/&gt; child elements.    Here is an example of a basic configuration for two listeners.    &lt;jms:listener-container&gt;    &lt;jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/&gt;    &lt;jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/&gt;&lt;/jms:listener-container&gt;    \n\r\n\rThe example above is equivalent to creating two distinct listener    container bean definitions and two distinct    MessageListenerAdapter bean definitions as    demonstrated in Section&nbsp;23.4.4, &#8220;The MessageListenerAdapter&#8221;.    In addition to the attributes shown above, the listener element    may contain several optional ones. The following table describes all available    attributes:    \n\r\n\rTable&nbsp;23.1.&nbsp;Attributes of the JMS &lt;listener&gt;      element            AttributeDescriptionid\n\r\n\rA bean name for the hosting listener container. If            not specified, a bean name will be automatically            generated.destination (required)\n\r\n\rThe destination name for this listener, resolved            through the DestinationResolver            strategy.ref (required)\n\r\n\rThe bean name of the handler object.method\n\r\n\rThe name of the handler method to invoke. If the            ref points to a            MessageListener or Spring            SessionAwareMessageListener, this            attribute may be omitted.response-destination\n\r\n\rThe name of the default response destination to send            response messages to. This will be applied in case of a request            message that does not carry a \"JMSReplyTo\" field. The type of this            destination will be determined by the listener-container\'s            \"destination-type\" attribute. Note: This only applies to a            listener method with a return value, for which each result object            will be converted into a response message.subscription\n\r\n\rThe name of the durable subscription, if            any.selector\n\r\n\rAn optional message selector for this            listener.    \n\r    \n\r\n\rThe &lt;listener-container/&gt; element also    accepts several optional attributes. This allows for customization of the    various strategies (for example, taskExecutor and    destinationResolver) as well as basic JMS settings    and resource references. Using these attributes, it is possible to define    highly-customized listener containers while still benefiting from the    convenience of the namespace.    &lt;jms:listener-container connection-factory=\"myConnectionFactory\"                        task-executor=\"myTaskExecutor\"                        destination-resolver=\"myDestinationResolver\"                        transaction-manager=\"myTransactionManager\"                        concurrency=\"10\"&gt;    &lt;jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/&gt;    &lt;jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/&gt;&lt;/jms:listener-container&gt;    \n\r\n\rThe following table describes all available attributes. Consult the    class-level Javadoc of the    AbstractMessageListenerContainer and its concrete    subclasses for more details on the individual properties. The Javadoc also    provides a discussion of transaction choices and message redelivery    scenarios.    \n\r\n\rTable&nbsp;23.2.&nbsp;Attributes of the JMS      &lt;listener-container&gt; element            AttributeDescriptioncontainer-type\n\r\n\rThe type of this listener container. Available            options are: default,            simple, default102, or            simple102 (the default value is            \'default\').connection-factory\n\r\n\rA reference to the JMS            ConnectionFactory bean (the default            bean name is            \'connectionFactory\').task-executor\n\r\n\rA reference to the Spring            TaskExecutor for the JMS listener            invokers.destination-resolver\n\r\n\rA reference to the            DestinationResolver strategy for            resolving JMS            Destinations.message-converter\n\r\n\rA reference to the            MessageConverter strategy for            converting JMS Messages to listener method arguments. Default is a            SimpleMessageConverter.destination-type\n\r\n\rThe JMS destination type for this listener:            queue, topic or            durableTopic. The default is            queue.client-id\n\r\n\rThe JMS client id for this listener container. Needs            to be specified when using durable subscriptions.cache\n\r\n\rThe cache level for JMS resources:            none, connection,            session, consumer or            auto. By default (auto), the            cache level will effectively be \"consumer\", unless an external            transaction manager has been specified - in which case the            effective default will be none (assuming            Java EE-style transaction management where the given            ConnectionFactory is an XA-aware pool).acknowledge\n\r\n\rThe native JMS acknowledge mode:            auto, client,            dups-ok or transacted. A            value of transacted activates a locally            transacted Session. As an            alternative, specify the transaction-manager            attribute described below. Default is            auto.transaction-manager\n\r\n\rA reference to an external            PlatformTransactionManager            (typically an XA-based transaction coordinator, e.g. Spring\'s            JtaTransactionManager). If not specified,            native acknowledging will be used (see \"acknowledge\"            attribute).concurrency\n\r\n\rThe number of concurrent sessions/consumers to start            for each listener. Can either be a simple number indicating the            maximum number (e.g. \"5\") or a range indicating the lower as well            as the upper limit (e.g. \"3-5\"). Note that a specified minimum is            just a hint and might be ignored at runtime. Default is 1; keep            concurrency limited to 1 in case of a topic listener or if queue            ordering is important; consider raising it for general            queues.prefetch\n\r\n\rThe maximum number of messages to load into a single            session. Note that raising this number might lead to starvation of            concurrent consumers!    \n\r    \n\r\n\rConfiguring a JCA-based listener container with the \"jms\" schema    support is very similar.    &lt;jms:jca-listener-container resource-adapter=\"myResourceAdapter\"                            destination-resolver=\"myDestinationResolver\"                            transaction-manager=\"myTransactionManager\"                            concurrency=\"10\"&gt;    &lt;jms:listener destination=\"queue.orders\" ref=\"myMessageListener\"/&gt;&lt;/jms:jca-listener-container&gt;    \n\r\n\rThe available configuration options for the JCA variant are    described in the following table:    \n\r\n\rTable&nbsp;23.3.&nbsp;Attributes of the JMS      &lt;jca-listener-container/&gt; element            AttributeDescriptionresource-adapter\n\r\n\rA reference to the JCA            ResourceAdapter bean (the default            bean name is \'resourceAdapter\').activation-spec-factory\n\r\n\rA reference to the            JmsActivationSpecFactory. The            default is to autodetect the JMS provider and its            ActivationSpec class (see            DefaultJmsActivationSpecFactory)destination-resolver\n\r\n\rA reference to the            DestinationResolver strategy for            resolving JMS Destinations.            message-converter\n\r\n\rA reference to the            MessageConverter strategy for            converting JMS Messages to listener method arguments. Default is a            SimpleMessageConverter.destination-type\n\r\n\rThe JMS destination type for this listener:            queue, topic or            durableTopic. The default is            queue.client-id\n\r\n\rThe JMS client id for this listener container. Needs            to be specified when using durable subscriptions.acknowledge\n\r\n\rThe native JMS acknowledge mode:            auto, client,            dups-ok or transacted. A            value of transacted activates a locally            transacted Session. As an            alternative, specify the transaction-manager            attribute described below. Default is            auto.transaction-manager\n\r\n\rA reference to a Spring            JtaTransactionManager or a            javax.transaction.TransactionManager            for kicking off an XA transaction for each incoming message. If            not specified, native acknowledging will be used (see the            \"acknowledge\" attribute).concurrency\n\r\n\rThe number of concurrent sessions/consumers to start            for each listener. Can either be a simple number indicating the            maximum number (e.g. \"5\") or a range indicating the lower as well            as the upper limit (e.g. \"3-5\"). Note that a specified minimum is            just a hint and will typically be ignored at runtime when using a            JCA listener container. Default is 1.prefetch\n\r\n\rThe maximum number of messages to load into a single            session. Note that raising this number might lead to starvation of            concurrent consumers!    \n\r  Prev&nbsp;Up&nbsp;Next22.&nbsp;Enterprise JavaBeans (EJB) integration&nbsp;Home&nbsp;24.&nbsp;JMX","23. JMS (Java Message Service)","scr\\jms.html","         24.&nbsp;JMXPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next24.&nbsp;JMX    24.1&nbsp;Introduction        \n\r\n\rThe JMX support in Spring provides you with the features to easily    and transparently integrate your Spring application into a JMX    infrastructure.    \n\r\n\rJMX?            \n\r\n\rThis chapter is not an introduction to JMX... it doesn\'t try to      explain the motivations of why one might want to use JMX (or indeed what      the letters JMX actually stand for). If you are new to JMX, check out      Section&nbsp;24.8, &#8220;Further Resources&#8221; at the end of this chapter.        \n\r\n\rSpecifically, Spring\'s JMX support provides four core    features:    \n\r        \n\r\n\rThe automatic registration of any Spring        bean as a JMX MBean      \n\r        \n\r\n\rA flexible mechanism for controlling the management interface of        your beans      \n\r        \n\r\n\rThe declarative exposure of MBeans over remote, JSR-160        connectors      \n\r        \n\r\n\rThe simple proxying of both local and remote MBean        resources      \n\r    \n\r\n\rThese features are designed to work without coupling your    application components to either Spring or JMX interfaces and classes.    Indeed, for the most part your application classes need not be aware of    either Spring or JMX in order to take advantage of the Spring JMX    features.    24.2&nbsp;Exporting your beans to JMX        \n\r\n\rThe core class in Spring\'s JMX framework is the    MBeanExporter. This class is responsible for taking    your Spring beans and registering them with a JMX    MBeanServer. For example, consider the following    class:    package org.springframework.jmx;public class JmxTestBean implements IJmxTestBean {    private String name;    private int age;    private boolean isSuperman;    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public void setName(String name) {        this.name = name;    }    public String getName() {        return name;    }    public int add(int x, int y) {        return x + y;    }    public void dontExposeMe() {        throw new RuntimeException();    }}    \n\r\n\rTo expose the properties and methods of this bean as attributes and    operations of an MBean you simply configure an instance of the    MBeanExporter class in your configuration file and    pass in the bean as shown below:    &lt;beans&gt;  &lt;!-- this bean must not be lazily initialized if the exporting is to happen --&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\" lazy-init=\"false\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;    \n\r\n\rThe pertinent bean definition from the above configuration snippet    is the exporter bean. The beans    property tells the MBeanExporter exactly which of    your beans must be exported to the JMX MBeanServer.    In the default configuration, the key of each entry in the    beans Map is used as the    ObjectName for the bean referenced by the    corresponding entry value. This behavior can be changed as described in    Section&nbsp;24.4, &#8220;Controlling the ObjectNames for your beans&#8221;.    \n\r\n\rWith this configuration the testBean bean is    exposed as an MBean under the ObjectName    bean:name=testBean1. By default, all    public properties of the bean are exposed as    attributes and all public methods (bar those    inherited from the Object class) are exposed as    operations.    24.2.1&nbsp;Creating an MBeanServer            \n\r\n\rThe above configuration assumes that the application is running in      an environment that has one (and only one)      MBeanServer already running. In this case, Spring      will attempt to locate the running MBeanServer      and register your beans with that server (if any). This behavior is      useful when your application is running inside a container such as      Tomcat or IBM WebSphere that has its own      MBeanServer.      \n\r\n\rHowever, this approach is of no use in a standalone environment,      or when running inside a container that does not provide an      MBeanServer. To address this you can create an      MBeanServer instance declaratively by adding an      instance of the      org.springframework.jmx.support.MBeanServerFactoryBean      class to your configuration. You can also ensure that a specific      MBeanServer is used by setting the value of the      MBeanExporter\'s server      property to the MBeanServer value returned by an      MBeanServerFactoryBean; for example:      &lt;beans&gt;  &lt;bean id=\"mbeanServer\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\"/&gt;  &lt;!--    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;    this means that it must not be marked as lazily initialized  --&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"server\" ref=\"mbeanServer\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rHere an instance of MBeanServer is created      by the MBeanServerFactoryBean and is supplied to      the MBeanExporter via the server property. When      you supply your own MBeanServer instance, the      MBeanExporter will not attempt to locate a      running MBeanServer and will use the supplied      MBeanServer instance. For this to work correctly,      you must (of course) have a JMX implementation on your classpath.        24.2.2&nbsp;Reusing an existing MBeanServer            \n\r\n\rIf no server is specified, the MBeanExporter      tries to automatically detect a running MBeanServer.      This works in most environment where only one      MBeanServer instance is used, however when multiple      instances exist, the exporter might pick the wrong server. In such      cases, one should use the MBeanServer      agentId to indicate which instance to be used:      &lt;beans&gt;   &lt;bean id=\"mbeanServer\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\"&gt;     &lt;!-- indicate to first look for a server --&gt;     &lt;property name=\"locateExistingServerIfPossible\" value=\"true\"/&gt;     &lt;!-- search for the MBeanServer instance with the given agentId --&gt;     &lt;property name=\"agentId\" value=\"&lt;MBeanServer instance agentId&gt;\"/&gt;   &lt;/bean&gt;   &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;     &lt;property name=\"server\" ref=\"mbeanServer\"/&gt;   ...   &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rFor platforms/cases where the existing MBeanServer      has a dynamic (or unknown) agentId which is retrieved through lookup      methods, one should use factory-method:      &lt;beans&gt;   &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;     &lt;property name=\"server\"&gt;       &lt;!-- Custom MBeanServerLocator --&gt;       &lt;bean class=\"platform.package.MBeanServerLocator\" factory-method=\"locateMBeanServer\"/&gt;     &lt;/property&gt;     &lt;!-- other beans here --&gt;   &lt;/bean&gt;&lt;/beans&gt;        24.2.3&nbsp;Lazy-initialized MBeans            \n\r\n\rIf you configure a bean with the      MBeanExporter that is also configured for lazy      initialization, then the MBeanExporter will      not break this contract and will avoid      instantiating the bean. Instead, it will register a proxy with      the MBeanServer and will defer obtaining the bean      from the container until the first invocation on the proxy occurs.        24.2.4&nbsp;Automatic registration of MBeans            \n\r\n\rAny beans that are exported through the      MBeanExporter and are already valid MBeans are      registered as-is with the MBeanServer without      further intervention from Spring. MBeans can be automatically detected      by the MBeanExporter by setting the      autodetect property to true:      &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;  &lt;property name=\"autodetect\" value=\"true\"/&gt;&lt;/bean&gt;&lt;bean name=\"spring:mbean=true\" class=\"org.springframework.jmx.export.TestDynamicMBean\"/&gt;      \n\r\n\rHere, the bean called spring:mbean=true is      already a valid JMX MBean and will be automatically registered by      Spring. By default, beans that are autodetected for JMX registration      have their bean name used as the ObjectName. This      behavior can be overridden as detailed in Section&nbsp;24.4, &#8220;Controlling the ObjectNames for your beans&#8221;.        24.2.5&nbsp;Controlling the registration behavior            \n\r\n\rConsider the scenario where a Spring      MBeanExporter attempts to register an      MBean with an MBeanServer      using the ObjectName      \'bean:name=testBean1\'. If an      MBean instance has already been registered under      that same ObjectName, the default behavior is to      fail (and throw an      InstanceAlreadyExistsException).      \n\r\n\rIt is possible to control the behavior of exactly what happens      when an MBean is registered with an      MBeanServer. Spring\'s JMX support allows for      three different registration behaviors to control the registration      behavior when the registration process finds that an      MBean has already been registered under the same      ObjectName; these registration behaviors are      summarized on the following table:      \n\r\n\rTable&nbsp;24.1.&nbsp;Registration Behaviors                    Registration behaviorExplanation\n\r\n\rREGISTRATION_FAIL_ON_EXISTING\n\r\n\r This is the default registration behavior. If an                MBean instance has already been                registered under the same ObjectName,                the MBean that is being registered will                not be registered and an                InstanceAlreadyExistsException will be                thrown. The existing MBean is                unaffected. \n\r\n\rREGISTRATION_IGNORE_EXISTING\n\r\n\r If an MBean instance has                already been registered under the same                ObjectName, the                MBean that is being registered will                not be registered. The existing                MBean is unaffected, and no                Exception will be thrown.                 \n\r\n\r This is useful in settings where multiple applications                want to share a common MBean in a                shared MBeanServer. \n\r\n\rREGISTRATION_REPLACE_EXISTING\n\r\n\r If an MBean instance has                already been registered under the same                ObjectName, the existing                MBean that was previously registered                will be unregistered and the new MBean                will be registered in its place (the new                MBean effectively replaces the previous                instance).         \n\r      \n\r\n\rThe above values are defined as constants on the      MBeanRegistrationSupport class (the      MBeanExporter class derives from this      superclass). If you want to change the default registration behavior,      you simply need to set the value of the      registrationBehaviorName property on your      MBeanExporter definition to one of those      values.      \n\r\n\rThe following example illustrates how to effect a change from the      default registration behavior to the      REGISTRATION_REPLACE_EXISTING behavior:      &lt;beans&gt;    &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;        &lt;property name=\"beans\"&gt;            &lt;map&gt;                &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"registrationBehaviorName\" value=\"REGISTRATION_REPLACE_EXISTING\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;        &lt;property name=\"name\" value=\"TEST\"/&gt;        &lt;property name=\"age\" value=\"100\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;        24.3&nbsp;Controlling the management interface of your beans        \n\r\n\rIn the previous example, you had little control over the management    interface of your bean; all of the    public properties and methods of each exported bean    was exposed as JMX attributes and operations respectively. To exercise    finer-grained control over exactly which properties and methods of your    exported beans are actually exposed as JMX attributes and operations,    Spring JMX provides a comprehensive and extensible mechanism for    controlling the management interfaces of your beans.    24.3.1&nbsp;The MBeanInfoAssembler      Interface            \n\r\n\rBehind the scenes, the MBeanExporter      delegates to an implementation of the      org.springframework.jmx.export.assembler.MBeanInfoAssembler      interface which is responsible for defining the management interface of      each bean that is being exposed. The default implementation,      org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler,      simply defines a management interface that exposes all public properties      and methods (as you saw in the previous examples). Spring provides two      additional implementations of the      MBeanInfoAssembler interface that allow      you to control the generated management interface using either      source-level metadata or any arbitrary interface.        24.3.2&nbsp;Using Source-Level Metadata (JDK 5.0 annotations)            \n\r\n\rUsing the MetadataMBeanInfoAssembler you      can define the management interfaces for your beans using source level      metadata. The reading of metadata is encapsulated by the      org.springframework.jmx.export.metadata.JmxAttributeSource      interface. Spring JMX provides a default implementation which uses JDK 5.0 annotations, namely      org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource. The      MetadataMBeanInfoAssembler      must be configured with an implementation instance      of the JmxAttributeSource interface for it to      function correctly (there is no default).      \n\r\n\rTo mark a bean for export to JMX, you should annotate the bean      class with the ManagedResource annotation. Each      method you wish to expose as an operation must be marked with the      ManagedOperation annotation and each property you      wish to expose must be marked with the      ManagedAttribute annotation. When marking      properties you can omit either the annotation of the getter or the      setter to create a write-only or read-only attribute      respectively.      \n\r\n\rThe example below shows the annotated version of the        JmxTestBean class that you saw earlier:      package org.springframework.jmx;import org.springframework.jmx.export.annotation.ManagedResource;import org.springframework.jmx.export.annotation.ManagedOperation;import org.springframework.jmx.export.annotation.ManagedAttribute;@ManagedResource(objectName=\"bean:name=testBean4\", description=\"My Managed Bean\", log=true,    logFile=\"jmx.log\", currencyTimeLimit=15, persistPolicy=\"OnUpdate\", persistPeriod=200,    persistLocation=\"foo\", persistName=\"bar\")public class AnnotationTestBean implements IJmxTestBean {  private String name;  private int age;  @ManagedAttribute(description=\"The Age Attribute\", currencyTimeLimit=15)  public int getAge() {    return age;  }  public void setAge(int age) {    this.age = age;  }  @ManagedAttribute(description=\"The Name Attribute\",      currencyTimeLimit=20,      defaultValue=\"bar\",      persistPolicy=\"OnUpdate\")  public void setName(String name) {    this.name = name;  }  @ManagedAttribute(defaultValue=\"foo\", persistPeriod=300)  public String getName() {    return name;  }  @ManagedOperation(description=\"Add two numbers\")  @ManagedOperationParameters({    @ManagedOperationParameter(name = \"x\", description = \"The first number\"),    @ManagedOperationParameter(name = \"y\", description = \"The second number\")})  public int add(int x, int y) {    return x + y;  }  public void dontExposeMe() {    throw new RuntimeException();  }}      \n\r\n\rHere you can see that the JmxTestBean class      is marked with the ManagedResource annotation and        that this ManagedResource annotation is configured      with a set of properties. These properties can be used to configure      various aspects of the MBean that is generated by the      MBeanExporter, and are explained in greater      detail later in section entitled Section&nbsp;24.3.3, &#8220;Source-Level Metadata Types&#8221;.      \n\r\n\rYou will also notice that both the age and      name properties are annotated with the      ManagedAttribute annotation, but in the case of      the age property, only the getter is marked. This      will cause both of these properties to be included in the management      interface as attributes, but the age attribute will      be read-only.      \n\r\n\rFinally, you will notice that the add(int, int)      method is marked with the ManagedOperation      attribute whereas the dontExposeMe() method is not.      This will cause the management interface to contain only one operation,      add(int, int), when using the      MetadataMBeanInfoAssembler.      \n\r\n\rThe configuration below shows how you configure the      MBeanExporter to use the      MetadataMBeanInfoAssembler:      &lt;beans&gt;    &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;        &lt;property name=\"assembler\" ref=\"assembler\"/&gt;        &lt;property name=\"namingStrategy\" ref=\"namingStrategy\"/&gt;        &lt;property name=\"autodetect\" value=\"true\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"jmxAttributeSource\"          class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/&gt;    &lt;!-- will create management interface using annotation metadata --&gt;    &lt;bean id=\"assembler\"          class=\"org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler\"&gt;        &lt;property name=\"attributeSource\" ref=\"jmxAttributeSource\"/&gt;    &lt;/bean&gt;    &lt;!-- will pick up the ObjectName from the annotation --&gt;    &lt;bean id=\"namingStrategy\"          class=\"org.springframework.jmx.export.naming.MetadataNamingStrategy\"&gt;        &lt;property name=\"attributeSource\" ref=\"jmxAttributeSource\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"testBean\" class=\"org.springframework.jmx.AnnotationTestBean\"&gt;        &lt;property name=\"name\" value=\"TEST\"/&gt;        &lt;property name=\"age\" value=\"100\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rHere you can see that an      MetadataMBeanInfoAssembler bean has been      configured with an instance of the        AnnotationJmxAttributeSource class and passed to      the MBeanExporter through the assembler property.      This is all that is required to take advantage of metadata-driven      management interfaces for your Spring-exposed MBeans.        24.3.3&nbsp;Source-Level Metadata Types            \n\r\n\rThe following source level metadata types are available for use in      Spring JMX:      \n\r\n\rTable&nbsp;24.2.&nbsp;Source-Level Metadata Types                    PurposeAnnotationAnnotation TypeMark all instances of a Class as                JMX managed resources@ManagedResourceClassMark a method as a JMX operation@ManagedOperationMethodMark a getter or setter as one half of a JMX                attribute@ManagedAttributeMethod (only getters and setters)Define descriptions for operation parameters@ManagedOperationParameter and                @ManagedOperationParametersMethod        \n\r\n\r\n\r      \n\r\n\rThe following configuration parameters are available for use on      these source-level metadata types:      \n\r\n\rTable&nbsp;24.3.&nbsp;Source-Level Metadata Parameters                    ParameterDescriptionApplies toObjectNameUsed by MetadataNamingStrategy                to determine the ObjectName of a                managed resourceManagedResourcedescriptionSets the friendly description of the resource,                attribute or operationManagedResource,                ManagedAttribute,                ManagedOperation,                ManagedOperationParametercurrencyTimeLimitSets the value of the                currencyTimeLimit descriptor fieldManagedResource,                ManagedAttributedefaultValueSets the value of the defaultValue                descriptor fieldManagedAttributelogSets the value of the log descriptor                fieldManagedResourcelogFileSets the value of the logFile                descriptor fieldManagedResourcepersistPolicySets the value of the persistPolicy                descriptor fieldManagedResourcepersistPeriodSets the value of the persistPeriod                descriptor fieldManagedResourcepersistLocationSets the value of the                persistLocation descriptor fieldManagedResourcepersistNameSets the value of the persistName                descriptor fieldManagedResourcenameSets the display name of an operation parameterManagedOperationParameterindexSets the index of an operation parameterManagedOperationParameter        \n\r\n\r\n\r        24.3.4&nbsp;The AutodetectCapableMBeanInfoAssembler      interface            \n\r\n\rTo simplify configuration even further, Spring introduces the      AutodetectCapableMBeanInfoAssembler interface      which extends the MBeanInfoAssembler      interface to add support for autodetection of MBean resources. If you      configure the MBeanExporter with an instance of      AutodetectCapableMBeanInfoAssembler then it is      allowed to \"vote\" on the inclusion of beans for exposure to JMX.      \n\r\n\rOut of the box, the only implementation of the      AutodetectCapableMBeanInfo interface is the      MetadataMBeanInfoAssembler which will vote to      include any bean which is marked with the      ManagedResource attribute. The default approach      in this case is to use the bean name as the      ObjectName which results in a configuration like      this:      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;!-- notice how no \'beans\' are explicitly configured here --&gt;    &lt;property name=\"autodetect\" value=\"true\"/&gt;    &lt;property name=\"assembler\" ref=\"assembler\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"assembler\" class=\"org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler\"&gt;    &lt;property name=\"attributeSource\"&gt;        &lt;bean class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/&gt;    &lt;/property&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rNotice that in this configuration no beans are passed to the      MBeanExporter; however, the      JmxTestBean will still be registered since it is      marked with the ManagedResource attribute and the      MetadataMBeanInfoAssembler detects this and votes      to include it. The only problem with this approach is that the name of      the JmxTestBean now has business meaning. You can      address this issue by changing the default behavior for      ObjectName creation as defined in      Section&nbsp;24.4, &#8220;Controlling the ObjectNames for your beans&#8221;.        24.3.5&nbsp;Defining management interfaces using Java interfaces            \n\r\n\rIn addition to the      MetadataMBeanInfoAssembler, Spring also includes      the InterfaceBasedMBeanInfoAssembler which allows      you to constrain the methods and properties that are exposed based on      the set of methods defined in a collection of interfaces.      \n\r\n\rAlthough the standard mechanism for exposing MBeans is to use      interfaces and a simple naming scheme, the      InterfaceBasedMBeanInfoAssembler extends this      functionality by removing the need for naming conventions, allowing you      to use more than one interface and removing the need for your beans to      implement the MBean interfaces.      \n\r\n\rConsider this interface that is used to define a management      interface for the JmxTestBean class that you saw      earlier:      public interface IJmxTestBean {  public int add(int x, int y);  public long myOperation();  public int getAge();  public void setAge(int age);  public void setName(String name);  public String getName();}      \n\r\n\rThis interface defines the methods and properties that will be      exposed as operations and attributes on the JMX MBean. The code below      shows how to configure Spring JMX to use this interface as the      definition for the management interface:      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"assembler\"&gt;      &lt;bean class=\"org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler\"&gt;        &lt;property name=\"managedInterfaces\"&gt;          &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;        &lt;/property&gt;      &lt;/bean&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rHere you can see that the      InterfaceBasedMBeanInfoAssembler is configured to      use the IJmxTestBean interface when      constructing the management interface for any bean. It is important to      understand that beans processed by the      InterfaceBasedMBeanInfoAssembler are      not required to implement the interface used to      generate the JMX management interface.      \n\r\n\rIn the case above, the IJmxTestBean      interface is used to construct all management interfaces for all beans.      In many cases this is not the desired behavior and you may want to use      different interfaces for different beans. In this case, you can pass      InterfaceBasedMBeanInfoAssembler a      Properties instance via the      interfaceMappings property, where the key of each      entry is the bean name and the value of each entry is a comma-separated      list of interface names to use for that bean.      \n\r\n\rIf no management interface is specified through either the      managedInterfaces or      interfaceMappings properties, then the      InterfaceBasedMBeanInfoAssembler will reflect on      the bean and use all of the interfaces implemented by that bean to      create the management interface.        24.3.6&nbsp;Using      MethodNameBasedMBeanInfoAssembler            \n\r\n\rThe MethodNameBasedMBeanInfoAssembler      allows you to specify a list of method names that will be exposed to JMX      as attributes and operations. The code below shows a sample      configuration for this:      &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"assembler\"&gt;      &lt;bean class=\"org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler\"&gt;        &lt;property name=\"managedMethods\"&gt;          &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;        &lt;/property&gt;      &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rHere you can see that the methods add and      myOperation will be exposed as JMX operations and      getName(), setName(String) and      getAge() will be exposed as the appropriate half of a      JMX attribute. In the code above, the method mappings apply to beans      that are exposed to JMX. To control method exposure on a bean-by-bean      basis, use the methodMappings property of      MethodNameMBeanInfoAssembler to map bean names to      lists of method names.        24.4&nbsp;Controlling the ObjectNames for your beans        \n\r\n\rBehind the scenes, the MBeanExporter    delegates to an implementation of the    ObjectNamingStrategy to obtain    ObjectNames for each of the beans it is    registering. The default implementation,    KeyNamingStrategy, will, by default, use the key of    the beans Map as the    ObjectName. In addition, the    KeyNamingStrategy can map the key of the    beans Map to an entry in a    Properties file (or files) to resolve the    ObjectName. In addition to the    KeyNamingStrategy, Spring provides two additional    ObjectNamingStrategy implementations: the    IdentityNamingStrategy that builds an    ObjectName based on the JVM identity of the bean    and the MetadataNamingStrategy that uses source    level metadata to obtain the ObjectName.    24.4.1&nbsp;Reading ObjectNames from Properties            \n\r\n\rYou can configure your own      KeyNamingStrategy instance and configure it to      read ObjectNames from a      Properties instance rather than use bean key. The      KeyNamingStrategy will attempt to locate an entry      in the Properties with a key corresponding to the      bean key. If no entry is found or if the      Properties instance is null      then the bean key itself is used.      \n\r\n\rThe code below shows a sample configuration for the      KeyNamingStrategy:      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"testBean\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"namingStrategy\" ref=\"namingStrategy\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming.KeyNamingStrategy\"&gt;    &lt;property name=\"mappings\"&gt;      &lt;props&gt;        &lt;prop key=\"testBean\"&gt;bean:name=testBean1&lt;/prop&gt;      &lt;/props&gt;    &lt;/property&gt;    &lt;property name=\"mappingLocations\"&gt;      &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;    &lt;/property&gt;  &lt;/bean&lt;/beans&gt;      \n\r\n\rHere an instance of KeyNamingStrategy is      configured with a Properties instance that is      merged from the Properties instance defined by      the mapping property and the properties files located in the paths      defined by the mappings property. In this configuration, the      testBean bean will be given the      ObjectName bean:name=testBean1      since this is the entry in the Properties      instance that has a key corresponding to the bean key.      \n\r\n\rIf no entry in the Properties instance can      be found then the bean key name is used as the      ObjectName.        24.4.2&nbsp;Using the MetadataNamingStrategy            \n\r\n\rThe MetadataNamingStrategy uses      the objectName property of the      ManagedResource attribute on each bean to create      the ObjectName. The code below shows the      configuration for the      MetadataNamingStrategy:      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"testBean\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"namingStrategy\" ref=\"namingStrategy\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming.MetadataNamingStrategy\"&gt;    &lt;property name=\"attributeSource\" ref=\"attributeSource\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"attributeSource\"      class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/&gt;&lt;/beans&gt;      \n\r\n\rIf no objectName has been provided for      the ManagedResource attribute, then an      ObjectName will be created with the      following format:      [fully-qualified-package-name]:type=[short-classname],name=[bean-name].      For example, the generated ObjectName for the      following bean would be: com.foo:type=MyClass,name=myBean.            &lt;bean id=\"myBean\" class=\"com.foo.MyClass\"/&gt;        24.4.3&nbsp;Configuring annotation based MBean export            \n\r\n\rIf you prefer using the annotation based      approach to define your management interfaces, then a convenience subclass of      MBeanExporter is available:      AnnotationMBeanExporter.      When defining an instance of this subclass, the namingStrategy,      assembler, and attributeSource      configuration is no longer needed, since it will always use standard Java      annotation-based metadata (autodetection is always enabled as well). In fact,      rather than defining an MBeanExporter bean, an even      simpler syntax is supported by the @EnableMBeanExport      @Configuration annotation.      @Configuration@EnableMBeanExportpublic class AppConfig {}      \n\r\n\rIf you prefer XML based configuration the \'context:mbean-export\'      element serves the same purpose.      &lt;context:mbean-export/&gt;      \n\r\n\rYou can provide a reference to a particular MBean server if      necessary, and the defaultDomain attribute      (a property of AnnotationMBeanExporter)      accepts an alternate value for the generated MBean      ObjectNames\' domains. This would be used      in place of the fully qualified package name as described in the      previous section on      MetadataNamingStrategy.            @EnableMBeanExport(server=\"myMBeanServer\", defaultDomain=\"myDomain\")@ConfigurationContextConfiguration {}      &lt;context:mbean-export server=\"myMBeanServer\" default-domain=\"myDomain\"/&gt;      Note        \n\r\n\rDo not use interface-based AOP proxies in combination with autodetection of        JMX annotations in your bean classes. Interface-based proxies \'hide\' the target class,        which also hides the JMX managed resource annotations. Hence, use target-class proxies        in that case: through setting the \'proxy-target-class\' flag on &lt;aop:config/&gt;,        &lt;tx:annotation-driven/&gt;, etc. Otherwise, your JMX beans        might be silently ignored at startup...              24.5&nbsp;JSR-160 Connectors        \n\r\n\rFor remote access, Spring JMX module offers two    FactoryBean implementations inside the    org.springframework.jmx.support package for creating    both server- and client-side connectors.    24.5.1&nbsp;Server-side Connectors            \n\r\n\rTo have Spring JMX create, start and expose a JSR-160      JMXConnectorServer use the following      configuration:      &lt;bean id=\"serverConnector\" class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\"/&gt;      \n\r\n\rBy default ConnectorServerFactoryBean creates a      JMXConnectorServer bound to      \"service:jmx:jmxmp://localhost:9875\". The      serverConnector bean thus exposes the local      MBeanServer to clients through the JMXMP protocol      on localhost, port 9875. Note that the JMXMP protocol is marked as      optional by the JSR 160 specification: currently, the main open-source      JMX implementation, MX4J, and the one provided with J2SE 5.0 do      not support JMXMP.      \n\r\n\rTo specify another URL and register the      JMXConnectorServer itself with the      MBeanServer use the serviceUrl      and ObjectName properties respectively:      &lt;bean id=\"serverConnector\"      class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\"&gt;  &lt;property name=\"objectName\" value=\"connector:name=rmi\"/&gt;  &lt;property name=\"serviceUrl\"            value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector\"/&gt;&lt;/bean&gt;      \n\r\n\rIf the ObjectName property is set Spring      will automatically register your connector with the      MBeanServer under that      ObjectName. The example below shows the full set      of parameters which you can pass to the      ConnectorServerFactoryBean when creating a      JMXConnector:      &lt;bean id=\"serverConnector\"      class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\"&gt;  &lt;property name=\"objectName\" value=\"connector:name=iiop\"/&gt;  &lt;property name=\"serviceUrl\"               value=\"service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector\"/&gt;  &lt;property name=\"threaded\" value=\"true\"/&gt;  &lt;property name=\"daemon\" value=\"true\"/&gt;  &lt;property name=\"environment\"&gt;    &lt;map&gt;      &lt;entry key=\"someKey\" value=\"someValue\"/&gt;    &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rNote that when using a RMI-based connector you need the lookup      service (tnameserv or rmiregistry) to be started in order for the name      registration to complete. If you are using Spring to export remote      services for you via RMI, then Spring will already have constructed an      RMI registry. If not, you can easily start a registry using the      following snippet of configuration:      &lt;bean id=\"registry\" class=\"org.springframework.remoting.rmi.RmiRegistryFactoryBean\"&gt;  &lt;property name=\"port\" value=\"1099\"/&gt;&lt;/bean&gt;        24.5.2&nbsp;Client-side Connectors            \n\r\n\rTo create an MBeanServerConnection to a      remote JSR-160 enabled MBeanServer use the      MBeanServerConnectionFactoryBean as shown      below:      &lt;bean id=\"clientConnector\" class=\"org.springframework.jmx.support.MBeanServerConnectionFactoryBean\"&gt;  &lt;property name=\"serviceUrl\" value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi\"/&gt;&lt;/bean&gt;        24.5.3&nbsp;JMX over Burlap/Hessian/SOAP            \n\r\n\rJSR-160 permits extensions to the way in which communication is      done between the client and the server. The examples above are using the      mandatory RMI-based implementation required by the JSR-160 specification      (IIOP and JRMP) and the (optional) JMXMP. By using other providers or      JMX implementations (such as MX4J) you can take advantage      of protocols like SOAP, Hessian, Burlap over simple HTTP or SSL and      others:      &lt;bean id=\"serverConnector\" class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\"&gt;  &lt;property name=\"objectName\" value=\"connector:name=burlap\"/&gt;  &lt;property name=\"serviceUrl\" value=\"service:jmx:burlap://localhost:9874\"/&gt;&lt;/bean&gt;      \n\r\n\rIn the case of the above example, MX4J 3.0.0 was used; see the      official MX4J documentation for more information.        24.6&nbsp;Accessing MBeans via Proxies        \n\r\n\rSpring JMX allows you to create proxies that re-route calls to    MBeans registered in a local or remote MBeanServer.    These proxies provide you with a standard Java interface through which you    can interact with your MBeans. The code below shows how to configure a    proxy for an MBean running in a local    MBeanServer:    &lt;bean id=\"proxy\" class=\"org.springframework.jmx.access.MBeanProxyFactoryBean\"&gt;    &lt;property name=\"objectName\" value=\"bean:name=testBean\"/&gt;    &lt;property name=\"proxyInterface\" value=\"org.springframework.jmx.IJmxTestBean\"/&gt;&lt;/bean&gt;    \n\r\n\rHere you can see that a proxy is created for the MBean registered    under the ObjectName:    bean:name=testBean. The set of interfaces that the    proxy will implement is controlled by the    proxyInterfaces property and the rules for mapping    methods and properties on these interfaces to operations and attributes on    the MBean are the same rules used by the    InterfaceBasedMBeanInfoAssembler.    \n\r\n\rThe MBeanProxyFactoryBean can create a proxy    to any MBean that is accessible via an    MBeanServerConnection. By default, the local    MBeanServer is located and used, but you can    override this and provide an MBeanServerConnection    pointing to a remote MBeanServer to cater for    proxies pointing to remote MBeans:    &lt;bean id=\"clientConnector\"      class=\"org.springframework.jmx.support.MBeanServerConnectionFactoryBean\"&gt;  &lt;property name=\"serviceUrl\" value=\"service:jmx:rmi://remotehost:9875\"/&gt;&lt;/bean&gt;&lt;bean id=\"proxy\" class=\"org.springframework.jmx.access.MBeanProxyFactoryBean\"&gt;  &lt;property name=\"objectName\" value=\"bean:name=testBean\"/&gt;  &lt;property name=\"proxyInterface\" value=\"org.springframework.jmx.IJmxTestBean\"/&gt;  &lt;property name=\"server\" ref=\"clientConnector\"/&gt;&lt;/bean&gt;    \n\r\n\rHere you can see that we create an    MBeanServerConnection pointing to a remote machine    using the MBeanServerConnectionFactoryBean. This    MBeanServerConnection is then passed to the    MBeanProxyFactoryBean via the    server property. The proxy that is created will forward    all invocations to the MBeanServer via this    MBeanServerConnection.    24.7&nbsp;Notifications        \n\r\n\rSpring\'s JMX offering includes comprehensive support for JMX    notifications.    24.7.1&nbsp;Registering Listeners for Notifications            \n\r\n\rSpring\'s JMX support makes it very easy to register any number of      NotificationListeners with any number of MBeans      (this includes MBeans exported by Spring\'s      MBeanExporter and MBeans registered via some      other mechanism). By way of an example, consider the scenario where one      would like to be informed (via a Notification)      each and every time an attribute of a target MBean changes.      package com.example;import javax.management.AttributeChangeNotification;import javax.management.Notification;import javax.management.NotificationFilter;import javax.management.NotificationListener;public class ConsoleLoggingNotificationListener               implements NotificationListener, NotificationFilter {    public void handleNotification(Notification notification, Object handback) {        System.out.println(notification);        System.out.println(handback);    }    public boolean isNotificationEnabled(Notification notification) {        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());    }}      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"notificationListenerMappings\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\"&gt;          &lt;bean class=\"com.example.ConsoleLoggingNotificationListener\"/&gt;        &lt;/entry&gt;      &lt;/map&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\rWith the above configuration in place, every time a JMX        Notification is broadcast from the target MBean        (bean:name=testBean1), the        ConsoleLoggingNotificationListener bean that was        registered as a listener via the        notificationListenerMappings property will be        notified. The ConsoleLoggingNotificationListener        bean can then take whatever action it deems appropriate in response to        the Notification.        \n\r\n\rYou can also use straight bean names as the link between exported beans        and listeners:        &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"notificationListenerMappings\"&gt;      &lt;map&gt;        &lt;entry key=\"testBean\"&gt;          &lt;bean class=\"com.example.ConsoleLoggingNotificationListener\"/&gt;        &lt;/entry&gt;      &lt;/map&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\rIf one wants to register a single NotificationListener        instance for all of the beans that the enclosing MBeanExporter        is exporting, one can use the special wildcard \'*\' (sans quotes)        as the key for an entry in the notificationListenerMappings        property map; for example:        &lt;property name=\"notificationListenerMappings\"&gt;  &lt;map&gt;    &lt;entry key=\"*\"&gt;      &lt;bean class=\"com.example.ConsoleLoggingNotificationListener\"/&gt;    &lt;/entry&gt;  &lt;/map&gt;&lt;/property&gt;      \n\r\n\rIf one needs to do the inverse (that is, register a number of distinct      listeners against an MBean), then one has to use the      notificationListeners list property instead (and in      preference to the notificationListenerMappings      property). This time, instead of configuring simply a      NotificationListener for a single MBean, one      configures NotificationListenerBean instances...      a NotificationListenerBean encapsulates a      NotificationListener and the      ObjectName (or      ObjectNames) that it is to be registered against      in an MBeanServer. The      NotificationListenerBean also encapsulates a      number of other properties such as a      NotificationFilter and an arbitrary handback      object that can be used in advanced JMX notification scenarios.      \n\r\n\rThe configuration when using      NotificationListenerBean instances is not wildly      different to what was presented previously:      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"notificationListeners\"&gt;        &lt;list&gt;            &lt;bean class=\"org.springframework.jmx.export.NotificationListenerBean\"&gt;                &lt;constructor-arg&gt;                    &lt;bean class=\"com.example.ConsoleLoggingNotificationListener\"/&gt;                &lt;/constructor-arg&gt;                &lt;property name=\"mappedObjectNames\"&gt;                    &lt;list&gt;                        &lt;value&gt;bean:name=testBean1&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe above example is equivalent to the first notification example.      Lets assume then that we want to be given a handback object every time a      Notification is raised, and that additionally we      want to filter out extraneous Notifications by      supplying a NotificationFilter. (For a full      discussion of just what a handback object is, and indeed what a      NotificationFilter is, please do consult that      section of the JMX specification (1.2) entitled \'The JMX      Notification Model\'.)      &lt;beans&gt;  &lt;bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\"&gt;    &lt;property name=\"beans\"&gt;      &lt;map&gt;        &lt;entry key=\"bean:name=testBean1\" value-ref=\"testBean1\"/&gt;        &lt;entry key=\"bean:name=testBean2\" value-ref=\"testBean2\"/&gt;      &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"notificationListeners\"&gt;        &lt;list&gt;            &lt;bean class=\"org.springframework.jmx.export.NotificationListenerBean\"&gt;                &lt;constructor-arg ref=\"customerNotificationListener\"/&gt;                &lt;property name=\"mappedObjectNames\"&gt;                    &lt;list&gt;                        &lt;!-- handles notifications from two distinct MBeans --&gt;                        &lt;value&gt;bean:name=testBean1&lt;/value&gt;                        &lt;value&gt;bean:name=testBean2&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;                &lt;property name=\"handback\"&gt;                    &lt;bean class=\"java.lang.String\"&gt;                        &lt;constructor-arg value=\"This could be anything...\"/&gt;                    &lt;/bean&gt;                &lt;/property&gt;                &lt;property name=\"notificationFilter\" ref=\"customerNotificationListener\"/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;!-- implements both the NotificationListener and NotificationFilter interfaces --&gt;  &lt;bean id=\"customerNotificationListener\" class=\"com.example.ConsoleLoggingNotificationListener\"/&gt;  &lt;bean id=\"testBean1\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"TEST\"/&gt;    &lt;property name=\"age\" value=\"100\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"testBean2\" class=\"org.springframework.jmx.JmxTestBean\"&gt;    &lt;property name=\"name\" value=\"ANOTHER TEST\"/&gt;    &lt;property name=\"age\" value=\"200\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        24.7.2&nbsp;Publishing Notifications            \n\r\n\rSpring provides support not just for registering to receive      Notifications, but also for publishing      Notifications.      Note        \n\r\n\rPlease note that this section is really only relevant to Spring        managed beans that have been exposed as MBeans via an        MBeanExporter; any existing, user-defined        MBeans should use the standard JMX APIs for notification publication.            \n\r\n\rThe key interface in Spring\'s JMX notification publication support      is the NotificationPublisher interface (defined      in the org.springframework.jmx.export.notification      package). Any bean that is going to be exported as an MBean via an      MBeanExporter instance can implement the related      NotificationPublisherAware interface to gain      access to a NotificationPublisher instance. The      NotificationPublisherAware interface simply      supplies an instance of a NotificationPublisher      to the implementing bean via a simple setter method, which the bean can      then use to publish Notifications.      \n\r\n\rAs stated in the Javadoc for the      NotificationPublisher class, managed beans that      are publishing events via the      NotificationPublisher mechanism are      not responsible for the state management of any      notification listeners and the like ... Spring\'s JMX support will take      care of handling all the JMX infrastructure issues. All one need do as      an application developer is implement the      NotificationPublisherAware interface and start      publishing events using the supplied      NotificationPublisher instance. Note that the      NotificationPublisher will be set      after the managed bean has been registered with an      MBeanServer.      \n\r\n\rUsing a NotificationPublisher instance is      quite straightforward... one simply creates a JMX      Notification instance (or an instance of an      appropriate Notification subclass), populates      the notification with the data pertinent to the event that is to be      published, and one then invokes the      sendNotification(Notification) on the      NotificationPublisher instance, passing in the      Notification.      \n\r\n\rFind below a simple example... in this scenario, exported      instances of the JmxTestBean are going to publish      a NotificationEvent every time the      add(int, int) operation is invoked.      package org.springframework.jmx;import org.springframework.jmx.export.notification.NotificationPublisherAware;import org.springframework.jmx.export.notification.NotificationPublisher;import javax.management.Notification;public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {    private String name;    private int age;    private boolean isSuperman;    private NotificationPublisher publisher;    // other getters and setters omitted for clarity    public int add(int x, int y) {        int answer = x + y;        this.publisher.sendNotification(new Notification(\"add\", this, 0));        return answer;    }    public void dontExposeMe() {        throw new RuntimeException();    }    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {        this.publisher = notificationPublisher;    }}      \n\r\n\rThe NotificationPublisher interface and the      machinery to get it all working is one of the nicer features of Spring\'s JMX support.      It does however come with the price tag of coupling your classes to both Spring and JMX; as      always, the advice here is to be pragmatic... if you need the functionality offered by the      NotificationPublisher and you can accept the coupling to both Spring      and JMX, then do so.        24.8&nbsp;Further Resources        \n\r\n\rThis section contains links to further resources about JMX.    \n\r        \n\r\n\rThe JMX homepage at Sun      \n\r        \n\r\n\rThe JMX specification (JSR-000003)      \n\r        \n\r\n\rThe JMX Remote API specification (JSR-000160)      \n\r        \n\r\n\rThe MX4J        homepage (an Open Source implementation of various JMX        specs)      \n\r        \n\r\n\rGetting Started with JMX - an introductory article from Sun.      \n\r  Prev&nbsp;Up&nbsp;Next23.&nbsp;JMS (Java Message Service)&nbsp;Home&nbsp;25.&nbsp;JCA CCI","24. JMX","scr\\jmx.html","         26.&nbsp;EmailPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next26.&nbsp;Email    26.1&nbsp;Introduction        \n\r\n\rLibrary dependencies                \n\r\n\rThe following additional jars to be on the classpath of your        application in order to be able to use the Spring Framework\'s email library.        \n\r                \n\r\n\rThe JavaMail mail.jar library            \n\r                \n\r\n\rThe JAF activation.jar library            \n\r        \n\r\n\rAll of these libraries are freely available on the web.        \n\r\n\rThe Spring Framework provides a helpful utility library for sending    email that shields the user from the specifics of the underlying mailing    system and is responsible for low level resource handling on behalf of    the client.    \n\r\n\rThe org.springframework.mail package is the root level package    for the Spring Framework\'s email support. The central interface for sending    emails is the MailSender interface; a simple value object    encapsulating the properties of a simple mail such as from and    to (plus many others) is the SimpleMailMessage class.    This package also contains a hierarchy of checked exceptions which provide    a higher level of abstraction over the lower level mail system exceptions    with the root exception being MailException. Please    refer to the JavaDocs for more information on the rich mail exception hierarchy.    \n\r\n\rThe org.springframework.mail.javamail.JavaMailSender    interface adds specialized JavaMail features such as MIME    message support to the MailSender interface    (from which it inherits). JavaMailSender also provides a    callback interface for preparation of JavaMail MIME messages, called    org.springframework.mail.javamail.MimeMessagePreparator      26.2&nbsp;Usage                \n\r\n\rLet\'s assume there is a business interface called OrderManager:        public interface OrderManager {    void placeOrder(Order order);}        \n\r\n\rLet us also assume that there is a requirement stating that an email message        with an order number needs to be generated and sent to a customer placing the        relevant order.        26.2.1&nbsp;Basic MailSender and SimpleMailMessage usage                        import org.springframework.mail.MailException;import org.springframework.mail.MailSender;import org.springframework.mail.SimpleMailMessage;public class SimpleOrderManager implements OrderManager {    private MailSender mailSender;    private SimpleMailMessage templateMessage;    public void setMailSender(MailSender mailSender) {        this.mailSender = mailSender;    }    public void setTemplateMessage(SimpleMailMessage templateMessage) {        this.templateMessage = templateMessage;    }    public void placeOrder(Order order) {        // Do the business calculations...        // Call the collaborators to persist the order...        // Create a thread safe \"copy\" of the template message and customize it        SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);        msg.setTo(order.getCustomer().getEmailAddress());        msg.setText(            \"Dear \" + order.getCustomer().getFirstName()                + order.getCustomer().getLastName()                + \", thank you for placing order. Your order number is \"                + order.getOrderNumber());        try{            this.mailSender.send(msg);        }        catch(MailException ex) {            // simply log it and go on...            System.err.println(ex.getMessage());        }    }}            \n\r\n\rFind below the bean definitions for the above code:            &lt;bean id=\"mailSender\" class=\"org.springframework.mail.javamail.JavaMailSenderImpl\"&gt;  &lt;property name=\"host\" value=\"mail.mycompany.com\"/&gt;&lt;/bean&gt;&lt;!-- this is a template message that we can pre-load with default state --&gt;&lt;bean id=\"templateMessage\" class=\"org.springframework.mail.SimpleMailMessage\"&gt;  &lt;property name=\"from\" value=\"customerservice@mycompany.com\"/&gt;  &lt;property name=\"subject\" value=\"Your order\"/&gt;&lt;/bean&gt;&lt;bean id=\"orderManager\" class=\"com.mycompany.businessapp.support.SimpleOrderManager\"&gt;  &lt;property name=\"mailSender\" ref=\"mailSender\"/&gt;  &lt;property name=\"templateMessage\" ref=\"templateMessage\"/&gt;&lt;/bean&gt;                26.2.2&nbsp;Using the JavaMailSender and the MimeMessagePreparator                        \n\r\n\rHere is another implementation of OrderManager using            the MimeMessagePreparator callback interface. Please note            in this case that the mailSender property is of type            JavaMailSender so that we are able to use the JavaMail            MimeMessage class:            import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage;import org.springframework.mail.MailException;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessagePreparator;public class SimpleOrderManager implements OrderManager {    private JavaMailSender mailSender;    public void setMailSender(JavaMailSender mailSender) {        this.mailSender = mailSender;    }    public void placeOrder(final Order order) {        // Do the business calculations...        // Call the collaborators to persist the order...        MimeMessagePreparator preparator = new MimeMessagePreparator() {            public void prepare(MimeMessage mimeMessage) throws Exception {                mimeMessage.setRecipient(Message.RecipientType.TO,                        new InternetAddress(order.getCustomer().getEmailAddress()));                mimeMessage.setFrom(new InternetAddress(\"mail@mycompany.com\"));                mimeMessage.setText(                    \"Dear \" + order.getCustomer().getFirstName() + \" \"                        + order.getCustomer().getLastName()                        + \", thank you for placing order. Your order number is \"                        + order.getOrderNumber());            }        };        try {            this.mailSender.send(preparator);        }        catch (MailException ex) {            // simply log it and go on...            System.err.println(ex.getMessage());        }    }}            Note                \n\r\n\rThe mail code is a crosscutting concern and could well be a candidate                for refactoring into a custom Spring AOP aspect,                which then could be executed at appropriate joinpoints on the                OrderManager target.                        \n\r\n\rThe Spring Framework\'s mail support ships with the standard JavaMail            implementation. Please refer to the relevant JavaDocs for more information.                26.3&nbsp;Using the JavaMail MimeMessageHelper                \n\r\n\rA class that comes in pretty handy when dealing with JavaMail messages is        the org.springframework.mail.javamail.MimeMessageHelper class,        which shields you from having to use the verbose JavaMail API. Using        the MimeMessageHelper it is pretty easy to        create a MimeMessage:        // of course you would use DI in any real-world casesJavaMailSenderImpl sender = new JavaMailSenderImpl();sender.setHost(\"mail.host.com\");MimeMessage message = sender.createMimeMessage();MimeMessageHelper helper = new MimeMessageHelper(message);helper.setTo(\"test@host.com\");helper.setText(\"Thank you for ordering!\");sender.send(message);        26.3.1&nbsp;Sending attachments and inline resources                        \n\r\n\rMultipart email messages allow for both attachments and inline resources.            Examples of inline resources would be images or a stylesheet you want to use            in your message, but that you don\'t want displayed as an attachment.            Attachments                                \n\r\n\rThe following example shows you how to use the                MimeMessageHelper to send an email along with a                single JPEG image attachment.                JavaMailSenderImpl sender = new JavaMailSenderImpl();sender.setHost(\"mail.host.com\");MimeMessage message = sender.createMimeMessage();// use the true flag to indicate you need a multipart messageMimeMessageHelper helper = new MimeMessageHelper(message, true);helper.setTo(\"test@host.com\");helper.setText(\"Check out this image!\");// let\'s attach the infamous windows Sample file (this time copied to c:/)FileSystemResource file = new FileSystemResource(new File(\"c:/Sample.jpg\"));helper.addAttachment(\"CoolImage.jpg\", file);sender.send(message);                        Inline resources                                \n\r\n\rThe following example shows you how to use the                MimeMessageHelper to send an email along with an                inline image.                JavaMailSenderImpl sender = new JavaMailSenderImpl();sender.setHost(\"mail.host.com\");MimeMessage message = sender.createMimeMessage();// use the true flag to indicate you need a multipart messageMimeMessageHelper helper = new MimeMessageHelper(message, true);helper.setTo(\"test@host.com\");// use the true flag to indicate the text included is HTMLhelper.setText(\"&lt;html&gt;&lt;body&gt;&lt;img src=\'cid:identifier1234\'&gt;&lt;/body&gt;&lt;/html&gt;\", true);// let\'s include the infamous windows Sample file (this time copied to c:/)FileSystemResource res = new FileSystemResource(new File(\"c:/Sample.jpg\"));helper.addInline(\"identifier1234\", res);sender.send(message);                Warning                    \n\r\n\rInline resources are added to the mime message using the                    specified Content-ID (identifier1234                    in the above example). The order in which you are adding the text and the                    resource are very important. Be sure to                    first add the text and after that the resources. If                    you are doing it the other way around, it won\'t work!                                            26.3.2&nbsp;Creating email content using a templating library                        \n\r\n\rThe code in the previous examples explicitly created the            content of the email message, using methods calls such as            message.setText(..). This is fine for            simple cases, and it is okay in the context of the aforementioned            examples, where the intent was to show you the very basics of the API.            \n\r\n\rIn your typical enterprise application though, you are not going            to create the content of your emails using the above approach for a number            of reasons.            \n\r\n\r                \n\r                        \n\r\n\rCreating HTML-based email content in Java code is tedious and error prone                    \n\r                        \n\r\n\rThere is no clear separation between display logic and business logic                    \n\r                        \n\r\n\rChanging the display structure of the email content requires writing Java code, recompiling, redeploying...                    \n\r\n\r\n\r                        \n\r\n\rTypically the approach taken to address these issues is to use a template library            such as FreeMarker or Velocity to define the display structure of email content. This leaves            your code tasked only with creating the data that is to be rendered in the email            template and sending the email. It is definitely a best practice for when            the content of your emails becomes even moderately complex, and with            the Spring Framework\'s support classes for FreeMarker and Velocity becomes            quite easy to do. Find below an example of using the Velocity template library            to create email content.            A Velocity-based example                                \n\r\n\rTo use Velocity to                create your email template(s), you will need to have the Velocity libraries                available on your classpath. You will also need to create one or more Velocity templates                for the email content that your application needs. Find below the Velocity                template that this example will be using. As you can see it is HTML-based,                and since it is plain text it can be created using your favorite HTML                or text editor.                # in the com/foo/package&lt;html&gt;&lt;body&gt;&lt;h3&gt;Hi ${user.userName}, welcome to the Chipping Sodbury On-the-Hill message boards!&lt;/h3&gt;&lt;div&gt;   Your email address is &lt;a href=\"mailto:${user.emailAddress}\"&gt;${user.emailAddress}&lt;/a&gt;.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;                \n\r\n\rFind below some simple code and Spring XML configuration that                makes use of the above Velocity template to create email content and                send email(s).                package com.foo;import org.apache.velocity.app.VelocityEngine;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.mail.javamail.MimeMessagePreparator;import org.springframework.ui.velocity.VelocityEngineUtils;import javax.mail.internet.MimeMessage;import java.util.HashMap;import java.util.Map;public class SimpleRegistrationService implements RegistrationService {   private JavaMailSender mailSender;   private VelocityEngine velocityEngine;   public void setMailSender(JavaMailSender mailSender) {      this.mailSender = mailSender;   }   public void setVelocityEngine(VelocityEngine velocityEngine) {      this.velocityEngine = velocityEngine;   }   public void register(User user) {      // Do the registration logic...      sendConfirmationEmail(user);   }   private void sendConfirmationEmail(final User user) {      MimeMessagePreparator preparator = new MimeMessagePreparator() {         public void prepare(MimeMessage mimeMessage) throws Exception {            MimeMessageHelper message = new MimeMessageHelper(mimeMessage);            message.setTo(user.getEmailAddress());            message.setFrom(\"webmaster@csonth.gov.uk\"); // could be parameterized...            Map model = new HashMap();            model.put(\"user\", user);            String text = VelocityEngineUtils.mergeTemplateIntoString(               velocityEngine, \"com/dns/registration-confirmation.vm\", model);            message.setText(text, true);         }      };      this.mailSender.send(preparator);   }}                &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;   &lt;bean id=\"mailSender\" class=\"org.springframework.mail.javamail.JavaMailSenderImpl\"&gt;      &lt;property name=\"host\" value=\"mail.csonth.gov.uk\"/&gt;   &lt;/bean&gt;   &lt;bean id=\"registrationService\" class=\"com.foo.SimpleRegistrationService\"&gt;      &lt;property name=\"mailSender\" ref=\"mailSender\"/&gt;      &lt;property name=\"velocityEngine\" ref=\"velocityEngine\"/&gt;   &lt;/bean&gt;   &lt;bean id=\"velocityEngine\" class=\"org.springframework.ui.velocity.VelocityEngineFactoryBean\"&gt;      &lt;property name=\"velocityProperties\"&gt;         &lt;value&gt;          resource.loader=class          class.resource.loader.class=org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader         &lt;/value&gt;      &lt;/property&gt;   &lt;/bean&gt;&lt;/beans&gt;                        Prev&nbsp;Up&nbsp;Next25.&nbsp;JCA CCI&nbsp;Home&nbsp;27.&nbsp;Task Execution and Scheduling","26. Email","scr\\mail.html","         Appendix&nbsp;C.&nbsp;Migrating to Spring Framework 3.1Prev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;C.&nbsp;Migrating to Spring Framework 3.1    \n\r\n\rIn this appendix we discuss what users will want to know when upgrading to  Spring Framework 3.1. For a general overview of features, please see  Chapter&nbsp;3, New Features and Enhancements in Spring Framework 3.1  C.1&nbsp;Component scanning against the \"org\" base package        \n\r\n\rSpring Framework 3.1 introduces a number of @Configuration    classes such as org.springframework.cache.annotation.ProxyCachingConfiguration     and    org.springframework.scheduling.annotation.ProxyAsyncConfiguration.    Because @Configuration is ultimately meta-annotated with Spring\'s    @Component annotation, these classes will inadvertently be scanned    and processed by the container for any component-scanning directive against the    unqualified \"org\" package, e.g.:            &lt;context:component-scan base-package=\"org\"/&gt;\n\r\n\r    Therefore, in order to avoid errors like the one reported in SPR-9843,    any such directives should be updated to at least one more level of qualification e.g.:          &lt;context:component-scan base-package=\"org.xyz\"/&gt;\n\r\n\r    Alternatively, an exclude-filter may be used. See    context:component-scan    documentation for details.  Prev&nbsp;Up&nbsp;NextAppendix&nbsp;B.&nbsp;Classic Spring AOP Usage&nbsp;Home&nbsp;Appendix&nbsp;D.&nbsp;Migrating to Spring Framework 3.2","C. Migrating to Spring Framework 3.1","scr\\migration-3.1.html","         Appendix&nbsp;D.&nbsp;Migrating to Spring Framework 3.2Prev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;D.&nbsp;Migrating to Spring Framework 3.2    \n\r\n\rIn this appendix we discuss what users will want to know when upgrading to  Spring Framework 3.2. For a general overview of features, please see  Chapter&nbsp;4, New Features and Enhancements in Spring Framework 3.2  D.1&nbsp;Newly optional dependencies        \n\r\n\rCertain inter-module dependencies are now optional at the    Maven POM level where they were once required. For example, spring-tx    and its dependence on spring-context. This may result in     ClassNotFoundErrors or other similar problems for users that have been relying    on transitive dependency management to pull in affected downstream spring-*    . To resolve this problem, simply add the appropriate missing jars to your    build configuration.    D.2&nbsp;EHCache support moved to spring-context-support        \n\r\n\rAlong with Spring\'s new JCache support, the EHCache support classes in the    org.springframework.cache.ehcache package moved from the    spring-context module to spring-context-support.    D.3&nbsp;Inlining of spring-asm jar        \n\r\n\rIn versions 3.0 and 3.1, we published a discrete spring-asm    containing repackaged org.objectweb.asm 3.x sources. As of Spring    Framework 3.2, we have upgraded to org.objectweb.asm 4.0 and done    away with the separate module jar, favoring inlining these classes directly within    spring-core. This should cause no migration issue for most users;    but on the off chance that you have spring-asm declared directly    within your project\'s build script, you\'ll want to remove it when upgrading to    Spring Framework 3.2.    D.4&nbsp;Explicit CGLIB dependency no longer required        \n\r\n\rIn prior versions, users of Spring\'s subclass-based AOP proxies (e.g. via    proxy-target-class=\"true\") and @Configuration    class support were required to declare an explicit dependency on CGLIB 2.2. As of    Spring Framework 3.2, we now repackage and inline the newly-released CGLIB 3.0.    \n\r\n\rThis means greater convenience for users, as well as correct functionality for    Java 7 users who are creating subclass proxies of types that contain     invokedynamic bytecode instructions. Repackaging CGLIB internally ensures    no classpath conflicts with other third party frameworks that may depend on other    versions of CGLIB.    D.5&nbsp;For OSGi users        \n\r\n\rOSGi metadata is no longer published within individual Spring Framework    jar MANIFEST.MF files. Please see this    announcement    for more information about how users can get OSGi-ready versions of Spring    Framework 3.2 jars.    D.6&nbsp;MVC Java Config and MVC Namespace        \n\r\n\rAs explained in Section&nbsp;17.15.4, &#8220;Configuring Content Negotiation&#8221;, both    the MVC Java config and the MVC namespace register extensions such as    .json and .xml if the    corresponding classpath dependencies are present. That means controller    methods may now return JSON or XML formatted content if those    extensions are present in the request URI,    even if the \'Accept\' header doesn\'t request those media types.    \n\r\n\rThe newly added support for matrix variables is explained in    the section called &#8220;Matrix Variables&#8221;. To preserve backward    compatibility, by default, semicolon content is removed from incoming    request URIs and therefore @MatrixVariable    cannot be used without additional configuration. However, when using    the MVC Java config and the MVC namespace, semicolon content is left    in the URI so that matrix variables are automatically supported.    The removal of semicolon content is controlled through the    UrlPathHelper property of    RequestMappingHandlerMapping.    D.7&nbsp;Decoding of URI Variable Values        \n\r\n\rURI variable values now get decoded when    UrlPathHelper.setUrlDecode is set to false.    See SPR-9098.    D.8&nbsp;HTTP PATCH method        \n\r\n\rThe DispatcherServlet now allows the    HTTP PATCH method where previously it didn\'t.    D.9&nbsp;Tiles 3        \n\r\n\rBesides the version number change, the set of Tiles    dependencies has also changed. You will need to have a subset or all of    tiles-request-api, tiles-api,    tiles-core, tiles-servlet,    tiles-jsp, tiles-el.        D.10&nbsp;Spring MVC Test standalone project        \n\r\n\rIf migrating from the    spring-test-mvc    standalone project to the spring-test module in    Spring Framework 3.2, you will need to adjust the root package    to be org.springframework.test.web.servlet.    \n\r\n\rYou will no longer be able to use the    MockMvcBuilders annotationConfigSetup    and xmlConfigSetup options. Instead you\'ll need to switch    to using the @WebAppConfiguration support    of spring-test for loading Spring configuration,    then inject a WebApplicationContext into    the test and use it to create a MockMvc. See    Section&nbsp;11.3.6, &#8220;Spring MVC Test Framework&#8221; for details.    D.11&nbsp;Spring Test Dependencies        \n\r\n\rThe spring-test module has been upgraded to    depend on JUnit 4.11 (junit:junit), TestNG 6.5.2    (org.testng:testng), and Hamcrest Core 1.3    (org.hamcrest:hamcrest-core). Each of these    dependencies is declared as an optional dependency in    the Maven POM. Furthermore, it is important to note that the JUnit team    has stopped inlining Hamcrest Core within the    junit:junit Maven artifact as of JUnit 4.11. Hamcrest    Core is now a required transitive dependency of    junit, and users may therefore need to remove any    exclusions on hamcrest-core that they had previously    configured for their build.    D.12&nbsp;Public API changes        D.12.1&nbsp;JDiff reports            \n\r\n\r      Select JDiff reports are now being published to provide users with a convenient      means of understanding what\'s changed between versions. Going forward these will be      published between each minor version, e.g. from 3.1.3.RELEASE to 3.1.4.RELEASE; from      the latest maintenance version to the latest GA release, e.g.            3.1.3.RELEASE to 3.2.0.RELEASE; and in between each milestone      and/or RC for users who are tracking next-generation development, e.g.            3.2.0.RC2 to 3.2.0.RELEASE.              D.12.2&nbsp;Deprecations            \n\r\n\rThe following packages and types have been wholly or partially deprecated      in Spring Framework 3.2 and may be removed in a future version. Click through      to the linked Javadoc for each item for exact details. See also the            complete list of deprecations in the framework.      \n\r          \n\r\n\r                    org.springframework.orm.ibatis                  \n\r          \n\r\n\r                    org.springframework.scheduling.backportconcurrent                  \n\r          \n\r\n\r                    org.springframework.ejb.support                  \n\r          \n\r\n\r                    org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter                  \n\r          \n\r\n\r                    org.springframework.web.jsf.DelegatingVariableResolver                  \n\r          \n\r\n\r                    org.springframework.web.jsf.SpringBeanVariableResolver                  \n\r          \n\r\n\r                    org.springframework.ui.velocity.CommonsLoggingLogSystem                  \n\r          \n\r\n\r                    org.springframework.ui.velocity.VelocityEngineUtils                  \n\r          \n\r\n\r                    org.springframework.beans.factory.config.BeanReferenceFactoryBean                  \n\r          \n\r\n\r                    org.springframework.beans.factory.config.CommonsLogFactoryBean                  \n\r          \n\r\n\r                    org.springframework.beans.instrument.classloading.oc4j.OC4JLoadTimeWeaver                  \n\r          \n\r\n\r                    org.springframework.transaction.jta.OC4JJtaTransactionManager                  \n\r          \n\r\n\r                    org.springframework.web.util.ExpressionEvaluationUtils                  \n\r          \n\r\n\r                    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter                  \n\r          \n\r\n\r                    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver                  \n\r          \n\r\n\r                    org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping                  \n\r          \n\r\n\r                    org.springframework.web.servlet.mvc.annotation.ServletAnnotationMappingUtils                  \n\r          \n\r\n\r                    org.springframework.jmx.support.MBeanRegistrationSupport                  \n\r          \n\r\n\r                    org.springframework.test.context.ContextConfigurationAttributes                  \n\r          \n\r\n\r                    org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests:          use of the simpleJdbcTemplate instance variable has been deprecated          in favor of the new jdbcTemplate instance variable.        \n\r          \n\r\n\r                    org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests:          use of the simpleJdbcTemplate instance variable has been deprecated          in favor of the new jdbcTemplate instance variable.        \n\r          \n\r\n\r                    org.springframework.test.jdbc.SimpleJdbcTestUtils has been deprecated in          favor of JdbcTestUtils which now contains all of the          functionality previously available in SimpleJdbcTestUtils.        \n\r          \n\r\n\r                    org.springframework.web.servlet.view.ContentNegotiatingViewResolver                  \n\r          \n\r\n\r                    org.springframework.transaction.interceptor.TransactionAspectUtils                  \n\r          \n\r\n\r                    org.springframework.http.HttpStatus                  \n\r          \n\r\n\r                    org.springframework.web.util.UriUtils                  \n\r          \n\r\n\r                    org.springframework.orm.jpa.vendor.TopLinkJpaDialect                  \n\r          \n\r\n\r                    org.springframework.orm.jpa.vendor.TopLinkJpaVendorAdapter                  \n\r          \n\r\n\r                    org.springframework.orm.util.CachingMapDecorator                  \n\r      Prev&nbsp;Up&nbsp;NextAppendix&nbsp;C.&nbsp;Migrating to Spring Framework 3.1&nbsp;Home&nbsp;Appendix&nbsp;E.&nbsp;XML Schema-based configuration","D. Migrating to Spring Framework 3.2","scr\\migration-3.2.html","         17.&nbsp;Web MVC frameworkPrev&nbsp;Part&nbsp;V.&nbsp;The Web&nbsp;Next17.&nbsp;Web MVC framework    17.1&nbsp;Introduction to Spring Web MVC framework        \n\r\n\rThe Spring Web model-view-controller (MVC) framework is designed    around a DispatcherServlet that dispatches requests    to handlers, with configurable handler mappings, view resolution, locale    and theme resolution as well as support for uploading files. The default    handler is based on the @Controller and    @RequestMapping annotations, offering a    wide range of flexible handling methods. With the introduction of Spring    3.0, the @Controller mechanism also allows    you to create RESTful Web sites and applications, through the    @PathVariable annotation and other    features.    \n\r\n\r&#8220;Open for extension...&#8221;            \n\r\n\rA key design principle in Spring Web MVC and in Spring in general      is the &#8220;Open for extension, closed for      modification&#8221; principle.      \n\r\n\rSome methods in the core classes of Spring Web MVC are marked      final. As a developer you cannot override these      methods to supply your own behavior. This has not been done arbitrarily,      but specifically with this principle in mind.      \n\r\n\rFor an explanation of this principle, refer to Expert      Spring Web MVC and Web Flow by Seth Ladd and others;      specifically see the section \"A Look At Design,\" on page 117 of the      first edition. Alternatively, see      \n\r          \n\r\n\rBob          Martin, The Open-Closed Principle (PDF)        \n\r      \n\r\n\rYou cannot add advice to final methods when you use Spring MVC.      For example, you cannot add advice to the      AbstractController.setSynchronizeOnSession() method.      Refer to Section&nbsp;9.6.1, &#8220;Understanding AOP proxies&#8221; for more      information on AOP proxies and why you cannot add advice to final      methods.        \n\r\n\rIn Spring Web MVC you can use any object as a command or    form-backing object; you do not need to implement a framework-specific    interface or base class. Spring\'s data binding is highly flexible: for    example, it treats type mismatches as validation errors that can be    evaluated by the application, not as system errors. Thus you need not    duplicate your business objects\' properties as simple, untyped strings in    your form objects simply to handle invalid submissions, or to convert the    Strings properly. Instead, it is often preferable to bind directly to your    business objects.    \n\r\n\rSpring\'s view resolution is extremely flexible. A    Controller is typically responsible for    preparing a model Map with data and selecting a    view name but it can also write directly to the response stream and    complete the request. View name resolution is highly configurable through    file extension or Accept header content type negotiation, through bean    names, a properties file, or even a custom    ViewResolver implementation. The model (the    M in MVC) is a Map interface, which allows    for the complete abstraction of the view technology. You can integrate    directly with template based rendering technologies such as JSP, Velocity    and Freemarker, or directly generate XML, JSON, Atom, and many other types    of content. The model Map is simply    transformed into an appropriate format, such as JSP request attributes, a    Velocity template model.    17.1.1&nbsp;Features of Spring Web MVC                  \n\r\n\rSpring Web Flow    \n\r\n\rSpring Web Flow (SWF) aims to be the best solution for the management  of web application page flow.  \n\r\n\rSWF integrates with existing frameworks like Spring MVC, Struts, and  JSF, in both servlet and portlet environments. If you have a business  process (or processes) that would benefit from a conversational model as  opposed to a purely request model, then SWF may be the solution.  \n\r\n\rSWF allows you to capture logical page flows as self-contained modules  that are reusable in different situations, and as such is ideal for building  web application modules that guide the user through controlled navigations  that drive business processes.  \n\r\n\rFor more information about SWF, consult the  Spring Web Flow website.        \n\r\n\rSpring\'s web module includes many unique web support      features:      \n\r          \n\r\n\rClear separation of roles. Each role &#8212;          controller, validator, command object, form object, model object,          DispatcherServlet, handler mapping, view          resolver, and so on &#8212; can be fulfilled by a specialized          object.        \n\r          \n\r\n\rPowerful and straightforward configuration of both          framework and application classes as JavaBeans. This          configuration capability includes easy referencing across contexts,          such as from web controllers to business objects and          validators.        \n\r          \n\r\n\rAdaptability, non-intrusiveness, and          flexibility. Define any controller method signature you          need, possibly using one of the parameter annotations (such as          @RequestParam, @RequestHeader, @PathVariable, and more) for a given          scenario.        \n\r          \n\r\n\rReusable business code, no need          for duplication. Use existing business objects as command          or form objects instead of mirroring them to extend a particular          framework base class.        \n\r          \n\r\n\rCustomizable binding and validation. Type          mismatches as application-level validation errors that keep the          offending value, localized date and number binding, and so on          instead of String-only form objects with manual parsing and          conversion to business objects.        \n\r          \n\r\n\rCustomizable handler mapping and view          resolution. Handler mapping and view resolution          strategies range from simple URL-based configuration, to          sophisticated, purpose-built resolution strategies. Spring is more          flexible than web MVC frameworks that mandate a particular          technique.        \n\r          \n\r\n\rFlexible model transfer. Model transfer          with a name/value Map supports easy          integration with any view technology.        \n\r          \n\r\n\rCustomizable locale and theme resolution, support          for JSPs with or without Spring tag library, support for JSTL,          support for Velocity without the need for extra bridges, and so          on.        \n\r          \n\r\n\rA simple yet powerful JSP tag library known as the          Spring tag library that provides support for features such as data          binding and themes. The custom tags allow for maximum          flexibility in terms of markup code. For information on the tag          library descriptor, see the appendix entitled Appendix&nbsp;G, spring.tld        \n\r          \n\r\n\rA JSP form tag library, introduced in Spring 2.0,          that makes writing forms in JSP pages much easier. For          information on the tag library descriptor, see the appendix entitled          Appendix&nbsp;H, spring-form.tld        \n\r          \n\r\n\rBeans whose lifecycle is scoped to the current HTTP          request or HTTP Session.          This is not a specific feature of Spring MVC itself, but rather of          the WebApplicationContext          container(s) that Spring MVC uses. These bean scopes are described          in Section&nbsp;5.5.4, &#8220;Request, session, and global session scopes&#8221;        \n\r        17.1.2&nbsp;Pluggability of other MVC implementations            \n\r\n\rNon-Spring MVC implementations are preferable for some projects.      Many teams expect to leverage their existing investment in skills and      tools. A large body of knowledge and experience exist for the Struts      framework. If you can abide Struts\' architectural flaws, it can be a      viable choice for the web layer; the same applies to WebWork and other      web MVC frameworks.      \n\r\n\rIf you do not want to use Spring\'s web MVC, but intend to leverage      other solutions that Spring offers, you can integrate the web MVC      framework of your choice with Spring easily. Simply start up a Spring      root application context through its      ContextLoaderListener, and access it through      its      ServletContext attribute (or Spring\'s      respective helper method) from within a Struts or WebWork action. No      \"plug-ins\" are involved, so no dedicated integration is necessary. From      the web layer\'s point of view, you simply use Spring as a library, with      the root application context instance as the entry point.      \n\r\n\rYour registered beans and Spring\'s services can be at your      fingertips even without Spring\'s Web MVC. Spring does not compete with      Struts or WebWork in this scenario. It simply addresses the many areas      that the pure web MVC frameworks do not, from bean configuration to data      access and transaction handling. So you can enrich your application with      a Spring middle tier and/or data access tier, even if you just want to      use, for example, the transaction abstraction with JDBC or      Hibernate.        17.2&nbsp;The DispatcherServlet        \n\r\n\rSpring\'s web MVC framework is, like many other web MVC frameworks,    request-driven, designed around a central Servlet that dispatches requests    to controllers and offers other functionality that facilitates the    development of web applications. Spring\'s    DispatcherServlet however, does more than just    that. It is completely integrated with the Spring IoC container and as    such allows you to use every other feature that Spring has.    \n\r\n\rThe request processing workflow of the Spring Web MVC    DispatcherServlet is illustrated in the following    diagram. The pattern-savvy reader will recognize that the    DispatcherServlet is an expression of the    &#8220;Front Controller&#8221; design pattern (this is a pattern that    Spring Web MVC shares with many other leading web frameworks).    \n\r\n\rThe request processing workflow in Spring Web MVC (high        level)    \n\r\n\rThe DispatcherServlet is an actual    Servlet (it inherits from the    HttpServlet base class), and as such is declared in    the web.xml of your web application. You need to map    requests that you want the DispatcherServlet to    handle, by using a URL mapping in the same web.xml    file. This is standard Java EE Servlet configuration; the following example    shows such a DispatcherServlet declaration and    mapping:    &lt;web-app&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;example&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;example&lt;/servlet-name&gt;        &lt;url-pattern&gt;/example/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;    \n\r\n\rIn the preceding example, all requests starting with    /example will be handled by the    DispatcherServlet instance named    example.    In a Servlet 3.0+ environment, you also have the    option of configuring the Servlet container programmatically. Below is the code    based equivalent of the above web.xml example:    public class MyWebApplicationInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext container) {        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet());        registration.setLoadOnStartup(1);        registration.addMapping(\"/example/*\");    }}    \n\r\n\rWebApplicationInitializer is an interface    provided by Spring MVC that ensures your code-based configuration is detected and    automatically used to initialize any Servlet 3 container. An abstract base class    implementation of this interace named    AbstractDispatcherServletInitializer makes it even easier    to register the DispatcherServlet by simply specifying    its servlet mapping. See    Code-based Servlet container initialization    for more details.    \n\r\n\rThe above is only the first step in setting up    Spring Web MVC. You    now need to configure the various beans used by the Spring Web MVC    framework (over and above the DispatcherServlet    itself).    \n\r\n\rAs detailed in Section&nbsp;5.14, &#8220;Additional Capabilities of the    ApplicationContext&#8221;,    ApplicationContext instances in Spring can    be scoped. In the Web MVC framework, each    DispatcherServlet has its own    WebApplicationContext, which inherits all    the beans already defined in the root    WebApplicationContext. These inherited    beans can be overridden in the servlet-specific scope, and you can define    new scope-specific beans local to a given Servlet instance.    Context hierarchy in Spring Web MVC    \n\r\n\rUpon initialization of a DispatcherServlet,    Spring MVC looks for a file named     [servlet-name]-servlet.xml in the    WEB-INF directory of your web application and creates    the beans defined there, overriding the definitions of any beans defined    with the same name in the global scope.    \n\r\n\rConsider the following DispatcherServlet    Servlet configuration (in the web.xml file):    &lt;web-app&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;golfing&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;golfing&lt;/servlet-name&gt;        &lt;url-pattern&gt;/golfing/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;    \n\r\n\rWith the above Servlet configuration in place, you    will need to have a file called /WEB-INF/golfing-servlet.xml in your    application; this file will contain all of your Spring Web MVC-specific    components (beans). You can change the exact location of this    configuration file through a Servlet initialization parameter (see below    for details).        \n\r\n\rThe WebApplicationContext is an    extension of the plain ApplicationContext    that has some extra features necessary for web applications. It differs    from a normal ApplicationContext in that it    is capable of resolving themes (see Section&nbsp;17.9, &#8220;Using themes&#8221;),    and that it knows which Servlet it is associated with (by having a link to    the ServletContext). The    WebApplicationContext is bound in the    ServletContext, and by using static methods    on the RequestContextUtils class you can always    look up the WebApplicationContext if you    need access to it.    17.2.1&nbsp;Special Bean Types In the WebApplicationContext                \n\r\n\rThe Spring DispatcherServlet uses special        beans to process requests and render the appropriate views. These beans        are part of Spring MVC. You can choose which special beans to use        by simply configuring one or more of them in the        WebApplicationContext.        However, you don\'t need to do that initially since Spring MVC        maintains a list of default beans to use if you don\'t configure any.        More on that in the next section. First see the table below        listing the special bean types the        DispatcherServlet relies on.        \n\r\n\rTable&nbsp;17.1.&nbsp;Special bean types in the          WebApplicationContext                    Bean typeExplanationHandlerMappingMaps incoming requests to handlers and a list of                pre- and post-processors (handler interceptors) based on some                criteria the details of which vary by HandlerMapping                implementation. The most popular implementation supports                annotated controllers but other implementations exists as well.HandlerAdapterHelps the DispatcherServlet to                invoke a handler mapped to a request regardless of the handler                is actually invoked. For example, invoking an annotated controller                requires resolving various annotations. Thus the main purpose                of a HandlerAdapter is to shield the                DispatcherServlet from such details.HandlerExceptionResolverMaps exceptions to views also allowing for more                complex exception handling code.ViewResolverResolves logical String-based view names to actual                View types.LocaleResolverResolves the locale a client is using,                in order to be able to offer internationalized viewsThemeResolverResolves themes your web application can use, for                example, to offer personalized layoutsMultipartResolverParses multi-part requests for example to support processing                file uploads from HTML forms.FlashMapManagerStores and retrieves the \"input\" and the \"output\"                FlashMap that can be used to pass attributes                from one request to another, usually across a redirect.        \n\r        17.2.2&nbsp;Default DispatcherServlet Configuration                \n\r\n\rAs mentioned in the previous section for each special bean        the DispatcherServlet maintains a list        of implementations to use by default. This information is        kept in the file DispatcherServlet.properties        in the package org.springframework.web.servlet.                \n\r\n\rAll special beans have  some reasonable defaults of        their own. Sooner or later though you\'ll need to customize        one or more of the properties these beans provide.        For example it\'s quite common to configure        an InternalResourceViewResolver        settings its prefix property to        the parent location of view files.        \n\r\n\rRegardless of the details, the important concept        to understand here is that once        you	configure a special bean such as an        InternalResourceViewResolver        in your WebApplicationContext, you        effectively override the list of default implementations        that would have been used otherwise for that special bean        type. For example if you configure an        InternalResourceViewResolver,        the default list of ViewResolver        implementations is ignored.                \n\r\n\rIn Section&nbsp;17.15, &#8220;Configuring Spring MVC&#8221; you\'ll learn about        other options for configuring Spring MVC including        MVC Java config and the MVC XML namespace both of which provide        a simple starting point and assume little knowledge of        how Spring MVC works. Regardless of how you choose to        configure your application, the concepts explained in this        section are fundamental should be of help to you.                17.2.3&nbsp;DispatcherServlet Processing Sequence                \n\r\n\rAfter you set up a DispatcherServlet, and a        request comes in for that specific        DispatcherServlet, the        DispatcherServlet starts processing the request as        follows:        \n\r            \n\r\n\rThe WebApplicationContext is            searched for and bound in the request as an attribute that the            controller and other elements in the process can use. It            is bound by default under the key            DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE.          \n\r            \n\r\n\rThe locale resolver is bound to the request to enable elements            in the process to resolve the locale to use when processing the            request (rendering the view, preparing data, and so on). If you do not            need locale resolving, you do not need it.                      \n\r            \n\r\n\rThe theme resolver is bound to the request to let elements such            as views determine which theme to use. If you do not use themes, you            can ignore it.                                  \n\r            \n\r\n\rIf you specify a multipart file resolver, the request is            inspected for multiparts; if multiparts are found, the request is            wrapped in a MultipartHttpServletRequest for            further processing by other elements in the process. See Section&nbsp;17.10, &#8220;Spring\'s multipart (file upload) support&#8221; for further information about multipart            handling.          \n\r            \n\r\n\rAn appropriate handler is searched for. If a handler is found,            the execution chain associated with the handler (preprocessors,            postprocessors, and controllers) is executed in order to prepare a            model or rendering.          \n\r            \n\r\n\rIf a model is returned, the view is rendered. If no model is            returned, (may be due to a preprocessor or postprocessor intercepting            the request, perhaps for security reasons), no view is rendered,            because the request could already have been fulfilled.                      \n\r        \n\r\n\rHandler exception resolvers that are declared in the        WebApplicationContext pick up exceptions        that are thrown during processing of the request. Using these exception        resolvers allows you to define custom behaviors to address        exceptions.        \n\r\n\rThe Spring DispatcherServlet also supports        the return of the last-modification-date, as        specified by the Servlet API. The process of determining the last        modification date for a specific request is straightforward: the        DispatcherServlet looks up an appropriate handler        mapping and tests whether the handler that is found implements the        LastModified        interface. If so, the value of the long        getLastModified(request) method of the        LastModified interface is returned to the        client.        \n\r\n\rYou can customize individual        DispatcherServlet instances by adding Servlet        initialization parameters (init-param elements) to the        Servlet declaration in the web.xml file. See the        following table for the list of supported parameters.                        \n\r\n\rTable&nbsp;17.2.&nbsp;DispatcherServlet initialization          parameters                    ParameterExplanationcontextClassClass that implements                WebApplicationContext, which                instantiates the context used by this Servlet. By default, the                XmlWebApplicationContext is used.contextConfigLocationString that is passed to the context instance (specified by                contextClass) to indicate where context(s) can                be found. The string consists potentially of multiple strings                (using a comma as a delimiter) to support multiple contexts. In                case of multiple context locations with beans that are defined                twice, the latest location takes precedence.namespaceNamespace of the                WebApplicationContext. Defaults to                [servlet-name]-servlet.        \n\r          17.3&nbsp;Implementing Controllers        \n\r\n\rControllers provide access to the application behavior that you    typically define through a service interface. Controllers    interpret user input and transform it into a model that is represented to    the user by the view. Spring implements a controller in a very abstract    way, which enables you to create a wide variety of controllers.    \n\r\n\rSpring 2.5 introduced an annotation-based programming model for MVC    controllers that uses annotations such as    @RequestMapping,    @RequestParam,    @ModelAttribute, and so on. This annotation    support is available for both Servlet MVC and Portlet MVC. Controllers    implemented in this style do not have to extend specific base classes or    implement specific interfaces. Furthermore, they do not usually have    direct dependencies on Servlet or Portlet APIs, although you can easily    configure access to Servlet or Portlet facilities.    Tip      \n\r\n\rAvailable in the samples      repository, a number of web applications leverage the annotation      support described in this section including      MvcShowcase, MvcAjax,      MvcBasic, PetClinic,      PetCare, and others.                  @Controllerpublic class HelloWorldController {    @RequestMapping(\"/helloWorld\")    public String helloWorld(Model model) {        model.addAttribute(\"message\", \"Hello World!\");        return \"helloWorld\";    }}    \n\r\n\rAs you can see, the @Controller and    @RequestMapping annotations allow flexible    method names and signatures. In this particular example the method accepts    a Model and returns a view name as a    String, but various other method parameters and    return values can be used as explained later in this section.    @Controller and    @RequestMapping and a number of other    annotations form the basis for the Spring MVC implementation. This section    documents these annotations and how they are most commonly used in a    Servlet environment.    17.3.1&nbsp;Defining a controller with      @Controller            \n\r\n\rThe @Controller annotation      indicates that a particular class serves the role of a      controller. Spring does not require you to extend      any controller base class or reference the Servlet API. However, you can      still reference Servlet-specific features if you need to.      \n\r\n\rThe @Controller annotation acts as      a stereotype for the annotated class, indicating its role. The      dispatcher scans such annotated classes for mapped methods and detects      @RequestMapping annotations (see the next      section).      \n\r\n\rYou can define annotated controller beans explicitly, using a      standard Spring bean definition in the dispatcher\'s context. However,      the @Controller stereotype also allows      for autodetection, aligned with Spring general support for detecting      component classes in the classpath and auto-registering bean definitions      for them.            \n\r\n\rTo enable autodetection of such annotated controllers, you add      component scanning to your configuration. Use the      spring-context schema as shown in the following XML      snippet:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:p=\"http://www.springframework.org/schema/p\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"org.springframework.samples.petclinic.web\"/&gt;    &lt;!-- ... --&gt;&lt;/beans&gt;        17.3.2&nbsp;Mapping Requests With      @RequestMapping            \n\r\n\rYou use the @RequestMapping      annotation to map URLs such as /appointments onto      an entire class or a particular handler method. Typically the      class-level annotation maps a specific request path (or path pattern)      onto a form controller, with additional method-level annotations      narrowing the primary mapping for a specific HTTP method request method      (\"GET\", \"POST\", etc.) or an HTTP request parameter condition.      \n\r\n\rThe following example from the Petcare sample      shows a controller in a Spring MVC application that uses this      annotation:      @Controller@RequestMapping(\"/appointments\")public class AppointmentsController {    private final AppointmentBook appointmentBook;    @Autowired    public AppointmentsController(AppointmentBook appointmentBook) {        this.appointmentBook = appointmentBook;    }    @RequestMapping(method = RequestMethod.GET)    public Map&lt;String, Appointment&gt; get() {        return appointmentBook.getAppointmentsForToday();    }    @RequestMapping(value=\"/{day}\", method = RequestMethod.GET)    public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) {        return appointmentBook.getAppointmentsForDay(day);    }    @RequestMapping(value=\"/new\", method = RequestMethod.GET)    public AppointmentForm getNewForm() {        return new AppointmentForm();    }    @RequestMapping(method = RequestMethod.POST)    public String add(@Valid AppointmentForm appointment, BindingResult result) {        if (result.hasErrors()) {            return \"appointments/new\";        }        appointmentBook.addAppointment(appointment);        return \"redirect:/appointments\";    }}      \n\r\n\rIn the example, the @RequestMapping      is used in a number of places. The first usage is on the type (class)      level, which indicates that all handling methods on this controller are      relative to the /appointments path. The      get() method has a further      @RequestMapping refinement: it only      accepts GET requests, meaning that an HTTP GET for      /appointments invokes this method. The      post() has a similar refinement, and the      getNewForm() combines the definition of HTTP      method and path into one, so that GET requests for      appointments/new are handled by that method.      \n\r\n\rThe getForDay() method shows another      usage of @RequestMapping: URI templates.      (See the next      section ).      \n\r\n\rA @RequestMapping on the class      level is not required. Without it, all paths are simply absolute, and      not relative. The following example from the      PetClinic sample application shows a multi-action      controller using @RequestMapping:      @Controllerpublic class ClinicController {    private final Clinic clinic;    @Autowired    public ClinicController(Clinic clinic) {        this.clinic = clinic;    }    @RequestMapping(\"/\")    public void welcomeHandler() {    }    @RequestMapping(\"/vets\")    public ModelMap vetsHandler() {        return new ModelMap(this.clinic.getVets());    }}      Using @RequestMapping On        Interface Methods                \n\r\n\rA common pitfall when working with annotated controller classes        happens when applying functionality that requires creating a proxy for        the controller object (e.g.        @Transactional methods). Usually you        will introduce an interface for the controller in order to use JDK        dynamic proxies. To make this work you must move the        @RequestMapping annotations, as well as        any other type and method-level annotations (e.g.        @ModelAttribute,        @InitBinder) to the        interface as well as the mapping mechanism can only \"see\" the        interface exposed by the proxy. Alternatively, you could activate        proxy-target-class=\"true\" in the configuration for the        functionality applied to the controller (in our transaction scenario        in &lt;tx:annotation-driven /&gt;). Doing so indicates        that CGLIB-based subclass proxies should be used instead of        interface-based JDK proxies. For more information on various proxying        mechanisms see Section&nbsp;9.6, &#8220;Proxying mechanisms&#8221;.        \n\r\n\rNote however that method argument annotations, e.g.        @RequestParam, must be present in        the method signatures of the controller class.            New Support Classes for @RequestMapping methods in Spring MVC 3.1                \n\r\n\rSpring 3.1 introduced a new set of support classes for        @RequestMapping methods called        RequestMappingHandlerMapping and        RequestMappingHandlerAdapter respectively.        They are recommended for use and even required to take advantage of        new features in Spring MVC 3.1 and going forward. The new support        classes are enabled by default by the MVC namespace and the MVC Java        config but must be configured explicitly if using neither.        This section describes a few        important differences between the old and the new support classes.                \n\r\n\rPrior to Spring 3.1, type and method-level request mappings were        examined in two separate stages -- a controller was selected first        by the DefaultAnnotationHandlerMapping and the        actual method to invoke was narrowed down second by        the AnnotationMethodHandlerAdapter.        \n\r\n\rWith the new support classes in Spring 3.1, the        RequestMappingHandlerMapping is the only place        where a decision is made about which method should process the request.        Think of controller methods as a collection of unique endpoints        with mappings for each method derived from type and method-level        @RequestMapping information.        \n\r\n\rThis enables some new possibilities. For once a        HandlerInterceptor or a        HandlerExceptionResolver can now expect the        Object-based handler to be a HandlerMethod,        which allows them to examine the exact method, its parameters and        associated annotations. The processing for a URL no longer needs to        be split across different controllers.                \n\r\n\rThere are also several things no longer possible:        \n\r\n\r\n\rSelect a controller first with a            SimpleUrlHandlerMapping or            BeanNameUrlHandlerMapping and then narrow            the method based on @RequestMapping            annotations.\n\r\n\r\n\rRely on method names as a fall-back mechanism to            disambiguate between two @RequestMapping methods            that don\'t have an explicit path mapping URL path but otherwise            match equally, e.g. by HTTP method. In the new support classes            @RequestMapping methods have to be mapped            uniquely.\n\r\n\r\n\rHave a single default method (without an explicit            path mapping) with which requests are processed if no other            controller method matches more concretely. In the new support            classes if a matching method is not found a 404 error            is raised.\n\r        \n\r\n\rThe above features are still supported with the existing support        classes. However to take advantage of new Spring MVC 3.1 features        you\'ll need to use the new support classes.            URI Template Patterns                \n\r\n\rURI templates can be used for convenient        access to selected parts of a URL in a        @RequestMapping method.        \n\r\n\rA URI Template is a URI-like string, containing one or more        variable names. When you substitute values for these variables, the        template becomes a URI. The proposed        RFC for URI Templates defines how a URI is parameterized. For        example, the URI Template        http://www.example.com/users/{userId} contains the        variable userId. Assigning the value        fred to the variable yields        http://www.example.com/users/fred.        \n\r\n\rIn Spring MVC you can use the        @PathVariable annotation on a method        argument to bind it to the value of a URI template variable:        @RequestMapping(value=\"/owners/{ownerId}\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) {  Owner owner = ownerService.findOwner(ownerId);  model.addAttribute(\"owner\", owner);  return \"displayOwner\";}        \n\r\n\rThe URI Template \"/owners/{ownerId}\"        specifies the variable name ownerId. When the        controller handles this request, the value of        ownerId is set to the value found in the        appropriate part of the URI. For example, when a request comes in for        /owners/fred, the value of ownerId is        fred.        Tip          \n\r\n\rTo process the @PathVariable annotation, Spring MVC needs to          find the matching URI template variable by name. You can specify it          in the annotation:          @RequestMapping(value=\"/owners/{ownerId}\", method=RequestMethod.GET)public String findOwner(@PathVariable(\"ownerId\") String theOwner, Model model) {  // implementation omitted}          \n\r\n\rOr if the URI template variable name matches the method          argument name you can omit that detail. As long as your code is not          compiled without debugging information, Spring MVC will match the          method argument name to the URI template variable name:          @RequestMapping(value=\"/owners/{ownerId}\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) {  // implementation omitted}                \n\r\n\rA method can have any number of        @PathVariable annotations:        @RequestMapping(value=\"/owners/{ownerId}/pets/{petId}\", method=RequestMethod.GET)public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {  Owner owner = ownerService.findOwner(ownerId);  Pet pet = owner.getPet(petId);  model.addAttribute(\"pet\", pet);  return \"displayPet\";}        \n\r\n\rWhen a @PathVariable annotation is        used on a Map&lt;String, String&gt; argument, the        map is populated with all URI template variables.                \n\r\n\rA URI template can be assembled from type and path level        @RequestMapping annotations. As a result the        findPet() method can be invoked with a URL        such as /owners/42/pets/21.        @Controller@RequestMapping(\"/owners/{ownerId}\")public class RelativePathUriTemplateController {  @RequestMapping(\"/pets/{petId}\")  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    // implementation omitted  }}        \n\r\n\rA @PathVariable argument can be        of any simple type such as int, long,        Date, etc. Spring automatically converts to the appropriate type or        throws a TypeMismatchException if it fails to        do so. You can also register support for parsing additional data        types. See the section called &#8220;Method Parameters And Type Conversion&#8221; and the section called &#8220;Customizing WebDataBinder        initialization&#8221;.            URI Template Patterns with Regular Expressions                \n\r\n\rSometimes you need more precision in defining URI template        variables. Consider the URL        \"/spring-web/spring-web-3.0.5.jar\". How do you break it        down into multiple parts?        \n\r\n\rThe @RequestMapping annotation        supports the use of regular expressions in URI template variables. The        syntax is {varName:regex} where the first part defines        the variable name and the second - the regular expression.For        example:        @RequestMapping(\"/spring-web/{symbolicName:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{extension:\\\\.[a-z]+}\")  public void handle(@PathVariable String version, @PathVariable String extension) {    // ...  }}            Path Patterns                \n\r\n\rIn addition to URI templates, the        @RequestMapping annotation also        supports Ant-style path patterns (for example,        /myPath/*.do). A combination of URI templates and        Ant-style globs is also supported (for example,        /owners/*/pets/{petId}).            Patterns with Placeholders                \n\r\n\rPatterns in @RequestMapping annotations        support ${...} placeholders against local properties and/or system properties        and environment variables. This may be useful in cases where the path a        controller is mapped to may need to be customized through configuration.        For more information on placeholders see the Javadoc for        PropertyPlaceholderConfigurer.            Matrix Variables                \n\r\n\rThe URI specification        RFC 3986        defines the possibility of including name-value pairs within path segments.        There is no specific term used in the spec.        The general \"URI path parameters\" could be applied although the more unique        \"Matrix URIs\",        originating from an old post by Tim Berners-Lee, is also frequently used        and fairly well known. Within Spring MVC these are referred to        as matrix variables.        \n\r\n\rMatrix variables can appear in any path segment, each matrix variable        separated with a \";\" (semicolon).        For example: \"/cars;color=red;year=2012\".        Multiple values may be either \",\" (comma) separated        \"color=red,green,blue\" or the variable name may be repeated        \"color=red;color=green;color=blue\".        \n\r\n\rIf a URL is expected to contain matrix variables, the request mapping        pattern must represent them with a URI template.        This ensures the request can be matched correctly regardless of whether        matrix variables are present or not and in what order they are        provided.        \n\r\n\rBelow is an example of extracting the matrix variable \"q\":        // GET /pets/42;q=11;r=22@RequestMapping(value = \"/pets/{petId}\", method = RequestMethod.GET)public void findPet(@PathVariable String petId, @MatrixVariable int q) {  // petId == 42  // q == 11}       \n\r\n\rSince all path segments may contain matrix variables, in some cases       you need to be more specific to identify where the variable is expected to be:        // GET /owners/42;q=11/pets/21;q=22@RequestMapping(value = \"/owners/{ownerId}/pets/{petId}\", method = RequestMethod.GET)public void findPet(    @MatrixVariable(value=\"q\", pathVar=\"ownerId\") int q1,    @MatrixVariable(value=\"q\", pathVar=\"petId\") int q2) {  // q1 == 11  // q2 == 22}       \n\r\n\rA matrix variable may be defined as optional and a default value specified:        // GET /pets/42@RequestMapping(value = \"/pets/{petId}\", method = RequestMethod.GET)  public void findPet(@MatrixVariable(required=true, defaultValue=\"1\") int q) {    // q == 1  }        \n\r\n\rAll matrix variables may be obtained in a Map:        // GET /owners/42;q=11;r=12/pets/21;q=22;s=23@RequestMapping(value = \"/owners/{ownerId}/pets/{petId}\", method = RequestMethod.GET)  public void findPet(        @MatrixVariable Map&lt;String, String&gt; matrixVars,        @MatrixVariable(pathVar=\"petId\"\") Map&lt;String, String&gt; petMatrixVars) {    // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]    // petMatrixVars: [\"q\" : 11, \"s\" : 23]  }        \n\r\n\rNote that to enable the use of matrix variables, you must set the        removeSemicolonContent property of        RequestMappingHandlerMapping to false.        By default it is set to false.            Consumable Media Types                \n\r\n\rYou can narrow the primary mapping by specifying a list of        consumable media types. The request will be matched only if the        Content-Type request header matches the specified        media type. For example:        @Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) {    // implementation omitted}        \n\r\n\rConsumable media type expressions can also be negated as in        !text/plain to match to all requests other than        those with Content-Type of        text/plain.        Tip          \n\r\n\rThe consumes condition is supported on          the type and on the method level. Unlike most other conditions, when          used at the type level, method-level consumable types override          rather than extend type-level consumable types.                    Producible Media Types                \n\r\n\rYou can narrow the primary mapping by specifying a list of        producible media types. The request will be matched only if the        Accept request header matches one of these        values. Furthermore, use of the produces        condition ensures the actual content type used to generate the        response respects the media types specified in the        produces condition. For example:        @Controller@RequestMapping(value = \"/pets/{petId}\", method = RequestMethod.GET, produces=\"application/json\")@ResponseBodypublic Pet getPet(@PathVariable String petId, Model model) {    // implementation omitted}        \n\r\n\rJust like with consumes, producible media        type expressions can be negated as in !text/plain        to match to all requests other than those with an        Accept header value of        text/plain.        Tip          \n\r\n\rThe produces condition is supported on          the type and on the method level. Unlike most other conditions, when          used at the type level, method-level producible types override          rather than extend type-level producible types.                    Request Parameters and Header Values                \n\r\n\rYou can narrow request matching through request parameter        conditions such as \"myParam\", \"!myParam\", or        \"myParam=myValue\". The first two test for request        parameter presence/absence and the third for a specific parameter        value. Here is an example with a request parameter value        condition:        @Controller@RequestMapping(\"/owners/{ownerId}\")public class RelativePathUriTemplateController {  @RequestMapping(value = \"/pets/{petId}\", method = RequestMethod.GET, params=\"myParam=myValue\")  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    // implementation omitted  }}        \n\r\n\rThe same can be done to test for request header presence/absence        or to match based on a specific request header value:        @Controller@RequestMapping(\"/owners/{ownerId}\")public class RelativePathUriTemplateController {@RequestMapping(value = \"/pets\", method = RequestMethod.GET, headers=\"myHeader=myValue\")  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    // implementation omitted  }}        Tip          \n\r\n\rAlthough you can match to Content-Type          and Accept header values using media type wild          cards (for example \"content-type=text/*\" will          match to \"text/plain\" and          \"text/html\"), it is recommended to use the          consumes and produces          conditions respectively instead. They are intended specifically for          that purpose.                      17.3.3&nbsp;Defining @RequestMapping handler      methods            \n\r\n\rAn @RequestMapping handler method can have      a very flexible signatures. The supported method arguments and return      values are described in the following section. Most arguments can be      used in arbitrary order with the only exception of      BindingResult arguments. This is described in the      next section.      Note\n\r\n\rSpring 3.1 introduced a new set of support classes for      @RequestMapping methods called      RequestMappingHandlerMapping and      RequestMappingHandlerAdapter respectively.      They are recommended for use and even required to take advantage      of new features in Spring MVC 3.1 and going forward.      The new support classes are enabled by default from the MVC namespace and      with use of the MVC Java config but must be      configured explicitly if using neither.            Supported method argument types                \n\r\n\rThe following are the supported method arguments: \n\r              \n\r\n\rRequest or response objects (Servlet API). Choose any              specific request or response type, for example              ServletRequest or              HttpServletRequest.            \n\r              \n\r\n\rSession object (Servlet API): of type              HttpSession. An argument of this              type enforces the presence of a corresponding session. As a              consequence, such an argument is never              null.              Note                \n\r\n\rSession access may not be thread-safe, in particular in                a Servlet environment. Consider setting the                RequestMappingHandlerAdapter\'s                \"synchronizeOnSession\" flag to \"true\" if multiple requests are                allowed to access a session concurrently.                          \n\r              \n\r\n\rorg.springframework.web.context.request.WebRequest              or              org.springframework.web.context.request.NativeWebRequest.              Allows for generic request parameter access as well as              request/session attribute access, without ties to the native              Servlet/Portlet API.            \n\r              \n\r\n\rjava.util.Locale for the current              request locale, determined by the most specific locale resolver              available, in effect, the configured              LocaleResolver in a Servlet              environment.            \n\r              \n\r\n\rjava.io.InputStream /              java.io.Reader for access to the              request\'s content. This value is the raw InputStream/Reader as              exposed by the Servlet API.            \n\r              \n\r\n\rjava.io.OutputStream /              java.io.Writer for generating the              response\'s content. This value is the raw OutputStream/Writer as              exposed by the Servlet API.            \n\r              \n\r\n\rjava.security.Principal              containing the currently authenticated user.            \n\r              \n\r\n\r@PathVariable annotated parameters              for access to URI template variables. See the section called &#8220;URI Template Patterns&#8221;.            \n\r              \n\r\n\r@MatrixVariable annotated parameters              for access to name-value pairs located in URI path segments.              See the section called &#8220;Matrix Variables&#8221;.            \n\r              \n\r\n\r@RequestParam annotated parameters              for access to specific Servlet request parameters. Parameter              values are converted to the declared method argument type. See              the section called &#8220;Binding request parameters to method parameters with        @RequestParam&#8221;.            \n\r              \n\r\n\r@RequestHeader annotated              parameters for access to specific Servlet request HTTP headers.              Parameter values are converted to the declared method argument              type.            \n\r              \n\r\n\r@RequestBody annotated              parameters for access to the HTTP request body. Parameter values              are converted to the declared method argument type using              HttpMessageConverters. See the section called &#8220;Mapping the request body with the @RequestBody        annotation&#8221;.            \n\r              \n\r\n\r@RequestPart annotated              parameters for access to the content of a \"multipart/form-data\"              request part. See Section&nbsp;17.10.5, &#8220;Handling a file upload request from programmatic clients&#8221; and Section&nbsp;17.10, &#8220;Spring\'s multipart (file upload) support&#8221;.            \n\r              \n\r\n\rHttpEntity&lt;?&gt; parameters for              access to the Servlet request HTTP headers and contents. The              request stream will be converted to the entity body using              HttpMessageConverters. See the section called &#8220;Using HttpEntity&lt;?&gt;&#8221;.            \n\r              \n\r\n\rjava.util.Map /              org.springframework.ui.Model /              org.springframework.ui.ModelMap for              enriching the implicit model that is exposed to the web              view.            \n\r              \n\r\n\rorg.springframework.web.servlet.mvc.support.RedirectAttributes              to specify the exact set of attributes to use in case of a              redirect and also to add flash attributes (attributes stored              temporarily on the server-side to make them available to the              request after the redirect).              RedirectAttributes is used instead of the              implicit model if the method returns a \"redirect:\" prefixed view              name or RedirectView.            \n\r              \n\r\n\rCommand or form objects to bind request parameters to bean              properties (via setters) or directly to fields, with              customizable type conversion, depending on              @InitBinder methods and/or the              HandlerAdapter configuration. See the              webBindingInitializer property on              RequestMappingHandlerAdapter. Such              command objects along with their validation results will be              exposed as model attributes by default, using the command class              class name - e.g. model attribute \"orderAddress\" for a command              object of type \"some.package.OrderAddress\". The              ModelAttribute annotation can be used on              a method argument to customize the model attribute name              used.            \n\r              \n\r\n\rorg.springframework.validation.Errors              /              org.springframework.validation.BindingResult              validation results for a preceding command or form object (the              immediately preceding method argument).            \n\r              \n\r\n\rorg.springframework.web.bind.support.SessionStatus              status handle for marking form processing as complete, which              triggers the cleanup of session attributes that have been              indicated by the @SessionAttributes              annotation at the handler type level.            \n\r              \n\r\n\rorg.springframework.web.util.UriComponentsBuilder              a builder for preparing a URL relative to the current request\'s              host, port, scheme, context path, and the literal part of the              servlet mapping.            \n\r        \n\r\n\rThe Errors or        BindingResult parameters have to follow        the model object that is being bound immediately as the method        signature might have more that one model object and Spring will create        a separate BindingResult instance for        each of them so the following sample won\'t work:        \n\r\n\rExample&nbsp;17.1.&nbsp;Invalid ordering of BindingResult and @ModelAttribute                    @RequestMapping(method = RequestMethod.POST)public String processSubmit(@ModelAttribute(\"pet\") Pet pet,    Model model, BindingResult result) { &#8230; }          \n\r\n\rNote, that there is a Model          parameter in between Pet and          BindingResult. To get this working          you have to reorder the parameters as follows:          @RequestMapping(method = RequestMethod.POST)public String processSubmit(@ModelAttribute(\"pet\") Pet pet,    BindingResult result, Model model) { &#8230; }        \n\r            Supported method return types                \n\r\n\rThe following are the supported return types: \n\r              \n\r\n\rA ModelAndView object, with the              model implicitly enriched with command objects and the results              of @ModelAttribute annotated reference data              accessor methods.            \n\r              \n\r\n\rA Model object, with the              view name implicitly determined through a              RequestToViewNameTranslator and              the model implicitly enriched with command objects and the              results of @ModelAttribute annotated              reference data accessor methods.            \n\r              \n\r\n\rA Map object for exposing a              model, with the view name implicitly determined through a              RequestToViewNameTranslator and              the model implicitly enriched with command objects and the              results of @ModelAttribute annotated              reference data accessor methods.            \n\r              \n\r\n\rA View object, with the              model implicitly determined through command objects and              @ModelAttribute annotated reference data              accessor methods. The handler method may also programmatically              enrich the model by declaring a              Model argument (see above).            \n\r              \n\r\n\rA String value that is interpreted              as the logical view name, with the model implicitly determined              through command objects and @ModelAttribute              annotated reference data accessor methods. The handler method              may also programmatically enrich the model by declaring a              Model argument (see              above).            \n\r              \n\r\n\rvoid if the method handles the response              itself (by writing the response content directly, declaring an              argument of type ServletResponse              / HttpServletResponse for that              purpose) or if the view name is supposed to be implicitly              determined through a              RequestToViewNameTranslator (not              declaring a response argument in the handler method              signature).            \n\r              \n\r\n\rIf the method is annotated with              @ResponseBody, the return type is              written to the response HTTP body. The return value will be              converted to the declared method argument type using              HttpMessageConverters. See the section called &#8220;Mapping the response body with the        @ResponseBody annotation&#8221;.            \n\r              \n\r\n\rA HttpEntity&lt;?&gt; or              ResponseEntity&lt;?&gt; object to provide              access to the Servlet response HTTP headers and contents. The              entity body will be converted to the response stream using              HttpMessageConverters. See the section called &#8220;Using HttpEntity&lt;?&gt;&#8221;.            \n\r              \n\r\n\rA Callable&lt;?&gt; can              be returned when the application wants to produce the return              value asynchronously in a thread managed by Spring MVC.            \n\r              \n\r\n\rA DeferredResult&lt;?&gt; can              be returned when the application wants to produce the return              value from a thread of its own choosing.            \n\r              \n\r\n\rAny other return type is considered to be a single model              attribute to be exposed to the view, using the attribute name              specified through @ModelAttribute at the              method level (or the default attribute name based on the return              type class name). The model is implicitly enriched with command              objects and the results of @ModelAttribute              annotated reference data accessor methods.            \n\r            Binding request parameters to method parameters with        @RequestParam                \n\r\n\rUse the @RequestParam annotation to bind        request parameters to a method parameter in your controller.        \n\r\n\rThe following code snippet shows the usage:        @Controller@RequestMapping(\"/pets\")@SessionAttributes(\"pet\")public class EditPetForm {    // ...    @RequestMapping(method = RequestMethod.GET)    public String setupForm(@RequestParam(\"petId\") int petId, ModelMap model) {        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(\"pet\", pet);        return \"petForm\";    }    // ...        \n\r\n\rParameters using this annotation are required by default, but        you can specify that a parameter is optional by setting        @RequestParam\'s        required attribute to false        (e.g., @RequestParam(value=\"id\",        required=false)).        \n\r\n\rType conversion is applied automatically if the target method        parameter type is not String. See the section called &#8220;Method Parameters And Type Conversion&#8221;.            Mapping the request body with the @RequestBody        annotation                \n\r\n\rThe @RequestBody method parameter        annotation indicates that a method parameter should be bound to the        value of the HTTP request body. For example:        @RequestMapping(value = \"/something\", method = RequestMethod.PUT)public void handle(@RequestBody String body, Writer writer) throws IOException {  writer.write(body);}        \n\r\n\rYou convert the request body to the method argument by using an        HttpMessageConverter.        HttpMessageConverter is responsible for        converting from the HTTP request message to an object and converting        from an object to the HTTP response body. The        RequestMappingHandlerAdapter supports the        @RequestBody annotation with the following        default HttpMessageConverters:        \n\r            \n\r\n\rByteArrayHttpMessageConverter            converts byte arrays.          \n\r            \n\r\n\rStringHttpMessageConverter converts            strings.          \n\r            \n\r\n\rFormHttpMessageConverter converts            form data to/from a MultiValueMap&lt;String, String&gt;.          \n\r            \n\r\n\rSourceHttpMessageConverter converts            to/from a javax.xml.transform.Source.          \n\r        \n\r\n\rFor more information on these converters, see Message Converters. Also note        that if using the MVC namespace or the MVC Java config, a wider        range of message converters are registered by default.        See Enabling the MVC Java Config or        the MVC XML Namespace for more information.        \n\r\n\rIf you intend to read and write XML, you will need to configure        the MarshallingHttpMessageConverter with a        specific Marshaller and an        Unmarshaller implementation from the        org.springframework.oxm package. The example        below shows how to do that directly in your configuration but if        your application is configured through the MVC namespace or the        MVC Java config see Enabling        the MVC Java Config or the MVC XML Namespace instead.        &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;    &lt;property name=\"messageConverters\"&gt;      &lt;util:list id=\"beanList\"&gt;        &lt;ref bean=\"stringHttpMessageConverter\"/&gt;        &lt;ref bean=\"marshallingHttpMessageConverter\"/&gt;      &lt;/util:list&gt;    &lt;/property&lt;/bean&gt;&lt;bean id=\"stringHttpMessageConverter\"       class=\"org.springframework.http.converter.StringHttpMessageConverter\"/&gt;&lt;bean id=\"marshallingHttpMessageConverter\"      class=\"org.springframework.http.converter.xml.MarshallingHttpMessageConverter\"&gt;  &lt;property name=\"marshaller\" ref=\"castorMarshaller\" /&gt;  &lt;property name=\"unmarshaller\" ref=\"castorMarshaller\" /&gt;&lt;/bean&gt;&lt;bean id=\"castorMarshaller\" class=\"org.springframework.oxm.castor.CastorMarshaller\"/&gt;        \n\r\n\rAn @RequestBody method parameter can be        annotated with @Valid, in which case it will be        validated using the configured Validator        instance. When using the MVC namespace or the MVC Java config, a JSR-303 validator        is configured automatically assuming a JSR-303 implementation is        available on the classpath.        \n\r\n\rJust like with @ModelAttribute parameters,        an Errors argument can be used to examine the errors.        If such an argument is not declared, a        MethodArgumentNotValidException will be raised.        The exception is handled in the        DefaultHandlerExceptionResolver, which sends        a 400 error back to the client.        Note          \n\r\n\rAlso see Enabling the MVC          Java Config or the MVC XML Namespace for          information on configuring message converters and a validator          through the MVC namespace or the MVC Java config.                    Mapping the response body with the        @ResponseBody annotation                \n\r\n\rThe @ResponseBody annotation is        similar to @RequestBody. This        annotation can be put on a method and indicates that the return type        should be written straight to the HTTP response body (and not placed        in a Model, or interpreted as a view name). For example:        @RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld()  {  return \"Hello World\";}        \n\r\n\rThe above example will result in the text Hello        World being written to the HTTP response stream.        \n\r\n\rAs with @RequestBody, Spring        converts the returned object to a response body by using an        HttpMessageConverter. For more        information on these converters, see the previous section and Message Converters.            Using HttpEntity&lt;?&gt;                \n\r\n\rThe HttpEntity is similar to        @RequestBody and        @ResponseBody. Besides getting access        to the request and response body, HttpEntity        (and the response-specific subclass        ResponseEntity) also allows access to the        request and response headers, like so:        @RequestMapping(\"/something\")public ResponseEntity&lt;String&gt; handle(HttpEntity&lt;byte[]&gt; requestEntity) throws UnsupportedEncodingException {  String requestHeader = requestEntity.getHeaders().getFirst(\"MyRequestHeader\"));  byte[] requestBody = requestEntity.getBody();  // do something with request header and body  HttpHeaders responseHeaders = new HttpHeaders();  responseHeaders.set(\"MyResponseHeader\", \"MyValue\");  return new ResponseEntity&lt;String&gt;(\"Hello World\", responseHeaders, HttpStatus.CREATED);}        \n\r\n\rThe above example gets the value of the        MyRequestHeader request header, and reads the body        as a byte array. It adds the MyResponseHeader to        the response, writes Hello World to the response        stream, and sets the response status code to 201 (Created).        \n\r\n\rAs with @RequestBody and        @ResponseBody, Spring uses        HttpMessageConverter to convert from        and to the request and response streams. For more information on these        converters, see the previous section and Message Converters.            Using @ModelAttribute on a        method                \n\r\n\rThe @ModelAttribute annotation        can be used on methods or on method arguments. This section explains        its usage on methods while the next section explains its usage on        method arguments.        \n\r\n\rAn @ModelAttribute on a method        indicates the purpose of that method is to add one or more model        attributes. Such methods support the same argument types as        @RequestMapping methods but cannot be        mapped directly to requests. Instead        @ModelAttribute methods in a controller        are invoked before @RequestMapping        methods, within the same controller. A couple of examples:        // Add one attribute// The return value of the method is added to the model under the name \"account\"// You can customize the name via @ModelAttribute(\"myAccount\")@ModelAttributepublic Account addAccount(@RequestParam String number) {    return accountManager.findAccount(number);}// Add multiple attributes@ModelAttributepublic void populateModel(@RequestParam String number, Model model) {    model.addAttribute(accountManager.findAccount(number));    // add more ...}        \n\r\n\r@ModelAttribute methods are used        to populate the model with commonly needed attributes for example to        fill a drop-down with states or with pet types, or to retrieve a        command object like Account in order to use it to represent the data        on an HTML form. The latter case is further discussed in the next        section.        \n\r\n\rNote the two styles of        @ModelAttribute methods. In the first,        the method adds an attribute implicitly by returning it. In the        second, the method accepts a Model and adds any        number of model attributes to it. You can choose between the two        styles depending on your needs.        \n\r\n\rA controller can have any number of        @ModelAttribute methods. All such        methods are invoked before        @RequestMapping methods of the same        controller.        \n\r\n\r@ModelAttribute methods can also        be defined in an @ControllerAdvice-annotated        class and such methods apply to all controllers.        The @ControllerAdvice annotation is        a component annotation allowing implementation classes to be autodetected        through classpath scanning.        Tip          \n\r\n\rWhat happens when a model attribute name is not explicitly          specified? In such cases a default name is assigned to the model          attribute based on its type. For example if the method returns an          object of type Account, the default name used          is \"account\". You can change that through the value of the          @ModelAttribute annotation. If adding          attributes directly to the Model, use the          appropriate overloaded addAttribute(..) method -          i.e., with or without an attribute name.                \n\r\n\rThe @ModelAttribute annotation        can be used on @RequestMapping methods        as well. In that case the return value of the        @RequestMapping method is interpreted        as a model attribute rather than as a view name. The view name is        derived from view name conventions instead much like for methods        returning void &#8212; see Section&nbsp;17.12.3, &#8220;The View -      RequestToViewNameTranslator&#8221;.            Using @ModelAttribute on a        method argument                \n\r\n\rAs explained in the previous section        @ModelAttribute can be used on methods        or on method arguments. This section explains its usage on method        arguments.        \n\r\n\rAn @ModelAttribute on a method        argument indicates the argument should be retrieved from the model. If        not present in the model, the argument should be instantiated first        and then added to the model. Once present in the model, the argument\'s        fields should be populated from all request parameters that have        matching names. This is known as data binding in Spring MVC, a very        useful mechanism that saves you from having to parse each form field        individually.        @RequestMapping(value=\"/owners/{ownerId}/pets/{petId}/edit\", method = RequestMethod.POST)public String processSubmit(@ModelAttribute Pet pet) {}        \n\r\n\rGiven the above example where can the Pet instance come from?        There are several options:        \n\r            \n\r\n\rIt may already be in the model due to use of            @SessionAttributes &#8212; see the section called &#8220;Using @SessionAttributes to store model        attributes in the HTTP session between requests&#8221;.          \n\r            \n\r\n\rIt may already be in the model due to an            @ModelAttribute method in the same            controller &#8212; as explained in the previous section.          \n\r            \n\r\n\rIt may be retrieved based on a URI template variable and            type converter (explained in more detail below).          \n\r            \n\r\n\rIt may be instantiated using its default constructor.          \n\r        \n\r\n\rAn @ModelAttribute method is a        common way to to retrieve an attribute from the database, which may        optionally be stored between requests through the use of        @SessionAttributes. In some cases it        may be convenient to retrieve the attribute by using an URI template        variable and a type converter. Here is an example:        @RequestMapping(value=\"/accounts/{account}\", method = RequestMethod.PUT)public String save(@ModelAttribute(\"account\") Account account) {}        \n\r\n\rIn this example the name of the model attribute (i.e. \"account\")        matches the name of a URI template variable. If you register        Converter&lt;String, Account&gt; that can turn        the String account value into an        Account instance, then the above example will        work without the need for an        @ModelAttribute method.        \n\r\n\rThe next step is data binding. The        WebDataBinder class matches request parameter        names &#8212; including query string parameters and form fields &#8212; to model        attribute fields by name. Matching fields are populated after type        conversion (from String to the target field type) has been applied        where necessary. Data binding and validation are covered in Chapter&nbsp;7, Validation, Data Binding, and Type Conversion. Customizing the data binding process for a        controller level is covered in the section called &#8220;Customizing WebDataBinder        initialization&#8221;.        \n\r\n\rAs a result of data binding there may be errors such as missing        required fields or type conversion errors. To check for such errors        add a BindingResult argument immediately        following the @ModelAttribute        argument:        @RequestMapping(value=\"/owners/{ownerId}/pets/{petId}/edit\", method = RequestMethod.POST)public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) {    if (result.hasErrors()) {        return \"petForm\";    }    // ...}        \n\r\n\rWith a BindingResult you can check if        errors were found in which case it\'s common to render the same form        where the errors can be shown with the help of Spring\'s        &lt;errors&gt; form tag.        \n\r\n\rIn addition to data binding you can also invoke validation using        your own custom validator passing the same        BindingResult that was used to record data        binding errors. That allows for data binding and validation errors to        be accumulated in one place and subsequently reported back to the        user:        @RequestMapping(value=\"/owners/{ownerId}/pets/{petId}/edit\", method = RequestMethod.POST)public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) {    new PetValidator().validate(pet, result);    if (result.hasErrors()) {        return \"petForm\";    }    // ...}        \n\r\n\rOr you can have validation invoked automatically by adding the        JSR-303 @Valid annotation:        @RequestMapping(value=\"/owners/{ownerId}/pets/{petId}/edit\", method = RequestMethod.POST)public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) {    if (result.hasErrors()) {        return \"petForm\";    }    // ...}        \n\r\n\rSee Section&nbsp;7.8, &#8220;Spring 3 Validation&#8221; and Chapter&nbsp;7, Validation, Data Binding, and Type Conversion for details on how to configure and use        validation.            Using @SessionAttributes to store model        attributes in the HTTP session between requests                \n\r\n\rThe type-level @SessionAttributes        annotation declares session attributes used by a specific handler.        This will typically list the names of model attributes or types of        model attributes which should be transparently stored in the session        or some conversational storage, serving as form-backing beans between        subsequent requests.        \n\r\n\rThe following code snippet shows the usage of this annotation,        specifying the model attribute name:        @Controller@RequestMapping(\"/editPet.do\")@SessionAttributes(\"pet\")public class EditPetForm {    // ...}        Note          \n\r\n\rWhen using controller interfaces (e.g., for AOP proxying),          make sure to consistently put all your mapping          annotations - such as @RequestMapping          and @SessionAttributes - on the          controller interface rather than on the          implementation class.                    Specifying redirect and flash attributes                \n\r\n\rBy default all model attributes are considered to be exposed as        URI template variables in the redirect URL. Of the remaining        attributes those that are primitive types or collections/arrays of        primitive types are automatically appended as query parameters.        \n\r\n\rIn annotated controllers however the model may contain        additional attributes originally added for rendering purposes (e.g.        drop-down field values). To gain precise control over the attributes        used in a redirect scenario, an        @RequestMapping method can declare an        argument of type RedirectAttributes and        use it to add attributes for use in        RedirectView. If the controller method does        redirect, the content of        RedirectAttributes is used. Otherwise        the content of the default Model is        used.        \n\r\n\rThe RequestMappingHandlerAdapter provides        a flag called \"ignoreDefaultModelOnRedirect\" that        can be used to indicate the content of the default        Model should never be used if a        controller method redirects. Instead the controller method should        declare an attribute of type        RedirectAttributes or if it doesn\'t do        so no attributes should be passed on to        RedirectView. Both the MVC namespace and the        MVC Java config keep this flag set to false in order to maintain        backwards compatibility. However, for new applications we recommend        setting it to true        \n\r\n\rThe RedirectAttributes interface        can also be used to add flash attributes. Unlike other redirect        attributes, which end up in the target redirect URL, flash attributes        are saved in the HTTP session (and hence do not appear in the URL).        The model of the controller serving the target redirect URL        automatically receives these flash attributes after which they are        removed from the session. See Section&nbsp;17.6, &#8220;Using flash attributes&#8221;        for an overview of the general support for flash attributes in Spring        MVC.            Working with        \"application/x-www-form-urlencoded\" data                \n\r\n\rThe previous sections covered use of        @ModelAttribute to support form        submission requests from browser clients. The same annotation is        recommended for use with requests from non-browser clients as well.        However there is one notable difference when it comes to working with        HTTP PUT requests. Browsers can submit form data via HTTP GET or HTTP        POST. Non-browser clients can also submit forms via HTTP PUT. This        presents a challenge because the Servlet specification requires the        ServletRequest.getParameter*() family of methods to        support form field access only for HTTP POST, not for HTTP PUT.        \n\r\n\rTo support HTTP PUT and PATCH requests, the spring-web        module provides the filter        HttpPutFormContentFilter, which can be        configured in web.xml:        &lt;filter&gt;  &lt;filter-name&gt;httpPutFormFilter&lt;/filter-name&gt;  &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;httpPutFormFilter&lt;/filter-name&gt;  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;&lt;/filter-mapping&gt;&lt;servlet&gt;  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;        \n\r\n\rThe above filter intercepts HTTP PUT and PATCH requests with content type        application/x-www-form-urlencoded, reads the form        data from the body of the request, and wraps the        ServletRequest in order to make the form data        available through the        ServletRequest.getParameter*() family of        methods.        Note          \n\r\n\rAs HttpPutFormContentFilter consumes the body of the          request, it should not be configured for PUT or PATCH URLs that rely on other          converters for application/x-www-form-urlencoded. This includes          @RequestBody MultiValueMap&lt;String, String&gt; and          HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;.                    Mapping cookie values with the @CookieValue annotation                \n\r\n\rThe @CookieValue annotation        allows a method parameter to be bound to the value of an HTTP        cookie.        \n\r\n\rLet us consider that the following cookie has been received with        an http request:        JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84        \n\r\n\rThe following code sample demonstrates how to get the value of        the JSESSIONID cookie:        @RequestMapping(\"/displayHeaderInfo.do\")public void displayHeaderInfo(@CookieValue(\"JSESSIONID\") String cookie)  {  //...}        \n\r\n\rType conversion is applied automatically if the target method        parameter type is not String. See the section called &#8220;Method Parameters And Type Conversion&#8221;.        \n\r\n\rThis annotation is supported for annotated handler methods in        Servlet and Portlet environments.            Mapping request header attributes with the @RequestHeader        annotation                \n\r\n\rThe @RequestHeader annotation        allows a method parameter to be bound to a request header.        \n\r\n\rHere is a sample request header:        Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300        \n\r\n\rThe following code sample demonstrates how to get the value of        the Accept-Encoding and        Keep-Alive headers:        @RequestMapping(\"/displayHeaderInfo.do\")public void displayHeaderInfo(@RequestHeader(\"Accept-Encoding\") String encoding,                              @RequestHeader(\"Keep-Alive\") long keepAlive)  {  //...}        \n\r\n\rType conversion is applied automatically if the method parameter        is not String. See the section called &#8220;Method Parameters And Type Conversion&#8221;.        Tip          \n\r\n\rBuilt-in support is available for converting a comma-separated          string into an array/collection of strings or other types known to          the type conversion system. For example a method parameter annotated          with @RequestHeader(\"Accept\") may be of type          String but also          String[] or          List&lt;String&gt;.                \n\r\n\rThis annotation is supported for annotated handler methods in        Servlet and Portlet environments.            Method Parameters And Type Conversion                \n\r\n\rString-based values extracted from the request including request        parameters, path variables, request headers, and cookie values may        need to be converted to the target type of the method parameter or        field (e.g., binding a request parameter to a field in an        @ModelAttribute parameter) they\'re        bound to. If the target type is not String,        Spring automatically converts to the appropriate type. All simple        types such as int, long, Date, etc. are supported. You can further        customize the conversion process through a        WebDataBinder (see the section called &#8220;Customizing WebDataBinder        initialization&#8221;) or by registering        Formatters with the        FormattingConversionService (see Section&nbsp;7.6, &#8220;Spring 3 Field Formatting&#8221;).            Customizing WebDataBinder        initialization                \n\r\n\rTo customize request parameter binding with PropertyEditors        through Spring\'s WebDataBinder, you can use        @InitBinder-annotated methods within        your controller, @InitBinder methods        within an @ControllerAdvice class,        or provide a custom        WebBindingInitializer.        Customizing data binding with          @InitBinder                    \n\r\n\rAnnotating controller methods with          @InitBinder allows you to configure          web data binding directly within your controller class.          @InitBinder identifies methods that          initialize the WebDataBinder that will be          used to populate command and form object arguments of annotated          handler methods.          \n\r\n\rSuch init-binder methods support all arguments that          @RequestMapping supports, except for          command/form objects and corresponding validation result objects.          Init-binder methods must not have a return value. Thus, they are          usually declared as void. Typical arguments          include WebDataBinder in combination with          WebRequest or          java.util.Locale, allowing code to register          context-specific editors.          \n\r\n\rThe following example demonstrates the use of          @InitBinder to configure a          CustomDateEditor for all          java.util.Date form properties.          @Controllerpublic class MyFormController {    @InitBinder    public void initBinder(WebDataBinder binder) {        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");        dateFormat.setLenient(false);        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));    }    // ...}                Configuring a custom          WebBindingInitializer                    \n\r\n\rTo externalize data binding initialization, you can provide a          custom implementation of the          WebBindingInitializer interface,          which you then enable by supplying a custom bean configuration for          an AnnotationMethodHandlerAdapter, thus          overriding the default configuration.          \n\r\n\rThe following example from the PetClinic application shows a          configuration using a custom implementation of the          WebBindingInitializer interface,          org.springframework.samples.petclinic.web.ClinicBindingInitializer,          which configures PropertyEditors required by several of the          PetClinic controllers.          &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;    &lt;property name=\"cacheSeconds\" value=\"0\" /&gt;    &lt;property name=\"webBindingInitializer\"&gt;        &lt;bean class=\"org.springframework.samples.petclinic.web.ClinicBindingInitializer\" /&gt;    &lt;/property&gt;&lt;/bean&gt;                Customizing data binding with externalized          @InitBinder methods                    \n\r\n\r@InitBinder methods can also          be defined in an @ControllerAdvice-annotated          class in which case they apply to all controllers. This provides an          alternative to using a WebBindingInitializer.                    \n\r\n\rThe @ControllerAdvice annotation is          a component annotation allowing implementation classes to be autodetected          through classpath scanning.                    Support for the \'Last-Modified\' Response Header To Facilitate        Content Caching                \n\r\n\rAn @RequestMapping method may        wish to support \'Last-Modified\' HTTP requests, as        defined in the contract for the Servlet API\'s        getLastModified method, to facilitate content        caching. This involves calculating a lastModified        long value for a given request, comparing it        against the \'If-Modified-Since\' request header        value, and potentially returning a response with status code 304 (Not        Modified). An annotated controller method can achieve that as        follows:        @RequestMappingpublic String myHandleMethod(WebRequest webRequest, Model model) {    long lastModified = // 1. application-specific calculation    if (request.checkNotModified(lastModified)) {        // 2. shortcut exit - no further processing necessary        return null;     }    // 3. or otherwise further request processing, actually preparing content    model.addAttribute(...);    return \"myViewName\";}        \n\r\n\rThere are two key elements to note: calling        request.checkNotModified(lastModified) and returning        null. The former sets the response status to 304        before it returns true. The latter, in combination        with the former, causes Spring MVC to do no further processing of the        request.              17.3.4&nbsp;Asynchronous Request Processing            \n\r\n\rSpring MVC 3.2 introduced Servlet 3 based asynchronous request      processing. Instead of returning a value, as usual, a controller method      can now return a java.util.concurrent.Callable      and produce the return value from a separate thread. Meanwhile the main Servlet      container thread is released and allowed to process other requests.      Spring MVC invokes the Callable in a      separate thread with the help of a TaskExecutor      and when the Callable returns, the      request is dispatched back to the Servlet container to resume      processing with the value returned by the      Callable.      Here is an example controller method:      @RequestMapping(method=RequestMethod.POST)public Callable&lt;String&gt; processUpload(final MultipartFile file) {  return new Callable&lt;String&gt;() {    public Object call() throws Exception {      // ...      return \"someView\";    }  };}      \n\r\n\rA second option is for the controller to return an instance of      DeferredResult. In this case the return value      will also be produced from a separate thread. However, that thread is not      known to Spring MVC. For example the result may be produced in response      to some external event such as a JMS message, a scheduled task, etc.      Here is an example controller method:      @RequestMapping(\"/quotes\")@ResponseBodypublic DeferredResult&lt;String&gt; quotes() {  DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();  // Save the deferredResult in in-memory queue ...  return deferredResult;}// In some other thread...deferredResult.setResult(data);      \n\r\n\rThis may be difficult to understand without any knowledge of the      Servlet 3 async processing feature. It would certainly help to read up on it.      At a very minimum consider the following basic facts:      \n\r          \n\r\n\rA ServletRequest          can be put in asynchronous mode by calling          request.startAsync(). The main effect of doing so is          that the Servlet, as well as any Filters, can exit but the response          will remain open allowing some other thread to complete processing.                  \n\r          \n\r\n\rThe call to request.startAsync() returns an          AsyncContext, which can be used for          further control over async processing. For example it provides          the method dispatch, which can be called from an          application thread in order to \"dispatch\" the request back to          the Servlet container. An async dispatch is similar to a forward          except it is made from one (application) thread to another          (Servlet container) thread whereas a forward occurs synchronously          in the same (Servlet container) thread.        \n\r          \n\r\n\rServletRequest provides access          to the current DispatcherType, which          can be used to distinguish if a Servlet or          a Filter is processing on          the initial request processing thread and when it is processing in          an async dispatch.        \n\r      \n\r\n\rWith the above in mind, the following is the sequence      of events for async request processing with a Callable:      (1) Controller returns a      Callable, (2) Spring MVC starts async processing      and submits the Callable      to a TaskExecutor      for processing in a separate thread, (3) the DispatcherServlet      and all Filter\'s exit the request processing thread but the response      remains open, (4) the Callable produces a result      and Spring MVC dispatches the request back to the Servlet container,      (5) the DispatcherServlet is invoked again and processing      resumes with the asynchronously produced result from the      Callable. The exact sequencing of (2),      (3), and (4) may vary depending on the speed of execution of the      concurrent threads.            \n\r\n\rThe sequence of events for async request processing with a      DeferredResult is the same in principal except      it\'s up to the application to produce the asynchronous result from some thread:      (1) Controller returns a DeferredResult and saves it      in some in-memory queue or list where it can be accessed,      (2) Spring MVC starts async processing, (3) the DispatcherServlet      and all configured Filter\'s exit the request processing thread but the response      remains open, (4) the application sets the DeferredResult      from some thread and Spring MVC dispatches the request back to the Servlet container,      (5) the DispatcherServlet is invoked again and processing      resumes with the asynchronously produced result.            \n\r\n\rExplaining the motivation for async request processing and when or why to use it      are beyond the scope of this document. For further information you may wish to read      this blog post series.            Exception Handling for Async Requests                \n\r\n\rWhat happens if a Callable returned        from a controller method raises an Exception while being executed?        The effect is similar to what happens when any controller method raises        an exception. It is handled by a matching        @ExceptionHandler method in the same        controller or by one of the configured        HandlerExceptionResolver instances.        Note          \n\r\n\rUnder the covers, when a Callable          raises an Exception, Spring MVC still dispatches to the Servlet          container to resume processing. The only difference is that the          result of executing the Callable          is an Exception that must be processed          with the configured          HandlerExceptionResolver instances.                \n\r\n\rWhen using a DeferredResult, you have        a choice of calling its setErrorResult(Object) method        and provide an Exception or any other Object        you\'d like to use as the result. If the result is an        Exception, it will be processed with a        matching @ExceptionHandler method in the        same controller or with any configured        HandlerExceptionResolver instance.            Intercepting Async Requests                \n\r\n\rAn existing HandlerInterceptor can        implement AsyncHandlerInterceptor, which        provides one additional method afterConcurrentHandlingStarted.        It is invoked after async processing starts and when the initial        request processing thread is being exited. See the Javadoc of        AsyncHandlerInterceptor for more details        on that.        \n\r\n\rFurther options for async request lifecycle callbacks are        provided directly on DeferredResult,        which has the methods onTimeout(Runnable) and        onCompletion(Runnable). Those are called when the        async request is about to time out or has completed respectively.        The timeout event can be handled by setting the        DeferredResult to some value.        The completion callback however is final and the result can no        longer be set.        \n\r\n\rSimilar callbacks are also available with a        Callable. However, you will need to wrap        the Callable in an instance of        WebAsyncTask and then use that to register        the timeout and completion callbacks. Just like with        DeferredResult, the timeout event can be        handled and a value can be returned while the completion event is final.        \n\r\n\rYou can also register a        CallableProcessingInterceptor or a        DeferredResultProcessingInterceptor        globally through the MVC Java config or the MVC namespace.        Those interceptors provide a full set of callbacks and apply every        time a Callable or a        DeferredResult is used.            Configuration for Async Request Processing                Servlet 3 Async Config                    \n\r\n\rTo use Servlet 3 async request processing, you need to update          web.xml to version 3.0:          &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"    version=\"3.0\"&gt;    ...  &lt;/web-app&gt;            \n\r\n\rThe DispatcherServlet and any          Filter configuration need to have          the &lt;async-supported&gt;true&lt;/async-supported&gt; sub-element.          Additionally, any Filter that also needs          to get involved in async dispatches should also be configured          to support the ASYNC dispatcher type. Note that it is safe          to enable the ASYNC dispatcher type for all filters provided with          the Spring Framework since they will not get involved in async          dispatches unless needed.          \n\r\n\rIf using Servlet 3, Java based configuration, e.g. via          WebApplicationInitializer, you\'ll          also need to set the \"asyncSupported\" flag as well as the          ASYNC dispatcher type just like with web.xml.          To simplify all this configuration, consider          extending AbstractDispatcherServletInitializer          or AbstractAnnotationConfigDispatcherServletInitializer,          which automatically set those options and make it very easy to register          Filter instances.                Spring MVC Async Config                    \n\r\n\rThe MVC Java config and the MVC namespace both provide options for          configuring async request processing.          WebMvcConfigurer has the method          configureAsyncSupport while &lt;mvc:annotation-driven&gt;          has an &lt;async-support&gt; sub-element.          \n\r\n\rThose allow you to configure the default timeout value to use for          async requests, which if not set depends on the underlying Servlet          container (e.g. 10 seconds on Tomcat). You can also configure an          AsyncTaskExecutor to use for executing          Callable instances returned from          controller methods. It is highly recommended to configure this property          since by default Spring MVC uses          SimpleAsyncTaskExecutor. The MVC Java config          and the MVC namespace also allow you to register          CallableProcessingInterceptor and          DeferredResultProcessingInterceptor          instances.          \n\r\n\rIf you need to override the default timeout value for a          specific DeferredResult, you can do so by using          the appropriate class constructor. Similarly, for a          Callable, you can wrap it in a          WebAsyncTask and use the appropriate class          constructor to customize the timeout value. The class constructor of          WebAsyncTask also allows providing          an AsyncTaskExecutor.                      17.3.5&nbsp;Testing Controllers            \n\r\n\rThe spring-test module offers first class support      for testing annotated controllers.      See Section&nbsp;11.3.6, &#8220;Spring MVC Test Framework&#8221;.        17.4&nbsp;Handler mappings        \n\r\n\rIn previous versions of Spring, users were required to define one or    more HandlerMapping beans in the web    application context to map incoming web requests to appropriate handlers.    With the introduction of annotated controllers, you generally don\'t need    to do that because the RequestMappingHandlerMapping    automatically looks for @RequestMapping    annotations on all @Controller beans.    However, do keep in mind that all HandlerMapping    classes extending from AbstractHandlerMapping have    the following properties that you can use to customize their    behavior:    interceptors          \n\r\n\rList of interceptors to use.          HandlerInterceptors are discussed in          Section&nbsp;17.4.1, &#8220;Intercepting requests with a      HandlerInterceptor&#8221;.        defaultHandler          \n\r\n\rDefault handler to use, when this handler mapping does not          result in a matching handler.        order          \n\r\n\rBased on the value of the order property (see the          org.springframework.core.Ordered interface),          Spring sorts all handler mappings available in the context and          applies the first matching handler.        alwaysUseFullPath          \n\r\n\rIf true , Spring uses the full path within          the current Servlet context to find an appropriate handler. If          false (the default), the path within the current          Servlet mapping is used. For example, if a Servlet is mapped using          /testing/* and the          alwaysUseFullPath property is set to true,          /testing/viewPage.html is used, whereas if the          property is set to false, /viewPage.html is          used.        urlDecode          \n\r\n\rDefaults to true, as of Spring 2.5. If you          prefer to compare encoded paths, set this flag to          false. However, the          HttpServletRequest always exposes the          Servlet path in decoded form. Be aware that the Servlet path will          not match when compared with encoded paths.            \n\r\n\rThe following example shows how to configure an interceptor:    &lt;beans&gt;  &lt;bean id=\"handlerMapping\" class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt;    &lt;property name=\"interceptors\"&gt;      &lt;bean class=\"example.MyInterceptor\"/&gt;    &lt;/property&gt;  &lt;/bean&gt;&lt;beans&gt;    17.4.1&nbsp;Intercepting requests with a      HandlerInterceptor            \n\r\n\rSpring\'s handler mapping mechanism includes handler interceptors,      which are useful when you want to apply specific functionality to      certain requests, for example, checking for a principal.      \n\r\n\rInterceptors located in the handler mapping must implement      HandlerInterceptor from the      org.springframework.web.servlet package. This      interface defines three methods: preHandle(..) is      called before the actual handler is executed;      postHandle(..) is called after      the handler is executed; and afterCompletion(..) is      called after the complete request has finished.      These three methods should provide enough flexibility to do all kinds of      preprocessing and postprocessing.      \n\r\n\rThe preHandle(..) method returns a boolean      value. You can use this method to break or continue the processing of      the execution chain. When this method returns true,      the handler execution chain will continue; when it returns false, the      DispatcherServlet assumes the interceptor itself      has taken care of requests (and, for example, rendered an appropriate      view) and does not continue executing the other interceptors and the      actual handler in the execution chain.      \n\r\n\rInterceptors can be configured using the      interceptors property, which is present on all      HandlerMapping classes extending from      AbstractHandlerMapping. This is shown in the      example below:      &lt;beans&gt;    &lt;bean id=\"handlerMapping\"          class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt;        &lt;property name=\"interceptors\"&gt;            &lt;list&gt;                &lt;ref bean=\"officeHoursInterceptor\"/&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"officeHoursInterceptor\"          class=\"samples.TimeBasedAccessInterceptor\"&gt;        &lt;property name=\"openingTime\" value=\"9\"/&gt;        &lt;property name=\"closingTime\" value=\"18\"/&gt;    &lt;/bean&gt;&lt;beans&gt;      package samples;public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {    private int openingTime;    private int closingTime;    public void setOpeningTime(int openingTime) {        this.openingTime = openingTime;    }    public void setClosingTime(int closingTime) {        this.closingTime = closingTime;    }    public boolean preHandle(            HttpServletRequest request,            HttpServletResponse response,            Object handler) throws Exception {        Calendar cal = Calendar.getInstance();        int hour = cal.get(HOUR_OF_DAY);        if (openingTime &lt;= hour &amp;&amp; hour &lt; closingTime) {            return true;        } else {            response.sendRedirect(\"http://host.com/outsideOfficeHours.html\");            return false;        }    }}      \n\r\n\rAny request handled by this mapping is intercepted by the      TimeBasedAccessInterceptor. If the current time      is outside office hours, the user is redirected to a static HTML file      that says, for example, you can only access the website during office      hours.      Note        \n\r\n\rWhen using the        RequestMappingHandlerMapping the actual handler        is an instance of HandlerMethod which        identifies the specific controller method that will be invoked.            \n\r\n\rAs you can see, the Spring adapter class      HandlerInterceptorAdapter makes it easier to      extend the HandlerInterceptor      interface.      Tip        \n\r\n\rIn the example above, the configured interceptor will apply to        all requests handled with annotated controller methods. If you want to        narrow down the URL paths to which an interceptor applies, you can use        the MVC namespace or the MVC Java config, or declare bean instances        of type MappedInterceptor to do that. See Enabling the MVC Java Config or the MVC        XML Namespace.              17.5&nbsp;Resolving views        \n\r\n\rAll MVC frameworks for web applications provide a way to address    views. Spring provides view resolvers, which enable you to render models    in a browser without tying you to a specific view technology. Out of the    box, Spring enables you to use JSPs, Velocity templates and XSLT views,    for example. See Chapter&nbsp;18, View technologies for a discussion of how to    integrate and use a number of disparate view technologies.    \n\r\n\rThe two interfaces that are important to the way Spring handles    views are ViewResolver and    View. The    ViewResolver provides a mapping between    view names and actual views. The View    interface addresses the preparation of the request and hands the request    over to one of the view technologies.    17.5.1&nbsp;Resolving views with the      ViewResolver interface            \n\r\n\rAs discussed in Section&nbsp;17.3, &#8220;Implementing Controllers&#8221;, all handler      methods in the Spring Web MVC controllers must resolve to a logical view      name, either explicitly (e.g., by returning a String,      View, or ModelAndView) or      implicitly (i.e., based on conventions). Views in Spring are addressed      by a logical view name and are resolved by a view resolver. Spring comes      with quite a few view resolvers. This table lists most of them; a couple      of examples follow.      \n\r\n\rTable&nbsp;17.3.&nbsp;View resolvers                ViewResolverDescriptionAbstractCachingViewResolverAbstract view resolver that caches views. Often views              need preparation before they can be used; extending this view              resolver provides caching.XmlViewResolverImplementation of              ViewResolver that accepts a              configuration file written in XML with the same DTD as Spring\'s              XML bean factories. The default configuration file is              /WEB-INF/views.xml.ResourceBundleViewResolverImplementation of              ViewResolver that uses bean              definitions in a ResourceBundle,              specified by the bundle base name. Typically you define the              bundle in a properties file, located in the classpath. The              default file name is              views.properties.UrlBasedViewResolverSimple implementation of the              ViewResolver interface that              effects the direct resolution of logical view names to URLs,              without an explicit mapping definition. This is appropriate if              your logical names match the names of your view resources in a              straightforward manner, without the need for arbitrary              mappings.InternalResourceViewResolverConvenient subclass of              UrlBasedViewResolver that supports              InternalResourceView (in effect, Servlets              and JSPs) and subclasses such as JstlView              and TilesView. You can specify the view              class for all views generated by this resolver by using              setViewClass(..). See the Javadocs for the              UrlBasedViewResolver class for              details.VelocityViewResolver /              FreeMarkerViewResolverConvenient subclass of              UrlBasedViewResolver that supports              VelocityView (in effect, Velocity              templates) or FreeMarkerView              ,respectively, and custom subclasses of them.ContentNegotiatingViewResolverImplementation of the              ViewResolver interface that              resolves a view based on the request file name or              Accept header. See Section&nbsp;17.5.4, &#8220;ContentNegotiatingViewResolver&#8221;.      \n\r      \n\r\n\rAs an example, with JSP as a view technology, you can use the      UrlBasedViewResolver. This view resolver      translates a view name to a URL and hands the request over to the      RequestDispatcher to render the view.      &lt;bean id=\"viewResolver\"      class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt;    &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt;    &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;    &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;      \n\r\n\rWhen returning test as a logical view name,      this view resolver forwards the request to the      RequestDispatcher that will send the request to      /WEB-INF/jsp/test.jsp.      \n\r\n\rWhen you combine different view technologies in a web application,      you can use the      ResourceBundleViewResolver:      &lt;bean id=\"viewResolver\"      class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\"&gt;    &lt;property name=\"basename\" value=\"views\"/&gt;    &lt;property name=\"defaultParentView\" value=\"parentView\"/&gt;&lt;/bean&gt;      \n\r\n\rThe ResourceBundleViewResolver inspects the      ResourceBundle identified by the basename, and      for each view it is supposed to resolve, it uses the value of the      property [viewname].(class) as the view class and the      value of the property [viewname].url as the view url.      Examples can be found in the next chapter which covers view      technologies. As you can see, you can identify a parent view, from which      all views in the properties file &#8220;extend&#8221;. This way you can      specify a default view class, for example.      Note        \n\r\n\rSubclasses of AbstractCachingViewResolver        cache view instances that they resolve. Caching improves performance        of certain view technologies. It\'s possible to turn off the cache by        setting the cache property to        false. Furthermore, if you must refresh a certain        view at runtime (for example when a Velocity template is modified),        you can use the removeFromCache(String viewName, Locale        loc) method.              17.5.2&nbsp;Chaining ViewResolvers            \n\r\n\rSpring supports multiple view resolvers. Thus you can chain      resolvers and, for example, override specific views in certain      circumstances. You chain view resolvers by adding more than one resolver      to your application context and, if necessary, by setting the      order property to specify ordering. Remember, the      higher the order property, the later the view resolver is positioned in      the chain.      \n\r\n\rIn the following example, the chain of view resolvers consists of      two resolvers, an InternalResourceViewResolver,      which is always automatically positioned as the last resolver in the      chain, and an XmlViewResolver for specifying      Excel views. Excel views are not supported by the      InternalResourceViewResolver.      &lt;bean id=\"jspViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;  &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt;  &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;  &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;&lt;bean id=\"excelViewResolver\" class=\"org.springframework.web.servlet.view.XmlViewResolver\"&gt;  &lt;property name=\"order\" value=\"1\"/&gt;  &lt;property name=\"location\" value=\"/WEB-INF/views.xml\"/&gt;&lt;/bean&gt;&lt;!-- in views.xml --&gt;&lt;beans&gt;  &lt;bean name=\"report\" class=\"org.springframework.example.ReportExcelView\"/&gt;&lt;/beans&gt;      \n\r\n\rIf a specific view resolver does not result in a view, Spring      examines the context for other view resolvers. If additional view      resolvers exist, Spring continues to inspect them until a view is      resolved. If no view resolver returns a view, Spring throws a      ServletException.      \n\r\n\rThe contract of a view resolver specifies that a view resolver      can return null to indicate the view could not be      found. Not all view resolvers do this, however, because in some cases,      the resolver simply cannot detect whether or not the view exists. For      example, the InternalResourceViewResolver uses      the RequestDispatcher internally, and dispatching      is the only way to figure out if a JSP exists, but this action can only      execute once. The same holds for the      VelocityViewResolver and some others. Check the      Javadoc for the view resolver to see whether it reports non-existing      views. Thus, putting an      InternalResourceViewResolver in the chain in a      place other than the last, results in the chain not being fully      inspected, because the      InternalResourceViewResolver will      always return a view!        17.5.3&nbsp;Redirecting to views            \n\r\n\rAs mentioned previously, a controller typically returns a logical      view name, which a view resolver resolves to a particular view      technology. For view technologies such as JSPs that are processed      through the Servlet or JSP engine, this resolution is usually handled      through the combination of      InternalResourceViewResolver and      InternalResourceView, which issues an internal      forward or include via the Servlet API\'s      RequestDispatcher.forward(..) method or      RequestDispatcher.include() method. For other view      technologies, such as Velocity, XSLT, and so on, the view itself writes      the content directly to the response stream.      \n\r\n\rIt is sometimes desirable to issue an HTTP redirect back to the      client, before the view is rendered. This is desirable, for example,      when one controller has been called with POSTed data,      and the response is actually a delegation to another controller (for      example on a successful form submission). In this case, a normal      internal forward will mean that the other controller will also see the      same POST data, which is potentially problematic if      it can confuse it with other expected data. Another reason to perform a      redirect before displaying the result is to eliminate the possibility of      the user submitting the form data multiple times. In this scenario, the      browser will first send an initial POST; it will then      receive a response to redirect to a different URL; and finally the      browser will perform a subsequent GET for the URL      named in the redirect response. Thus, from the perspective of the      browser, the current page does not reflect the result of a      POST but rather of a GET. The end      effect is that there is no way the user can accidentally      re-POST the same data by performing a refresh. The      refresh forces a GET of the result page, not a resend      of the initial POST data.      RedirectView                \n\r\n\rOne way to force a redirect as the result of a controller        response is for the controller to create and return an instance of        Spring\'s RedirectView. In this case,        DispatcherServlet does not use the normal view        resolution mechanism. Rather because it has been given the (redirect)        view already, the DispatcherServlet simply        instructs the view to do its work.        \n\r\n\rThe RedirectView issues an        HttpServletResponse.sendRedirect() call that        returns to the client browser as an HTTP redirect. By default all        model attributes are considered to be exposed as URI template        variables in the redirect URL. Of the remaining attributes those that        are primitive types or collections/arrays of primitive types are        automatically appended as query parameters.        \n\r\n\rAppending primitive type attributes as query parameters may be        the desired result if a model instance was prepared specifically for        the redirect. However, in annotated controllers the model may contain        additional attributes added for rendering purposes (e.g. drop-down        field values). To avoid the possibility of having such attributes        appear in the URL an annotated controller can declare an argument of        type RedirectAttributes and use it to        specify the exact attributes to make available to        RedirectView. If the controller method decides        to redirect, the content of        RedirectAttributes is used. Otherwise        the content of the model is used.        \n\r\n\rNote that URI template variables from the present request are        automatically made available when expanding a redirect URL and do not        need to be added explicitly neither through        Model nor        RedirectAttributes. For example:        @RequestMapping(value = \"/files/{path}\", method = RequestMethod.POST)public String upload(...) {    // ...    return \"redirect:files/{path}\";}        \n\r\n\rIf you use RedirectView and the view is        created by the controller itself, it is recommended that you configure        the redirect URL to be injected into the controller so that it is not        baked into the controller but configured in the context along with the        view names. The next section discusses this process.            The redirect: prefix                \n\r\n\rWhile the use of RedirectView works fine,        if the controller itself creates the        RedirectView, there is no avoiding the fact        that the controller is aware that a redirection is happening. This is        really suboptimal and couples things too tightly. The controller        should not really care about how the response gets handled. In general        it should operate only in terms of view names that have been injected        into it.        \n\r\n\rThe special redirect: prefix allows you to        accomplish this. If a view name is returned that has the prefix        redirect:, the        UrlBasedViewResolver (and all subclasses) will        recognize this as a special indication that a redirect is needed. The        rest of the view name will be treated as the redirect URL.        \n\r\n\rThe net effect is the same as if the controller had returned a        RedirectView, but now the controller itself can        simply operate in terms of logical view names. A logical view name        such as redirect:/myapp/some/resource will redirect        relative to the current Servlet context, while a name such as        redirect:http://myhost.com/some/arbitrary/path will        redirect to an absolute URL.            The forward: prefix                \n\r\n\rIt is also possible to use a special forward:        prefix for view names that are ultimately resolved by        UrlBasedViewResolver and subclasses. This        creates an InternalResourceView (which        ultimately does a RequestDispatcher.forward())        around the rest of the view name, which is considered a URL.        Therefore, this prefix is not useful with        InternalResourceViewResolver and        InternalResourceView (for JSPs for example).        But the prefix can be helpful when you are primarily using another        view technology, but still want to force a forward of a resource to be        handled by the Servlet/JSP engine. (Note that you may also chain        multiple view resolvers, instead.)        \n\r\n\rAs with the redirect: prefix, if the view        name with the forward: prefix is injected into the        controller, the controller does not detect that anything special is        happening in terms of handling the response.              17.5.4&nbsp;ContentNegotiatingViewResolver            \n\r\n\rThe ContentNegotiatingViewResolver does not      resolve views itself but rather delegates to other view resolvers,      selecting the view that resembles the representation requested by the      client. Two strategies exist for a client to request a representation      from the server:      \n\r          \n\r\n\rUse a distinct URI for each resource, typically by using a          different file extension in the URI. For example, the URI          http://www.example.com/users/fred.pdf requests a PDF          representation of the user fred, and          http://www.example.com/users/fred.xml requests an          XML representation.        \n\r      \n\r          \n\r\n\rUse the same URI for the client to locate the resource, but          set the Accept HTTP request header to list the          media          types that it understands. For example, an HTTP request for          http://www.example.com/users/fred with an          Accept header set to application/pdf          requests a PDF representation of the user fred, while          http://www.example.com/users/fred with an          Accept header set to text/xml          requests an XML representation. This strategy is known as content          negotiation.        \n\r      Note        \n\r\n\rOne issue with the Accept header is that it        is impossible to set it in a web browser within HTML. For example, in        Firefox, it is fixed to:        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        \n\r\n\rFor this reason it is common to see the use of a distinct URI        for each representation when developing browser based web        applications.            \n\r\n\rTo support multiple representations of a resource, Spring provides      the ContentNegotiatingViewResolver to resolve a      view based on the file extension or Accept header of      the HTTP request. ContentNegotiatingViewResolver      does not perform the view resolution itself but instead delegates to a      list of view resolvers that you specify through the bean property      ViewResolvers.      \n\r\n\rThe ContentNegotiatingViewResolver selects      an appropriate View to handle the request by      comparing the request media type(s) with the media type (also known as      Content-Type) supported by the      View associated with each of its      ViewResolvers. The first      View in the list that has a compatible      Content-Type returns the representation to the      client. If a compatible view cannot be supplied by the      ViewResolver chain, then the list of views      specified through the DefaultViews property will be      consulted. This latter option is appropriate for singleton      Views that can render an appropriate      representation of the current resource regardless of the logical view      name. The Accept header may include wild cards, for      example text/*, in which case a      View whose Content-Type was      text/xml is a compatible match.      \n\r\n\rTo support the resolution of a view based on a file extension, use      the ContentNegotiatingViewResolver bean property      mediaTypes to specify a mapping of file extensions to      media types. For more information on the algorithm used to determine the      request media type, refer to the API documentation for      ContentNegotiatingViewResolver.      \n\r\n\rHere is an example configuration of a      ContentNegotiatingViewResolver:      &lt;bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\"&gt;  &lt;property name=\"mediaTypes\"&gt;    &lt;map&gt;      &lt;entry key=\"atom\" value=\"application/atom+xml\"/&gt;      &lt;entry key=\"html\" value=\"text/html\"/&gt;      &lt;entry key=\"json\" value=\"application/json\"/&gt;    &lt;/map&gt;  &lt;/property&gt;  &lt;property name=\"viewResolvers\"&gt;    &lt;list&gt;      &lt;bean class=\"org.springframework.web.servlet.view.BeanNameViewResolver\"/&gt;      &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;        &lt;property name=\"suffix\" value=\".jsp\"/&gt;      &lt;/bean&gt;    &lt;/list&gt;  &lt;/property&gt;  &lt;property name=\"defaultViews\"&gt;    &lt;list&gt;      &lt;bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\" /&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"content\" class=\"com.springsource.samples.rest.SampleContentAtomView\"/&gt;      \n\r\n\rThe InternalResourceViewResolver handles      the translation of view names and JSP pages, while the      BeanNameViewResolver returns a view based on the      name of a bean. (See \"Resolving views with the      ViewResolver interface\" for more details on how Spring looks up      and instantiates a view.) In this example, the      content bean is a class that inherits from      AbstractAtomFeedView, which returns an Atom RSS      feed. For more information on creating an Atom Feed representation, see      the section Atom Views.      \n\r\n\rIn the above configuration, if a request is made with an      .html extension, the view resolver looks for a view      that matches the text/html media type. The      InternalResourceViewResolver provides the      matching view for text/html. If the request is made      with the file extension .atom, the view resolver      looks for a view that matches the      application/atom+xml media type. This view is      provided by the BeanNameViewResolver that maps to      the SampleContentAtomView if the view name      returned is content. If the request is made with      the file extension .json, the      MappingJackson2JsonViewinstance from the      DefaultViews list will be selected regardless of the      view name. Alternatively, client requests can be made without a file      extension but with the Accept header set to the      preferred media-type, and the same resolution of request to views would      occur.      Note        \n\r\n\rIf ContentNegotiatingViewResolver\'s list        of ViewResolvers is not configured explicitly, it automatically uses        any ViewResolvers defined in the application context.            \n\r\n\rThe corresponding controller code that returns an Atom RSS feed      for a URI of the form http://localhost/content.atom      or http://localhost/content with an      Accept header of application/atom+xml is shown      below.      @Controllerpublic class ContentController {    private List&lt;SampleContent&gt; contentList = new ArrayList&lt;SampleContent&gt;();    @RequestMapping(value=\"/content\", method=RequestMethod.GET)    public ModelAndView getContent() {        ModelAndView mav = new ModelAndView();        mav.setViewName(\"content\");        mav.addObject(\"sampleContentList\", contentList);        return mav;    }}        17.6&nbsp;Using flash attributes        \n\r\n\rFlash attributes provide a way for one request to store attributes    intended for use in another. This is most commonly needed when redirecting    &#8212; for example, the Post/Redirect/Get pattern. Flash    attributes are saved temporarily before the redirect (typically in the    session) to be made available to the request after the redirect and    removed immediately.    \n\r\n\rSpring MVC has two main abstractions in support of flash attributes.    FlashMap is used to hold flash attributes while    FlashMapManager is used to store, retrieve,    and manage FlashMap instances.    \n\r\n\rFlash attribute support is always \"on\" and does not need to enabled    explicitly although if not used, it never causes HTTP session creation. On    each request there is an \"input\" FlashMap with    attributes passed from a previous request (if any) and an \"output\"    FlashMap with attributes to save for a subsequent    request. Both FlashMap instances are accessible    from anywhere in Spring MVC through static methods in    RequestContextUtils.    \n\r\n\rAnnotated controllers typically do not need to work with    FlashMap directly. Instead an    @RequestMapping method can accept an    argument of type RedirectAttributes and use    it to add flash attributes for a redirect scenario. Flash attributes added    via RedirectAttributes are automatically    propagated to the \"output\" FlashMap. Similarly after the redirect    attributes from the \"input\" FlashMap are    automatically added to the Model of the    controller serving the target URL.    \n\r\n\rMatching requests to flash attributes            \n\r\n\rThe concept of flash attributes exists in many other Web      frameworks and has proven to be exposed sometimes to concurrency issues.      This is because by definition flash attributes are to be stored until      the next request. However the very \"next\" request may not be the      intended recipient but another asynchronous request (e.g. polling or      resource requests) in which case the flash attributes are removed too      early.      \n\r\n\rTo reduce the possibility of such issues,      RedirectView automatically \"stamps\"      FlashMap instances with the path and query      parameters of the target redirect URL. In turn the default      FlashMapManager matches that information to      incoming requests when looking up the \"input\"      FlashMap.      \n\r\n\rThis does not eliminate the possibility of a concurrency issue      entirely but nevertheless reduces it greatly with information that is      already available in the redirect URL. Therefore the use of flash      attributes is recommended mainly for redirect scenarios .        17.7&nbsp;Building URIs        \n\r\n\rSpring MVC provides a mechanism for building and encoding a URI    using UriComponentsBuilder and    UriComponents.        \n\r\n\rFor example you can expand and encode a URI template string:UriComponents uriComponents =        UriComponentsBuilder.fromUriString(\"http://example.com/hotels/{hotel}/bookings/{booking}\").build();URI uri = uriComponents.expand(\"42\", \"21\").encode().toUri();    \n\r\n\rNote that UriComponents is immutable and    the expand() and encode()    operations return new instances if necessary.    \n\r\n\rYou can also expand and encode using individual URI components:UriComponents uriComponents =        UriComponentsBuilder.newInstance()            .scheme(\"http\").host(\"example.com\").path(\"/hotels/{hotel}/bookings/{booking}\").build()            .expand(\"42\", \"21\")            .encode();    \n\r\n\rIn a Servlet environment the    ServletUriComponentsBuilder sub-class provides    static factory methods to copy available URL information from a    Servlet requests:    HttpServletRequest request = ...// Re-use host, scheme, port, path and query string// Replace the \"accountId\" query paramServletUriComponentsBuilder ucb =        ServletUriComponentsBuilder.fromRequest(request).replaceQueryParam(\"accountId\", \"{id}\").build()            .expand(\"123\")            .encode();    \n\r\n\rAlternatively, you may choose to copy a subset of the available    information up to and including the context path:// Re-use host, port and context path// Append \"/accounts\" to the pathServletUriComponentsBuilder ucb =        ServletUriComponentsBuilder.fromContextPath(request).path(\"/accounts\").build()    \n\r\n\rOr in cases where the DispatcherServlet is mapped    by name (e.g. /main/*), you can also have the literal part    of the servlet mapping included:// Re-use host, port, context path// Append the literal part of the servlet mapping to the path// Append \"/accounts\" to the pathServletUriComponentsBuilder ucb =        ServletUriComponentsBuilder.fromServletMapping(request).path(\"/accounts\").build()    17.8&nbsp;Using locales        \n\r\n\rMost parts of Spring\'s architecture support internationalization,    just as the Spring web MVC framework does.    DispatcherServlet enables you to automatically    resolve messages using the client\'s locale. This is done with    LocaleResolver objects.    \n\r\n\rWhen a request comes in, the    DispatcherServlet looks for a locale resolver, and    if it finds one it tries to use it to set the locale. Using the    RequestContext.getLocale() method, you can always    retrieve the locale that was resolved by the locale resolver.    \n\r\n\rIn addition to automatic locale resolution, you can also attach an    interceptor to the handler mapping (see Section&nbsp;17.4.1, &#8220;Intercepting requests with a      HandlerInterceptor&#8221; for more information on    handler mapping interceptors) to change the locale under specific    circumstances, for example, based on a parameter in the request.    \n\r\n\rLocale resolvers and interceptors are defined in the    org.springframework.web.servlet.i18n package and are    configured in your application context in the normal way. Here is a    selection of the locale resolvers included in Spring.    17.8.1&nbsp;AcceptHeaderLocaleResolver            \n\r\n\rThis locale resolver inspects the      accept-language header in the request that was sent      by the client (e.g., a web browser). Usually this header field contains      the locale of the client\'s operating system.        17.8.2&nbsp;CookieLocaleResolver            \n\r\n\rThis locale resolver inspects a Cookie that      might exist on the client to see if a locale is specified. If so, it      uses the specified locale. Using the properties of this locale resolver,      you can specify the name of the cookie as well as the maximum age. Find      below an example of defining a      CookieLocaleResolver.      &lt;bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\"&gt;    &lt;property name=\"cookieName\" value=\"clientlanguage\"/&gt;    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;    &lt;property name=\"cookieMaxAge\" value=\"100000\"&gt;&lt;/bean&gt;      \n\r\n\rTable&nbsp;17.4.&nbsp;CookieLocaleResolver properties                PropertyDefaultDescriptioncookieNameclassname + LOCALEThe name of the cookiecookieMaxAgeInteger.MAX_INTThe maximum time a cookie will stay persistent on the              client. If -1 is specified, the cookie will not be persisted; it              will only be available until the client shuts down his or her              browser.cookiePath/Limits the visibility of the cookie to a certain part of              your site. When cookiePath is specified, the cookie will only be              visible to that path and the paths below it.      \n\r        17.8.3&nbsp;SessionLocaleResolver            \n\r\n\rThe SessionLocaleResolver allows you to      retrieve locales from the session that might be associated with the      user\'s request.        17.8.4&nbsp;LocaleChangeInterceptor            \n\r\n\rYou can enable changing of locales by adding the      LocaleChangeInterceptor to one of the handler      mappings (see Section&nbsp;17.4, &#8220;Handler mappings&#8221;). It will detect a      parameter in the request and change the locale. It calls      setLocale() on the      LocaleResolver that also exists in the      context. The following example shows that calls to all      *.view resources containing a parameter named      siteLanguage will now change the locale. So, for      example, a request for the following URL,      http://www.sf.net/home.view?siteLanguage=nl will      change the site language to Dutch.      &lt;bean id=\"localeChangeInterceptor\"      class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"&gt;    &lt;property name=\"paramName\" value=\"siteLanguage\"/&gt;&lt;/bean&gt;&lt;bean id=\"localeResolver\"      class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\"/&gt;&lt;bean id=\"urlMapping\"      class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;    &lt;property name=\"interceptors\"&gt;        &lt;list&gt;            &lt;ref bean=\"localeChangeInterceptor\"/&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=\"mappings\"&gt;        &lt;value&gt;/**/*.view=someController&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;        17.9&nbsp;Using themes        17.9.1&nbsp;Overview of themes            \n\r\n\rYou can apply Spring Web MVC framework themes to set the overall      look-and-feel of your application, thereby enhancing user experience. A      theme is a collection of static resources, typically style sheets and      images, that affect the visual style of the application.        17.9.2&nbsp;Defining themes            \n\r\n\rTo use themes in your web application, you must set up an      implementation of the      org.springframework.ui.context.ThemeSource      interface. The WebApplicationContext      interface extends ThemeSource but      delegates its responsibilities to a dedicated implementation. By default      the delegate will be an      org.springframework.ui.context.support.ResourceBundleThemeSource      implementation that loads properties files from the root of the      classpath. To use a custom ThemeSource      implementation or to configure the base name prefix of the      ResourceBundleThemeSource, you can register a      bean in the application context with the reserved name      themeSource. The web application context      automatically detects a bean with that name and uses it.      \n\r\n\rWhen using the ResourceBundleThemeSource, a      theme is defined in a simple properties file. The      properties file lists the resources that make up the theme. Here is an      example:      styleSheet=/themes/cool/style.cssbackground=/themes/cool/img/coolBg.jpg      \n\r\n\rThe keys of the properties are the names that refer to the themed      elements from view code. For a JSP, you typically do this using the      spring:theme custom tag, which is very similar to the      spring:message tag. The following JSP fragment uses      the theme defined in the previous example to customize the look and      feel:      &lt;%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\"%&gt;&lt;html&gt;   &lt;head&gt;      &lt;link rel=\"stylesheet\" href=\"&lt;spring:theme code=\'styleSheet\'/&gt;\" type=\"text/css\"/&gt;   &lt;/head&gt;   &lt;body style=\"background=&lt;spring:theme code=\'background\'/&gt;\"&gt;      ...   &lt;/body&gt;&lt;/html&gt;      \n\r\n\rBy default, the ResourceBundleThemeSource      uses an empty base name prefix. As a result, the properties files are      loaded from the root of the classpath. Thus you would put the      cool.properties theme definition in a directory at      the root of the classpath, for example, in      /WEB-INF/classes. The      ResourceBundleThemeSource uses the standard Java      resource bundle loading mechanism, allowing for full      internationalization of themes. For example, we could have a      /WEB-INF/classes/cool_nl.properties that references a      special background image with Dutch text on it.        17.9.3&nbsp;Theme resolvers            \n\r\n\rAfter you define themes, as in the preceding section, you decide      which theme to use. The DispatcherServlet will      look for a bean named themeResolver to find out      which ThemeResolver implementation to      use. A theme resolver works in much the same way as a      LocaleResolver. It detects the theme to      use for a particular request and can also alter the request\'s theme. The      following theme resolvers are provided by Spring:      \n\r\n\rTable&nbsp;17.5.&nbsp;ThemeResolver        implementations                ClassDescriptionFixedThemeResolverSelects a fixed theme, set using the              defaultThemeName property.SessionThemeResolverThe theme is maintained in the user\'s HTTP session. It              only needs to be set once for each session, but is not persisted              between sessions.CookieThemeResolverThe selected theme is stored in a cookie on the              client.      \n\r      \n\r\n\rSpring also provides a      ThemeChangeInterceptor that allows theme changes      on every request with a simple request parameter.        17.10&nbsp;Spring\'s multipart (file upload) support        17.10.1&nbsp;Introduction            \n\r\n\rSpring\'s built-in multipart support handles file uploads in web      applications. You enable this multipart support with pluggable      MultipartResolver objects, defined in the      org.springframework.web.multipart package. Spring      provides one MultipartResolver      implementation for use with  Commons      FileUpload and another for use with Servlet 3.0      multipart request parsing.      \n\r\n\rBy default, Spring does no multipart handling, because some      developers want to handle multiparts themselves. You enable Spring      multipart handling by adding a multipart resolver to the web      application\'s context. Each request is inspected to see if it contains a      multipart. If no multipart is found, the request continues as expected.      If a multipart is found in the request, the      MultipartResolver that has been declared in your      context is used. After that, the multipart attribute in your request is      treated like any other attribute.        17.10.2&nbsp;Using a MultipartResolver with      Commons FileUpload            \n\r\n\rThe following example shows how to use the      CommonsMultipartResolver:      &lt;bean id=\"multipartResolver\"    class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;    &lt;property name=\"maxUploadSize\" value=\"100000\"/&gt;&lt;/bean&gt;      \n\r\n\rOf course you also need to put the appropriate jars in your      classpath for the multipart resolver to work. In the case of the      CommonsMultipartResolver, you need to use      commons-fileupload.jar.      \n\r\n\rWhen the Spring DispatcherServlet detects a      multi-part request, it activates the resolver that has been declared in      your context and hands over the request. The resolver then wraps the      current HttpServletRequest into a      MultipartHttpServletRequest that supports      multipart file uploads. Using the      MultipartHttpServletRequest, you can get      information about the multiparts contained by this request and actually      get access to the multipart files themselves in your controllers.        17.10.3&nbsp;Using a MultipartResolver with      Servlet 3.0            \n\r\n\rIn order to use Servlet 3.0 based multipart parsing, you need to      mark the DispatcherServlet with a      \"multipart-config\" section in      web.xml, or with a      javax.servlet.MultipartConfigElement in      programmatic Servlet registration, or in case of a custom Servlet class      possibly with a      javax.servlet.annotation.MultipartConfig      annotation on your Servlet class. Configuration settings such as maximum      sizes or storage locations need to be applied at that Servlet      registration level as Servlet 3.0 does not allow for those settings to      be done from the MultipartResolver.      \n\r\n\rOnce Servlet 3.0 multipart parsing has been enabled in one of the      above mentioned ways you can add the      StandardServletMultipartResolver to your Spring      configuration:      &lt;bean id=\"multipartResolver\"    class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"&gt;&lt;/bean&gt;        17.10.4&nbsp;Handling a file upload in a form            \n\r\n\rAfter the MultipartResolver completes its      job, the request is processed like any other. First, create a form with      a file input that will allow the user to upload a form. The encoding      attribute (enctype=\"multipart/form-data\") lets the      browser know how to encode the form as multipart request:      &lt;html&gt;    &lt;head&gt;        &lt;title&gt;Upload a file please&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Please upload a file&lt;/h1&gt;        &lt;form method=\"post\" action=\"/form\" enctype=\"multipart/form-data\"&gt;            &lt;input type=\"text\" name=\"name\"/&gt;            &lt;input type=\"file\" name=\"file\"/&gt;            &lt;input type=\"submit\"/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;      \n\r\n\rThe next step is to create a controller that handles the file      upload. This controller is very similar to a normal annotated      @Controller, except that we use      MultipartHttpServletRequest or      MultipartFile in the method parameters:      @Controllerpublic class FileUploadController {    @RequestMapping(value = \"/form\", method = RequestMethod.POST)    public String handleFormUpload(@RequestParam(\"name\") String name,        @RequestParam(\"file\") MultipartFile file) {        if (!file.isEmpty()) {            byte[] bytes = file.getBytes();            // store the bytes somewhere           return \"redirect:uploadSuccess\";       } else {           return \"redirect:uploadFailure\";       }    }}      \n\r\n\rNote how the @RequestParam method      parameters map to the input elements declared in the form. In this      example, nothing is done with the byte[], but in      practice you can save it in a database, store it on the file system, and      so on.      \n\r\n\rWhen using Servlet 3.0 multipart parsing you can also use      javax.servlet.http.Part for the method      parameter:      @Controllerpublic class FileUploadController {    @RequestMapping(value = \"/form\", method = RequestMethod.POST)    public String handleFormUpload(@RequestParam(\"name\") String name,        @RequestParam(\"file\") Part file) {        InputStream inputStream = file.getInputStream();        // store bytes from uploaded file somewhere        return \"redirect:uploadSuccess\";    }}        17.10.5&nbsp;Handling a file upload request from programmatic clients            \n\r\n\rMultipart requests can also be submitted from non-browser clients      in a RESTful service scenario. All of the above examples and      configuration apply here as well. However, unlike browsers that      typically submit files and simple form fields, a programmatic client can      also send more complex data of a specific content type &#8212; for example a      multipart request with a file and second part with JSON formatted data:      POST /someUrlContent-Type: multipart/mixed--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=\"meta-data\"Content-Type: application/json; charset=UTF-8Content-Transfer-Encoding: 8bit{  \"name\": \"value\"}--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\"Content-Type: text/xmlContent-Transfer-Encoding: 8bit... File Data ...      \n\r\n\rYou could access the part named \"meta-data\" with a      @RequestParam(\"meta-data\") String      metadata controller method argument. However, you would      probably prefer to accept a strongly typed object initialized from the      JSON formatted data in the body of the request part, very similar to the      way @RequestBody converts the body of a      non-multipart request to a target object with the help of an      HttpMessageConverter.      \n\r\n\rYou can use the @RequestPart      annotation instead of the @RequestParam      annotation for this purpose. It allows you to have the content of a      specific multipart passed through an      HttpMessageConverter taking into consideration      the \'Content-Type\' header of the multipart:      @RequestMapping(value=\"/someUrl\", method = RequestMethod.POST)public String onSubmit(@RequestPart(\"meta-data\") MetaData metadata,                       @RequestPart(\"file-data\") MultipartFile file) {    // ...}      \n\r\n\rNotice how MultipartFile method arguments      can be accessed with @RequestParam or      with @RequestPart interchangeably.      However, the @RequestPart(\"meta-data\") MetaData      method argument in this case is read as JSON content based on its      \'Content-Type\' header and converted with the help of      the MappingJackson2HttpMessageConverter.        17.11&nbsp;Handling exceptions        17.11.1&nbsp;HandlerExceptionResolver            \n\r\n\rSpring HandlerExceptionResolver implementations      deal with unexpected exceptions that occur during controller execution.      A HandlerExceptionResolver somewhat resembles the      exception mappings you can define in the web application descriptor      web.xml. However, they provide a more flexible way to      do so. For example they provide information about which handler was      executing when the exception was thrown. Furthermore, a programmatic way      of handling exceptions gives you more options for responding      appropriately before the request is forwarded to another URL (the same      end result as when you use the Servlet specific exception      mappings).      \n\r\n\rBesides implementing the      HandlerExceptionResolver interface, which      is only a matter of implementing the      resolveException(Exception, Handler) method and      returning a ModelAndView, you may also use the provided      SimpleMappingExceptionResolver or create      @ExceptionHandler methods.      The SimpleMappingExceptionResolver      enables you to take the class name of any exception that might be thrown      and map it to a view name. This is functionally equivalent to the      exception mapping feature from the Servlet API, but it is also possible      to implement more finely grained mappings of exceptions from different      handlers. The @ExceptionHandler annotation on      the other hand can be used on methods that should be invoked to handle an      exception. Such methods may be defined locally within an      @Controller or may apply globally to all      @RequestMapping methods when defined within      an @ControllerAdvice class.      The following sections explain this in more detail.        17.11.2&nbsp;@ExceptionHandler            \n\r\n\rThe HandlerExceptionResolver interface      and the SimpleMappingExceptionResolver implementations      allow you to map Exceptions to specific views declaratively along with some      optional Java logic before forwarding to those views. However, in some cases,      especially when relying on @ResponseBody methods      rather than on view resolution, it may be more convenient to directly set the      status of the response and optionally write error content to the body of the      response.      \n\r\n\rYou can do that with @ExceptionHandler      methods. When declared within a controller such methods apply to exceptions      raised by @RequestMapping methods of that      contoroller (or any of its sub-classes). You can also declare an      @ExceptionHandler method within an      @ControllerAdvice class in which case it      handles exceptions from @RequestMapping      methods from any controller.      The @ControllerAdvice annotation is      a component annotation, which can be used with classpath scanning. It is      automatically enabled when using the MVC namespace and the MVC Java config,      or otherwise depending on whether the      ExceptionHandlerExceptionResolver is configured or not.      Below is an example of a controller-local      @ExceptionHandler method:      @Controllerpublic class SimpleController {  // @RequestMapping methods omitted ...  @ExceptionHandler(IOException.class)  public ResponseEntity&lt;String&gt; handleIOException(IOException ex) {    // prepare responseEntity    return responseEntity;  }}      \n\r\n\rThe @ExceptionHandler value can be set to      an array of Exception types. If an exception is thrown that matches one of      the types in the list, then the method annotated with the matching      @ExceptionHandler will be invoked. If the      annotation value is not set then the exception types listed as method      arguments are used.      \n\r\n\rMuch like standard controller methods annotated with a      @RequestMapping annotation, the method arguments      and return values of @ExceptionHandler methods      can be flexible. For example, the      HttpServletRequest can be accessed in Servlet      environments and the PortletRequest in Portlet      environments. The return type can be a String,      which is interpreted as a view name, a      ModelAndView object, a      ResponseEntity, or you can also add the      @ResponseBody to have the method return value      converted with message converters and written to the response stream.        17.11.3&nbsp;Handling Standard Spring MVC Exceptions            \n\r\n\rSpring MVC may raise a number of exceptions while processing      a request. The SimpleMappingExceptionResolver can easily      map any exception to a default error view as needed.      However, when working with clients that interpret responses in an automated      way you will want to set specific status code on the response. Depending on      the exception raised the status code may indicate a client error (4xx) or a      server error (5xx).      \n\r\n\rThe DefaultHandlerExceptionResolver translates      Spring MVC exceptions to specific error status codes. It is registered      by default with the MVC namespace, the MVC Java config, and also by the      the DispatcherServlet (i.e. when not using the MVC      namespace or Java config). Listed below are some of the exceptions handled      by this resolver and the corresponding status codes:                ExceptionHTTP Status CodeBindException400 (Bad Request)ConversionNotSupportedException500 (Internal Server Error)HttpMediaTypeNotAcceptableException406 (Not Acceptable)HttpMediaTypeNotSupportedException415 (Unsupported Media Type)HttpMessageNotReadableException400 (Bad Request)HttpMessageNotWritableException500 (Internal Server Error)HttpRequestMethodNotSupportedException405 (Method Not Allowed)MethodArgumentNotValidException400 (Bad Request)MissingServletRequestParameterException400 (Bad Request)MissingServletRequestPartException400 (Bad Request)NoSuchRequestHandlingMethodException404 (Not Found)TypeMismatchException400 (Bad Request)        \n\r\n\r                \n\r\n\rThe DefaultHandlerExceptionResolver works        transparently by setting the status of the response. However, it stops short        of writing any error content to the body of the response while your        application may need to add developer-friendly content to every error        response for example when providing a REST API. You can prepare a        ModelAndView and        render error content through view resolution -- i.e. by configuring a        ContentNeogitatingViewResolver,        MappingJacksonJsonView, and so on. However, you        may prefer to use @ExceptionHandler        methods instead.        \n\r\n\rIf you prefer to write error content via        @ExceptionHandler methods you can extend        ResponseEntityExceptionHandler instead.        This is a convenient base for @ControllerAdvice        classes providing an @ExceptionHandler        method to handle standard Spring MVC exceptions and return        ResponseEntity. That allows you to customize the response        and write error content with message converters. See the Javadoc of        ResponseEntityExceptionHandler for more details.        17.11.4&nbsp;Annotating Business Exceptions With @ResponseStatus            \n\r\n\rA business exception can be annotated with      @ResponseStatus. When the exception is raised,      the ResponseStatusExceptionResolver handles it by      setting the status of the response accordingly.      By default the DispatcherServlet registers      the ResponseStatusExceptionResolver and it is      available for use.        17.11.5&nbsp;Customizing the Default Servlet Container Error Page              \n\r\n\rWhen the status of the response is set to an error status code        and the body of the response is empty, Servlet containers commonly render        an HTML formatted error page.        To customize the default error page of the container, you can        declare an &lt;error-page&gt; element in        web.xml. Up until Servlet 3, that element had to        be mapped to a specific status code or exception type. Starting with        Servlet 3 an error page does not need to be mapped, which effectively        means the specified location customizes the default Servlet container        error page.      &lt;error-page&gt;    &lt;location&gt;/error&lt;/location&gt;&lt;/error-page&gt;        \n\r\n\rNote that the actual location for the error page can be a        JSP page or some other URL within the container including one handled        through an @Controller method:        \n\r\n\rWhen writing error information, the status code and the error message        set on the HttpServletResponse can be        accessed through request attributes in a controller:@Controllerpublic class ErrorController {    @RequestMapping(value=\"/error\", produces=\"application/json\")    @ResponseBody    public Map&lt;String, Object&gt; handle(HttpServletRequest request) {        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"status\", request.getAttribute(\"javax.servlet.error.status_code\"));        map.put(\"reason\", request.getAttribute(\"javax.servlet.error.message\"));        return map;    }}        \n\r\n\ror in a JSP:      &lt;%@ page contentType=\"application/json\" pageEncoding=\"UTF-8\"%&gt;{   status:&lt;%=request.getAttribute(\"javax.servlet.error.status_code\") %&gt;,   reason:&lt;%=request.getAttribute(\"javax.servlet.error.message\") %&gt;}        17.12&nbsp;Convention over configuration support        \n\r\n\rFor a lot of projects, sticking to established conventions and    having reasonable defaults is just what they (the projects) need, and    Spring Web MVC now has explicit support for convention over    configuration. What this means is that if you establish a set    of naming conventions and suchlike, you can    substantially cut down on the amount of configuration    that is required to set up handler mappings, view resolvers,    ModelAndView instances, etc. This is a great boon    with regards to rapid prototyping, and can also lend a degree of (always    good-to-have) consistency across a codebase should you choose to move    forward with it into production.    \n\r\n\rConvention-over-configuration support addresses the three core areas    of MVC: models, views, and controllers.    17.12.1&nbsp;The Controller      ControllerClassNameHandlerMapping            \n\r\n\rThe ControllerClassNameHandlerMapping class      is a HandlerMapping implementation that      uses a convention to determine the mapping between request URLs and the      Controller instances that are to handle      those requests.      \n\r\n\rConsider the following simple      Controller implementation. Take special      notice of the name of the class.      public class ViewShoppingCartController implements Controller {    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {        // the implementation is not hugely important for this example...    }}      \n\r\n\rHere is a snippet from the corresponding Spring Web MVC      configuration file:      &lt;bean class=\"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"/&gt;&lt;bean id=\"viewShoppingCart\" class=\"x.y.z.ViewShoppingCartController\"&gt;    &lt;!-- inject dependencies as required... --&gt;&lt;/bean&gt;      \n\r\n\rThe ControllerClassNameHandlerMapping finds      all of the various handler (or      Controller) beans defined in its      application context and strips Controller off the      name to define its handler mappings. Thus,      ViewShoppingCartController maps to the      /viewshoppingcart* request URL.      \n\r\n\rLet\'s look at some more examples so that the central idea becomes      immediately familiar. (Notice all lowercase in the URLs, in contrast to      camel-cased Controller class      names.)      \n\r          \n\r\n\rWelcomeController maps to the          /welcome* request URL        \n\r          \n\r\n\rHomeController maps to the          /home* request URL        \n\r          \n\r\n\rIndexController maps to the          /index* request URL        \n\r          \n\r\n\rRegisterController maps to the          /register* request URL        \n\r      \n\r\n\rIn the case of MultiActionController      handler classes, the mappings generated are slightly more complex. The      Controller names in the following      examples are assumed to be MultiActionController      implementations:      \n\r          \n\r\n\rAdminController maps to the          /admin/* request URL        \n\r          \n\r\n\rCatalogController maps to the          /catalog/* request URL        \n\r      \n\r\n\rIf you follow the convention of naming your      Controller implementations as      xxxController, the      ControllerClassNameHandlerMapping saves you the      tedium of defining and maintaining a potentially      looooong      SimpleUrlHandlerMapping (or suchlike).      \n\r\n\rThe ControllerClassNameHandlerMapping class      extends the AbstractHandlerMapping base class so      you can define HandlerInterceptor      instances and everything else just as you would with many other      HandlerMapping implementations.        17.12.2&nbsp;The Model ModelMap      (ModelAndView)            \n\r\n\rThe ModelMap class is essentially a      glorified Map that can make adding      objects that are to be displayed in (or on) a      View adhere to a common naming      convention. Consider the following      Controller implementation; notice that      objects are added to the ModelAndView without any      associated name specified.      public class DisplayShoppingCartController implements Controller {    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {        List cartItems = // get a List of CartItem objects        User user = // get the User doing the shopping        ModelAndView mav = new ModelAndView(\"displayShoppingCart\"); &lt;-- the logical view name        mav.addObject(cartItems); &lt;-- look ma, no name, just the object        mav.addObject(user); &lt;-- and again ma!        return mav;    }}      \n\r\n\rThe ModelAndView class uses a      ModelMap class that is a custom      Map implementation that automatically      generates a key for an object when an object is added to it. The      strategy for determining the name for an added object is, in the case of      a scalar object such as User, to use the short      class name of the object\'s class. The following examples are names that      are generated for scalar objects put into a      ModelMap instance.      \n\r          \n\r\n\rAn x.y.User instance added will have          the name user generated.        \n\r          \n\r\n\rAn x.y.Registration instance added will          have the name registration generated.        \n\r          \n\r\n\rAn x.y.Foo instance added will have the          name foo generated.        \n\r          \n\r\n\rA java.util.HashMap instance added will          have the name hashMap generated. You probably          want to be explicit about the name in this case because          hashMap is less than intuitive.        \n\r          \n\r\n\rAdding null will result in an          IllegalArgumentException being thrown. If the          object (or objects) that you are adding could be          null, then you will also want to be explicit          about the name.        \n\r      \n\r\n\rWhat, no automatic pluralization?                \n\r\n\rSpring Web MVC\'s convention-over-configuration support does not        support automatic pluralization. That is, you cannot add a        List of Person        objects to a ModelAndView and have the        generated name be people.        \n\r\n\rThis decision was made after some debate, with the        &#8220;Principle of Least Surprise&#8221; winning out in the        end.            \n\r\n\rThe strategy for generating a name after adding a      Set or a      List is to peek into the collection, take      the short class name of the first object in the collection, and use that      with List appended to the name. The same applies to      arrays although with arrays it is not necessary to peek into the array      contents. A few examples will make the semantics of name generation for      collections clearer:      \n\r          \n\r\n\rAn x.y.User[] array with zero or more          x.y.User elements added will have the name          userList generated.        \n\r          \n\r\n\rAn x.y.Foo[] array with zero or more          x.y.User elements added will have the name          fooList generated.        \n\r          \n\r\n\rA java.util.ArrayList with one or more          x.y.User elements added will have the name          userList generated.        \n\r          \n\r\n\rA java.util.HashSet with one or more          x.y.Foo elements added will have the name          fooList generated.        \n\r          \n\r\n\rAn empty          java.util.ArrayList will not be added at all          (in effect, the addObject(..) call will          essentially be a no-op).        \n\r        17.12.3&nbsp;The View -      RequestToViewNameTranslator            \n\r\n\rThe RequestToViewNameTranslator      interface determines a logical View name      when no such logical view name is explicitly supplied. It has just one      implementation, the      DefaultRequestToViewNameTranslator class.      \n\r\n\rThe DefaultRequestToViewNameTranslator maps      request URLs to logical view names, as with this example:      public class RegistrationController implements Controller {    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {        // process the request...        ModelAndView mav = new ModelAndView();        // add data as necessary to the model...        return mav;        // notice that no View or logical view name has been set    }}      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;!-- this bean with the well known name generates view names for us --&gt;    &lt;bean id=\"viewNameTranslator\"        class=\"org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\"/&gt;    &lt;bean class=\"x.y.RegistrationController\"&gt;        &lt;!-- inject dependencies as necessary --&gt;    &lt;/bean&gt;    &lt;!-- maps request URLs to Controller names --&gt;    &lt;bean class=\"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"/&gt;    &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;        &lt;property name=\"suffix\" value=\".jsp\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rNotice how in the implementation of the      handleRequest(..) method no      View or logical view name is ever set on      the ModelAndView that is returned. The      DefaultRequestToViewNameTranslator is tasked with      generating a logical view name from the URL of the      request. In the case of the above      RegistrationController, which is used in      conjunction with the      ControllerClassNameHandlerMapping, a request URL      of http://localhost/registration.html results in a      logical view name of registration being generated by      the DefaultRequestToViewNameTranslator. This      logical view name is then resolved into the      /WEB-INF/jsp/registration.jsp view by the      InternalResourceViewResolver bean.      Tip        \n\r\n\rYou do not need to define a        DefaultRequestToViewNameTranslator bean        explicitly. If you like the default settings of the        DefaultRequestToViewNameTranslator, you can        rely on the Spring Web MVC DispatcherServlet to        instantiate an instance of this class if one is not explicitly        configured.            \n\r\n\rOf course, if you need to change the default settings, then you do      need to configure your own      DefaultRequestToViewNameTranslator bean      explicitly. Consult the comprehensive Javadoc for the      DefaultRequestToViewNameTranslator class for      details of the various properties that can be configured.        17.13&nbsp;ETag support        \n\r\n\rAn ETag    (entity tag) is an HTTP response header returned by an HTTP/1.1 compliant    web server used to determine change in content at a given URL. It can be    considered to be the more sophisticated successor to the    Last-Modified header. When a server returns a    representation with an ETag header, the client can use this header in    subsequent GETs, in an If-None-Match header. If the    content has not changed, the server returns 304: Not    Modified.    \n\r\n\rSupport for ETags is provided by the Servlet filter    ShallowEtagHeaderFilter. It is a plain Servlet    Filter, and thus can be used in combination with any web framework. The    ShallowEtagHeaderFilter filter creates so-called    shallow ETags (as opposed to deep ETags, more about that later).The    filter caches the content of the rendered JSP (or other content),    generates an MD5 hash over that, and returns that as an ETag header in the    response. The next time a client sends a request for the same resource, it    uses that hash as the If-None-Match value. The filter    detects this, renders the view again, and compares the two hashes. If they    are equal, a 304 is returned. This filter will not save    processing power, as the view is still rendered. The only thing it saves    is bandwidth, as the rendered response is not sent back over the    wire.    \n\r\n\rYou configure the ShallowEtagHeaderFilter in    web.xml:    &lt;filter&gt;  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.ShallowEtagHeaderFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;etagFilter&lt;/filter-name&gt;  &lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;&lt;/filter-mapping&gt;    17.14&nbsp;Code-based Servlet container initialization        \n\r\n\rIn a Servlet 3.0+ environment, you  have the option of configuring the    Servlet container programmatically as an alternative or in combination with    a web.xml file.    Below is an example of registering a DispatcherServlet:    import org.springframework.web.WebApplicationInitializer;public class MyWebApplicationInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext container) {        XmlWebApplicationContext appContext = new XmlWebApplicationContext();        appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet(appContext));        registration.setLoadOnStartup(1);        registration.addMapping(\"/\");    }}    \n\r\n\rWebApplicationInitializer is an interface    provided by Spring MVC that ensures your implementation is detected and    automatically used to initialize any Servlet 3 container. An abstract base    class implementation of WebApplicationInitializer named    AbstractDispatcherServletInitializer makes it even    easier to register the DispatcherServlet by simply overriding    methods to specify the servlet mapping and the location of the    DispatcherServlet configuration:    public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return null;    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[] { MyWebConfig.class };    }    @Override    protected String[] getServletMappings() {        return new String[] { \"/\" };    }}    \n\r\n\rThe above example is for an application that uses Java-based Spring    configuration. If using XML-based Spring configuration, extend directly from    AbstractDispatcherServletInitializer:    public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {    @Override    protected WebApplicationContext createRootApplicationContext() {        return null;    }    @Override    protected WebApplicationContext createServletApplicationContext() {        XmlWebApplicationContext cxt = new XmlWebApplicationContext();        cxt.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");        return cxt;    }    @Override    protected String[] getServletMappings() {        return new String[] { \"/\" };    }}    \n\r\n\rAbstractDispatcherServletInitializer also provides    a convenient way to add Filter instances    and have them automatically mapped to the DispatcherServlet:    public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {    // ...    @Override    protected Filter[] getServletFilters() {        return new Filter[] { new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };    }}    \n\r\n\rEach filter is added with a default name based on its concrete type and    automatically mapped to the DispatcherServlet.    \n\r\n\rThe isAsyncSupported protected method of    AbstractDispatcherServletInitializer provides    a single place to enable async support on the DispatcherServlet    and all filters mapped to it. By default this flag is set to true.    17.15&nbsp;Configuring Spring MVC        \n\r\n\rSection&nbsp;17.2.1, &#8220;Special Bean Types In the WebApplicationContext&#8221; and    Section&nbsp;17.2.2, &#8220;Default DispatcherServlet Configuration&#8221; explained about    Spring MVC\'s special beans and the default implementations    used by the DispatcherServlet.    In this section you\'ll learn about two additional ways of    configuring Spring MVC. Namely the MVC Java config and    the MVC XML namespace.        \n\r\n\rThe MVC Java config and the MVC namespace provide    similar default configuration that overrides    the DispatcherServlet defaults.    The goal is to spare most applications from having to    having to create the same configuration and also to    provide higher-level constructs for configuring    Spring MVC that serve as a simple starting point and    require little or no prior knowledge of the underlying    configuration.    \n\r\n\rYou can choose either the MVC Java config or the    MVC namespace depending on your preference. Also as you    will see further below, with the MVC Java config it is    easier to see the underlying configuration as well as    to make fine-grained customizations directly to the    created Spring MVC beans.    But let\'s start from the beginning.        17.15.1&nbsp;Enabling the MVC Java Config or the MVC XML Namespace                \n\r\n\rTo enable MVC Java config add the annotation        @EnableWebMvc to one of your        @Configuration classes:        @Configuration@EnableWebMvcpublic class WebConfig {}        \n\r\n\rTo achieve the same in XML use the mvc:annotation-driven element:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;    &lt;mvc:annotation-driven /&gt;&lt;/beans&gt;      \n\r\n\rThe above registers a      RequestMappingHandlerMapping, a      RequestMappingHandlerAdapter, and an      ExceptionHandlerExceptionResolver (among others)      in support of processing requests with annotated controller methods using      annotations such as @RequestMapping ,      @ExceptionHandler, and others.      \n\r\n\rIt also enables the following:      \n\r            \n\r\n\rSpring 3 style type conversion through a ConversionService instance            in addition to the JavaBeans PropertyEditors used for Data Binding.          \n\r            \n\r\n\rSupport for formatting Number            fields using the @NumberFormat            annotation through the            ConversionService.          \n\r            \n\r\n\rSupport for formatting Date,            Calendar, Long, and Joda Time fields using the            @DateTimeFormat            annotation.          \n\r            \n\r\n\rSupport for validating @Controller            inputs with @Valid,            if a JSR-303 Provider is present on the classpath.          \n\r            \n\r\n\rHttpMessageConverter support for            @RequestBody method            parameters and @ResponseBody            method return values from            @RequestMapping or            @ExceptionHandler methods.            \n\r\n\rThis is the complete list of HttpMessageConverters set up by            mvc:annotation-driven: \n\r                  \n\r\n\rByteArrayHttpMessageConverter                  converts byte arrays.                \n\r                  \n\r\n\rStringHttpMessageConverter                  converts strings.                \n\r                  \n\r\n\rResourceHttpMessageConverter                  converts to/from                  org.springframework.core.io.Resource                  for all media types.                \n\r                  \n\r\n\rSourceHttpMessageConverter                  converts to/from a                  javax.xml.transform.Source.                \n\r                  \n\r\n\rFormHttpMessageConverter                  converts form data to/from a                  MultiValueMap&lt;String,                  String&gt;.                \n\r                  \n\r\n\rJaxb2RootElementHttpMessageConverter                  converts Java objects to/from XML &#8212; added if JAXB2 is                  present on the classpath.                \n\r                  \n\r\n\rMappingJackson2HttpMessageConverter                  (or MappingJacksonHttpMessageConverter)                  converts to/from JSON &#8212; added if Jackson 2 (or Jackson) is present                  on the classpath.                \n\r                  \n\r\n\rAtomFeedHttpMessageConverter                  converts Atom feeds &#8212; added if Rome is present on the                  classpath.                \n\r                  \n\r\n\rRssChannelHttpMessageConverter                  converts RSS feeds &#8212; added if Rome is present on the                  classpath.                \n\r          \n\r\n\r\n\r                17.15.2&nbsp;Customizing the Provided Configuration                \n\r\n\rTo customize the default configuration in Java you simply        implement the WebMvcConfigurer        interface or more likely extend the class        WebMvcConfigurerAdapter and override        the methods you need. Below is an example of some of the available        methods to override. See WebMvcConifgurer for        a list of all methods and the Javadoc for further details:        @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  protected void addFormatters(FormatterRegistry registry) {    // Add formatters and/or converters  }  @Override  public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {    // Configure the list of HttpMessageConverters to use  }}        \n\r\n\rTo customize the default configuration of        &lt;mvc:annotation-driven /&gt; check what        attributes and sub-elements it supports. You can view the        Spring MVC XML schema        or use the code completion feature of your IDE to discover        what attributes and sub-elements are available.        The sample below shows a subset of what is available:        &lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;    &lt;mvc:message-converters&gt;        &lt;bean class=\"org.example.MyHttpMessageConverter\"/&gt;        &lt;bean class=\"org.example.MyOtherHttpMessageConverter\"/&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt;    &lt;property name=\"formatters\"&gt;        &lt;list&gt;            &lt;bean class=\"org.example.MyFormatter\"/&gt;            &lt;bean class=\"org.example.MyOtherFormatter\"/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;        17.15.3&nbsp;Configuring Interceptors            \n\r\n\rYou can configure HandlerInterceptors      or WebRequestInterceptors to be applied      to all incoming requests or restricted to specific URL path patterns.      \n\r\n\rAn example of registering interceptors in Java:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void addInterceptors(InterceptorRegistry registry) {    registry.addInterceptor(new LocaleInterceptor());    registry.addInterceptor(new ThemeInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/admin/**\");    registry.addInterceptor(new SecurityInterceptor()).addPathPatterns(\"/secure/*\"); }}      \n\r\n\rAnd in XML use the &lt;mvc:interceptors&gt; element:      &lt;mvc:interceptors&gt;    &lt;bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /&gt;    &lt;mvc:interceptor&gt;        &lt;mapping path=\"/**\"/&gt;        &lt;exclude-mapping path=\"/admin/**\"/&gt;        &lt;bean class=\"org.springframework.web.servlet.theme.ThemeChangeInterceptor\" /&gt;    &lt;/mvc:interceptor&gt;    &lt;mvc:interceptor&gt;        &lt;mapping path=\"/secure/*\"/&gt;        &lt;bean class=\"org.example.SecurityInterceptor\" /&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;        17.15.4&nbsp;Configuring Content Negotiation            \n\r\n\rStaring with Spring Framework 3.2, you can configure how Spring MVC      determines the requested media types from the client for request mapping      as well as for content negotiation purposes. The available options are      to check the file extension in the request URI, the \"Accept\" header,      a request parameter, as well as to fall back on a default content type.      By default, file extension in the request URI is checked first and      the \"Accept\" header is checked next.      \n\r\n\rFor file extensions in the request URI, the MVC Java config and      the MVC namespace, automatically register extensions such as      .json, .xml,      .rss, and .atom if the      corresponding dependencies such as Jackson, JAXB2, or Rome      are present on the classpath. Additional extensions may be not need      to be registered explicitly if they can be discovered via      ServletContext.getMimeType(String) or the      Java Activation Framework      (see javax.activation.MimetypesFileTypeMap).      \n\r\n\rBelow is an example of customizing content negotiation      options through the MVC Java config:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {    configurer.favorPathExtension(false).favorParameter(true);  }}     \n\r\n\rIn the MVC namespace, the &lt;mvc:annotation-driven&gt; element     has a content-negotiation-manager attribute, which expects a     ContentNegotiationManager that in turn can be created     with a ContentNegotiationManagerFactoryBean:     &lt;mvc:annotation-driven content-negotiation-manager=\"contentNegotiationManager\" /&gt;&lt;bean id=\"contentNegotiationManager\" class=\"org.springframework.web.accept.ContentNegotiationManagerFactoryBean\"&gt;    &lt;property name=\"favorPathExtension\" value=\"false\" /&gt;    &lt;property name=\"favorParameter\" value=\"true\" /&gt;    &lt;property name=\"mediaTypes\" &gt;        &lt;value&gt;            json=application/json            xml=application/xml        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rIf not using the MVC Java config or the MVC namespace, you\'ll need      to create an instance of ContentNegotiationManager      and use it to configure      RequestMappingHandlerMapping for request mapping      purposes, and RequestMappingHandlerAdapter and      ExceptionHandlerExceptionResolver for      content negotiation purposes.      \n\r\n\rNote that ContentNegotiatingViewResolver      now can also be configured with a ContentNegotiatingViewResolver,      so you can use one instance throughout Spring MVC.      \n\r\n\rIn more advanced cases, it may be useful to configure      multiple ContentNegotiationManager instances      that in turn may contain custom      ContentNegotiationStrategy implementations.      For example you could configure      ExceptionHandlerExceptionResolver with      a ContentNegotiationManager that always      resolves the requested media type to \"application/json\".      Or you may want to plug a custom strategy that has some logic to select      a default content type (e.g. either XML or JSON) if no content      types were requested.        17.15.5&nbsp;Configuring View Controllers            \n\r\n\rThis is a shortcut for defining a      ParameterizableViewController that immediately      forwards to a view when invoked. Use it in static cases when there is no      Java controller logic to execute before the view generates the      response.      \n\r\n\rAn example of forwarding a request for \"/\"      to a view called \"home\" in Java:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void addViewControllers(ViewControllerRegistry registry) {    registry.addViewController(\"/\").setViewName(\"home\");  }}      \n\r\n\rAnd the same in XML use the &lt;mvc:view-controller&gt; element:      &lt;mvc:view-controller path=\"/\" view-name=\"home\"/&gt;        17.15.6&nbsp;Configuring Serving of Resources            \n\r\n\rThis option allows static resource requests following a particular      URL pattern to be served by a      ResourceHttpRequestHandler from any of a list of      Resource locations. This provides a convenient      way to serve static resources from locations other than the web      application root, including locations on the classpath. The      cache-period property may be used to set far future      expiration headers (1 year is the recommendation of optimization tools      such as Page Speed and YSlow) so that they will be more efficiently      utilized by the client. The handler also properly evaluates the      Last-Modified header (if present) so that a      304 status code will be returned as appropriate, avoiding      unnecessary overhead for resources that are already cached by the      client. For example, to serve resource requests with a URL pattern of      /resources/** from a public-resources      directory within the web application root you would use:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void addResourceHandlers(ResourceHandlerRegistry registry) {    registry.addResourceHandler(\"/resources/**\").addResourceLocations(\"/public-resources/\");  }}      \n\r\n\rAnd the same in XML:      &lt;mvc:resources mapping=\"/resources/**\" location=\"/public-resources/\"/&gt;      \n\r\n\rTo serve these resources with a 1-year future expiration to ensure      maximum use of the browser cache and a reduction in HTTP requests made      by the browser:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void addResourceHandlers(ResourceHandlerRegistry registry) {    registry.addResourceHandler(\"/resources/**\").addResourceLocations(\"/public-resources/\").setCachePeriod(31556926);  }}      \n\r\n\rAnd in XML:      &lt;mvc:resources mapping=\"/resources/**\" location=\"/public-resources/\" cache-period=\"31556926\"/&gt;      \n\r\n\rThe mapping attribute must be an Ant pattern that can      be used by SimpleUrlHandlerMapping, and the      location attribute must specify one or more valid resource      directory locations. Multiple resource locations may be specified using      a comma-separated list of values. The locations specified will be      checked in the specified order for the presence of the resource for any      given request. For example, to enable the serving of resources from both      the web application root and from a known path of      /META-INF/public-web-resources/ in any jar on the      classpath use:      @EnableWebMvc@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void addResourceHandlers(ResourceHandlerRegistry registry) {    registry.addResourceHandler(\"/resources/**\")      .addResourceLocations(\"/\", \"classpath:/META-INF/public-web-resources/\");  }}      \n\r\n\rAnd in XML:      &lt;mvc:resources mapping=\"/resources/**\" location=\"/, classpath:/META-INF/public-web-resources/\"/&gt;      \n\r\n\rWhen serving resources that may change when a new version of the      application is deployed, it is recommended that you incorporate a      version string into the mapping pattern used to request the resources,      so that you may force clients to request the newly deployed version of      your application\'s resources. Such a version string can be parameterized      and accessed using SpEL so that it may be easily managed in a single      place when deploying new versions.      \n\r\n\rAs an example, let\'s consider an application that uses a      performance-optimized custom build (as recommended) of the Dojo      JavaScript library in production, and that the build is generally      deployed within the web application at a path of      /public-resources/dojo/dojo.js. Since different parts of      Dojo may be incorporated into the custom build for each new version of      the application, the client web browsers need to be forced to      re-download that custom-built dojo.js resource any time a      new version of the application is deployed. A simple way to achieve this      would be to manage the version of the application in a properties file,      such as:      application.version=1.0.0      \n\r\n\rand then to make the properties file\'s values accessible to SpEL      as a bean using the util:properties tag:      &lt;util:properties id=\"applicationProps\" location=\"/WEB-INF/spring/application.properties\"/&gt;      \n\r\n\rWith the application version now accessible via SpEL, we can      incorporate this into the use of the resources tag:      &lt;mvc:resources mapping=\"/resources-#{applicationProps[\'application.version\']}/**\" location=\"/public-resources/\"/&gt;      \n\r\n\rIn Java, you can use the @PropertySouce      annotation and then inject the Environment      abstraction for access to all defined properties:      @Configuration@EnableWebMvc@PropertySource(\"/WEB-INF/spring/application.properties\")public class WebConfig extends WebMvcConfigurerAdapter {  @Inject Environment env;  @Override  public void addResourceHandlers(ResourceHandlerRegistry registry) {    registry.addResourceHandler(\"/resources-\" + env.getProperty(\"application.version\") + \"/**\")      .addResourceLocations(\"/public-resources/\");  }}      \n\r\n\rand finally, to request the resource with the proper URL, we can      take advantage of the Spring JSP tags:      &lt;spring:eval expression=\"@applicationProps[\'application.version\']\" var=\"applicationVersion\"/&gt;&lt;spring:url value=\"/resources-{applicationVersion}\" var=\"resourceUrl\"&gt;    &lt;spring:param name=\"applicationVersion\" value=\"${applicationVersion}\"/&gt;&lt;/spring:url&gt;&lt;script src=\"${resourceUrl}/dojo/dojo.js\" type=\"text/javascript\"&gt; &lt;/script&gt;        17.15.7&nbsp;mvc:default-servlet-handler            \n\r\n\rThis tag allows for mapping the DispatcherServlet to      \"/\" (thus overriding the mapping of the container\'s default Servlet),      while still allowing static resource requests to be handled by the      container\'s default Servlet. It configures a      DefaultServletHttpRequestHandler with a URL mapping of      \"/**\" and the lowest priority relative to other URL mappings.      \n\r\n\rThis handler will forward all requests to the default Servlet.      Therefore it is important that it remains last in the order of all other      URL HandlerMappings. That will be the case if you use      &lt;mvc:annotation-driven&gt; or alternatively if you are      setting up your own customized HandlerMapping instance be      sure to set its order property to a value lower than that      of the DefaultServletHttpRequestHandler, which is      Integer.MAX_VALUE.      \n\r\n\rTo enable the feature using the default setup use:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {    configurer.enable();  }}      \n\r\n\rOr in XML:      &lt;mvc:default-servlet-handler/&gt;      \n\r\n\rThe caveat to overriding the \"/\" Servlet mapping is that the      RequestDispatcher for the default Servlet must be retrieved      by name rather than by path. The      DefaultServletHttpRequestHandler will attempt to      auto-detect the default Servlet for the container at startup time, using      a list of known names for most of the major Servlet containers      (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and      WebSphere). If the default Servlet has been custom configured with a      different name, or if a different Servlet container is being used where      the default Servlet name is unknown, then the default Servlet\'s name      must be explicitly provided as in the following example:      @Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter {  @Override  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {    configurer.enable(\"myCustomDefaultServlet\");  }}      \n\r\n\rOr in XML:      &lt;mvc:default-servlet-handler default-servlet-name=\"myCustomDefaultServlet\"/&gt;        17.15.8&nbsp;More Spring Web MVC Resources            \n\r\n\rSee the following links and pointers for more resources about Spring Web MVC:      \n\r          \n\r\n\rThere are many excellent articles and tutorials that show how to          build web applications with Spring MVC. Read them at the Spring          Documentation page.        \n\r          \n\r\n\r&#8220;Expert Spring Web MVC and Web Flow&#8221; by Seth Ladd          and others (published by Apress) is an excellent hard copy source of          Spring Web MVC goodness.        \n\r        17.15.9&nbsp;Advanced Customizations with MVC Java Config            \n\r\n\rAs you can see from the above examples, MVC Java config and      the MVC namespace provide higher level constructs that do not      require deep knowledge of the underlying beans created for you.      Instead it helps you to focus on your application needs.      However, at some point you may need more fine-grained control      or you may simply wish to understand the underlying configuration.      \n\r\n\rThe first step towards more fine-grained control is to see the      underlying beans created for you. In MVC Java config you can      see the Javadoc and the @Bean      methods in WebMvcConfigurationSupport.      The configuration in this class is automatically imported      through the @EnableWebMvc annotation.      In fact if you open @EnableWebMvc you can      see the @Import statement.      \n\r\n\rThe next step towards more fine-grained control is to      customize a property on one of the beans created in      WebMvcConfigurationSupport or perhaps      to provide your own instance. This requires two things --      remove the @EnableWebMvc      annotation in order to prevent the import and then      extend directly from WebMvcConfigurationSupport.      Here is an example:            @Configurationpublic class WebConfig extends WebMvcConfigurationSupport {  @Override  public void addInterceptors(InterceptorRegistry registry){    // ...  }  @Override  @Bean  public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {      // Create or let \"super\" create the adapter      // Then customize one of its properties  }}      \n\r\n\rNote that modifying beans in this way does not prevent      you from using any of the higher-level constructs shown earlier in      this section.         17.15.10&nbsp;Advanced Customizations with the MVC Namespace            \n\r\n\rFine-grained control over the configuration created for      you is a bit harder with the MVC namespace.      \n\r\n\rIf you do need to do that, rather than replicating the      configuration it provides, consider configuring a      BeanPostProcessor that detects      the bean you want to customize by type and then modifying its      properties as necessary. For example:    @Componentpublic class MyPostProcessor implements BeanPostProcessor {  public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {    if (bean instanceof RequestMappingHandlerAdapter) {      // Modify properties of the adapter    }  }}      \n\r\n\rNote that MyPostProcessor needs to be      included in an &lt;component scan /&gt;      in order for it to be detected or if you prefer you can declare it      explicitly with an XML bean declaration.      Prev&nbsp;Up&nbsp;NextPart&nbsp;V.&nbsp;The Web&nbsp;Home&nbsp;18.&nbsp;View technologies","17. Web MVC framework","scr\\mvc.html","         2.&nbsp;New Features and Enhancements in Spring Framework 3.0Prev&nbsp;Part&nbsp;II.&nbsp;What\'s New in Spring 3&nbsp;Next2.&nbsp;New Features and Enhancements in Spring Framework 3.0    \n\r\n\rIf you have been using the Spring Framework for some time, you will be  aware that Spring has undergone two major revisions: Spring 2.0, released in  October 2006, and Spring 2.5, released in November 2007. It is now time for  a third overhaul resulting in Spring Framework 3.0.  \n\r\n\rJava SE and Java EE Support        \n\r\n\rThe Spring Framework is now based on Java 5, and Java 6 is fully    supported.    \n\r\n\rFurthermore, Spring is compatible with J2EE 1.4 and Java EE 5, while    at the same time introducing some early support for Java EE 6.    2.1&nbsp;Java 5        \n\r\n\rThe entire framework code has been revised to take advantage of Java    5 features like generics, varargs and other language improvements. We have    done our best to still keep the code backwards compatible. We now have    consistent use of generic Collections and Maps, consistent use of generic    FactoryBeans, and also consistent resolution of bridge methods in the    Spring AOP API. Generic ApplicationListeners automatically receive    specific event types only. All callback interfaces such as    TransactionCallback and HibernateCallback declare a generic result value    now. Overall, the Spring core codebase is now freshly revised and    optimized for Java 5.    \n\r\n\rSpring\'s TaskExecutor abstraction has been updated for close    integration with Java 5\'s java.util.concurrent facilities. We provide    first-class support for Callables and Futures now, as well as    ExecutorService adapters, ThreadFactory integration, etc. This has been    aligned with JSR-236 (Concurrency Utilities for Java EE 6) as far as    possible. Furthermore, we provide support for asynchronous method    invocations through the use of the new @Async annotation (or EJB 3.1\'s    @Asynchronous annotation).    2.2&nbsp;Improved documentation        \n\r\n\rThe Spring reference documentation has also substantially been    updated to reflect all of the changes and new features for Spring Framework    3.0. While every effort has been made to ensure that there are no errors in    this documentation, some errors may nevertheless have crept in. If you do    spot any typos or even more serious errors, and you can spare a few cycles    during lunch, please do bring the error to the attention of the Spring    team by raising an    issue.    2.3&nbsp;New articles and tutorials        \n\r\n\r        There are many excellent articles and tutorials that show how to get        started with Spring Framework 3 features. Read them at the        Spring Documentation page.            \n\r\n\r      The samples have been improved and updated to take advantage of the new features in Spring      Framework 3. Additionally, the samples have been moved out of the source tree into a dedicated SVN      repository available at:    \n\r\n\r      https://anonsvn.springframework.org/svn/spring-samples/            \n\r\n\rAs such, the samples are no longer distributed alongside Spring      Framework 3 and need to be downloaded separately from the repository      mentioned above. However, this documentation will continue to refer to      some samples (in particular Petclinic) to illustrate various features.      Note\n\r\n\rFor more information on Subversion (or in short SVN), see the project homepage at:      http://subversion.apache.org/          2.4&nbsp;New module organization and build system        \n\r\n\rThe framework modules have been revised and are now managed    separately with one source-tree per module jar:    \n\r        \n\r\n\rorg.springframework.aop      \n\r        \n\r\n\rorg.springframework.beans      \n\r        \n\r\n\rorg.springframework.context      \n\r        \n\r\n\rorg.springframework.context.support      \n\r        \n\r\n\rorg.springframework.expression      \n\r        \n\r\n\rorg.springframework.instrument      \n\r        \n\r\n\rorg.springframework.jdbc      \n\r        \n\r\n\rorg.springframework.jms      \n\r        \n\r\n\rorg.springframework.orm      \n\r        \n\r\n\rorg.springframework.oxm      \n\r        \n\r\n\rorg.springframework.test      \n\r        \n\r\n\rorg.springframework.transaction      \n\r        \n\r\n\rorg.springframework.web      \n\r        \n\r\n\rorg.springframework.web.portlet      \n\r        \n\r\n\rorg.springframework.web.servlet      \n\r        \n\r\n\rorg.springframework.web.struts      \n\r    \n\r\n\rNote:            \n\r\n\rThe spring.jar artifact that contained almost the entire framework      is no longer provided.        \n\r\n\rWe are now using a new Spring build system as known from Spring Web    Flow 2.0. This gives us:    \n\r        \n\r\n\rIvy-based \"Spring Build\" system      \n\r        \n\r\n\rconsistent deployment procedure      \n\r        \n\r\n\rconsistent dependency management      \n\r        \n\r\n\rconsistent generation of OSGi manifests      \n\r    2.5&nbsp;Overview of new features        \n\r\n\rThis is a list of new features for Spring Framework 3.0. We will cover these    features in more detail later in this section.    \n\r        \n\r\n\rSpring Expression Language      \n\r        \n\r\n\rIoC enhancements/Java based bean metadata      \n\r        \n\r\n\rGeneral-purpose type conversion system and field formatting        system      \n\r        \n\r\n\rObject to XML mapping functionality (OXM) moved from Spring Web        Services project      \n\r        \n\r\n\rComprehensive REST support      \n\r        \n\r\n\r@MVC additions      \n\r        \n\r\n\rDeclarative model validation      \n\r        \n\r\n\rEarly support for Java EE 6      \n\r        \n\r\n\rEmbedded database support      \n\r    2.5.1&nbsp;Core APIs updated for Java 5            \n\r\n\rBeanFactory interface returns typed bean instances as far as      possible: \n\r            \n\r\n\rT getBean(Class&lt;T&gt; requiredType)          \n\r            \n\r\n\rT getBean(String name, Class&lt;T&gt; requiredType)          \n\r            \n\r\n\rMap&lt;String, T&gt; getBeansOfType(Class&lt;T&gt;            type)          \n\r      \n\r\n\rSpring\'s TaskExecutor interface now extends      java.util.concurrent.Executor: \n\r            \n\r\n\rextended AsyncTaskExecutor supports standard Callables with            Futures          \n\r      \n\r\n\rNew Java 5 based converter API and SPI: \n\r            \n\r\n\rstateless ConversionService and Converters          \n\r            \n\r\n\rsuperseding standard JDK PropertyEditors          \n\r      \n\r\n\rTyped ApplicationListener&lt;E&gt;        2.5.2&nbsp;Spring Expression Language            \n\r\n\rSpring introduces an expression language which is similar to      Unified EL in its syntax but offers significantly more features. The      expression language can be used when defining XML and Annotation based      bean definitions and also serves as the foundation for expression      language support across the Spring portfolio. Details of this new      functionality can be found in the chapter Spring Expression Language (SpEL).      \n\r\n\rThe Spring Expression Language was created to provide the Spring      community a single, well supported expression language that can be used      across all the products in the Spring portfolio. Its language features      are driven by the requirements of the projects in the Spring portfolio,      including tooling requirements for code completion support within the      Eclipse based SpringSource      Tool Suite.      \n\r\n\rThe following is an example of how the Expression Language can be      used to configure some properties of a database setup &lt;bean class=\"mycompany.RewardsTestDatabase\"&gt;    &lt;property name=\"databaseName\"        value=\"#{systemProperties.databaseName}\"/&gt;    &lt;property name=\"keyGenerator\"        value=\"#{strategyBean.databaseKeyGenerator}\"/&gt;&lt;/bean&gt;      \n\r\n\rThis functionality is also available if you prefer to configure      your components using annotations: @Repositorypublic class RewardsTestDatabase {    @Value(\"#{systemProperties.databaseName}\")    public void setDatabaseName(String dbName) { &#8230; }    @Value(\"#{strategyBean.databaseKeyGenerator}\")    public void setKeyGenerator(KeyGenerator kg) { &#8230; }}        2.5.3&nbsp;The Inversion of Control (IoC) container            Java based bean metadata                \n\r\n\rSome core features from the JavaConfig        project have been added to the Spring Framework now. This means that        the following annotations are now directly supported: \n\r              \n\r\n\r@Configuration            \n\r              \n\r\n\r@Bean            \n\r              \n\r\n\r@DependsOn            \n\r              \n\r\n\r@Primary            \n\r              \n\r\n\r@Lazy            \n\r              \n\r\n\r@Import            \n\r              \n\r\n\r@ImportResource            \n\r              \n\r\n\r@Value            \n\r        \n\r\n\rHere is an example of a Java class providing basic configuration        using the new JavaConfig features: package org.example.config;@Configurationpublic class AppConfig {    private @Value(\"#{jdbcProperties.url}\") String jdbcUrl;    private @Value(\"#{jdbcProperties.username}\") String username;    private @Value(\"#{jdbcProperties.password}\") String password;    @Bean    public FooService fooService() {        return new FooServiceImpl(fooRepository());    }    @Bean    public FooRepository fooRepository() {        return new HibernateFooRepository(sessionFactory());    }    @Bean    public SessionFactory sessionFactory() {        // wire up a session factory        AnnotationSessionFactoryBean asFactoryBean =            new AnnotationSessionFactoryBean();        asFactoryBean.setDataSource(dataSource());        // additional config        return asFactoryBean.getObject();    }    @Bean    public DataSource dataSource() {        return new DriverManagerDataSource(jdbcUrl, username, password);    }}\n\r\n\r To get this to work you need to add the following component        scanning entry in your minimal application context XML file.        &lt;context:component-scan base-package=\"org.example.config\"/&gt;&lt;util:properties id=\"jdbcProperties\" location=\"classpath:org/example/config/jdbc.properties\"/&gt;        \n\r\n\r        Or you can bootstrap a @Configuration class directly using        AnnotationConfigApplicationContext:        public static void main(String[] args) {    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);    FooService fooService = ctx.getBean(FooService.class);    fooService.doStuff();}\n\r\n\r        See Section&nbsp;5.12.2, &#8220;Instantiating the Spring container using      AnnotationConfigApplicationContext&#8221; for full information on        AnnotationConfigApplicationContext.            Defining bean metadata within components                \n\r\n\r@Bean annotated methods are also supported        inside Spring components. They contribute a factory bean definition to        the container. See Defining bean metadata within        components for more information              2.5.4&nbsp;General purpose type conversion system and field formatting      system            \n\r\n\rA general purpose type conversion      system has been introduced. The system is currently used by SpEL      for type conversion, and may also be used by a Spring Container and DataBinder when      binding bean property values.      \n\r\n\rIn addition, a formatter SPI      has been introduced for formatting field values. This SPI provides      a simpler and more robust alternative to JavaBean PropertyEditors for use in client      environments such as Spring MVC.        2.5.5&nbsp;The Data Tier            \n\r\n\rObject to XML mapping functionality (OXM) from the Spring Web      Services project has been moved to the core Spring Framework now. The      functionality is found in the org.springframework.oxm      package. More information on the use of the OXM      module can be found in the Marshalling XML using O/X      Mappers chapter.        2.5.6&nbsp;The Web Tier            \n\r\n\rThe most exciting new feature for the Web Tier is the support for      building RESTful web services and web applications. There are also some      new annotations that can be used in any web application.      Comprehensive REST support                \n\r\n\rServer-side support for building RESTful applications has been        provided as an extension of the existing annotation driven MVC web        framework. Client-side support is provided by the        RestTemplate class in the spirit of other        template classes such as JdbcTemplate and        JmsTemplate. Both server and client side REST        functionality make use of        HttpConverters to facilitate the        conversion between objects and their representation in HTTP requests        and responses.        \n\r\n\rThe MarshallingHttpMessageConverter uses        the Object to XML mapping functionality mentioned        earlier.        \n\r\n\rRefer to the sections on MVC and the RestTemplate for more        information.            @MVC additions                \n\r\n\rA mvc namespace has been introduced that greatly simplifies Spring MVC configuration.        \n\r\n\rAdditional annotations such as        @CookieValue and        @RequestHeaders have been added. See Mapping cookie values with the        @CookieValue annotation and Mapping request header attributes with        the @RequestHeader annotation for more information.              2.5.7&nbsp;Declarative model validation            \n\r\n\rSeveral validation enhancements,      including JSR 303 support that uses Hibernate Validator as the default provider.        2.5.8&nbsp;Early support for Java EE 6            \n\r\n\rWe provide support for asynchronous method invocations through the      use of the new @Async annotation (or EJB 3.1\'s @Asynchronous      annotation).      \n\r\n\rJSR 303, JSF 2.0, JPA 2.0, etc        2.5.9&nbsp;Support for embedded databases            \n\r\n\rConvenient support for embedded Java database      engines, including HSQL, H2, and Derby, is now provided.      Prev&nbsp;Up&nbsp;NextPart&nbsp;II.&nbsp;What\'s New in Spring 3&nbsp;Home&nbsp;3.&nbsp;New Features and Enhancements in Spring Framework 3.1","2. New Features and Enhancements in Spring Framework 3.0","scr\\new-in-3.0.html","         3.&nbsp;New Features and Enhancements in Spring Framework 3.1Prev&nbsp;Part&nbsp;II.&nbsp;What\'s New in Spring 3&nbsp;Next3.&nbsp;New Features and Enhancements in Spring Framework 3.1    \n\r\n\rThis is a list of new features for Spring Framework 3.1. A number of features  do not have dedicated reference documentation but do have complete Javadoc. In such  cases, fully-qualified class names are given. See also Appendix&nbsp;C, Migrating to Spring Framework 3.1    3.1&nbsp;Cache Abstraction        \n\r        \n\r\n\rChapter&nbsp;29, Cache Abstraction      \n\r        \n\r\n\r        Cache Abstraction (SpringSource team blog)      \n\r    3.2&nbsp;Bean Definition Profiles        \n\r        \n\r\n\r        XML profiles (SpringSource Team Blog)      \n\r        \n\r\n\r        Introducing @Profile (SpringSource Team Blog)      \n\r        \n\r\n\rSee org.springframework.context.annotation.Configuration        Javadoc      \n\r        \n\r\n\rSee org.springframework.context.annotation.Profile        Javadoc      \n\r    3.3&nbsp;Environment Abstraction        \n\r        \n\r\n\r        Environment Abstraction (SpringSource Team Blog)      \n\r        \n\r\n\rSee org.springframework.core.env.Environment Javadoc      \n\r    3.4&nbsp;PropertySource Abstraction        \n\r        \n\r\n\r        Unified Property Management (SpringSource Team Blog)      \n\r        \n\r\n\rSee org.springframework.core.env.Environment Javadoc      \n\r        \n\r\n\rSee org.springframework.core.env.PropertySource Javadoc      \n\r        \n\r\n\rSee org.springframework.context.annotation.PropertySource        Javadoc      \n\r    3.5&nbsp;Code equivalents for Spring\'s XML namespaces        \n\r\n\rCode-based equivalents to popular Spring XML namespace elements    &lt;context:component-scan/&gt;, &lt;tx:annotation-driven/&gt;    and &lt;mvc:annotation-driven&gt; have been developed, most in the    form of @Enable annotations. These are    designed for use in conjunction with Spring\'s    @Configuration classes, which were    introduced in Spring Framework 3.0.    \n\r        \n\r\n\rSee org.springframework.context.annotation.Configuration        Javadoc      \n\r        \n\r\n\rSee org.springframework.context.annotation.ComponentScan        Javadoc      \n\r        \n\r\n\rSee        org.springframework.transaction.annotation.EnableTransactionManagement        Javadoc      \n\r        \n\r\n\rSee        org.springframework.cache.annotation.EnableCaching Javadoc      \n\r        \n\r\n\rSee org.springframework.web.servlet.config.annotation.EnableWebMvc        Javadoc      \n\r        \n\r\n\rSee org.springframework.scheduling.annotation.EnableScheduling        Javadoc      \n\r        \n\r\n\rSee org.springframework.scheduling.annotation.EnableAsync        Javadoc      \n\r        \n\r\n\rSee        org.springframework.context.annotation.EnableAspectJAutoProxy        Javadoc      \n\r        \n\r\n\rSee        org.springframework.context.annotation.EnableLoadTimeWeaving        Javadoc      \n\r        \n\r\n\rSee        org.springframework.beans.factory.aspectj.EnableSpringConfigured        Javadoc      \n\r    3.6&nbsp;Support for Hibernate 4.x        \n\r        \n\r\n\rSee Javadoc for classes within the new        org.springframework.orm.hibernate4 package      \n\r    3.7&nbsp;TestContext framework support for @Configuration classes and bean    definition profiles        \n\r\n\rThe @ContextConfiguration    annotation now supports supplying    @Configuration classes for configuring    the Spring TestContext. In addition, a new    @ActiveProfiles annotation has been    introduced to support declarative configuration of active bean    definition profiles in ApplicationContext    integration tests.    \n\r        \n\r\n\rSpring        3.1 M2: Testing with @Configuration Classes and Profiles        (SpringSource Team Blog)      \n\r        \n\r\n\rSee Section&nbsp;11.3.5, &#8220;Spring TestContext Framework&#8221;      \n\r        \n\r\n\rSee the section called &#8220;Context configuration with annotated classes&#8221;        and        org.springframework.test.context.ContextConfiguration        Javadoc      \n\r        \n\r\n\rSee        org.springframework.test.context.ActiveProfiles        Javadoc      \n\r        \n\r\n\rSee        org.springframework.test.context.SmartContextLoader        Javadoc      \n\r        \n\r\n\rSee        org.springframework.test.context.support.DelegatingSmartContextLoader        Javadoc      \n\r        \n\r\n\rSee        org.springframework.test.context.support.AnnotationConfigContextLoader        Javadoc      \n\r    3.8&nbsp;c: namespace for more concise constructor injection        \n\r        \n\r\n\rthe section called &#8220;XML shortcut with the c-namespace&#8221;      \n\r    3.9&nbsp;Support for injection against non-standard JavaBeans    setters        \n\r\n\rPrior to Spring Framework 3.1, in order to inject against a property    method it had to conform strictly to JavaBeans property signature rules,    namely that any \'setter\' method must be void-returning. It is now possible    in Spring XML to specify setter methods that return any object type. This    is useful when considering designing APIs for method-chaining, where    setter methods return a reference to \'this\'.    3.10&nbsp;Support for Servlet 3 code-based configuration of Servlet    Container        \n\r\n\rThe new WebApplicationInitializer    builds atop Servlet 3.0\'s    ServletContainerInitializer support to    provide a programmatic alternative to the traditional web.xml.    \n\r        \n\r\n\rSee org.springframework.web.WebApplicationInitializer        Javadoc      \n\r        \n\r\n\rDiff from Spring\'s        Greenhouse reference application demonstrating migration        from web.xml to        WebApplicationInitializer      \n\r    3.11&nbsp;Support for Servlet 3 MultipartResolver        \n\r        \n\r\n\rSee        org.springframework.web.multipart.support.StandardServletMultipartResolver        Javadoc      \n\r    3.12&nbsp;JPA EntityManagerFactory bootstrapping without    persistence.xml        \n\r\n\rIn standard JPA, persistence units get defined through    META-INF/persistence.xml files in specific jar files    which will in turn get searched for @Entity classes.    In many cases, persistence.xml does not contain more than a unit name    and relies on defaults and/or external setup for all other concerns    (such as the DataSource to use, etc). For that reason, Spring Framework    3.1 provides an alternative:    LocalContainerEntityManagerFactoryBean accepts a    \'packagesToScan\' property, specifying base packages to scan for    @Entity classes. This is analogous to    AnnotationSessionFactoryBean\'s property of the    same name for native Hibernate setup, and also to Spring\'s    component-scan feature for regular Spring beans. Effectively, this    allows for XML-free JPA setup at the mere expense of specifying a base    package for entity scanning: a particularly fine match for Spring    applications which rely on component scanning for Spring beans as well,    possibly even bootstrapped using a code-based Servlet 3.0    initializer.    3.13&nbsp;New HandlerMethod-based Support Classes For Annotated Controller    Processing        \n\r\n\rSpring Framework 3.1 introduces a new set of support classes for    processing requests with annotated controllers:    \n\r        \n\r\n\rRequestMappingHandlerMapping      \n\r        \n\r\n\rRequestMappingHandlerAdapter      \n\r        \n\r\n\rExceptionHandlerExceptionResolver      \n\r    \n\r\n\rThese classes are a replacement for the existing:    \n\r        \n\r\n\rDefaultAnnotationHandlerMapping      \n\r        \n\r\n\rAnnotationMethodHandlerAdapter      \n\r        \n\r\n\rAnnotationMethodHandlerExceptionResolver      \n\r    \n\r\n\rThe new classes were developed in response to many requests to    make annotation controller support classes more customizable and open    for extension. Whereas previously you could configure a custom annotated    controller method argument resolver, with the new support classes you    can customize the processing for any supported method argument or return    value type.    \n\r        \n\r\n\rSee        org.springframework.web.method.support.HandlerMethodArgumentResolver        Javadoc      \n\r        \n\r\n\rSee        org.springframework.web.method.support.HandlerMethodReturnValueHandler        Javadoc      \n\r    \n\r\n\rA second notable difference is the introduction of a    HandlerMethod abstraction to represent an    @RequestMapping method. This abstraction is used    throughout by the new support classes as the handler    instance. For example a HandlerInterceptor can    cast the handler from Object    to HandlerMethod and get access to the target    controller method, its annotations, etc.    \n\r\n\rThe new classes are enabled by default by the MVC namespace and by    Java-based configuration via @EnableWebMvc. The    existing classes will continue to be available but use of the new    classes is recommended going forward.    \n\r\n\rSee the section called &#8220;New Support Classes for @RequestMapping methods in Spring MVC 3.1&#8221; for additional    details and a list of features not available with the new support classes.    3.14&nbsp;\"consumes\" and \"produces\" conditions in    @RequestMapping        \n\r\n\rImproved support for specifying media types consumed by a method    through the \'Content-Type\' header as well as for    producible types specified through the \'Accept\'    header. See the section called &#8220;Consumable Media Types&#8221; and the section called &#8220;Producible Media Types&#8221;    3.15&nbsp;Flash Attributes and    RedirectAttributes        \n\r\n\rFlash attributes can now be stored in a    FlashMap and saved in the HTTP session to survive    a redirect. For an overview of the general support for flash attributes    in Spring MVC see Section&nbsp;17.6, &#8220;Using flash attributes&#8221;.    \n\r\n\rIn annotated controllers, an    @RequestMapping method can add flash    attributes by declaring a method argument of type    RedirectAttributes. This method argument    can now also be used to get precise control over the attributes used in    a redirect scenario. See the section called &#8220;Specifying redirect and flash attributes&#8221;    for more details.    3.16&nbsp;URI Template Variable Enhancements        \n\r\n\rURI template variables from the current request are used in more    places: \n\r          \n\r\n\rURI template variables are used in addition to request          parameters when binding a request to          @ModelAttribute method          arguments.        \n\r          \n\r\n\r@PathVariable method argument values are merged into the          model before rendering, except in views that generate content in          an automated fashion such as JSON serialization or XML          marshalling.        \n\r          \n\r\n\rA redirect string can contain placeholders for URI variables          (e.g. \"redirect:/blog/{year}/{month}\"). When          expanding the placeholders, URI template variables from the          current request are automatically considered.        \n\r          \n\r\n\rAn @ModelAttribute method          argument can be instantiated from a URI template variable provided          there is a registered Converter or PropertyEditor to convert from          a String to the target object type.        \n\r    3.17&nbsp;@Valid On    @RequestBody Controller Method Arguments        \n\r\n\rAn @RequestBody method argument can be    annotated with @Valid to invoke automatic    validation similar to the support for    @ModelAttribute method arguments. A resulting    MethodArgumentNotValidException is handled in the    DefaultHandlerExceptionResolver and results in a    400 response code.    3.18&nbsp;@RequestPart Annotation On    Controller Method Arguments        \n\r\n\rThis new annotation provides access to the content of a    \"multipart/form-data\" request part. See Section&nbsp;17.10.5, &#8220;Handling a file upload request from programmatic clients&#8221; and Section&nbsp;17.10, &#8220;Spring\'s multipart (file upload) support&#8221;.    3.19&nbsp;UriComponentsBuilder and UriComponents        \n\r\n\rA new UriComponents class has been added,    which is an immutable container of URI components providing    access to all contained URI components.    A new UriComponentsBuilder class is also    provided to help create UriComponents instances.    Together the two classes give fine-grained control over all    aspects of preparing a URI including construction, expansion    from URI template variables, and encoding.    \n\r\n\rIn most cases the new classes can be used as a more flexible    alternative to the existing UriTemplate    especially since UriTemplate relies on those    same classes internally.        \n\r\n\rA ServletUriComponentsBuilder sub-class    provides static factory methods to copy information from    a Servlet request. See Section&nbsp;17.7, &#8220;Building URIs&#8221;.      Prev&nbsp;Up&nbsp;Next2.&nbsp;New Features and Enhancements in Spring Framework 3.0&nbsp;Home&nbsp;4.&nbsp;New Features and Enhancements in Spring Framework 3.2","3. New Features and Enhancements in Spring Framework 3.1","scr\\new-in-3.1.html","         4.&nbsp;New Features and Enhancements in Spring Framework 3.2Prev&nbsp;Part&nbsp;II.&nbsp;What\'s New in Spring 3&nbsp;Next4.&nbsp;New Features and Enhancements in Spring Framework 3.2    \n\r\n\rThis section covers what\'s new in Spring Framework 3.2. See also  Appendix&nbsp;D, Migrating to Spring Framework 3.2  4.1&nbsp;Support for Servlet 3 based asynchronous request processing        \n\r\n\rThe Spring MVC programming model now provides explicit Servlet 3    async support. @RequestMapping methods can    return one of:    \n\r        \n\r\n\rjava.util.concurrent.Callable to        complete processing in a separate thread managed by a task executor        within Spring MVC.      \n\r        \n\r\n\rorg.springframework.web.context.request.async.DeferredResult        to complete processing at a later time from a thread not known to        Spring MVC &#8212; for example, in response to some external event (JMS,        AMQP, etc.)      \n\r        \n\r\n\rorg.springframework.web.context.request.async.AsyncTask        to wrap a Callable and customize the        timeout value or the task executor to use.      \n\r    \n\r\n\rSee Section&nbsp;17.3.4, &#8220;Asynchronous Request Processing&#8221;.    4.2&nbsp;Spring MVC Test framework        \n\r\n\rFirst-class support for testing Spring MVC applications with a    fluent API and without a Servlet container. Server-side tests involve use    of the DispatcherServlet while client-side REST    tests rely on the RestTemplate. See Section&nbsp;11.3.6, &#8220;Spring MVC Test Framework&#8221;.    4.3&nbsp;Content negotiation improvements        \n\r\n\rA ContentNegotiationStrategy is now    available for resolving the requested media types from an incoming    request. The available implementations are based on the file extension,    query parameter, the \'Accept\' header, or a fixed content type.    Equivalent options were previously available only in the    ContentNegotiatingViewResolver but are now available throughout.    \n\r\n\rContentNegotiationManager is the central    class to use when configuring content negotiation options.    For more details see Section&nbsp;17.15.4, &#8220;Configuring Content Negotiation&#8221;.    \n\r\n\rThe introduction of ContentNegotiationManger    also enables selective suffix pattern matching for incoming requests.    For more details, see the Javadoc of    RequestMappingHandlerMapping.setUseRegisteredSuffixPatternMatch.    4.4&nbsp;@ControllerAdvice annotation        \n\r\n\rClasses annotated with    @ControllerAdvice can contain    @ExceptionHandler,    @InitBinder, and    @ModelAttribute methods and those will    apply to @RequestMapping methods across    controller hierarchies as opposed to the controller hierarchy within which    they are declared. @ControllerAdvice is a    component annotation allowing implementation classes to be auto-detected    through classpath scanning.    4.5&nbsp;Matrix variables        \n\r\n\rA new @MatrixVariable annotation adds    support for extracting matrix variables from the request URI. For more    details see the section called &#8220;Matrix Variables&#8221;.    4.6&nbsp;Abstract base class for code-based Servlet 3+ container    initialization        \n\r\n\rAn abstract base class implementation of the    WebApplicationInitializer interface is    provided to simplify code-based registration of a DispatcherServlet and    filters mapped to it. The new class is named    AbstractDispatcherServletInitializer and its    sub-class    AbstractAnnotationConfigDispatcherServletInitializer    can be used with Java-based Spring configuration. For more details see    Section&nbsp;17.14, &#8220;Code-based Servlet container initialization&#8221;.    4.7&nbsp;ResponseEntityExceptionHandler class        \n\r\n\rA convenient base class with an    @ExceptionHandler method that handles    standard Spring MVC exceptions and returns a    ResponseEntity that allowing customizing and    writing the response with HTTP message converters. This serves as an    alternative to the DefaultHandlerExceptionResolver,    which does the same but returns a ModelAndView    instead.    \n\r\n\rSee the revised Section&nbsp;17.11, &#8220;Handling exceptions&#8221; including    information on customizing the default Servlet container error    page.    4.8&nbsp;Support for generic types in the    RestTemplate and in    @RequestBody arguments        \n\r\n\rThe RestTemplate can now read an HTTP    response to a generic type (e.g. List&lt;Account&gt;). There    are three new exchange() methods that accept    ParameterizedTypeReference, a new class that    enables capturing and passing generic type info.    \n\r\n\rIn support of this feature, the    HttpMessageConverter is extended by    GenericHttpMessageConverter adding a method    for reading content given a specified parameterized type. The new    interface is implemented by the    MappingJacksonHttpMessageConverter and also by a    new Jaxb2CollectionHttpMessageConverter that can    read read a generic Collection where the    generic type is a JAXB type annotated with    @XmlRootElement or    @XmlType.    4.9&nbsp;Jackson JSON 2 and related improvements        \n\r\n\rThe Jackson JSON 2 library is now supported. Due to packaging    changes in the Jackson library, there are separate classes in Spring MVC    as well. Those are    MappingJackson2HttpMessageConverter and    MappingJackson2JsonView. Other related    configuration improvements include support for pretty printing as well as    a JacksonObjectMapperFactoryBean for convenient    customization of an ObjectMapper in XML    configuration.    4.10&nbsp;Tiles 3        \n\r\n\rTiles 3 is now supported in addition to Tiles 2.x. Configuring    it should be very similar to the Tiles 2 configuration, i.e. the    combination of TilesConfigurer,    TilesViewResolver and TilesView    except using the tiles3 instead of the tiles2    package.    \n\r\n\rAlso note that besides the version number change, the tiles    dependencies have also changed. You will need to have a subset or all of    tiles-request-api, tiles-api,    tiles-core, tiles-servlet,    tiles-jsp, tiles-el.        4.11&nbsp;@RequestBody improvements        \n\r\n\rAn @RequestBody or an    @RequestPart argument can now be followed    by an Errors argument making it possible to    handle validation errors (as a result of an    @Valid annotation) locally within the    @RequestMapping method.    @RequestBody now also supports a required    flag.    4.12&nbsp;HTTP PATCH method        \n\r\n\rThe HTTP request method PATCH may now be used in    @RequestMapping methods as well as in the    RestTemplate in conjunction with Apache    HttpComponents HttpClient version 4.2 or later. The JDK    HttpURLConnection does not support the    PATCH method.    4.13&nbsp;Excluded patterns in mapped interceptors        \n\r\n\rMapped interceptors now support URL patterns to be excluded. The MVC    namespace and the MVC JavaConfig both expose these options.    4.14&nbsp;Using meta-annotations for injection points and for bean definition methods        \n\r\n\rAs of 3.2, Spring allows for @Autowired and    @Value to be used as meta-annotations,    e.g. to build custom injection annotations in combination with specific qualifiers.    Analogously, you may build custom @Bean definition    annotations for @Configuration classes,    e.g. in combination with specific qualifiers, @Lazy, @Primary, etc.    4.15&nbsp;Initial support for JCache 0.5        \n\r\n\rSpring provides a CacheManager adapter for JCache, building against the JCache 0.5    preview release. Full JCache support is coming next year, along with Java EE 7 final.    4.16&nbsp;Support for @DateTimeFormat without    Joda Time        \n\r\n\rThe @DateTimeFormat annotation can    now be used without needing a dependency on the Joda Time library. If Joda    Time is not present the JDK SimpleDateFormat will    be used to parse and print date patterns. When Joda Time is present it    will continue to be used in preference to    SimpleDateFormat.    4.17&nbsp;Global date &amp; time formatting        \n\r\n\rIt is now possible to define global formats that will be used when    parsing and printing date and time types. See Section&nbsp;7.7, &#8220;Configuring a global date &amp; time format&#8221; for    details.    4.18&nbsp;New Testing Features        \n\r\n\rIn addition to the aforementioned inclusion of the Spring MVC Test Framework in    the spring-test module, the Spring    TestContext Framework has been revised with support for    integration testing web applications as well as configuring application    contexts with context initializers. For further details, consult the    following.    \n\r        \n\r\n\rConfiguring and loading a        WebApplicationContext in integration tests      \n\r        \n\r\n\rConfiguring context hierarchies        in integration tests      \n\r        \n\r\n\rTesting request and        session scoped beans      \n\r        \n\r\n\rImprovements to Servlet API        mocks      \n\r        \n\r\n\rConfiguring test application contexts with ApplicationContextInitializers      \n\r    4.19&nbsp;Concurrency refinements across the framework        \n\r\n\rSpring Framework 3.2 includes fine-tuning of concurrent data structures    in many parts of the framework, minimizing locks and generally improving the    arrangements for highly concurrent creation of scoped/prototype beans.    4.20&nbsp;New Gradle-based build and move to GitHub        \n\r\n\rBuilding and contributing to the framework has never been simpler with    our move to a Gradle-based build system and source control at GitHub.    See the     building from source section of the README and the        contributor guidelines for complete details.    4.21&nbsp;Refined Java SE 7 / OpenJDK 7 support        \n\r\n\rLast but not least, Spring Framework 3.2 comes with refined Java 7 support    within the framework as well as through upgraded third-party dependencies:    specifically, CGLIB 3.0, ASM 4.0 (both of which come as inlined dependencies with    Spring now) and AspectJ 1.7 support (next to the existing AspectJ 1.6 support).  Prev&nbsp;Up&nbsp;Next3.&nbsp;New Features and Enhancements in Spring Framework 3.1&nbsp;Home&nbsp;Part&nbsp;III.&nbsp;Core Technologies","4. New Features and Enhancements in Spring Framework 3.2","scr\\new-in-3.2.html","         15.&nbsp;Object Relational Mapping (ORM) Data AccessPrev&nbsp;Part&nbsp;IV.&nbsp;Data Access&nbsp;Next15.&nbsp;Object Relational Mapping (ORM) Data Access    15.1&nbsp;Introduction to ORM with Spring        \n\r\n\rThe Spring Framework supports integration    with Hibernate, Java Persistence API (JPA), Java Data Objects (JDO) and    iBATIS SQL Maps for resource management, data access object (DAO)    implementations, and transaction strategies. For example, for Hibernate    there is first-class support with several convenient IoC features that    address many typical Hibernate integration issues. You can configure    all of the supported features for O/R (object relational) mapping tools through    Dependency Injection. They can participate in Spring\'s resource    and transaction management, and they comply with Spring\'s generic    transaction and DAO exception hierarchies. The recommended integration    style is to code DAOs against plain Hibernate, JPA, and JDO APIs. The    older style of using Spring\'s DAO templates is no longer recommended;    however, coverage of this style can be found in the Section&nbsp;A.1, &#8220;Classic ORM usage&#8221; in the appendices.    \n\r\n\rSpring adds significant enhancements to the ORM layer of your choice    when you create data access applications. You can leverage as much of the    integration support as you wish, and you should compare this integration    effort with the cost and risk of building a similar infrastructure    in-house. You can use much of the ORM support as you would a library,    regardless of technology, because everything is designed as a set of    reusable JavaBeans. ORM in a Spring IoC container facilitates    configuration and deployment. Thus most examples in this section show    configuration inside a Spring container.    \n\r\n\rBenefits of using the Spring Framework to create your ORM DAOs    include:    \n\r        \n\r\n\rEasier testing. Spring\'s IoC approach makes        it easy to swap the implementations and configuration locations of        Hibernate SessionFactory instances,        JDBC DataSource instances, transaction        managers, and mapped object implementations (if needed). This in turn makes it        much easier to test each piece of persistence-related code in        isolation.      \n\r        \n\r\n\rCommon data access exceptions. Spring can        wrap exceptions from your ORM tool, converting them from proprietary        (potentially checked) exceptions to a common runtime        DataAccessException hierarchy. This feature allows you to handle most        persistence exceptions, which are non-recoverable, only in the        appropriate layers, without annoying boilerplate catches, throws, and        exception declarations. You can still trap and handle exceptions as        necessary. Remember that JDBC exceptions (including DB-specific        dialects) are also converted to the same hierarchy, meaning that you        can perform some operations with JDBC within a consistent programming        model.      \n\r        \n\r\n\rGeneral resource management. Spring        application contexts can handle the location and configuration of        Hibernate SessionFactory instances, JPA        EntityManagerFactory instances, JDBC        DataSource instances, iBATIS SQL Maps        configuration objects, and other related resources. This makes these        values easy to manage and change. Spring offers efficient, easy, and        safe handling of persistence resources. For example, related code that        uses Hibernate generally needs to use the same Hibernate        Session to ensure efficiency and proper        transaction handling. Spring makes it easy to create and bind a        Session to the current thread        transparently, by        exposing a current Session through the        Hibernate SessionFactory. Thus Spring        solves many chronic problems of typical Hibernate usage, for any local        or JTA transaction environment.      \n\r        \n\r\n\rIntegrated transaction management. You can        wrap your ORM code with a declarative, aspect-oriented programming        (AOP) style method interceptor either through the        @Transactional annotation or by        explicitly configuring the transaction AOP advice in an XML        configuration file. In both cases, transaction semantics and exception        handling (rollback, and so on) are handled for you. As discussed        below, in Resource and transaction        management, you can also swap various transaction managers,        without affecting your ORM-related code. For example, you can swap        between local transactions and JTA, with the same full services (such        as declarative transactions) available in both scenarios.        Additionally, JDBC-related code can fully integrate transactionally        with the code you use to do ORM. This is useful for data access that        is not suitable for ORM, such as batch processing and BLOB streaming,        which still need to        share common transactions with ORM operations.      \n\r    \n\r\n\rTODO:    provide links to current samples    15.2&nbsp;General ORM integration considerations        \n\r\n\rThis section highlights considerations that apply to all ORM    technologies. The Section&nbsp;15.3, &#8220;Hibernate&#8221; section provides more    details and also show these features and configurations in a concrete    context.    \n\r\n\rThe major goal of Spring\'s ORM integration is clear application    layering, with any data access and transaction technology, and for loose    coupling of application objects. No more business service dependencies on    the data access or transaction strategy, no more hard-coded resource    lookups, no more hard-to-replace singletons, no more custom service    registries. One simple and consistent approach to wiring up application    objects, keeping them as reusable and free from container dependencies as    possible. All the individual data access features are usable on their own    but integrate nicely with Spring\'s application context concept, providing    XML-based configuration and cross-referencing of plain JavaBean instances    that need not be Spring-aware. In a typical Spring application, many    important objects are JavaBeans: data access templates, data access    objects, transaction managers, business services that use the data access    objects and transaction managers, web view resolvers, web controllers that    use the business services,and so on.    15.2.1&nbsp;Resource and transaction management            \n\r\n\rTypical business applications are cluttered with repetitive      resource management code. Many projects try to invent their own      solutions, sometimes sacrificing proper handling of failures for      programming convenience. Spring advocates simple solutions for proper      resource handling, namely IoC through templating in the case of      JDBC and applying AOP interceptors for the ORM technologies.      \n\r\n\rThe infrastructure provides proper resource handling and      appropriate conversion of specific API exceptions to an unchecked      infrastructure exception hierarchy. Spring      introduces a DAO exception hierarchy, applicable to any data access      strategy. For direct JDBC, the JdbcTemplate class      mentioned in a previous section provides connection handling and proper      conversion of SQLException to the      DataAccessException hierarchy, including      translation of database-specific SQL error codes to meaningful exception      classes. For ORM technologies, see the next section for how to get the      same exception translation benefits.      \n\r\n\rWhen it comes to transaction management, the      JdbcTemplate class hooks in to the Spring      transaction support and supports both JTA and JDBC transactions, through      respective Spring transaction managers. For the supported ORM      technologies Spring offers Hibernate, JPA and JDO support through the      Hibernate, JPA, and JDO transaction managers as well as JTA support. For      details on transaction support, see the Chapter&nbsp;12, Transaction Management      chapter.        15.2.2&nbsp;Exception translation            \n\r\n\rWhen you use Hibernate, JPA, or JDO in a DAO, you must decide how      to handle the persistence technology\'s native exception classes. The DAO      throws a subclass of a HibernateException,      PersistenceException or      JDOException depending on the technology.      These exceptions are all run-time exceptions and do not have to be      declared or caught. You may also have to deal with      IllegalArgumentException and      IllegalStateException. This means that callers      can only treat exceptions as generally fatal, unless they want to depend      on the persistence technology\'s own exception structure. Catching      specific causes such as an optimistic locking failure is not possible      without tying the caller to the implementation strategy. This trade off      might be acceptable to applications that are strongly ORM-based and/or      do not need any special exception treatment. However, Spring enables      exception translation to be applied transparently through the      @Repository annotation:      @Repositorypublic class ProductDaoImpl implements ProductDao {    // class body here...}      &lt;beans&gt;  &lt;!-- Exception translation bean post processor --&gt;  &lt;bean class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\"/&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/&gt;&lt;/beans&gt;      \n\r\n\rThe postprocessor automatically looks for all exception      translators (implementations of the      PersistenceExceptionTranslator interface)      and advises all beans marked with the      @Repository annotation so that the      discovered translators can intercept and apply the appropriate      translation on the thrown exceptions.      \n\r\n\rIn summary: you can implement DAOs based on the plain persistence      technology\'s API and annotations, while still benefiting from      Spring-managed transactions, dependency injection, and transparent      exception conversion (if desired) to Spring\'s custom exception      hierarchies.        15.3&nbsp;Hibernate        \n\r\n\rWe will start with a coverage of Hibernate 3 in a Spring    environment, using it to demonstrate the approach that Spring takes    towards integrating O/R mappers. This section will cover many issues in    detail and show different variations of DAO implementations and    transaction demarcation. Most of these patterns can be directly translated    to all other supported ORM tools. The following sections in this chapter    will then cover the other ORM technologies, showing briefer examples    there.    Note\n\r\n\rAs of Spring 3.0, Spring requires Hibernate 3.2 or later.    15.3.1&nbsp;SessionFactory setup in a Spring      container            \n\r\n\rTo avoid tying application objects to hard-coded resource lookups,      you can define resources such as a JDBC      DataSource or a Hibernate      SessionFactory as beans in the Spring      container. Application objects that need to access resources receive      references to such predefined instances through bean references, as      illustrated in the DAO definition in the next section.      \n\r\n\rThe following excerpt from an XML application context definition      shows how to set up a JDBC DataSource and a      Hibernate SessionFactory on top of      it:      &lt;beans&gt;  &lt;bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;    &lt;property name=\"driverClassName\" value=\"org.hsqldb.jdbcDriver\"/&gt;    &lt;property name=\"url\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/&gt;    &lt;property name=\"username\" value=\"sa\"/&gt;    &lt;property name=\"password\" value=\"\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"mySessionFactory\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;    &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt;    &lt;property name=\"mappingResources\"&gt;      &lt;list&gt;        &lt;value&gt;product.hbm.xml&lt;/value&gt;      &lt;/list&gt;    &lt;/property&gt;    &lt;property name=\"hibernateProperties\"&gt;      &lt;value&gt;        hibernate.dialect=org.hibernate.dialect.HSQLDialect      &lt;/value&gt;    &lt;/property&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rSwitching from a local Jakarta Commons DBCP      BasicDataSource to a JNDI-located      DataSource (usually managed by an      application server) is just a matter of configuration:      &lt;beans&gt;  &lt;jee:jndi-lookup id=\"myDataSource\" jndi-name=\"java:comp/env/jdbc/myds\"/&gt;&lt;/beans&gt;      \n\r\n\rYou can also access a JNDI-located      SessionFactory, using Spring\'s      JndiObjectFactoryBean /      &lt;jee:jndi-lookup&gt; to retrieve and expose it.      However, that is typically not common outside of an EJB context.        15.3.2&nbsp;Implementing DAOs based on plain Hibernate 3 API            \n\r\n\rHibernate 3 has a feature called contextual sessions, wherein      Hibernate itself manages one current      Session per transaction. This is roughly      equivalent to Spring\'s synchronization of one Hibernate      Session per transaction. A corresponding      DAO implementation resembles the following example, based on the plain      Hibernate API:      public class ProductDaoImpl implements ProductDao {    private SessionFactory sessionFactory;    public void setSessionFactory(SessionFactory sessionFactory) {        this.sessionFactory = sessionFactory;    }    public Collection loadProductsByCategory(String category) {        return this.sessionFactory.getCurrentSession()                .createQuery(\"from test.Product product where product.category=?\")                .setParameter(0, category)                .list();    }}      \n\r\n\rThis style is similar to that of the Hibernate reference      documentation and examples, except for holding the      SessionFactory in an instance variable.      We strongly recommend such an instance-based setup over the old-school      static HibernateUtil class      from Hibernate\'s CaveatEmptor sample application. (In general, do not      keep any resources in static variables unless      absolutely necessary.)      \n\r\n\rThe above DAO follows the dependency injection pattern: it fits      nicely into a Spring IoC container, just as it would if coded against      Spring\'s HibernateTemplate. Of course, such a DAO      can also be set up in plain Java (for example, in unit tests). Simply      instantiate it and call setSessionFactory(..)      with the desired factory reference. As a Spring bean definition, the DAO      would resemble the following:      &lt;beans&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"sessionFactory\" ref=\"mySessionFactory\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe main advantage of this DAO style is that it depends on      Hibernate API only; no import of any Spring class is required. This is      of course appealing from a non-invasiveness perspective, and will no      doubt feel more natural to Hibernate developers.      \n\r\n\rHowever, the DAO throws plain      HibernateException (which is unchecked, so does      not have to be declared or caught), which means that callers can only      treat exceptions as generally fatal - unless they want to depend on      Hibernate\'s own exception hierarchy. Catching specific causes such as an      optimistic locking failure is not possible without tying the caller to      the implementation strategy. This trade off might be acceptable to      applications that are strongly Hibernate-based and/or do not need any      special exception treatment.      \n\r\n\rFortunately, Spring\'s      LocalSessionFactoryBean supports Hibernate\'s      SessionFactory.getCurrentSession() method for      any Spring transaction strategy, returning the current Spring-managed      transactional Session even with      HibernateTransactionManager. Of course, the      standard behavior of that method remains the return of the current      Session associated with the ongoing JTA      transaction, if any. This behavior applies regardless of whether you are      using Spring\'s JtaTransactionManager, EJB      container managed transactions (CMTs), or JTA.      \n\r\n\rIn summary: you can implement DAOs based on the plain Hibernate 3      API, while still being able to participate in Spring-managed      transactions.        15.3.3&nbsp;Declarative transaction demarcation            \n\r\n\rWe recommend that you use Spring\'s declarative transaction      support, which enables you to replace explicit transaction demarcation      API calls in your Java code with an AOP transaction interceptor. This      transaction interceptor can be configured in a Spring container using      either Java annotations or XML.This declarative transaction capability allows you      to keep business services free of repetitive transaction demarcation      code and to focus on adding business logic, which is the real value of      your application.      Note        \n\r\n\rPrior to continuing, you are strongly        encouraged to read Section&nbsp;12.5, &#8220;Declarative transaction management&#8221; if you        have not done so.            \n\r\n\rFurthermore, transaction semantics like propagation behavior and      isolation level can be changed in a configuration file and do not affect      the business service implementations.      \n\r\n\rThe following example shows how you can configure an AOP      transaction interceptor, using XML, for a simple service class:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;!-- SessionFactory, DataSource, etc. omitted --&gt;  &lt;bean id=\"transactionManager\"            class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;    &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;  &lt;/bean&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"productServiceMethods\"            expression=\"execution(* product.ProductService.*(..))\"/&gt;    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"productServiceMethods\"/&gt;  &lt;/aop:config&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"myTxManager\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"increasePrice*\" propagation=\"REQUIRED\"/&gt;      &lt;tx:method name=\"someOtherBusinessMethod\" propagation=\"REQUIRES_NEW\"/&gt;      &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;bean id=\"myProductService\" class=\"product.SimpleProductService\"&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThis is the service class that is advised:      public class ProductServiceImpl implements ProductService {    private ProductDao productDao;    public void setProductDao(ProductDao productDao) {        this.productDao = productDao;    }    // notice the absence of transaction demarcation code in this method    // Spring\'s declarative transaction infrastructure will be demarcating    // transactions on your behalf     public void increasePriceOfAllProductsInCategory(final String category) {        List productsToChange = this.productDao.loadProductsByCategory(category);        // ...    }}      \n\r\n\rWe also show an attribute-support based configuration, in the      following example. You      annotate the service layer with @Transactional annotations and instruct      the Spring container to find these annotations and provide transactional      semantics for these annotated methods.      public class ProductServiceImpl implements ProductService {    private ProductDao productDao;    public void setProductDao(ProductDao productDao) {        this.productDao = productDao;    }    @Transactional    public void increasePriceOfAllProductsInCategory(final String category) {        List productsToChange = this.productDao.loadProductsByCategory(category);        // ...    }    @Transactional(readOnly = true)    public List&lt;Product&gt; findAllProducts() {        return this.productDao.findAllProducts();    }}      \n\r\n\rAs you can see from the following configuration example, the      configuration is much simplified, compared to the XML example above,      while still providing the same functionality driven by the annotations      in the service layer code. All you need to provide is the      TransactionManager implementation and a \"&lt;tx:annotation-driven/&gt;\"      entry.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;!-- SessionFactory, DataSource, etc. omitted --&gt;  &lt;bean id=\"transactionManager\"            class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;    &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;  &lt;/bean&gt;  &lt;tx:annotation-driven/&gt;  &lt;bean id=\"myProductService\" class=\"product.SimpleProductService\"&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        15.3.4&nbsp;Programmatic transaction demarcation            \n\r\n\rYou can demarcate transactions in a higher level of the      application, on top of such lower-level data access services spanning      any number of operations. Nor do restrictions exist on the      implementation of the surrounding business service; it just needs a      Spring PlatformTransactionManager. Again, the      latter can come from anywhere, but preferably as a bean reference      through a setTransactionManager(..) method,      just as the productDAO should be set by a      setProductDao(..) method. The following      snippets show a transaction manager and a business service definition in      a Spring application context, and an example for a business method      implementation:      &lt;beans&gt;  &lt;bean id=\"myTxManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;    &lt;property name=\"sessionFactory\" ref=\"mySessionFactory\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductService\" class=\"product.ProductServiceImpl\"&gt;    &lt;property name=\"transactionManager\" ref=\"myTxManager\"/&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      public class ProductServiceImpl implements ProductService {    private TransactionTemplate transactionTemplate;    private ProductDao productDao;    public void setTransactionManager(PlatformTransactionManager transactionManager) {        this.transactionTemplate = new TransactionTemplate(transactionManager);    }    public void setProductDao(ProductDao productDao) {        this.productDao = productDao;    }    public void increasePriceOfAllProductsInCategory(final String category) {        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {                public void doInTransactionWithoutResult(TransactionStatus status) {                    List productsToChange = this.productDao.loadProductsByCategory(category);                    // do the price increase...                }            }        );    }}      \n\r\n\rSpring\'s TransactionInterceptor allows any      checked application exception to be thrown with the callback code, while      TransactionTemplate is restricted to unchecked      exceptions within the callback.      TransactionTemplate triggers a rollback in case      of an unchecked application exception, or if the transaction is marked      rollback-only by the application (via      TransactionStatus).      TransactionInterceptor behaves the same way by      default but allows configurable rollback policies per method.        15.3.5&nbsp;Transaction management strategies            \n\r\n\rBoth TransactionTemplate and      TransactionInterceptor delegate the actual      transaction handling to a      PlatformTransactionManager instance, which can be      a HibernateTransactionManager (for a single      Hibernate SessionFactory, using a      ThreadLocal      Session under the hood) or a      JtaTransactionManager (delegating to the JTA      subsystem of the container) for Hibernate applications. You can even use      a custom PlatformTransactionManager      implementation. Switching from native Hibernate transaction management      to JTA, such as when facing distributed transaction requirements for      certain deployments of your application, is just a matter of      configuration. Simply replace the Hibernate transaction manager with      Spring\'s JTA transaction implementation. Both transaction demarcation      and data access code will work without changes, because they just use      the generic transaction management APIs.      \n\r\n\rFor distributed transactions across multiple Hibernate session      factories, simply combine JtaTransactionManager      as a transaction strategy with multiple      LocalSessionFactoryBean definitions. Each DAO      then gets one specific SessionFactory      reference passed into its corresponding bean property. If all underlying      JDBC data sources are transactional container ones, a business service      can demarcate transactions across any number of DAOs and any number of      session factories without special regard, as long as it is using      JtaTransactionManager as the strategy.      &lt;beans&gt;  &lt;jee:jndi-lookup id=\"dataSource1\" jndi-name=\"java:comp/env/jdbc/myds1\"/&gt;  &lt;jee:jndi-lookup id=\"dataSource2\" jndi-name=\"java:comp/env/jdbc/myds2\"/&gt;  &lt;bean id=\"mySessionFactory1\"            class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;    &lt;property name=\"dataSource\" ref=\"myDataSource1\"/&gt;    &lt;property name=\"mappingResources\"&gt;      &lt;list&gt;        &lt;value&gt;product.hbm.xml&lt;/value&gt;      &lt;/list&gt;    &lt;/property&gt;    &lt;property name=\"hibernateProperties\"&gt;      &lt;value&gt;        hibernate.dialect=org.hibernate.dialect.MySQLDialect        hibernate.show_sql=true      &lt;/value&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"mySessionFactory2\"            class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;    &lt;property name=\"dataSource\" ref=\"myDataSource2\"/&gt;    &lt;property name=\"mappingResources\"&gt;      &lt;list&gt;        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;      &lt;/list&gt;    &lt;/property&gt;    &lt;property name=\"hibernateProperties\"&gt;      &lt;value&gt;        hibernate.dialect=org.hibernate.dialect.OracleDialect      &lt;/value&gt;    &lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=\"myTxManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"sessionFactory\" ref=\"mySessionFactory1\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myInventoryDao\" class=\"product.InventoryDaoImpl\"&gt;    &lt;property name=\"sessionFactory\" ref=\"mySessionFactory2\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductService\" class=\"product.ProductServiceImpl\"&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;    &lt;property name=\"inventoryDao\" ref=\"myInventoryDao\"/&gt;  &lt;/bean&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"productServiceMethods\"                expression=\"execution(* product.ProductService.*(..))\"/&gt;    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"productServiceMethods\"/&gt;  &lt;/aop:config&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"myTxManager\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"increasePrice*\" propagation=\"REQUIRED\"/&gt;      &lt;tx:method name=\"someOtherBusinessMethod\" propagation=\"REQUIRES_NEW\"/&gt;      &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;&lt;/beans&gt;      \n\r\n\rBoth HibernateTransactionManager and      JtaTransactionManager allow for proper JVM-level      cache handling with Hibernate, without container-specific transaction      manager lookup or a JCA connector (if you are not using EJB to initiate      transactions).      \n\r\n\rHibernateTransactionManager can export the      Hibernate JDBC Connection to plain JDBC      access code, for a specific DataSource.      This capability allows for high-level transaction demarcation with mixed      Hibernate and JDBC data access completely without JTA, if you are      accessing only one database.      HibernateTransactionManager automatically exposes      the Hibernate transaction as a JDBC transaction if you have set up the      passed-in SessionFactory with a      DataSource through the      dataSource property of the      LocalSessionFactoryBean class. Alternatively, you      can specify explicitly the DataSource for      which the transactions are supposed to be exposed through the      dataSource property of the      HibernateTransactionManager class.        15.3.6&nbsp;Comparing container-managed and locally defined resources            \n\r\n\rYou can switch between a container-managed JNDI      SessionFactory and a      locally defined one, without having to change a single line of      application code. Whether to keep resource definitions in the container      or locally within the application is mainly a matter of the transaction      strategy that you use. Compared to a Spring-defined local      SessionFactory, a manually registered      JNDI SessionFactory does not provide any      benefits. Deploying a SessionFactory      through Hibernate\'s JCA connector provides the added value of      participating in the Java EE server\'s management infrastructure, but      does not add actual value beyond that.      \n\r\n\rSpring\'s transaction support is not bound to a container.      Configured with any strategy other than JTA, transaction support also      works in a stand-alone or test environment. Especially in the typical      case of single-database transactions, Spring\'s single-resource local      transaction support is      a lightweight and powerful alternative to JTA. When you use local EJB      stateless session beans to drive transactions, you depend both on an EJB      container and JTA, even if you access only a single database, and only      use stateless session beans to provide declarative transactions through      container-managed transactions. Also,      direct use of JTA programmatically requires a Java EE environment as      well. JTA does not involve only container dependencies in terms of JTA      itself and of JNDI DataSource instances.      For non-Spring, JTA-driven Hibernate transactions, you have to use the      Hibernate JCA connector, or extra Hibernate transaction code with the      TransactionManagerLookup configured for      proper JVM-level caching.      \n\r\n\rSpring-driven transactions can work as well with a locally defined      Hibernate SessionFactory as they do with      a local JDBC DataSource if they are      accessing a single database. Thus you only have to use Spring\'s JTA      transaction strategy when you have distributed transaction requirements.      A JCA connector requires container-specific deployment steps, and      obviously JCA support in the first place. This configuration requires      more work than deploying a simple web application with local resource      definitions and Spring-driven transactions. Also, you often need the      Enterprise Edition of your container if you are using, for example,      WebLogic Express, which does not provide JCA. A Spring application with      local resources and transactions spanning one single database works in      any Java EE web container (without JTA, JCA, or EJB) such as Tomcat,      Resin, or even plain Jetty. Additionally, you can easily reuse such a      middle tier in desktop applications or test suites.      \n\r\n\rAll things considered, if you do not use EJBs, stick with local      SessionFactory setup and Spring\'s      HibernateTransactionManager or      JtaTransactionManager. You get all of the      benefits, including proper transactional JVM-level caching and      distributed transactions, without the inconvenience of container      deployment. JNDI registration of a Hibernate      SessionFactory through the JCA connector      only adds value when used in conjunction with EJBs.        15.3.7&nbsp;Spurious application server warnings with Hibernate            \n\r\n\rIn some JTA environments with very strict      XADataSource implementations -- currently      only some WebLogic Server and WebSphere versions -- when Hibernate is      configured without regard to the JTA      PlatformTransactionManager object for      that environment, it is possible for spurious warning or exceptions to      show up in the application server log. These warnings or exceptions      indicate that the connection being accessed is no longer valid, or JDBC      access is no longer valid, possibly because the transaction is no longer      active. As an example, here is an actual exception from WebLogic:      java.sql.SQLException: The transaction is no longer active - status: \'Committed\'.   No further JDBC access is allowed within this transaction.      \n\r\n\rYou resolve this warning by simply making Hibernate aware of the      JTA PlatformTransactionManager instance,      to which it will synchronize (along with Spring). You have two options      for doing this:      \n\r          \n\r\n\rIf in your application context you are already directly          obtaining the JTA          PlatformTransactionManager object          (presumably from JNDI through          JndiObjectFactoryBean or &lt;jee:jndi-lookup&gt;)          and feeding it, for example, to Spring\'s          JtaTransactionManager, then the easiest way          is to specify a reference to the bean defining this JTA          PlatformTransactionManager          instance as          the value of the jtaTransactionManager property          for LocalSessionFactoryBean. Spring then makes          the object available to Hibernate.        \n\r          \n\r\n\rMore likely you do not already have the JTA          PlatformTransactionManager instance,          because Spring\'s JtaTransactionManager can          find it itself. Thus          you need to configure Hibernate to look up JTA          PlatformTransactionManager directly.          You do this by configuring an application server- specific          TransactionManagerLookup class in the Hibernate          configuration, as described in the Hibernate manual.        \n\r      \n\r\n\rThe remainder of this section describes the sequence of events      that occur with and without Hibernate\'s awareness of the JTA      PlatformTransactionManager.      \n\r\n\rWhen Hibernate is not configured with any awareness of the JTA      PlatformTransactionManager, the following      events occur when a JTA transaction commits:      \n\r          \n\r\n\rThe JTA transaction commits.        \n\r          \n\r\n\rSpring\'s JtaTransactionManager is          synchronized to the JTA transaction, so it is called back through an          afterCompletion callback by the JTA transaction          manager.        \n\r          \n\r\n\rAmong other activities, this synchronization can          trigger a callback by Spring to Hibernate, through Hibernate\'s          afterTransactionCompletion callback (used          to clear the Hibernate cache), followed by an explicit          close() call on the Hibernate Session, which          causes Hibernate to attempt to close() the JDBC          Connection.        \n\r          \n\r\n\rIn some environments, this          Connection.close() call then triggers the          warning or error, as the application server no longer considers the          Connection usable at all, because the          transaction has already been committed.        \n\r      \n\r\n\rWhen Hibernate is configured with awareness of the JTA      PlatformTransactionManager, the following      events occur when a JTA transaction commits:      \n\r          \n\r\n\rthe JTA transaction is ready to commit.        \n\r          \n\r\n\rSpring\'s JtaTransactionManager is          synchronized to the JTA transaction, so the transaction is called          back through a beforeCompletion callback by the          JTA transaction manager.        \n\r          \n\r\n\rSpring is aware that Hibernate itself is synchronized to the          JTA transaction, and behaves differently than in the previous          scenario. Assuming the Hibernate          Session needs to be closed at all,          Spring will close it now.        \n\r          \n\r\n\rThe JTA transaction commits.        \n\r          \n\r\n\rHibernate is synchronized to the JTA transaction, so the          transaction is called back through an          afterCompletion callback by the JTA transaction          manager, and can properly clear its cache.        \n\r        15.4&nbsp;JDO        \n\r\n\rSpring supports the standard JDO 2.0 and 2.1 APIs as data access    strategy, following the same style as the Hibernate support. The    corresponding integration classes reside in the    org.springframework.orm.jdo package.    15.4.1&nbsp;PersistenceManagerFactory      setup            \n\r\n\rSpring provides a      LocalPersistenceManagerFactoryBean class that      allows you to define a local JDO      PersistenceManagerFactory within a Spring      application context:      &lt;beans&gt;  &lt;bean id=\"myPmf\" class=\"org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean\"&gt;    &lt;property name=\"configLocation\" value=\"classpath:kodo.properties\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rAlternatively, you can set up a      PersistenceManagerFactory through direct      instantiation of a      PersistenceManagerFactory implementation      class. A JDO PersistenceManagerFactory      implementation class follows the JavaBeans pattern, just like a JDBC      DataSource implementation class, which is      a natural fit for a configuration that uses Spring. This setup style      usually supports a Spring-defined JDBC      DataSource, passed into the      connectionFactory property. For example, for the      open source JDO implementation DataNucleus (formerly JPOX) (http://www.datanucleus.org/),      this is the XML configuration of the      PersistenceManagerFactory      implementation:      &lt;beans&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;   &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;   &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;   &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;   &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/bean&gt; &lt;bean id=\"myPmf\" class=\"org.datanucleus.jdo.JDOPersistenceManagerFactory\" destroy-method=\"close\"&gt;   &lt;property name=\"connectionFactory\" ref=\"dataSource\"/&gt;   &lt;property name=\"nontransactionalRead\" value=\"true\"/&gt; &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rYou can also set up JDO      PersistenceManagerFactory in the JNDI      environment of a Java EE application server, usually through the JCA      connector provided by the particular JDO implementation. Spring\'s      standard JndiObjectFactoryBean or      &lt;jee:jndi-lookup&gt; can be used to      retrieve and expose such a      PersistenceManagerFactory. However,      outside an EJB context, no real benefit exists in holding the      PersistenceManagerFactory in JNDI: only      choose such a setup for a good reason. See Section&nbsp;15.3.6, &#8220;Comparing container-managed and locally defined resources&#8221; for a discussion; the arguments      there apply to JDO as well.        15.4.2&nbsp;Implementing DAOs based on the plain JDO API            \n\r\n\rDAOs can also be written directly against plain JDO API, without      any Spring dependencies, by using an injected      PersistenceManagerFactory. The following      is an example of a corresponding DAO implementation:      public class ProductDaoImpl implements ProductDao {    private PersistenceManagerFactory persistenceManagerFactory;    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {        this.persistenceManagerFactory = pmf;    }    public Collection loadProductsByCategory(String category) {        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();        try {            Query query = pm.newQuery(Product.class, \"category = pCategory\");            query.declareParameters(\"String pCategory\");            return query.execute(category);        }        finally {          pm.close();        }    }}      \n\r\n\rBecause the above DAO follows the dependency injection pattern, it      fits nicely into a Spring container, just as it would if coded against      Spring\'s JdoTemplate:      &lt;beans&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"persistenceManagerFactory\" ref=\"myPmf\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe main problem with such DAOs is that they always get a new      PersistenceManager from the factory. To      access a Spring-managed transactional      PersistenceManager, define a      TransactionAwarePersistenceManagerFactoryProxy      (as included in Spring) in front of your target      PersistenceManagerFactory, then passing a      reference to that proxy into your DAOs as in the following example:      &lt;beans&gt;  &lt;bean id=\"myPmfProxy\"      class=\"org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy\"&gt;    &lt;property name=\"targetPersistenceManagerFactory\" ref=\"myPmf\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"persistenceManagerFactory\" ref=\"myPmfProxy\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rYour data access code will receive a transactional      PersistenceManager (if any) from the      PersistenceManagerFactory.getPersistenceManager()      method that it calls. The latter method call goes through the proxy,      which first checks for a current transactional      PersistenceManager before getting a new      one from the factory. Any close() calls on the      PersistenceManager are ignored in case of      a transactional      PersistenceManager.      \n\r\n\rIf your data access code always runs within an active transaction      (or at least within active transaction synchronization), it is safe to      omit the PersistenceManager.close() call and      thus the entire finally block, which you might do to      keep your DAO implementations concise:      public class ProductDaoImpl implements ProductDao {    private PersistenceManagerFactory persistenceManagerFactory;    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {        this.persistenceManagerFactory = pmf;    }    public Collection loadProductsByCategory(String category) {        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();        Query query = pm.newQuery(Product.class, \"category = pCategory\");        query.declareParameters(\"String pCategory\");        return query.execute(category);    }}      \n\r\n\rWith such DAOs that rely on active transactions, it is recommended      that you enforce active transactions through turning off      TransactionAwarePersistenceManagerFactoryProxy\'s      allowCreate flag:      &lt;beans&gt;  &lt;bean id=\"myPmfProxy\"      class=\"org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy\"&gt;    &lt;property name=\"targetPersistenceManagerFactory\" ref=\"myPmf\"/&gt;    &lt;property name=\"allowCreate\" value=\"false\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"&gt;    &lt;property name=\"persistenceManagerFactory\" ref=\"myPmfProxy\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe main advantage of this DAO style is that it depends on JDO API      only; no import of any Spring class is required. This is of course      appealing from a non-invasiveness perspective, and might feel more      natural to JDO developers.      \n\r\n\rHowever, the DAO throws plain      JDOException (which is unchecked, so does      not have to be declared or caught), which means that callers can only      treat exceptions as fatal, unless you want to depend on JDO\'s own      exception structure. Catching specific causes such as an optimistic      locking failure is not possible without tying the caller to the      implementation strategy. This trade off might be acceptable to      applications that are strongly JDO-based and/or do not need any special      exception treatment.      \n\r\n\rIn summary, you can DAOs based on the plain JDO API, and they can      still participate in Spring-managed transactions. This strategy might      appeal to you if you are already familiar with JDO. However, such DAOs      throw plain JDOException, and you would      have to convert explicitly to Spring\'s      DataAccessException (if desired).        15.4.3&nbsp;Transaction management            Note        \n\r\n\rYou are strongly encouraged to read Section&nbsp;12.5, &#8220;Declarative transaction management&#8221; if you have not done so, to get a        more detailed coverage of Spring\'s declarative transaction        support.            \n\r\n\rTo execute service operations within transactions, you can use      Spring\'s common declarative transaction facilities. For example:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans        xmlns=\"http://www.springframework.org/schema/beans\"        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"        xmlns:aop=\"http://www.springframework.org/schema/aop\"        xmlns:tx=\"http://www.springframework.org/schema/tx\"        xsi:schemaLocation=\"   http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx.xsd   http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;bean id=\"myTxManager\" class=\"org.springframework.orm.jdo.JdoTransactionManager\"&gt;    &lt;property name=\"persistenceManagerFactory\" ref=\"myPmf\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductService\" class=\"product.ProductServiceImpl\"&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;  &lt;/bean&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"increasePrice*\" propagation=\"REQUIRED\"/&gt;      &lt;tx:method name=\"someOtherBusinessMethod\" propagation=\"REQUIRES_NEW\"/&gt;      &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"productServiceMethods\"            expression=\"execution(* product.ProductService.*(..))\"/&gt;    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"productServiceMethods\"/&gt;  &lt;/aop:config&gt;&lt;/beans&gt;      \n\r\n\rJDO requires an active transaction to modify a persistent object.      The non-transactional flush concept does not exist in JDO, in contrast      to Hibernate. For this reason, you need to set up the chosen JDO      implementation for a specific environment. Specifically, you need to set      it up explicitly for JTA synchronization, to detect an active JTA      transaction itself. This is not necessary for local transactions as      performed by Spring\'s JdoTransactionManager, but      it is necessary to participate in JTA transactions, whether driven by      Spring\'s JtaTransactionManager or by EJB CMT and      plain JTA.      \n\r\n\rJdoTransactionManager is capable of      exposing a JDO transaction to JDBC access code that accesses the same      JDBC DataSource, provided that the      registered JdoDialect supports retrieval of the      underlying JDBC Connection. This is the      case for JDBC-based JDO 2.0 implementations by default.        15.4.4&nbsp;JdoDialect            \n\r\n\rAs an advanced feature, both JdoTemplate      and JdoTransactionManager support a custom      JdoDialect that can be passed into the      jdoDialect bean property. In this scenario, the DAOs will      not receive a PersistenceManagerFactory      reference but rather a full JdoTemplate instance      (for example, passed into the jdoTemplate      property of JdoDaoSupport). Using a      JdoDialect implementation, you can enable      advanced features supported by Spring, usually in a vendor-specific      manner:      \n\r          \n\r\n\rApplying specific transaction semantics such as custom          isolation level or transaction timeout        \n\r          \n\r\n\rRetrieving the transactional JDBC          Connection for exposure to JDBC-based          DAOs        \n\r          \n\r\n\rApplying query timeouts, which are automatically calculated          from Spring-managed transaction timeouts        \n\r          \n\r\n\rEagerly flushing a          PersistenceManager, to make          transactional changes visible to JDBC-based data access code        \n\r          \n\r\n\rAdvanced translation of JDOExceptions to          Spring DataAccessExceptions        \n\r      \n\r\n\rSee the JdoDialect Javadoc for more details      on its operations and how to use them within Spring\'s JDO      support.        15.5&nbsp;JPA        \n\r\n\rThe Spring JPA, available under the    org.springframework.orm.jpa package, offers    comprehensive support for the Java    Persistence API in a similar manner to the integration with    Hibernate or JDO, while being aware of the underlying implementation in    order to provide additional features.    15.5.1&nbsp;Three options for JPA setup in a Spring environment            \n\r\n\rThe Spring JPA support offers three ways of setting up the JPA      EntityManagerFactory that will be used by      the application to obtain an entity manager.      LocalEntityManagerFactoryBean                Note          \n\r\n\rOnly use this option in simple deployment environments such as          stand-alone applications and integration tests.                \n\r\n\rThe LocalEntityManagerFactoryBean creates        an EntityManagerFactory suitable for        simple deployment environments where the application uses only JPA for        data access. The factory bean uses the JPA        PersistenceProvider autodetection        mechanism (according to JPA\'s Java SE bootstrapping) and, in most        cases, requires you to specify only the persistence unit name:        &lt;beans&gt;   &lt;bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalEntityManagerFactoryBean\"&gt;      &lt;property name=\"persistenceUnitName\" value=\"myPersistenceUnit\"/&gt;   &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\rThis form of JPA deployment is the simplest and the most        limited. You cannot refer to        an existing JDBC DataSource bean        definition and no support for global transactions exists. Furthermore,        weaving (byte-code transformation) of persistent classes is        provider-specific, often requiring a specific JVM agent to specified        on startup. This option is sufficient only for stand-alone        applications and test environments, for which the JPA specification is        designed.            Obtaining an EntityManagerFactory from        JNDI                Note          \n\r\n\rUse this option when deploying to a Java EE 5 server. Check          your server\'s documentation on how to deploy a custom JPA provider          into your server, allowing for a different provider than the          server\'s default.                \n\r\n\rObtaining an EntityManagerFactory        from JNDI (for example in a Java EE 5 environment), is simply a matter        of changing the XML configuration:        &lt;beans&gt;    &lt;jee:jndi-lookup id=\"myEmf\" jndi-name=\"persistence/myPersistenceUnit\"/&gt;&lt;/beans&gt;        \n\r\n\rThis action assumes standard Java EE 5 bootstrapping: the Java        EE server autodetects persistence units (in effect,        META-INF/persistence.xml files in application jars)        and persistence-unit-ref entries in the Java EE        deployment descriptor (for example, web.xml) and        defines environment naming context locations for those persistence        units.        \n\r\n\rIn such a scenario, the entire persistence unit deployment,        including the weaving (byte-code transformation) of persistent        classes, is up to the Java EE server. The JDBC        DataSource is defined through a JNDI        location in the META-INF/persistence.xml file;        EntityManager transactions are integrated with the server\'s JTA        subsystem. Spring merely uses the obtained        EntityManagerFactory, passing it on to        application objects through dependency injection, and managing        transactions for the persistence unit,        typically through JtaTransactionManager.        \n\r\n\rIf multiple persistence units are used in the same application,        the bean names of such JNDI-retrieved persistence units should match        the persistence unit names that the application uses to refer to them,        for example, in @PersistenceUnit and        @PersistenceContext annotations.            LocalContainerEntityManagerFactoryBean                Note          \n\r\n\rUse this option for full JPA capabilities in a Spring-based          application environment. This includes web containers such as Tomcat          as well as stand-alone applications and integration tests with          sophisticated persistence requirements.                \n\r\n\rThe        LocalContainerEntityManagerFactoryBean gives        full control over EntityManagerFactory        configuration and is appropriate for environments where fine-grained        customization is required. The        LocalContainerEntityManagerFactoryBean creates        a PersistenceUnitInfo instance based        on the persistence.xml file, the supplied        dataSourceLookup strategy, and the specified        loadTimeWeaver. It is thus possible to work with        custom data sources outside of JNDI and to control the weaving        process. The following example shows a typical bean definition for a        LocalContainerEntityManagerFactoryBean:        &lt;beans&gt; &lt;bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt;  &lt;property name=\"dataSource\" ref=\"someDataSource\"/&gt;  &lt;property name=\"loadTimeWeaver\"&gt;    &lt;bean class=\"org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\"/&gt;  &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;        \n\r\n\rThe following example shows a typical        persistence.xml file:        &lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"1.0\"&gt;  &lt;persistence-unit name=\"myUnit\" transaction-type=\"RESOURCE_LOCAL\"&gt;    &lt;mapping-file&gt;META-INF/orm.xml&lt;/mapping-file&gt;    &lt;exclude-unlisted-classes/&gt;  &lt;/persistence-unit&gt;&lt;/persistence&gt;        Note          \n\r\n\rThe exclude-unlisted-classes element always          indicates that no scanning for annotated entity          classes is supposed to occur, in order to support the          &lt;exclude-unlisted-classes/&gt; shortcut. This is in          line with the JPA specification, which suggests that shortcut, but          unfortunately is in conflict with the JPA XSD, which implies          false for that shortcut. Consequently,          &lt;exclude-unlisted-classes&gt; false          &lt;/exclude-unlisted-classes/&gt; is not supported. Simply          omit the exclude-unlisted-classes element if you want          entity class scanning to occur.                \n\r\n\rUsing the        LocalContainerEntityManagerFactoryBean is the        most powerful JPA setup option, allowing for flexible local        configuration within the application. It supports links to an existing        JDBC DataSource, supports both local        and global transactions, and so on. However, it also imposes        requirements on the runtime environment, such as the availability of        a weaving-capable class loader if the persistence provider demands        byte-code transformation.        \n\r\n\rThis option may conflict with the built-in JPA capabilities of a        Java EE 5 server. In a full Java EE 5 environment, consider obtaining        your EntityManagerFactory from JNDI.        Alternatively, specify a custom        persistenceXmlLocation on your        LocalContainerEntityManagerFactoryBean        definition, for example, META-INF/my-persistence.xml, and only include        a descriptor with that name in your application jar files. Because the        Java EE 5 server only looks for default        META-INF/persistence.xml files, it ignores such        custom persistence units and hence avoid conflicts with a        Spring-driven JPA setup upfront. (This applies to Resin 3.1, for        example.)        \n\r\n\rWhen is load-time weaving required?                    \n\r\n\rNot all JPA providers require a JVM agent ; Hibernate is an          example of one that does not. If your provider does not require an          agent or you have other alternatives, such as applying enhancements          at build time through a custom compiler or an ant task, the          load-time weaver should not be          used.                \n\r\n\rThe LoadTimeWeaver interface is a        Spring-provided class that allows JPA        ClassTransformer instances to be        plugged in a specific manner, depending whether the environment is a        web container or application server.         Hooking ClassTransformers through a Java 5 agent        typically is not efficient. The agents work against the        entire virtual machine and inspect        every class that is loaded, which is usually        undesirable in a production server environment.        \n\r\n\rSpring provides a number of        LoadTimeWeaver implementations for        various environments, allowing        ClassTransformer instances to be        applied only per class loader and not per        VM.        \n\r\n\rRefer to the section called &#8220;Spring configuration&#8221; in the AOP chapter for more insight regarding the        LoadTimeWeaver implementations and their setup, either generic or customized to        various platforms (such as Tomcat, WebLogic, OC4J, GlassFish, Resin and JBoss).        \n\r\n\rAs described in the aforementioned section, you can configure a context-wide LoadTimeWeaver        using the @EnableLoadTimeWeaving annotation of context:load-time-weaver XML element.        Such a global weaver is picked up by all JPA LocalContainerEntityManagerFactoryBeans        automatically. This is the preferred way of setting up a load-time weaver, delivering autodetection of the platform        (WebLogic, OC4J, GlassFish, Tomcat, Resin, JBoss or VM agent) and automatic propagation of the weaver to all weaver-aware beans:        &lt;context:load-time-weaver/&gt;&lt;bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt;    ...&lt;/bean&gt;        \n\r\n\r However, if needed, one can manually specify a dedicated weaver through the loadTimeWeaver property:        &lt;bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt;  &lt;property name=\"loadTimeWeaver\"&gt;    &lt;bean class=\"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\"/&gt;  &lt;/property&gt;&lt;/bean&gt;          \n\r\n\rNo matter how the LTW is configured, using this technique, JPA applications relying on          instrumentation can run in the target platform (ex: Tomcat) without needing an agent.          This is important especially when the hosting applications rely on different JPA implementations          because the JPA transformers are applied only at class loader level and thus are          isolated from each other.                    Dealing with multiple persistence units                \n\r\n\rFor applications that rely on multiple persistence units        locations, stored in various JARS in the classpath, for example,        Spring offers the        PersistenceUnitManager to act as a        central repository and to avoid the persistence units discovery        process, which can be expensive. The default implementation allows        multiple locations to be specified that are parsed and later retrieved        through the persistence unit name. (By default, the classpath is        searched for META-INF/persistence.xml        files.)        &lt;bean id=\"pum\" class=\"org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager\"&gt;  &lt;property name=\"persistenceXmlLocations\"&gt;    &lt;list&gt;     &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;     &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;     &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;  &lt;property name=\"dataSources\"&gt;   &lt;map&gt;    &lt;entry key=\"localDataSource\" value-ref=\"local-db\"/&gt;    &lt;entry key=\"remoteDataSource\" value-ref=\"remote-db\"/&gt;   &lt;/map&gt;  &lt;/property&gt;  &lt;!-- if no datasource is specified, use this one --&gt;  &lt;property name=\"defaultDataSource\" ref=\"remoteDataSource\"/&gt;&lt;/bean&gt;&lt;bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt;  &lt;property name=\"persistenceUnitManager\" ref=\"pum\"/&gt;  &lt;property name=\"persistenceUnitName\" value=\"myCustomUnit\"/&gt;&lt;/bean&gt;        \n\r\n\rThe default implementation allows customization of the        PersistenceUnitInfo instances,        before they are fed to the JPA provider, declaratively through its        properties,        which affect all hosted units, or        programmatically, through the        PersistenceUnitPostProcessor, which        allows persistence unit selection. If no        PersistenceUnitManager is specified,        one is created and used internally by        LocalContainerEntityManagerFactoryBean.              15.5.2&nbsp;Implementing DAOs based on plain JPA            Note        \n\r\n\rAlthough EntityManagerFactory        instances are thread-safe,        EntityManager instances are not. The        injected JPA EntityManager behaves like        an EntityManager fetched from an        application server\'s JNDI environment, as defined by the JPA        specification. It delegates all calls to the current transactional        EntityManager, if any; otherwise, it        falls back to a newly created        EntityManager per operation, in effect        making its usage thread-safe.            \n\r\n\rIt is possible to write code against the plain JPA without any      Spring dependencies, by using an injected      EntityManagerFactory or      EntityManager. Spring can understand      @PersistenceUnit and      @PersistenceContext annotations both at      field and method level if a      PersistenceAnnotationBeanPostProcessor is      enabled. A plain JPA DAO implementation using the      @PersistenceUnit annotation might      look like this:      public class ProductDaoImpl implements ProductDao {    private EntityManagerFactory emf;    @PersistenceUnit    public void setEntityManagerFactory(EntityManagerFactory emf) {        this.emf = emf;    }    public Collection loadProductsByCategory(String category) {        EntityManager em = this.emf.createEntityManager();        try {             Query query = em.createQuery(\"from Product as p where p.category = ?1\");             query.setParameter(1, category);             return query.getResultList();        }        finally {            if (em != null) {                em.close();            }        }    }}      \n\r\n\rThe DAO above has no dependency on Spring and still fits nicely      into a Spring application context. Moreover, the DAO takes advantage of      annotations to require the injection of the default      EntityManagerFactory:      &lt;beans&gt;  &lt;!-- bean post-processor for JPA annotations --&gt;  &lt;bean class=\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/&gt;&lt;/beans&gt;      \n\r\n\rAs an alternative to defining a      PersistenceAnnotationBeanPostProcessor      explicitly, consider using the Spring      context:annotation-config XML element in your      application context configuration. Doing so automatically registers all      Spring standard post-processors for annotation-based configuration,      including CommonAnnotationBeanPostProcessor and      so on.      &lt;beans&gt;  &lt;!-- post-processors for all standard config annotations --&gt;  &lt;context:annotation-config/&gt;  &lt;bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/&gt;&lt;/beans&gt;      \n\r\n\rThe main problem with such a DAO is that it always creates a new      EntityManager through the factory. You      can avoid this by requesting a transactional      EntityManager (also called \"shared      EntityManager\" because it is a shared, thread-safe proxy for the actual      transactional EntityManager) to be injected instead of the      factory:      public class ProductDaoImpl implements ProductDao {    @PersistenceContext    private EntityManager em;    public Collection loadProductsByCategory(String category) {       Query query = em.createQuery(\"from Product as p where p.category = :category\");       query.setParameter(\"category\", category);       return query.getResultList();    }}      \n\r\n\rThe @PersistenceContext annotation has an      optional attribute type, which defaults to      PersistenceContextType.TRANSACTION. This default is      what you need to receive a shared EntityManager proxy. The alternative,      PersistenceContextType.EXTENDED, is a completely      different affair: This results in a so-called extended EntityManager,      which is not thread-safe and hence must not be used      in a concurrently accessed component such as a Spring-managed singleton      bean. Extended EntityManagers are only supposed to be used in stateful      components that, for example, reside in a session, with the lifecycle of      the EntityManager not tied to a current transaction but rather being      completely up to the application.      \n\r\n\rMethod- and field-level Injection                \n\r\n\rAnnotations that indicate dependency injections (such as        @PersistenceUnit and        @PersistenceContext) can be applied on field or        methods inside a class, hence the expressions method-level        injection and field-level injection.        Field-level annotations are concise and easier to use while        method-level allows for further processing of the injected dependency.        In both cases the member visibility (public, protected, private) does        not matter.        \n\r\n\rWhat about class-level annotations?        \n\r\n\rOn the Java EE 5 platform, they are used for dependency        declaration and not for resource injection.            \n\r\n\rThe injected EntityManager is      Spring-managed (aware of the ongoing transaction). It is important to      note that even though the new DAO implementation uses method level      injection of an EntityManager instead of      an EntityManagerFactory, no change is      required in the application context XML due to annotation usage.      \n\r\n\rThe main advantage of this DAO style is that it only depends on      Java Persistence API; no import of any Spring class is required.      Moreover, as the JPA annotations are understood, the injections are      applied automatically by the Spring container. This is appealing from a      non-invasiveness perspective, and might feel more natural to JPA      developers.        15.5.3&nbsp;Transaction Management            Note        \n\r\n\rYou are strongly encouraged to read Section&nbsp;12.5, &#8220;Declarative transaction management&#8221; if you have not done so, to get a        more detailed coverage of Spring\'s declarative transaction        support.            \n\r\n\rTo execute service operations within transactions, you can use      Spring\'s common declarative transaction facilities. For example:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;bean id=\"myTxManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"&gt;    &lt;property name=\"entityManagerFactory\" ref=\"myEmf\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"myProductService\" class=\"product.ProductServiceImpl\"&gt;    &lt;property name=\"productDao\" ref=\"myProductDao\"/&gt;  &lt;/bean&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"productServiceMethods\" expression=\"execution(* product.ProductService.*(..))\"/&gt;    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"productServiceMethods\"/&gt;  &lt;/aop:config&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"myTxManager\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"increasePrice*\" propagation=\"REQUIRED\"/&gt;      &lt;tx:method name=\"someOtherBusinessMethod\" propagation=\"REQUIRES_NEW\"/&gt;      &lt;tx:method name=\"*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;&lt;/beans&gt;      \n\r\n\rSpring JPA allows a configured      JpaTransactionManager to expose a JPA transaction      to JDBC access code that accesses the same JDBC      DataSource, provided that the registered      JpaDialect supports retrieval of the      underlying JDBC Connection. Out of the      box, Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA      implementations. See the next section for details on the      JpaDialect mechanism.        15.5.4&nbsp;JpaDialect            \n\r\n\rAs an advanced feature JpaTemplate,      JpaTransactionManager and subclasses of      AbstractEntityManagerFactoryBean support a custom      JpaDialect, to be passed into the      jpaDialect bean property. In such a scenario, the      DAOs do not receive an      EntityManagerFactory reference but rather      a full JpaTemplate instance (for example,      passed      into the jpaTemplate property of      JpaDaoSupport). A JpaDialect      implementation can enable some advanced features supported by Spring,      usually in a vendor-specific manner:      \n\r          \n\r\n\rApplying specific transaction semantics such as custom          isolation level or transaction timeout)        \n\r          \n\r\n\rRetrieving the transactional JDBC          Connection for exposure to JDBC-based          DAOs)        \n\r          \n\r\n\rAdvanced translation of          PersistenceExceptions to Spring          DataAccessExceptions        \n\r      \n\r\n\rThis is particularly valuable for special transaction semantics      and for advanced translation of exception. The default implementation      used (DefaultJpaDialect) does not provide any      special capabilities and if the above features are required, you have to      specify the appropriate dialect.      \n\r\n\rSee the JpaDialect Javadoc for more      details of its operations and how they are used within Spring\'s JPA      support.        15.6&nbsp;iBATIS SQL Maps        \n\r\n\rThe iBATIS support in the Spring Framework much resembles the JDBC    support in that it supports the same template style programming, and as    with JDBC and other ORM technologies, the iBATIS support works with    Spring\'s exception hierarchy and lets you enjoy Spring\'s IoC    features.    \n\r\n\rTransaction management can be handled through Spring\'s standard    facilities. No special transaction strategies are necessary for iBATIS,    because no special transactional resource involved other than a JDBC    Connection. Hence, Spring\'s standard JDBC    DataSourceTransactionManager or    JtaTransactionManager are perfectly    sufficient.    Note      \n\r\n\rSpring supports iBATIS 2.x. The iBATIS 1.x support classes are no      longer provided.        15.6.1&nbsp;Setting up the SqlMapClient            \n\r\n\rUsing iBATIS SQL Maps involves creating SqlMap configuration files      containing statements and result maps. Spring takes care of loading      those using the SqlMapClientFactoryBean. For the      examples we will be using the following Account      class:      public class Account {    private String name;    private String email;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }    public String getEmail() {        return this.email;    }    public void setEmail(String email) {        this.email = email;    }}      \n\r\n\rTo map this Account class with iBATIS 2.x we      need to create the following SQL map      Account.xml:      &lt;sqlMap namespace=\"Account\"&gt;  &lt;resultMap id=\"result\" class=\"examples.Account\"&gt;    &lt;result property=\"name\" column=\"NAME\" columnIndex=\"1\"/&gt;    &lt;result property=\"email\" column=\"EMAIL\" columnIndex=\"2\"/&gt;  &lt;/resultMap&gt;  &lt;select id=\"getAccountByEmail\" resultMap=\"result\"&gt;    select ACCOUNT.NAME, ACCOUNT.EMAIL    from ACCOUNT    where ACCOUNT.EMAIL = #value#  &lt;/select&gt;  &lt;insert id=\"insertAccount\"&gt;    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)  &lt;/insert&gt;&lt;/sqlMap&gt;      \n\r\n\rThe configuration file for iBATIS 2 looks like this:      &lt;sqlMapConfig&gt;  &lt;sqlMap resource=\"example/Account.xml\"/&gt;&lt;/sqlMapConfig&gt;      \n\r\n\rRemember that iBATIS loads resources from the class path, so be      sure to add theAccount.xml file to the class      path.      \n\r\n\rWe can use the SqlMapClientFactoryBean in      the Spring container. Note that with iBATIS SQL Maps 2.x, the JDBC      DataSource is usually specified on the      SqlMapClientFactoryBean, which enables lazy      loading. This is the configuration needed for these bean      definitions:      &lt;beans&gt;  &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;    &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;    &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;    &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"sqlMapClient\" class=\"org.springframework.orm.ibatis.SqlMapClientFactoryBean\"&gt;    &lt;property name=\"configLocation\" value=\"WEB-INF/sqlmap-config.xml\"/&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;        15.6.2&nbsp;Using SqlMapClientTemplate and      SqlMapClientDaoSupport            \n\r\n\rThe SqlMapClientDaoSupport class offers a      supporting class similar to the SqlMapDaoSupport.      We extend it to implement our DAO:      public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {    public Account getAccount(String email) throws DataAccessException {        return (Account) getSqlMapClientTemplate().queryForObject(\"getAccountByEmail\", email);    }    public void insertAccount(Account account) throws DataAccessException {        getSqlMapClientTemplate().update(\"insertAccount\", account);    }}      \n\r\n\rIn the DAO, we use the pre-configured      SqlMapClientTemplate to execute the queries,      after setting up the SqlMapAccountDao in the      application context and wiring it with our      SqlMapClient instance:      &lt;beans&gt;  &lt;bean id=\"accountDao\" class=\"example.SqlMapAccountDao\"&gt;    &lt;property name=\"sqlMapClient\" ref=\"sqlMapClient\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rAn SqlMapTemplate instance can also be      created manually, passing in the SqlMapClient as      constructor argument. The SqlMapClientDaoSupport base      class simply preinitializes a      SqlMapClientTemplate instance for us.      \n\r\n\rThe SqlMapClientTemplate offers a generic      execute method, taking a custom      SqlMapClientCallback implementation as argument. This      can, for example, be used for batching:      public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {    public void insertAccount(Account account) throws DataAccessException {        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {                executor.startBatch();                executor.update(\"insertAccount\", account);                executor.update(\"insertAddress\", account.getAddress());                executor.executeBatch();            }        });    }}      \n\r\n\rIn general, any combination of operations offered by the native      SqlMapExecutor API can be used in such a callback.      Any thrown SQLException is converted automatically to      Spring\'s generic DataAccessException      hierarchy.        15.6.3&nbsp;Implementing DAOs based on plain iBATIS API            \n\r\n\rDAOs can also be written against plain iBATIS API, without any      Spring dependencies, directly using an injected      SqlMapClient. The following example shows a      corresponding DAO implementation:      public class SqlMapAccountDao implements AccountDao {    private SqlMapClient sqlMapClient;    public void setSqlMapClient(SqlMapClient sqlMapClient) {        this.sqlMapClient = sqlMapClient;    }    public Account getAccount(String email) {        try {            return (Account) this.sqlMapClient.queryForObject(\"getAccountByEmail\", email);        }        catch (SQLException ex) {            throw new MyDaoException(ex);        }    }    public void insertAccount(Account account) throws DataAccessException {        try {            this.sqlMapClient.update(\"insertAccount\", account);        }        catch (SQLException ex) {            throw new MyDaoException(ex);        }    }}      \n\r\n\rIn this scenario, you need to handle the      SQLException thrown by the iBATIS API in a custom      fashion, usually by wrapping it in your own application-specific DAO      exception. Wiring in the application context would still look like it      does in the example for the      SqlMapClientDaoSupport,      due to the fact that the plain iBATIS-based DAO still follows the      dependency injection pattern:      &lt;beans&gt;  &lt;bean id=\"accountDao\" class=\"example.SqlMapAccountDao\"&gt;    &lt;property name=\"sqlMapClient\" ref=\"sqlMapClient\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      Prev&nbsp;Up&nbsp;Next14.&nbsp;Data access with JDBC&nbsp;Home&nbsp;16.&nbsp;Marshalling XML using O/X Mappers","15. Object Relational Mapping (ORM) Data Access","scr\\orm.html","         1.&nbsp;Introduction to Spring FrameworkPrev&nbsp;Part&nbsp;I.&nbsp;Overview of Spring Framework&nbsp;Next1.&nbsp;Introduction to Spring Framework    \n\r\n\rSpring Framework is a Java platform that provides comprehensive  infrastructure support for developing Java applications. Spring handles the  infrastructure so you can focus on your application.  \n\r\n\rSpring enables you to build applications from &#8220;plain old Java objects&#8221;  (POJOs) and to apply enterprise services non-invasively to POJOs. This  capability applies to the Java SE programming model and to full and partial  Java EE.  \n\r\n\rExamples of how you, as an application developer, can use the Spring  platform advantage:  \n\r      \n\r\n\rMake a Java method execute in a database transaction without      having to deal with transaction APIs.    \n\r      \n\r\n\rMake a local Java method a remote procedure without having to deal      with remote APIs.    \n\r      \n\r\n\rMake a local Java method a management operation without having to      deal with JMX APIs.    \n\r      \n\r\n\rMake a local Java method a message handler without having to deal      with JMS APIs.    \n\r  1.1&nbsp;Dependency Injection and Inversion of Control        \n\r\n\rBackground            \n\r\n\r&#8220;The question is, what aspect of control are      [they] inverting?&#8221; Martin Fowler posed this question      about Inversion of Control (IoC) on his site in 2004. Fowler suggested      renaming the principle to make it more self-explanatory and came up with      Dependency Injection.      \n\r\n\rFor insight into IoC and DI, refer to Fowler\'s article at http://martinfowler.com/articles/injection.html.        \n\r\n\rJava applications -- a loose term that runs the gamut from    constrained applets to n-tier server-side enterprise applications --    typically consist of objects that collaborate to form the application    proper. Thus the objects in an application have    dependencies on each other.    \n\r\n\rAlthough the Java platform provides a wealth of application    development functionality, it lacks the means to organize the basic    building blocks into a coherent whole, leaving that task to architects and    developers. True, you can use design patterns such as    Factory, Abstract Factory,    Builder, Decorator, and    Service Locator to compose the various classes and    object instances that make up an application. However, these patterns are    simply that: best practices given a name, with a description of what the    pattern does, where to apply it, the problems it addresses, and so forth.    Patterns are formalized best practices that you must implement    yourself in your application.    \n\r\n\rThe Spring Framework Inversion of Control (IoC)    component addresses this concern by providing a formalized means of    composing disparate components into a fully working application ready for    use. The    Spring Framework codifies formalized design patterns as first-class    objects that you can integrate into your own application(s). Numerous    organizations and institutions use the Spring Framework in this manner to    engineer robust, maintainable applications.    1.2&nbsp;Modules        \n\r\n\rThe Spring Framework consists of features organized into about 20    modules. These modules are grouped into Core Container, Data    Access/Integration, Web, AOP (Aspect Oriented Programming),    Instrumentation, and Test, as shown in the following diagram.    \n\r\n\rOverview of the Spring Framework    1.2.1&nbsp;Core Container            \n\r\n\rThe Core      Container consists of the Core, Beans, Context, and      Expression Language modules.      \n\r\n\rThe Core and      Beans modules provide the fundamental parts of the      framework, including the IoC and Dependency Injection features. The      BeanFactory is a sophisticated implementation of      the factory pattern. It removes the need for programmatic singletons and      allows you to decouple the configuration and specification of      dependencies from your actual program logic.      \n\r\n\rThe Context      module builds on the solid base provided by the Core and Beans      modules: it is a means to access objects in a framework-style manner      that is similar to a JNDI registry. The Context module inherits its      features from the Beans module and adds support for internationalization      (using, for example, resource bundles), event-propagation,      resource-loading, and the transparent creation of contexts by, for      example, a servlet container. The Context module also supports Java EE      features such as EJB, JMX ,and basic remoting. The      ApplicationContext interface is the focal point      of the Context module.      \n\r\n\rThe Expression      Language module provides      a powerful expression language for querying and manipulating an object      graph at runtime. It is an extension of the unified expression language      (unified EL) as specified in the JSP 2.1 specification. The language      supports setting and getting property values, property assignment,      method invocation, accessing the context of arrays, collections and      indexers, logical and arithmetic operators, named variables, and      retrieval of objects by name from Spring\'s IoC container. It also      supports list projection and selection as well as common list      aggregations.        1.2.2&nbsp;Data Access/Integration            \n\r\n\rThe Data Access/Integration layer consists of      the JDBC, ORM, OXM, JMS and Transaction modules.      \n\r\n\rThe JDBC module provides      a JDBC-abstraction layer that removes the need to do tedious JDBC coding      and parsing of database-vendor specific error codes.      \n\r\n\rThe ORM module      provides integration layers for popular object-relational mapping APIs,      including JPA, JDO, Hibernate, and iBatis. Using the ORM package you can use      all of these O/R-mapping frameworks in combination with all of the other      features Spring offers, such as the simple declarative transaction      management feature mentioned previously.      \n\r\n\rThe OXM module provides an abstraction      layer that supports Object/XML mapping implementations for JAXB, Castor,      XMLBeans, JiBX and XStream.      \n\r\n\rThe Java Messaging Service (JMS) module      contains features for producing and consuming messages.      \n\r\n\rThe Transaction module supports      programmatic and declarative transaction management for classes that      implement special interfaces and for all your POJOs (plain old      Java objects).        1.2.3&nbsp;Web            \n\r\n\rThe Web layer consists of the Web,      Web-Servlet, Web-Struts, and Web-Portlet modules.      \n\r\n\rSpring\'s Web module provides basic      web-oriented integration features such as multipart file-upload      functionality and the initialization of the IoC container using servlet      listeners and a web-oriented application context. It also contains the      web-related parts of Spring\'s remoting support.      \n\r\n\rThe Web-Servlet module contains Spring\'s      model-view-controller (MVC)      implementation for web applications. Spring\'s MVC framework provides a      clean separation between domain model code and web forms, and integrates      with all the other features of the Spring Framework.      \n\r\n\rThe Web-Struts module contains the support      classes for integrating a classic Struts web tier within a Spring      application. Note that this support is now deprecated as of Spring 3.0.      Consider migrating your application to Struts 2.0 and its Spring      integration or to a Spring MVC solution.      \n\r\n\rThe Web-Portlet module provides the MVC      implementation to be used in a portlet environment and mirrors the      functionality of Web-Servlet module.        1.2.4&nbsp;AOP and Instrumentation            \n\r\n\rSpring\'s AOP module      provides an AOP Alliance-compliant aspect-oriented      programming implementation allowing you to define, for example,      method-interceptors and pointcuts to cleanly decouple code that      implements functionality that should be separated. Using source-level      metadata functionality, you can also incorporate behavioral information      into your code, in a manner similar to that of .NET attributes.      \n\r\n\rThe separate Aspects module provides      integration with AspectJ.      \n\r\n\rThe Instrumentation module provides class      instrumentation support and classloader implementations to be used in      certain application servers.        1.2.5&nbsp;Test            \n\r\n\rThe Test module supports the testing of      Spring components with JUnit or TestNG. It provides consistent loading      of Spring ApplicationContexts and caching of those contexts. It also      provides mock objects that you can use to test your code in      isolation.        1.3&nbsp;Usage scenarios        \n\r\n\rThe building blocks described previously make Spring a logical    choice in many scenarios, from applets to full-fledged enterprise    applications that use Spring\'s transaction management functionality and    web framework integration.    \n\r\n\rTypical full-fledged Spring web        application    \n\r\n\rSpring\'s declarative    transaction management features make the web application fully    transactional, just as it would be if you used EJB container-managed    transactions. All your custom business logic can be implemented with    simple POJOs and managed by Spring\'s IoC container. Additional services    include support for sending email and validation that is independent of    the web layer, which lets you choose where to execute validation rules.    Spring\'s ORM support is integrated with JPA, Hibernate, JDO and iBatis;    for example, when using Hibernate, you can continue to use your existing    mapping files and standard Hibernate    SessionFactory configuration. Form    controllers seamlessly integrate the web-layer with the domain model,    removing the need for ActionForms or other classes    that transform HTTP parameters to values for your domain model.    \n\r\n\rSpring middle-tier using a third-party web        framework    \n\r\n\rSometimes circumstances do not allow you to completely switch to a    different framework. The Spring Framework does not    force you to use everything within it; it is not an    all-or-nothing solution. Existing front-ends built    with WebWork, Struts, Tapestry, or other UI frameworks can be integrated    with a Spring-based middle-tier, which allows you to use Spring    transaction features. You simply need to wire up your business logic using    an ApplicationContext and use a    WebApplicationContext to integrate your web    layer.    \n\r\n\rRemoting usage scenario    \n\r\n\rWhen you need to access existing code through web services, you can    use Spring\'s Hessian-, Burlap-,    Rmi- or JaxRpcProxyFactory    classes. Enabling remote access to existing applications is not    difficult.    \n\r\n\rEJBs - Wrapping existing POJOs    \n\r\n\rThe Spring Framework also provides an access and    abstraction layer for Enterprise JavaBeans, enabling you to reuse    your existing POJOs and wrap them in stateless session beans for use in    scalable, fail-safe web applications that might need declarative    security.    1.3.1&nbsp;Dependency Management and Naming Conventions            \n\r\n\rDependency management and dependency injection are different      things. To get those nice features of Spring into your application (like      dependency injection) you need to assemble all the libraries needed (jar      files) and get them onto your classpath at runtime, and possibly at      compile time. These dependencies are not virtual components that are      injected, but physical resources in a file system (typically). The      process of dependency management involves locating those resources,      storing them and adding them to classpaths. Dependencies can be direct      (e.g. my application depends on Spring at runtime), or indirect (e.g. my      application depends on commons-dbcp which depends on      commons-pool). The indirect dependencies are also known as      \"transitive\" and it is those dependencies that are hardest to identify      and manage.      \n\r\n\rIf you are going to use Spring you need to get a copy of the jar      libraries that comprise the pieces of Spring that you need. To make this      easier Spring is packaged as a set of modules that separate the      dependencies as much as possible, so for example if you don\'t want to      write a web application you don\'t need the spring-web modules. To refer      to Spring library modules in this guide we use a shorthand naming      convention spring-* or spring-*.jar, where \"*\"      represents the short name for the module (e.g. spring-core,      spring-webmvc, spring-jms, etc.). The actual      jar file name that you use may be in this form (see below) or it may      not, and normally it also has a version number in the file name (e.g.      spring-core-3.0.0.RELEASE.jar).      \n\r\n\rIn general, Spring publishes its artifacts to four different      places:\n\r            \n\r\n\rOn the community download site http://www.springsource.org/download/community.            Here you find all the Spring jars bundled together into a zip file            for easy download. The names of the jars here since version 3.0            are in the form            org.springframework.*-&lt;version&gt;.jar.          \n\r            \n\r\n\rMaven Central, which is the default repository that Maven            queries, and does not require any special configuration to use.            Many of the common libraries that Spring depends on also are            available from Maven Central and a large section of the Spring            community uses Maven for dependency management, so this is            convenient for them. The names of the jars here are in the form            spring-*-&lt;version&gt;.jar and the Maven groupId is            org.springframework.          \n\r            \n\r\n\rThe Enterprise Bundle Repository (EBR), which is run by            SpringSource and also hosts all the libraries that integrate with            Spring. Both Maven and Ivy repositories are available here for all            Spring jars and their dependencies, plus a large number of other            common libraries that people use in applications with Spring. Both            full releases and also milestones and development snapshots are            deployed here. The names of the jar files are in the same form as            the community download            (org.springframework.*-&lt;version&gt;.jar), and the            dependencies are also in this \"long\" form, with external libraries            (not from SpringSource) having the prefix            com.springsource. See the FAQ            for more information.          \n\r            \n\r\n\rIn a public Maven repository hosted on Amazon S3 for            development snapshots and milestone releases (a copy of the final            releases is also held here). The jar file names are in the same            form as Maven Central, so this is a useful place to get            development versions of Spring to use with other libraries deployed            in Maven Central.          \n\r      \n\r\n\rSo the first thing you need to decide is how to manage your      dependencies: most people use an automated system like Maven or Ivy, but      you can also do it manually by downloading all the jars yourself. When      obtaining Spring with Maven or Ivy you have then to decide which place      you\'ll get it from. In general, if you care about OSGi, use the EBR,      since it houses OSGi compatible artifacts for all of Spring\'s      dependencies, such as Hibernate and Freemarker. If OSGi does not matter      to you, either place works, though there are some pros and cons between      them. In general, pick one place or the other for your project; do not      mix them. This is particularly important since EBR artifacts necessarily      use a different naming convention than Maven Central artifacts.      \n\r\n\rTable&nbsp;1.1.&nbsp;Comparison of Maven Central and SpringSource EBR          Repositories                    FeatureMaven CentralEBROSGi CompatibleNot explicitYesNumber of ArtifactsTens of thousands; all kindsHundreds; those that Spring integrates withConsistent Naming ConventionsNoYesNaming Convention: GroupIdVaries. Newer artifacts often use domain name, e.g.                org.slf4j. Older ones often just use the artifact name, e.g.                log4j.Domain name of origin or main package root, e.g.                org.springframeworkNaming Convention: ArtifactIdVaries. Generally the project or module name, using a                hyphen \"-\" separator, e.g. spring-core, logj4.Bundle Symbolic Name, derived from the main package                root, e.g. org.springframework.beans. If the jar had to be                patched to ensure OSGi compliance then com.springsource is                appended, e.g. com.springsource.org.apache.log4jNaming Convention: VersionVaries. Many new artifacts use m.m.m or m.m.m.X (with                m=digit, X=text). Older ones use m.m. Some neither. Ordering                is defined but not often relied on, so not strictly                reliable.OSGi version number m.m.m.X, e.g. 3.0.0.RC3. The text                qualifier imposes alphabetic ordering on versions with the                same numeric values.PublishingUsually automatic via rsync or source control updates.                Project authors can upload individual jars to JIRA.Manual (JIRA processed by SpringSource)Quality AssuranceBy policy. Accuracy is responsibility of                authors.Extensive for OSGi manifest, Maven POM and Ivy                metadata. QA performed by Spring team.HostingContegix. Funded by Sonatype with several                mirrors.S3 funded by SpringSource.Search UtilitiesVarioushttp://www.springsource.com/repositoryIntegration with SpringSource ToolsIntegration through STS with Maven dependency                managementExtensive integration through STS with Maven, Roo,                CloudFoundry        \n\r\n\r\n\r      Spring Dependencies and Depending on Spring                \n\r\n\rAlthough Spring provides integration and support for a huge        range of enterprise and other external tools, it intentionally keeps        its mandatory dependencies to an absolute minimum: you shouldn\'t have        to locate and download (even automatically) a large number of jar        libraries in order to use Spring for simple use cases. For basic        dependency injection there is only one mandatory external dependency,        and that is for logging (see below for a more detailed description of        logging options).        \n\r\n\rNext we outline the basic steps needed to configure an        application that depends on Spring, first with Maven and then with        Ivy. In all cases, if anything is unclear, refer to the documentation        of your dependency management system, or look at some sample code -        Spring itself uses Ivy to manage dependencies when it is building, and        our samples mostly use Maven.            Maven Dependency Management                \n\r\n\rIf you are using Maven for dependency management you don\'t even        need to supply the logging dependency explicitly. For example, to        create an application context and use dependency injection to        configure an application, your Maven dependencies will look like        this:        &lt;dependencies&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;3.0.0.RELEASE&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;         \n\r\n\rThat\'s it. Note the scope can be declared as runtime if you        don\'t need to compile against Spring APIs, which is typically the case        for basic dependency injection use cases.        \n\r\n\rWe used the Maven Central naming conventions in the example        above, so that works with Maven Central or the SpringSource S3 Maven        repository. To use the S3 Maven repository (e.g. for milestones or        developer snapshots), you need to specify the repository location in        your Maven configuration. For full releases:        &lt;repositories&gt;   &lt;repository&gt;      &lt;id&gt;com.springsource.repository.maven.release&lt;/id&gt;      &lt;url&gt;http://repo.springsource.org/release/&lt;/url&gt;      &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;   &lt;/repository&gt;&lt;/repositories&gt;        \n\r\n\rFor milestones:        &lt;repositories&gt;   &lt;repository&gt;      &lt;id&gt;com.springsource.repository.maven.milestone&lt;/id&gt;      &lt;url&gt;http://repo.springsource.org/milestone/&lt;/url&gt;      &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;   &lt;/repository&gt;&lt;/repositories&gt;        \n\r\n\rAnd for snapshots:        &lt;repositories&gt;   &lt;repository&gt;      &lt;id&gt;com.springsource.repository.maven.snapshot&lt;/id&gt;      &lt;url&gt;http://repo.springsource.org/snapshot/&lt;/url&gt;      &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;   &lt;/repository&gt;&lt;/repositories&gt;        \n\r\n\rTo use the SpringSource EBR you would need to use a different        naming convention for the dependencies. The names are usually easy to        guess, e.g. in this case it is:        &lt;dependencies&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;org.springframework.context&lt;/artifactId&gt;      &lt;version&gt;3.0.0.RELEASE&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;        \n\r\n\rYou also need to declare the location of the repository        explicitly (only the URL is important):        &lt;repositories&gt;   &lt;repository&gt;      &lt;id&gt;com.springsource.repository.bundles.release&lt;/id&gt;      &lt;url&gt;http://repository.springsource.com/maven/bundles/release/&lt;/url&gt;   &lt;/repository&gt;&lt;/repositories&gt;        \n\r\n\rIf you are managing your dependencies by hand, the URL in the        repository declaration above is not browsable, but there is a user        interface at http://www.springsource.com/repository        that can be used to search for and download dependencies. It also has        handy snippets of Maven and Ivy configuration that you can copy and        paste if you are using those tools.            Ivy Dependency Management                \n\r\n\rIf you prefer to use Ivy to manage dependencies        then there are similar names and configuration options.         \n\r\n\rTo configure Ivy to point to the SpringSource EBR add the        following resolvers to your        ivysettings.xml:        &lt;resolvers&gt;  &lt;url name=\"com.springsource.repository.bundles.release\"&gt;    &lt;ivy pattern=\"http://repository.springsource.com/ivy/bundles/release/      [organisation]/[module]/[revision]/[artifact]-[revision].[ext]\" /&gt;    &lt;artifact pattern=\"http://repository.springsource.com/ivy/bundles/release/      [organisation]/[module]/[revision]/[artifact]-[revision].[ext]\" /&gt;  &lt;/url&gt;  &lt;url name=\"com.springsource.repository.bundles.external\"&gt;    &lt;ivy pattern=\"http://repository.springsource.com/ivy/bundles/external/       [organisation]/[module]/[revision]/[artifact]-[revision].[ext]\" /&gt;    &lt;artifact pattern=\"http://repository.springsource.com/ivy/bundles/external/       [organisation]/[module]/[revision]/[artifact]-[revision].[ext]\" /&gt;  &lt;/url&gt;&lt;/resolvers&gt;        \n\r\n\rThe XML above is not valid because the lines are too long - if        you copy-paste then remove the extra line endings in the middle of the        url patterns.        \n\r\n\rOnce Ivy is configured to look in the EBR adding a dependency is        easy. Simply pull up the details page for the bundle in question in        the repository browser and you\'ll find an Ivy snippet ready for you to        include in your dependencies section. For example (in        ivy.xml):         &lt;dependency org=\"org.springframework\"      name=\"org.springframework.core\" rev=\"3.0.0.RELEASE\" conf=\"compile-&gt;runtime\"/&gt;              1.3.2&nbsp;Logging            \n\r\n\rLogging is a very important dependency for Spring because a) it is      the only mandatory external dependency, b) everyone likes to see some      output from the tools they are using, and c) Spring integrates with lots      of other tools all of which have also made a choice of logging      dependency. One of the goals of an application developer is often to      have unified logging configured in a central place for the whole      application, including all external components. This is more difficult      than it might have been since there are so many choices of logging      framework.      \n\r\n\rThe mandatory logging dependency in Spring is the Jakarta Commons      Logging API (JCL). We compile against JCL and we also make JCL      Log objects visible for classes that extend the      Spring Framework. It\'s important to users that all versions of Spring      use the same logging library: migration is easy because backwards      compatibility is preserved even with applications that extend Spring.      The way we do this is to make one of the modules in Spring depend      explicitly on commons-logging (the canonical implementation      of JCL), and then make all the other modules depend on that at compile      time. If you are using Maven for example, and wondering where you picked      up the dependency on commons-logging, then it is from      Spring and specifically from the central module called      spring-core.      \n\r\n\rThe nice thing about commons-logging is that you      don\'t need anything else to make your application work. It has a runtime      discovery algorithm that looks for other logging frameworks in well      known places on the classpath and uses one that it thinks is appropriate      (or you can tell it which one if you need to). If nothing else is      available you get pretty nice looking logs just from the JDK      (java.util.logging or JUL for short). You should find that your Spring      application works and logs happily to the console out of the box in most      situations, and that\'s important.      Not Using Commons Logging                \n\r\n\rUnfortunately, the runtime discovery algorithm in        commons-logging, while convenient for the end-user, is        problematic. If we could turn back the clock and start Spring now        as a new project it would use a different logging dependency. The        first choice would probably be the Simple Logging Facade for Java (SLF4J), which is also used by a lot        of other tools that people use with Spring inside their        applications.        \n\r\n\rSwitching off commons-logging is easy: just make        sure it isn\'t on the classpath at runtime. In Maven terms you exclude        the dependency, and because of the way that the Spring dependencies        are declared, you only have to do that once.        &lt;dependencies&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;3.0.0.RELEASE&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;      &lt;exclusions&gt;         &lt;exclusion&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;         &lt;/exclusion&gt;      &lt;/exclusions&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;         \n\r\n\rNow this application is probably broken because there is no        implementation of the JCL API on the classpath, so to fix it a new one        has to be provided. In the next section we show you how to provide an        alternative implementation of JCL using SLF4J as an example.            Using SLF4J                  \n\r\n\rSLF4J is a cleaner dependency and more efficient at runtime than          commons-logging because it uses compile-time bindings          instead of runtime discovery of the other logging frameworks it          integrates. This also means that you have to be more explicit about what          you want to happen at runtime, and declare it or configure it          accordingly. SLF4J provides bindings to many common logging frameworks,          so you can usually choose one that you already use, and bind to that for          configuration and management.          \n\r\n\rSLF4J provides bindings to many common logging frameworks,          including JCL, and it also does the reverse: bridges between other          logging frameworks and itself. So to use SLF4J with Spring you need to          replace the commons-logging dependency with the SLF4J-JCL          bridge. Once you have done that then logging calls from within Spring          will be translated into logging calls to the SLF4J API, so if other          libraries in your application use that API, then you have a single place          to configure and manage logging.          \n\r\n\rA common choice might be to bridge Spring to SLF4J, and then          provide explicit binding from SLF4J to Log4J. You need to supply 4          dependencies (and exclude the existing commons-logging):          the bridge, the SLF4J API, the binding to Log4J, and the Log4J          implementation itself. In Maven you would do that like this          &lt;dependencies&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;          &lt;version&gt;3.0.0.RELEASE&lt;/version&gt;          &lt;scope&gt;runtime&lt;/scope&gt;          &lt;exclusions&gt;             &lt;exclusion&gt;                &lt;groupId&gt;commons-logging&lt;/groupId&gt;                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;             &lt;/exclusion&gt;          &lt;/exclusions&gt;       &lt;/dependency&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;          &lt;version&gt;1.5.8&lt;/version&gt;          &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;          &lt;version&gt;1.5.8&lt;/version&gt;          &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;          &lt;version&gt;1.5.8&lt;/version&gt;          &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;       &lt;dependency&gt;          &lt;groupId&gt;log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j&lt;/artifactId&gt;          &lt;version&gt;1.2.14&lt;/version&gt;          &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;    &lt;/dependencies&gt;           \n\r\n\rThat might seem like a lot of dependencies just to get some          logging. Well it is, but it is optional, and it          should behave better than the vanilla commons-logging with          respect to classloader issues, notably if you are in a strict container          like an OSGi platform. Allegedly there is also a performance benefit          because the bindings are at compile-time not runtime.          \n\r\n\rA more common choice amongst SLF4J users, which uses fewer steps          and generates fewer dependencies, is to bind directly to Logback. This removes the extra          binding step because Logback implements SLF4J directly, so you only need          to depend on two libraries not four (jcl-over-slf4j and          logback). If you do that you might also need to exclude the          slf4j-api dependency from other external dependencies (not Spring),          because you only want one version of that API on the classpath.            Using Log4J                \n\r\n\rMany people use Log4j as a logging        framework for configuration and management purposes. It\'s efficient        and well-established, and in fact it\'s what we use at runtime when we        build and test Spring. Spring also provides some utilities for        configuring and initializing Log4j, so it has an optional compile-time        dependency on Log4j in some modules.        \n\r\n\rTo make Log4j work with the default JCL dependency        (commons-logging) all you need to do is put Log4j on the        classpath, and provide it with a configuration file        (log4j.properties or log4j.xml in the root        of the classpath). So for Maven users this is your dependency        declaration:        &lt;dependencies&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;3.0.0.RELEASE&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;   &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j&lt;/artifactId&gt;      &lt;version&gt;1.2.14&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;         \n\r\n\rAnd here\'s a sample log4j.properties for logging to the        console:        log4j.rootCategory=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %t %c{2}:%L - %m%nlog4j.category.org.springframework.beans.factory=DEBUG        Runtime Containers with Native JCL                    \n\r\n\rMany people run their Spring applications in a container that          itself provides an implementation of JCL. IBM Websphere Application          Server (WAS) is the archetype. This often causes problems, and          unfortunately there is no silver bullet solution; simply excluding          commons-logging from your application is not enough in          most situations.          \n\r\n\rTo be clear about this: the problems reported are usually not          with JCL per se, or even with commons-logging: rather          they are to do with binding commons-logging to another          framework (often Log4J). This can fail because          commons-logging changed the way they do the runtime          discovery in between the older versions (1.0) found in some          containers and the modern versions that most people use now (1.1).          Spring does not use any unusual parts of the JCL API, so nothing          breaks there, but as soon as Spring or your application tries to do          any logging you can find that the bindings to Log4J are not          working.          \n\r\n\rIn such cases with WAS the easiest thing to do is to invert          the class loader hierarchy (IBM calls it \"parent last\") so that the          application controls the JCL dependency, not the container. That          option isn\'t always open, but there are plenty of other suggestions          in the public domain for alternative approaches, and your mileage          may vary depending on the exact version and feature set of the          container.                    Prev&nbsp;Up&nbsp;NextPart&nbsp;I.&nbsp;Overview of Spring Framework&nbsp;Home&nbsp;Part&nbsp;II.&nbsp;What\'s New in Spring 3","1. Introduction to Spring Framework","scr\\overview.html","         16.&nbsp;Marshalling XML using O/X MappersPrev&nbsp;Part&nbsp;IV.&nbsp;Data Access&nbsp;Next16.&nbsp;Marshalling XML using O/X Mappers        16.1&nbsp;Introduction                \n\r\n\r            In this chapter, we will describe Spring\'s Object/XML Mapping support. Object/XML Mapping, or O/X mapping            for short, is the act of converting an XML document to and from an object. This conversion process is also            known as XML Marshalling, or XML Serialization. This chapter uses these terms interchangeably.                \n\r\n\r            Within the field of O/X mapping, a marshaller is responsible for serializing an            object (graph) to XML. In similar fashion, an unmarshaller deserializes the XML to an            object graph. This XML can take the form of a DOM document, an input or output stream, or a SAX handler.                \n\r\n\rSome of the benefits of using Spring for your O/X mapping needs are:        \n\r\n\r            Ease of configuration.&nbsp;                            Spring\'s bean factory makes it easy to configure marshallers, without needing to construct JAXB context,                JiBX binding factories, etc. The marshallers can be configured as any other bean in your application                context. Additionally, XML Schema-based configuration is available for a number of marshallers, making                the configuration even simpler.                            \n\r\n\r            Consistent Interfaces.&nbsp;                            Spring\'s O/X mapping operates through two global interfaces: the                Marshaller and Unmarshaller interface.                These abstractions allow you to switch O/X mapping                frameworks with relative ease, with little or no changes required on the classes that do the                marshalling. This approach has the additional benefit of making it possible to do XML marshalling with                a mix-and-match approach (e.g. some marshalling performed using JAXB, other using XMLBeans) in a                non-intrusive fashion, leveraging the strength of each technology.                            \n\r\n\r            Consistent Exception Hierarchy.&nbsp;                            Spring provides a conversion from exceptions from the underlying O/X mapping tool to its own exception                hierarchy with the XmlMappingException as the root exception. As can be expected,                these runtime exceptions wrap the original exception so no information is lost.                            16.2&nbsp;Marshaller and Unmarshaller                \n\r\n\r            As stated in the introduction, a marshaller serializes an object to XML, and an            unmarshaller deserializes XML stream to an object. In this section, we will describe            the two Spring interfaces used for this purpose.                16.2.1&nbsp;Marshaller                        \n\r\n\r                Spring abstracts all marshalling operations behind the                org.springframework.oxm.Marshaller interface, the main methods of which                is listed below.                public interface Marshaller {    /**     * Marshals the object graph with the given root into the provided Result.     */    void marshal(Object graph, Result result)        throws XmlMappingException, IOException;}\n\r\n\r                The Marshaller interface has one main method, which marshals the given                object to a given javax.xml.transform.Result. Result is a tagging                interface that basically represents an XML output abstraction: concrete implementations wrap various XML                representations, as indicated in the table below.                                    Result implementationWraps XML representationDOMResultorg.w3c.dom.NodeSAXResultorg.xml.sax.ContentHandlerStreamResult                                    java.io.File,                                    java.io.OutputStream, or                                    java.io.Writer                                                \n\r\n\r                Note                    \n\r\n\r                        Although the marshal() method accepts a plain object as its first                        parameter, most Marshaller implementations cannot handle arbitrary                        objects. Instead, an object class must be mapped in a mapping file, marked with an annotation,                        registered with the marshaller, or have a common base class. Refer to the further sections                        in this chapter to determine how your O/X technology of choice manages this.                                    \n\r\n\r                            16.2.2&nbsp;Unmarshaller                        \n\r\n\r                Similar to the Marshaller, there is the                org.springframework.oxm.Unmarshaller interface.                public interface Unmarshaller {    /**     * Unmarshals the given provided Source into an object graph.     */    Object unmarshal(Source source)        throws XmlMappingException, IOException;}\n\r\n\r                This interface also has one method, which reads from the given                javax.xml.transform.Source (an XML input abstraction), and returns the                object read. As with Result, Source is a tagging interface that has three concrete implementations. Each                wraps a different XML representation, as indicated in the table below.                                    Source implementationWraps XML representationDOMSourceorg.w3c.dom.NodeSAXSource                                    org.xml.sax.InputSource, and                                    org.xml.sax.XMLReader                                StreamSource                                    java.io.File,                                    java.io.InputStream, or                                    java.io.Reader                                                \n\r\n\r                        \n\r\n\r                Even though there are two separate marshalling interfaces (Marshaller                and Unmarshaller), all implementations found in Spring-WS implement both in                one class. This means that you can wire up one marshaller class and refer to it both as a marshaller and an                unmarshaller in your applicationContext.xml.                            16.2.3&nbsp;XmlMappingException                        \n\r\n\r                Spring converts exceptions from the underlying O/X mapping tool to its own exception hierarchy with the                XmlMappingException as the root exception. As can be expected, these runtime                exceptions wrap the original exception so no information will be lost.                        \n\r\n\r                Additionally, the MarshallingFailureException and                UnmarshallingFailureException provide a distinction between marshalling and                unmarshalling operations, even though the underlying O/X mapping tool does not do so.                        \n\r\n\r                The O/X Mapping exception hierarchy is shown in the following figure:                O/X Mapping exception hierarchy\n\r\n\r                            16.3&nbsp;Using Marshaller and Unmarshaller                \n\r\n\r            Spring\'s OXM can be used for a wide variety of situations. In the following example, we will use it to            marshal the settings of a Spring-managed application as an XML file. We will use a simple JavaBean to            represent the settings:            public class Settings {    private boolean fooEnabled;    public boolean isFooEnabled() {        return fooEnabled;    }    public void setFooEnabled(boolean fooEnabled) {        this.fooEnabled = fooEnabled;    }}\n\r\n\r                \n\r\n\r            The application class uses this bean to store its settings. Besides a main method, the class has two            methods: saveSettings() saves the settings bean to a file named            settings.xml, and loadSettings() loads these settings again. A            main() method constructs a Spring application context, and calls these two methods.            import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.oxm.Marshaller;import org.springframework.oxm.Unmarshaller;public class Application {    private static final String FILE_NAME = \"settings.xml\";    private Settings settings = new Settings();    private Marshaller marshaller;    private Unmarshaller unmarshaller;    public void setMarshaller(Marshaller marshaller) {        this.marshaller = marshaller;    }    public void setUnmarshaller(Unmarshaller unmarshaller) {        this.unmarshaller = unmarshaller;    }    public void saveSettings() throws IOException {        FileOutputStream os = null;        try {            os = new FileOutputStream(FILE_NAME);            this.marshaller.marshal(settings, new StreamResult(os));        } finally {            if (os != null) {                os.close();            }        }    }    public void loadSettings() throws IOException {        FileInputStream is = null;        try {            is = new FileInputStream(FILE_NAME);            this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));        } finally {            if (is != null) {                is.close();            }        }    }    public static void main(String[] args) throws IOException {        ApplicationContext appContext =            new ClassPathXmlApplicationContext(\"applicationContext.xml\");        Application application = (Application) appContext.getBean(\"application\");        application.saveSettings();        application.loadSettings();    }}\n\r\n\r            The Application requires both a marshaller            and unmarshaller property to be set. We can do so using the following            applicationContext.xml:            &lt;beans&gt;    &lt;bean id=\"application\" class=\"Application\"&gt;        &lt;property name=\"marshaller\" ref=\"castorMarshaller\" /&gt;        &lt;property name=\"unmarshaller\" ref=\"castorMarshaller\" /&gt;    &lt;/bean&gt;    &lt;bean id=\"castorMarshaller\" class=\"org.springframework.oxm.castor.CastorMarshaller\"/&gt;&lt;/beans&gt;\n\r\n\r            This application context uses Castor, but we could have used any of the other marshaller instances described            later in this chapter. Note that Castor does not require any further configuration by default, so the bean            definition is rather simple. Also note that the CastorMarshaller implements both            Marshaller and Unmarshaller, so we can refer            to the castorMarshaller bean in both the marshaller and            unmarshaller property of the application.                \n\r\n\r            This sample application produces the following settings.xml file:            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings foo-enabled=\"false\"/&gt;\n\r\n\r                16.4&nbsp;XML Schema-based Configuration                      \n\r\n\r               Marshallers could be configured more concisely using tags from the OXM namespace.               To make these tags available, the appropriate schema has to be referenced first in the preamble of the XML configuration file.               Note the \'oxm\' related text below:                      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:oxm=\"http://www.springframework.org/schema/oxm\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/oxm    http://www.springframework.org/schema/oxm/spring-oxm.xsd\"&gt;        \n\r\n\r            Currently, the following tags are available:            \n\r                    \n\r\n\rjaxb2-marshaller                \n\r                    \n\r\n\rxmlbeans-marshaller                \n\r                    \n\r\n\rcastor-marshaller                \n\r                    \n\r\n\rjibx-marshaller                \n\r\n\r\n\r                \n\r\n\r            Each tag will be explained in its respective marshaller\'s section. As an example though, here is how            the configuration of a JAXB2 marshaller might look like:                &lt;oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/&gt;        16.5&nbsp;JAXB                \n\r\n\r            The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a            jaxb.properties file, and possibly some resource files. JAXB also offers a            way to generate a schema from annotated Java classes.                \n\r\n\r            Spring supports the JAXB 2.0 API as XML marshalling strategies, following the            Marshaller and Unmarshaller            interfaces described in Section&nbsp;16.2, &#8220;Marshaller and Unmarshaller&#8221;. The corresponding integration            classes reside in the org.springframework.oxm.jaxb package.                16.5.1&nbsp;Jaxb2Marshaller                        \n\r\n\r                The Jaxb2Marshaller class implements both the Spring                Marshaller and Unmarshallerinterface. It                requires a context path to operate, which you can set using the contextPath                property. The context path is a list of colon (:) separated Java package names that contain schema                derived classes. It also offers a classesToBeBound property, which allows you to set an array of                classes to be supported by the marshaller. Schema validation is performed by specifying one or more                schema resource to the bean, like so:                        &lt;beans&gt;    &lt;bean id=\"jaxb2Marshaller\" class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\"&gt;        &lt;property name=\"classesToBeBound\"&gt;            &lt;list&gt;                &lt;value&gt;org.springframework.oxm.jaxb.Flight&lt;/value&gt;                &lt;value&gt;org.springframework.oxm.jaxb.Flights&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=\"schema\" value=\"classpath:org/springframework/oxm/schema.xsd\"/&gt;    &lt;/bean&gt;    ...&lt;/beans&gt;            XML Schema-based Configuration                                \n\r\n\r                    The jaxb2-marshaller tag configures a org.springframework.oxm.jaxb.Jaxb2Marshaller.                    Here is an example:                                &lt;oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/&gt;                \n\r\n\r                    Alternatively, the list of classes to bind can be provided to the marshaller via the class-to-be-bound child tag:                                &lt;oxm:jaxb2-marshaller id=\"marshaller\"&gt;    &lt;oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Airport\"/&gt;    &lt;oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Flight\"/&gt;    ...&lt;/oxm:jaxb2-marshaller&gt;                                \n\r\n\r                    Available attributes are:                                            AttributeDescriptionRequiredidthe id of the marshallernocontextPaththe JAXB Context pathno                    \n\r\n\r                                            16.6&nbsp;Castor                \n\r\n\r            Castor XML mapping is an open source XML binding framework. It allows you to transform the data contained in            a java object model into/from an XML document. By default, it does not require any further configuration,            though a mapping file can be used to have more control over the behavior of Castor.                \n\r\n\r            For more information on Castor, refer to the             Castor web site. The Spring integration classes reside in the            org.springframework.oxm.castor package.                16.6.1&nbsp;CastorMarshaller                        \n\r\n\r                As with JAXB, the CastorMarshaller implements both the                Marshaller and Unmarshaller interface.                It can be wired up as follows:                        &lt;beans&gt;    &lt;bean id=\"castorMarshaller\" class=\"org.springframework.oxm.castor.CastorMarshaller\" /&gt;    ...&lt;/beans&gt;                16.6.2&nbsp;Mapping                        \n\r\n\r                Although it is possible to rely on Castor\'s default marshalling behavior, it might be necessary to have                more control over it. This can be accomplished using a Castor mapping file. For more information, refer                to Castor XML Mapping.                        \n\r\n\r                The mapping can be set using the mappingLocation resource property, indicated                below with a classpath resource.                        &lt;beans&gt;    &lt;bean id=\"castorMarshaller\" class=\"org.springframework.oxm.castor.CastorMarshaller\" &gt;        &lt;property name=\"mappingLocation\" value=\"classpath:mapping.xml\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;            XML Schema-based Configuration                                \n\r\n\r                    The castor-marshaller tag configures a                    org.springframework.oxm.castor.CastorMarshaller.                    Here is an example:                                                    &lt;oxm:castor-marshaller id=\"marshaller\" mapping-location=\"classpath:org/springframework/oxm/castor/mapping.xml\"/&gt;                \n\r\n\r                    The marshaller instance can be configured in two ways, by specifying either the location of                    a mapping file (through the mapping-location property), or by                    identifying Java POJOs (through the target-class or                    target-package properties) for which there exist corresponding                    XML descriptor classes. The latter way is usually used in conjunction with XML code generation                    from XML schemas.                                \n\r\n\r                    Available attributes are:                                            AttributeDescriptionRequired                                        id                                    the id of the marshallerno                                        encoding                                    the encoding to use for unmarshalling from XMLno                                        target-class                                    a Java class name for a POJO for which an XML class descriptor is available (as                                        generated through code generation)                                    no                                        target-package                                    a Java package name that identifies a package that contains POJOs and their                                        corresponding Castor                                        XML descriptor classes (as generated through code generation from XML schemas)                                    no                                        mapping-location                                    location of a Castor XML mapping fileno                    \n\r\n\r                                            16.7&nbsp;XMLBeans                \n\r\n\r            XMLBeans is an XML binding tool that has full XML Schema support, and offers full XML Infoset            fidelity. It takes a different approach to that of most other O/X mapping frameworks, in that            all classes that are generated from an XML Schema are all derived from            XmlObject, and contain XML binding information in them.                \n\r\n\r            For more information on XMLBeans, refer to the                XMLBeans web site . The Spring-WS integration classes reside            in the org.springframework.oxm.xmlbeans package.                16.7.1&nbsp;XmlBeansMarshaller                        \n\r\n\r                The XmlBeansMarshaller                implements both the Marshaller                and Unmarshaller                interfaces. It can be configured as follows:                        &lt;beans&gt;    &lt;bean id=\"xmlBeansMarshaller\" class=\"org.springframework.oxm.xmlbeans.XmlBeansMarshaller\" /&gt;    ...&lt;/beans&gt;            Note                \n\r\n\r                    Note that the XmlBeansMarshaller                    can only marshal objects of type XmlObject,                    and not every java.lang.Object.                                        XML Schema-based Configuration                                \n\r\n\r                    The xmlbeans-marshaller tag configures a org.springframework.oxm.xmlbeans.XmlBeansMarshaller.                    Here is an example:                                &lt;oxm:xmlbeans-marshaller id=\"marshaller\"/&gt;                \n\r\n\r                    Available attributes are:                                            AttributeDescriptionRequiredidthe id of the marshallernooptionsthe bean name of the XmlOptions that is to be used for this marshaller. Typically a                                    XmlOptionsFactoryBean definitionno                    \n\r\n\r                                            16.8&nbsp;JiBX                \n\r\n\r            The JiBX framework offers a solution similar to that which JDO provides for ORM: a binding definition defines the            rules for how your Java objects are converted to or from XML. After preparing the binding and compiling the            classes, a JiBX binding compiler enhances the class files, and adds code to handle converting instances of            the classes from or to XML.                \n\r\n\r            For more information on JiBX, refer to the             JiBX web site. The Spring integration classes reside in the            org.springframework.oxm.jibx package.                16.8.1&nbsp;JibxMarshaller                        \n\r\n\r                The JibxMarshaller class implements both the                Marshaller and Unmarshaller interface.                To operate, it requires the name of the class to marshal in, which you can set using the                targetClass property. Optionally, you can set the binding name using the                bindingName property. In the next sample, we bind the                Flights class:                        &lt;beans&gt;    &lt;bean id=\"jibxFlightsMarshaller\" class=\"org.springframework.oxm.jibx.JibxMarshaller\"&gt;        &lt;property name=\"targetClass\"&gt;org.springframework.oxm.jibx.Flights&lt;/property&gt;    &lt;/bean&gt;    ...            \n\r\n\r                A JibxMarshaller is configured for a single class. If you want to marshal                multiple classes, you have to configure multiple JibxMarshallers with                different targetClass property values.                        XML Schema-based Configuration                                \n\r\n\r                    The jibx-marshaller tag configures a org.springframework.oxm.jibx.JibxMarshaller.                    Here is an example:                                &lt;oxm:jibx-marshaller id=\"marshaller\" target-class=\"org.springframework.ws.samples.airline.schema.Flight\"/&gt;                \n\r\n\r                    Available attributes are:                                            AttributeDescriptionRequiredidthe id of the marshallernotarget-classthe target class for this marshalleryesbindingNamethe binding name used by this marshallerno                    \n\r\n\r                                            16.9&nbsp;XStream                \n\r\n\r            XStream is a simple library to serialize objects to XML and back again. It does not require any mapping, and            generates clean XML.                \n\r\n\r            For more information on XStream, refer to the             XStream web site. The Spring integration classes reside in the            org.springframework.oxm.xstream package.                16.9.1&nbsp;XStreamMarshaller                        \n\r\n\r                The XStreamMarshaller does not require any configuration, and can be configured                in an application context directly. To further customize the XML, you can set an                alias map, which consists of string aliases mapped to classes:                        &lt;beans&gt;    &lt;bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\"&gt;        &lt;property name=\"aliases\"&gt;            &lt;props&gt;                &lt;prop key=\"Flight\"&gt;org.springframework.oxm.xstream.Flight&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    ...&lt;/beans&gt;            Warning                \n\r\n\r                  By default, XStream allows for arbitrary classes to be unmarshalled, which can result in security                  vulnerabilities.                  As such, it is recommended to set the supportedClasses property on the                  XStreamMarshaller, like so:                  &lt;bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\"&gt;    &lt;property name=\"supportedClasses\" value=\"org.springframework.oxm.xstream.Flight\"/&gt;    ...&lt;/bean&gt;\n\r\n\r                  This will make sure that only the registered classes are eligible for unmarshalling.                                \n\r\n\r                  Additionally, you can register                   custom converters to make sure that only your supported classes can be unmarshalled.                                      Note              \n\r\n\r                  Note that XStream is an XML serialization library, not a data binding library. Therefore, it has                  limited namespace support. As such, it is rather unsuitable for usage within Web services.                                    Prev&nbsp;Up&nbsp;Next15.&nbsp;Object Relational Mapping (ORM) Data Access&nbsp;Home&nbsp;Part&nbsp;V.&nbsp;The Web","16. Marshalling XML using O/X Mappers","scr\\oxm.html","         20.&nbsp;Portlet MVC FrameworkPrev&nbsp;Part&nbsp;V.&nbsp;The Web&nbsp;Next20.&nbsp;Portlet MVC Framework    20.1&nbsp;Introduction        \n\r\n\rJSR-168 The Java Portlet Specification            \n\r\n\rFor more general information about portlet development, please      review a whitepaper from Sun entitled      \"Introduction to JSR 168\",      and of course the      JSR-168 Specification itself.        \n\r\n\rIn addition to supporting conventional (servlet-based) Web development,    Spring also supports JSR-168 Portlet development. As much as possible, the    Portlet MVC framework is a mirror image of the Web MVC framework, and also    uses the same underlying view abstractions and integration technology. So, be    sure to review the chapters entitled Chapter&nbsp;17, Web MVC framework and    Chapter&nbsp;18, View technologies before continuing with this chapter.    Note      \n\r\n\rBear in mind that while the concepts of Spring MVC are the      same in Spring Portlet MVC, there are some notable differences      created by the unique workflow of JSR-168 portlets.        \n\r\n\rThe main way in which portlet workflow differs from servlet    workflow is that the request to the portlet can have two distinct    phases: the action phase and the render phase. The action phase is    executed only once and is where any \'backend\' changes or actions occur,    such as making changes in a database. The render phase then produces    what is displayed to the user each time the display is refreshed.    The critical point here is that for a single overall request, the action    phase is executed only once, but the render phase may be executed    multiple times. This provides (and requires) a clean separation between    the activities that modify the persistent state of your system and the    activities that generate what is displayed to the user.        \n\r\n\rSpring Web Flow    \n\r\n\rSpring Web Flow (SWF) aims to be the best solution for the management  of web application page flow.  \n\r\n\rSWF integrates with existing frameworks like Spring MVC, Struts, and  JSF, in both servlet and portlet environments. If you have a business  process (or processes) that would benefit from a conversational model as  opposed to a purely request model, then SWF may be the solution.  \n\r\n\rSWF allows you to capture logical page flows as self-contained modules  that are reusable in different situations, and as such is ideal for building  web application modules that guide the user through controlled navigations  that drive business processes.  \n\r\n\rFor more information about SWF, consult the  Spring Web Flow website.      \n\r\n\rThe dual phases of portlet requests are one of the real strengths    of the JSR-168 specification. For example, dynamic search results can be    updated routinely on the display without the user explicitly rerunning    the search. Most other portlet MVC frameworks attempt to completely    hide the two phases from the developer and make it look as much like    traditional servlet development as possible - we think this    approach removes one of the main benefits of using portlets. So, the    separation of the two phases is preserved throughout the Spring Portlet    MVC framework. The primary manifestation of this approach is that where    the servlet version of the MVC classes will have one method that deals    with the request, the portlet version of the MVC classes will have two    methods that deal with the request: one for the action phase and one for    the render phase. For example, where the servlet version of    AbstractController has the    handleRequestInternal(..) method, the portlet    version of AbstractController has    handleActionRequestInternal(..) and    handleRenderRequestInternal(..) methods.    \n\r\n\rThe framework is designed around a    DispatcherPortlet that dispatches requests to    handlers, with configurable handler mappings and view resolution, just    as the DispatcherServlet in the web framework    does. File upload is also supported in the same way.    \n\r\n\rLocale resolution and theme resolution are not supported in    Portlet MVC - these areas are in the purview of the    portal/portlet container and are not appropriate at the Spring level.    However, all mechanisms in Spring that depend on the locale (such as    internationalization of messages) will still function properly because    DispatcherPortlet exposes the current locale in    the same way as DispatcherServlet.    20.1.1&nbsp;Controllers - The C in MVC            \n\r\n\rThe default handler is still a very simple      Controller interface, offering just two      methods:      \n\r          \n\r\n\rvoid handleActionRequest(request,response)         \n\r          \n\r\n\rModelAndView handleRenderRequest(request,response)         \n\r      \n\r\n\rThe framework also includes most of the same controller      implementation hierarchy, such as AbstractController,      SimpleFormController, and so on. Data binding,      command object usage, model handling, and view resolution are all the      same as in the servlet framework.        20.1.2&nbsp;Views - The V in MVC            \n\r\n\rAll the view rendering capabilities of the servlet framework are      used directly via a special bridge servlet named      ViewRendererServlet. By using this servlet, the      portlet request is converted into a servlet request and the view can be      rendered using the entire normal servlet infrastructure. This means all      the existing renderers, such as JSP, Velocity, etc., can still be used      within the portlet.        20.1.3&nbsp;Web-scoped beans            \n\r\n\rSpring Portlet MVC supports beans whose lifecycle is scoped to the      current HTTP request or HTTP Session (both      normal and global). This is not a specific feature of Spring Portlet MVC      itself, but rather of the WebApplicationContext      container(s) that Spring Portlet MVC uses. These bean scopes are described      in detail in Section&nbsp;5.5.4, &#8220;Request, session, and global session scopes&#8221;                20.2&nbsp;The DispatcherPortlet        \n\r\n\rPortlet MVC is a request-driven web MVC framework, designed around    a portlet that dispatches requests to controllers and offers other    functionality facilitating the development of portlet applications.    Spring\'s DispatcherPortlet however, does more    than just that. It is completely integrated with the Spring    ApplicationContext and allows you to use    every other feature Spring has.    \n\r\n\rLike ordinary portlets, the    DispatcherPortlet is declared in the    portlet.xml file of your web application:    &lt;portlet&gt;    &lt;portlet-name&gt;sample&lt;/portlet-name&gt;    &lt;portlet-class&gt;org.springframework.web.portlet.DispatcherPortlet&lt;/portlet-class&gt;    &lt;supports&gt;        &lt;mime-type&gt;text/html&lt;/mime-type&gt;        &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;    &lt;/supports&gt;    &lt;portlet-info&gt;        &lt;title&gt;Sample Portlet&lt;/title&gt;    &lt;/portlet-info&gt;&lt;/portlet&gt;    \n\r\n\rThe DispatcherPortlet now needs to be    configured.    \n\r\n\rIn the Portlet MVC framework, each    DispatcherPortlet has its own    WebApplicationContext, which inherits all    the beans already defined in the Root    WebApplicationContext. These inherited    beans can be overridden in the portlet-specific scope, and new    scope-specific beans can be defined local to a given portlet instance.    \n\r\n\rThe framework will, on initialization of a    DispatcherPortlet, look for a file named    [portlet-name]-portlet.xml in the WEB-INF    directory of your web application and create the beans defined there    (overriding the definitions of any beans defined with the same name in    the global scope).    \n\r\n\rThe config location used by the    DispatcherPortlet can be modified through a    portlet initialization parameter (see below for details).    \n\r\n\rThe Spring DispatcherPortlet has a few    special beans it uses, in order to be able to process requests and    render the appropriate views. These beans are included in the Spring    framework and can be configured in the    WebApplicationContext, just as any other    bean would be configured. Each of those beans is described in more    detail below. Right now, we\'ll just mention them, just to let you know    they exist and to enable us to go on talking about the    DispatcherPortlet. For most of the beans,    defaults are provided so you don\'t have to worry about configuring    them.    \n\r\n\rTable&nbsp;20.1.&nbsp;Special beans in the WebApplicationContext            ExpressionExplanationhandler mapping(s)(Section&nbsp;20.5, &#8220;Handler mappings&#8221;) a            list of pre- and post-processors and controllers that            will be executed if they match certain criteria (for            instance a matching portlet mode specified with the            controller)controller(s)(Section&nbsp;20.4, &#8220;Controllers&#8221;) the beans            providing the actual functionality (or at least, access            to the functionality) as part of the MVC triadview resolver(Section&nbsp;20.6, &#8220;Views and resolving them&#8221;) capable            of resolving view names to view definitionsmultipart resolver(Section&nbsp;20.7, &#8220;Multipart (file upload) support&#8221;) offers            functionality to process file uploads from HTML            formshandler exception resolver(Section&nbsp;20.8, &#8220;Handling exceptions&#8221;)            offers functionality to map exceptions to views or            implement other more complex exception handling            code    \n\r    \n\r\n\rWhen a DispatcherPortlet is setup for use    and a request comes in for that specific    DispatcherPortlet, it starts processing the    request. The list below describes the complete process a request goes    through if handled by a DispatcherPortlet:    \n\r\n\r\n\rThe locale returned by      PortletRequest.getLocale() is bound to the      request to let elements in the process resolve the locale to use      when processing the request (rendering the view, preparing data,      etc.).\n\r\n\r\n\rIf a multipart resolver is specified and this is an      ActionRequest, the request is      inspected for multiparts and if they are found, it is wrapped in a      MultipartActionRequest for further      processing by other elements in the process. (See Section&nbsp;20.7, &#8220;Multipart (file upload) support&#8221; for further information about      multipart handling).\n\r\n\r\n\rAn appropriate handler is searched for. If a handler      is found, the execution chain associated with the handler      (pre-processors, post-processors, controllers) will be executed in order      to prepare a model.\n\r\n\r\n\rIf a model is returned, the view is rendered, using      the view resolver that has been configured with the      WebApplicationContext. If no model is      returned (which could be due to a pre- or post-processor      intercepting the request, for example, for security reasons), no      view is rendered, since the request could already have been      fulfilled.\n\r    \n\r\n\rExceptions that are thrown during processing of the request    get picked up by any of the handler exception resolvers that are    declared in the WebApplicationContext.    Using these exception resolvers you can define custom behavior in case    such exceptions get thrown.    \n\r\n\rYou can customize Spring\'s DispatcherPortlet    by adding context parameters in the portlet.xml file or    portlet init-parameters. The possibilities are listed below.    \n\r\n\rTable&nbsp;20.2.&nbsp;DispatcherPortlet initialization parameters            ParameterExplanationcontextClassClass that implements            WebApplicationContext,            which will be used to instantiate the context used by            this portlet. If this parameter isn\'t specified, the            XmlPortletApplicationContext will            be used.contextConfigLocationString which is passed to the context instance            (specified by contextClass) to            indicate where context(s) can be found. The String is            potentially split up into multiple Strings (using a            comma as a delimiter) to support multiple contexts (in            case of multiple context locations, for beans that are            defined twice, the latest takes precedence).namespaceThe namespace of the            WebApplicationContext.            Defaults to [portlet-name]-portlet.viewRendererUrlThe URL at which            DispatcherPortlet can access an            instance of ViewRendererServlet            (see Section&nbsp;20.3, &#8220;The ViewRendererServlet&#8221;).    \n\r    20.3&nbsp;The ViewRendererServlet        \n\r\n\rThe rendering process in Portlet MVC is a bit more complex than in    Web MVC. In order to reuse all the view technologies    from Spring Web MVC, we must convert the    PortletRequest /    PortletResponse to    HttpServletRequest /    HttpServletResponse and then call the    render method of the    View. To do this,    DispatcherPortlet uses a special servlet that    exists for just this purpose: the    ViewRendererServlet.    \n\r\n\rIn order for DispatcherPortlet rendering to    work, you must declare an instance of the    ViewRendererServlet in the    web.xml file for your web application as    follows:    &lt;servlet&gt;    &lt;servlet-name&gt;ViewRendererServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.ViewRendererServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ViewRendererServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/WEB-INF/servlet/view&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;    \n\r\n\rTo perform the actual rendering, DispatcherPortlet    does the following:    \n\r\n\r\n\rBinds the      WebApplicationContext to the request      as an attribute under the same      WEB_APPLICATION_CONTEXT_ATTRIBUTE key that      DispatcherServlet uses.\n\r\n\r\n\rBinds the Model and      View objects to the request to make      them available to the      ViewRendererServlet.\n\r\n\r\n\rConstructs a      PortletRequestDispatcher and performs      an include using the /WEB-      INF/servlet/view URL that is mapped to the      ViewRendererServlet.\n\r    \n\r\n\rThe ViewRendererServlet is then able to    call the render method on the    View with the appropriate    arguments.    \n\r\n\rThe actual URL for the ViewRendererServlet    can be changed using DispatcherPortlet&#8217;s    viewRendererUrl configuration parameter.    20.4&nbsp;Controllers        \n\r\n\rThe controllers in Portlet MVC are very similar to the Web MVC    Controllers, and porting code from one to the other should be    simple.    \n\r\n\rThe basis for the Portlet MVC controller architecture is the    org.springframework.web.portlet.mvc.Controller    interface, which is listed below.    public interface Controller {    /**     * Process the render request and return a ModelAndView object which the     * DispatcherPortlet will render.     */    ModelAndView handleRenderRequest(RenderRequest request, RenderResponse response)        throws Exception;    /**     * Process the action request. There is nothing to return.     */    void handleActionRequest(ActionRequest request, ActionResponse response)        throws Exception;}    \n\r\n\rAs you can see, the Portlet    Controller interface requires two methods    that handle the two phases of a portlet request: the action request and    the render request. The action phase should be capable of handling an    action request, and the render phase should be capable of handling a    render request and returning an appropriate model and view. While the    Controller interface is quite abstract,    Spring Portlet MVC offers several controllers that already contain a    lot of the functionality you might need; most of these are very similar    to controllers from Spring Web MVC. The    Controller interface just defines the    most common functionality required of every controller: handling an    action request, handling a render request, and returning a model and a    view.    20.4.1&nbsp;AbstractController and PortletContentGenerator            \n\r\n\rOf course, just a Controller      interface isn\'t enough. To provide a basic infrastructure, all of      Spring Portlet MVC\'s Controllers      inherit from AbstractController, a class      offering access to Spring\'s      ApplicationContext and control over      caching.      \n\r\n\rTable&nbsp;20.3.&nbsp;Features offered by the AbstractController                ParameterExplanationrequireSessionIndicates whether or not this              Controller requires a              session to do its work. This feature is offered to              all controllers. If a session is not present when              such a controller receives a request, the user is              informed using a              SessionRequiredException.synchronizeSessionUse this if you want handling by this              controller to be synchronized on the user\'s session.              To be more specific, the extending controller will              override the handleRenderRequestInternal(..) and              handleActionRequestInternal(..) methods, which will be              synchronized on the user&#8217;s session if you specify              this variable.renderWhenMinimizedIf you want your controller to actually              render the view when the portlet is in a minimized              state, set this to true. By default, this is set to              false so that portlets that are in a minimized state              don&#8217;t display any content.cacheSecondsWhen you want a controller to override the              default cache expiration defined for the portlet,              specify a positive integer here. By default it is              set to -1, which does not change              the default caching. Setting it to 0              will ensure the result is never cached.      \n\r      \n\r\n\rThe requireSession and      cacheSeconds properties are declared on the      PortletContentGenerator class, which is the      superclass of AbstractController) but are      included here for completeness.      \n\r\n\rWhen using the AbstractController as a      base class for your controllers (which is not recommended since there      are a lot of other controllers that might already do the job for      you) you only have to override either the      handleActionRequestInternal(ActionRequest,      ActionResponse) method or the      handleRenderRequestInternal(RenderRequest,      RenderResponse) method (or both), implement your logic,      and return a ModelAndView object (in the case      of handleRenderRequestInternal).      \n\r\n\rThe default implementations of both      handleActionRequestInternal(..) and      handleRenderRequestInternal(..) throw a      PortletException. This is consistent with      the behavior of GenericPortlet from the JSR-      168 Specification API. So you only need to override the method that      your controller is intended to handle.      \n\r\n\rHere is short example consisting of a class and a declaration      in the web application context.      package samples;import javax.portlet.RenderRequest;import javax.portlet.RenderResponse;import org.springframework.web.portlet.mvc.AbstractController;import org.springframework.web.portlet.ModelAndView;public class SampleController extends AbstractController {    public ModelAndView handleRenderRequestInternal(RenderRequest request, RenderResponse response) {        ModelAndView mav = new ModelAndView(\"foo\");        mav.addObject(\"message\", \"Hello World!\");        return mav;    }}&lt;bean id=\"sampleController\" class=\"samples.SampleController\"&gt;    &lt;property name=\"cacheSeconds\" value=\"120\"/&gt;&lt;/bean&gt;      \n\r\n\rThe class above and the declaration in the web application      context is all you need besides setting up a handler mapping (see      Section&nbsp;20.5, &#8220;Handler mappings&#8221;) to get this very simple      controller working.        20.4.2&nbsp;Other simple controllers            \n\r\n\rAlthough you can extend AbstractController,      Spring Portlet MVC provides a number of concrete implementations which offer      functionality that is commonly used in simple MVC applications.      \n\r\n\rThe ParameterizableViewController is      basically the same as the example above, except for the fact that      you can specify the view name that it will return in the web      application context (no need to hard-code the view name).      \n\r\n\rThe PortletModeNameViewController uses      the current mode of the portlet as the view name. So, if your      portlet is in View mode (i.e. PortletMode.VIEW)      then it uses \"view\" as the view name.        20.4.3&nbsp;Command Controllers            \n\r\n\rSpring Portlet MVC has the exact same hierarchy of      command controllers as Spring Web MVC. They      provide a way to interact with data objects and dynamically bind      parameters from the PortletRequest to      the data object specified. Your data objects don\'t have to      implement a framework-specific interface, so you can directly      manipulate your persistent objects if you desire. Let\'s examine what      command controllers are available, to get an overview of what you can do      with them:      \n\r\n\r\n\rAbstractCommandController        - a command controller you can use to create your own command        controller, capable of binding request parameters to a data        object you specify. This class does not offer form        functionality, it does however offer validation features and        lets you specify in the controller itself what to do with the        command object that has been filled with the parameters from the        request.\n\r\n\r\n\rAbstractFormController -        an abstract controller offering form submission support. Using        this controller you can model forms and populate them using a        command object you retrieve in the controller. After a user has        filled the form, AbstractFormController        binds the fields, validates, and hands the object back to the        controller to take appropriate action. Supported features are:        invalid form submission (resubmission), validation, and normal        form workflow. You implement methods to determine which views        are used for form presentation and success. Use this controller        if you need forms, but don\'t want to specify what views you\'re        going to show the user in the application        context.\n\r\n\r\n\rSimpleFormController - a        concrete AbstractFormController that        provides even more support when creating a form with a        corresponding command object. The        SimpleFormController lets you specify a        command object, a viewname for the form, a viewname for the page you        want to show the user when form submission has succeeded, and        more.\n\r\n\r\n\rAbstractWizardFormController &#8211;        a concrete AbstractFormController that        provides a wizard-style interface for editing the contents of a        command object across multiple display pages. Supports multiple        user actions: finish, cancel, or page change, all of which are        easily specified in request parameters from the        view.\n\r      \n\r\n\rThese command controllers are quite powerful, but they do      require a detailed understanding of how they operate in order to use      them efficiently. Carefully review the Javadocs for this entire      hierarchy and then look at some sample implementations before you      start using them.        20.4.4&nbsp;PortletWrappingController            \n\r\n\rInstead of developing new controllers, it is possible to use      existing portlets and map requests to them from a      DispatcherPortlet. Using the      PortletWrappingController, you can      instantiate an existing Portlet as a      Controller as follows:      &lt;bean id=\"myPortlet\" class=\"org.springframework.web.portlet.mvc.PortletWrappingController\"&gt;    &lt;property name=\"portletClass\" value=\"sample.MyPortlet\"/&gt;    &lt;property name=\"portletName\" value=\"my-portlet\"/&gt;    &lt;property name=\"initParameters\"&gt;        &lt;value&gt;config=/WEB-INF/my-portlet-config.xml&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThis can be very valuable since you can then use interceptors      to pre-process and post-process requests going to these portlets.      Since JSR-168 does not support any kind of filter mechanism, this is      quite handy. For example, this can be used to wrap the Hibernate      OpenSessionInViewInterceptor around a MyFaces      JSF Portlet.        20.5&nbsp;Handler mappings        \n\r\n\rUsing a handler mapping you can map incoming portlet requests to    appropriate handlers. There are some handler mappings you can use out    of the box, for example, the    PortletModeHandlerMapping, but let\'s first    examine the general concept of a    HandlerMapping.    \n\r\n\rNote: We are intentionally using the term &#8220;Handler&#8221; here instead    of &#8220;Controller&#8221;. DispatcherPortlet is designed    to be used with other ways to process requests than just Spring Portlet    MVC&#8217;s own Controllers. A Handler is any Object that can handle portlet    requests. Controllers are an example of Handlers, and they are of    course the default. To use some other framework with    DispatcherPortlet, a corresponding implementation    of HandlerAdapter is all that is needed.    \n\r\n\rThe functionality a basic    HandlerMapping provides is the delivering    of a HandlerExecutionChain, which must contain    the handler that matches the incoming request, and may also contain a    list of handler interceptors that are applied to the request. When a    request comes in, the DispatcherPortlet will hand    it over to the handler mapping to let it inspect the request and come up    with an appropriate HandlerExecutionChain. Then    the DispatcherPortlet will execute the handler    and interceptors in the chain (if any). These concepts are all exactly    the same as in Spring Web MVC.    \n\r\n\rThe concept of configurable handler mappings that can optionally    contain interceptors (executed before or after the actual handler was    executed, or both) is extremely powerful. A lot of supporting    functionality can be built into a custom    HandlerMapping. Think of a custom handler    mapping that chooses a handler not only based on the portlet mode of the    request coming in, but also on a specific state of the session    associated with the request.    \n\r\n\rIn Spring Web MVC, handler mappings are commonly based on URLs.    Since there is really no such thing as a URL within a Portlet, we must    use other mechanisms to control mappings. The two most common are the    portlet mode and a request parameter, but anything available to the    portlet request can be used in a custom handler mapping.    \n\r\n\rThe rest of this section describes three of Spring Portlet MVC\'s    most commonly used handler mappings. They all extend    AbstractHandlerMapping and share the following    properties:    \n\r\n\r\n\rinterceptors: The list of      interceptors to use.      HandlerInterceptors are discussed in      Section&nbsp;20.5.4, &#8220;Adding HandlerInterceptors&#8221;.\n\r\n\r\n\rdefaultHandler: The default      handler to use, when this handler mapping does not result in a      matching handler.\n\r\n\r\n\rorder: Based on the value of the      order property (see the      org.springframework.core.Ordered      interface), Spring will sort all handler mappings available in the      context and apply the first matching handler.\n\r\n\r\n\rlazyInitHandlers: Allows for lazy      initialization of singleton handlers (prototype handlers are always      lazily initialized). Default value is false. This property is      directly implemented in the three concrete      Handlers.\n\r    20.5.1&nbsp;PortletModeHandlerMapping            \n\r\n\rThis is a simple handler mapping that maps incoming requests      based on the current mode of the portlet (e.g. &#8216;view&#8217;, &#8216;edit&#8217;,      &#8216;help&#8217;). An example:      &lt;bean class=\"org.springframework.web.portlet.handler.PortletModeHandlerMapping\"&gt;    &lt;property name=\"portletModeMap\"&gt;        &lt;map&gt;            &lt;entry key=\"view\" value-ref=\"viewHandler\"/&gt;            &lt;entry key=\"edit\" value-ref=\"editHandler\"/&gt;            &lt;entry key=\"help\" value-ref=\"helpHandler\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;        20.5.2&nbsp;ParameterHandlerMapping            \n\r\n\rIf we need to navigate around to multiple controllers without      changing portlet mode, the simplest way to do this is with a request      parameter that is used as the key to control the mapping.      \n\r\n\rParameterHandlerMapping uses the value      of a specific request parameter to control the mapping. The default      name of the parameter is \'action\', but can be changed      using the \'parameterName\' property.      \n\r\n\rThe bean configuration for this mapping will look something      like this:      &lt;bean class=\"org.springframework.web.portlet.handler.ParameterHandlerMapping&#8221;&gt;    &lt;property name=\"parameterMap\"&gt;        &lt;map&gt;            &lt;entry key=\"add\" value-ref=\"addItemHandler\"/&gt;            &lt;entry key=\"edit\" value-ref=\"editItemHandler\"/&gt;            &lt;entry key=\"delete\" value-ref=\"deleteItemHandler\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;        20.5.3&nbsp;PortletModeParameterHandlerMapping            \n\r\n\rThe most powerful built-in handler mapping,      PortletModeParameterHandlerMapping combines      the capabilities of the two previous ones to allow different      navigation within each portlet mode.      \n\r\n\rAgain the default name of the parameter is \"action\", but can      be changed using the parameterName      property.      \n\r\n\rBy default, the same parameter value may not be used in two      different portlet modes. This is so that if the portal itself      changes the portlet mode, the request will no longer be valid in the      mapping. This behavior can be changed by setting the      allowDupParameters property to true. However,      this is not recommended.      \n\r\n\rThe bean configuration for this mapping will look something      like this:      &lt;bean class=\"org.springframework.web.portlet.handler.PortletModeParameterHandlerMapping\"&gt;    &lt;property name=\"portletModeParameterMap\"&gt;        &lt;map&gt;            &lt;entry key=\"view\"&gt; &lt;!-- \'view\' portlet mode --&gt;                &lt;map&gt;                    &lt;entry key=\"add\" value-ref=\"addItemHandler\"/&gt;                    &lt;entry key=\"edit\" value-ref=\"editItemHandler\"/&gt;                    &lt;entry key=\"delete\" value-ref=\"deleteItemHandler\"/&gt;                &lt;/map&gt;            &lt;/entry&gt;            &lt;entry key=\"edit\"&gt; &lt;!-- \'edit\' portlet mode --&gt;                &lt;map&gt;                    &lt;entry key=\"prefs\" value-ref=\"prefsHandler\"/&gt;                    &lt;entry key=\"resetPrefs\" value-ref=\"resetPrefsHandler\"/&gt;                &lt;/map&gt;            &lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThis mapping can be chained ahead of a      PortletModeHandlerMapping, which can then provide      defaults for each mode and an overall default as well.        20.5.4&nbsp;Adding HandlerInterceptors            \n\r\n\rSpring\'s handler mapping mechanism has a notion of handler      interceptors, which can be extremely useful when you want to apply      specific functionality to certain requests, for example, checking      for a principal. Again Spring Portlet MVC implements these concepts      in the same way as Web MVC.      \n\r\n\rInterceptors located in the handler mapping must implement      HandlerInterceptor from the      org.springframework.web.portlet package. Just      like the servlet version, this interface defines three methods: one      that will be called before the actual handler will be executed      (preHandle), one that will be called after the      handler is executed (postHandle), and one that is      called after the complete request has finished      (afterCompletion). These three methods should      provide enough flexibility to do all kinds of pre- and post-      processing.      \n\r\n\rThe preHandle method returns a boolean      value. You can use this method to break or continue the processing      of the execution chain. When this method returns      true, the handler execution chain will continue.      When it returns false, the      DispatcherPortlet assumes the interceptor      itself has taken care of requests (and, for example, rendered an      appropriate view) and does not continue executing the other      interceptors and the actual handler in the execution chain.      \n\r\n\rThe postHandle method is only called on a      RenderRequest. The      preHandle and afterCompletion      methods are called on both an      ActionRequest and a      RenderRequest. If you need to      execute logic in these methods for just one type of request, be sure      to check what kind of request it is before processing it.        20.5.5&nbsp;HandlerInterceptorAdapter            \n\r\n\rAs with the servlet package, the portlet package has a      concrete implementation of      HandlerInterceptor called      HandlerInterceptorAdapter. This class has      empty versions of all the methods so that you can inherit from this      class and implement just one or two methods when that is all you      need.        20.5.6&nbsp;ParameterMappingInterceptor            \n\r\n\rThe portlet package also has a concrete interceptor named      ParameterMappingInterceptor that is meant to      be used directly with ParameterHandlerMapping      and PortletModeParameterHandlerMapping. This      interceptor will cause the parameter that is being used to control      the mapping to be forwarded from an      ActionRequest to the subsequent      RenderRequest. This will help ensure      that the RenderRequest is mapped to      the same Handler as the      ActionRequest. This is done in the      preHandle method of the interceptor, so you can      still modify the parameter value in your handler to change where the      RenderRequest will be mapped.      \n\r\n\rBe aware that this interceptor is calling      setRenderParameter on the      ActionResponse, which means that you      cannot call sendRedirect in your handler when      using this interceptor. If you need to do external redirects then      you will either need to forward the mapping parameter manually or      write a different interceptor to handle this for you.        20.6&nbsp;Views and resolving them        \n\r\n\rAs mentioned previously, Spring Portlet MVC directly reuses all    the view technologies from Spring Web MVC. This includes not only the    various View implementations themselves,    but also the ViewResolver implementations.    For more information, refer to Chapter&nbsp;18, View technologies and    Section&nbsp;17.5, &#8220;Resolving views&#8221; respectively.    \n\r\n\rA few items on using the existing View and    ViewResolver implementations  are worth mentioning:    \n\r\n\r\n\rMost portals expect the result of rendering a      portlet to be an HTML fragment. So, things like JSP/JSTL, Velocity,      FreeMarker, and XSLT all make sense. But it is unlikely that views      that return other document types will make any sense in a portlet      context.\n\r\n\r\n\rThere is no such thing as an HTTP redirect from      within a portlet (the sendRedirect(..) method of      ActionResponse cannot      be used to stay within the portal). So, RedirectView      and use of the \'redirect:\' prefix will      not work correctly from within Portlet MVC.\n\r\n\r\n\rIt may be possible to use the \'forward:\' prefix from      within Portlet MVC. However, remember that since you are in a      portlet, you have no idea what the current URL looks like. This      means you cannot use a relative URL to access other resources in      your web application and that you will have to use an absolute      URL.\n\r    \n\r\n\rAlso, for JSP development, the new Spring Taglib and the new    Spring Form Taglib both work in portlet views in exactly the same way    that they work in servlet views.    20.7&nbsp;Multipart (file upload) support        \n\r\n\rSpring Portlet MVC has built-in multipart support to handle file    uploads in portlet applications, just like Web MVC does. The design for    the multipart support is done with pluggable    PortletMultipartResolver objects, defined    in the org.springframework.web.portlet.multipart    package. Spring provides a PortletMultipartResolver    for use with    Commons FileUpload.    How uploading files is supported will be described in the rest of this section.    \n\r\n\rBy default, no multipart handling will be done by Spring Portlet    MVC, as some developers will want to handle multiparts themselves. You    will have to enable it yourself by adding a multipart resolver to the    web application\'s context. After you have done that,    DispatcherPortlet will inspect each request to    see if it contains a multipart. If no multipart is found, the request    will continue as expected. However, if a multipart is found in the    request, the PortletMultipartResolver    that has been declared in your context will be used. After that, the    multipart attribute in your request will be treated like any other    attribute.    Note      \n\r\n\rAny configured PortletMultipartResolver      bean must have the following id (or name):      \"portletMultipartResolver\". If you have defined your      PortletMultipartResolver with any other name,      then the DispatcherPortlet will not      find your PortletMultipartResolver, and      consequently no multipart support will be in effect.        20.7.1&nbsp;Using the PortletMultipartResolver            \n\r\n\rThe following example shows how to use the      CommonsPortletMultipartResolver:      &lt;bean id=\"portletMultipartResolver\"        class=\"org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver\"&gt;    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;    &lt;property name=\"maxUploadSize\" value=\"100000\"/&gt;&lt;/bean&gt;      \n\r\n\rOf course you also need to put the appropriate jars in your      classpath for the multipart resolver to work. In the case of the      CommonsMultipartResolver, you need to use      commons-fileupload.jar. Be sure to use at least      version 1.1 of Commons FileUpload as previous versions do not      support JSR-168 Portlet applications.      \n\r\n\rNow that you have seen how to set Portlet MVC up to handle      multipart requests, let\'s talk about how to actually use it. When      DispatcherPortlet detects a multipart      request, it activates the resolver that has been declared in your      context and hands over the request. What the resolver then does is      wrap the current ActionRequest in a      MultipartActionRequest that has      support for multipart file uploads. Using the      MultipartActionRequest you can get      information about the multiparts contained by this request and      actually get access to the multipart files themselves in your      controllers.      \n\r\n\rNote that you can only receive multipart file uploads as part      of an ActionRequest, not as part of a      RenderRequest.        20.7.2&nbsp;Handling a file upload in a form            \n\r\n\rAfter the      PortletMultipartResolver has finished      doing its job, the request will be processed like any other. To use      the PortletMultipartResolver, create      a form with an upload field (see example below),      then let Spring bind the file onto your form (backing object). To      actually let the user upload a file, we have to create a (JSP/HTML)      form:      &lt;h1&gt;Please upload a file&lt;/h1&gt;&lt;form method=\"post\" action=\"&lt;portlet:actionURL/&gt;\" enctype=\"multipart/form-data\"&gt;    &lt;input type=\"file\" name=\"file\"/&gt;    &lt;input type=\"submit\"/&gt;&lt;/form&gt;      \n\r\n\rAs you can see, we\'ve created a field named &#8220;file&#8221; that matches the      property of the bean that holds the byte[] array.      Furthermore we\'ve added the encoding attribute      (enctype=\"multipart/form-data\"), which is      necessary to let the browser know how to encode the multipart fields      (do not forget this!).      \n\r\n\rJust as with any other property that\'s not automagically      convertible to a string or primitive type, to be able to put binary      data in your objects you have to register a custom editor with the      PortletRequestDataBinder. There are a couple      of editors available for handling files and setting the results on      an object. There\'s a      StringMultipartFileEditor capable of      converting files to Strings (using a user-defined character set), and      there is a ByteArrayMultipartFileEditor which      converts files to byte arrays. They function analogous to the      CustomDateEditor.      \n\r\n\rSo, to be able to upload files using a form, declare the      resolver, a mapping to a controller that will process the bean, and      the controller itself.      &lt;bean id=\"portletMultipartResolver\"        class=\"org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver\"/&gt;&lt;bean class=\"org.springframework.web.portlet.handler.PortletModeHandlerMapping\"&gt;    &lt;property name=\"portletModeMap\"&gt;        &lt;map&gt;            &lt;entry key=\"view\" value-ref=\"fileUploadController\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"fileUploadController\" class=\"examples.FileUploadController\"&gt;    &lt;property name=\"commandClass\" value=\"examples.FileUploadBean\"/&gt;    &lt;property name=\"formView\" value=\"fileuploadform\"/&gt;    &lt;property name=\"successView\" value=\"confirmation\"/&gt;&lt;/bean&gt;      \n\r\n\rAfter that, create the controller and the actual class to hold      the file property.      public class FileUploadController extends SimpleFormController {    public void onSubmitAction(ActionRequest request, ActionResponse response,            Object command, BindException errors) throws Exception {        // cast the bean        FileUploadBean bean = (FileUploadBean) command;        // let\'s see if there\'s content there        byte[] file = bean.getFile();        if (file == null) {            // hmm, that\'s strange, the user did not upload anything        }        // do something with the file here    }    protected void initBinder(            PortletRequest request, PortletRequestDataBinder binder) throws Exception {        // to actually be able to convert Multipart instance to byte[]        // we have to register a custom editor        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());        // now Spring knows how to handle multipart object and convert    }}public class FileUploadBean {    private byte[] file;    public void setFile(byte[] file) {        this.file = file;    }    public byte[] getFile() {        return file;    }}      \n\r\n\rAs you can see, the FileUploadBean has      a property of type byte[] that holds the file. The      controller registers a custom editor to let Spring know how to      actually convert the multipart objects the resolver has found to      properties specified by the bean. In this example, nothing is done      with the byte[] property of the bean itself, but      in practice you can do whatever you want (save it in a database,      mail it to somebody, etc).      \n\r\n\rAn equivalent example in which a file is bound straight to a      String-typed property on a form backing object might look like      this:      public class FileUploadController extends SimpleFormController {    public void onSubmitAction(ActionRequest request, ActionResponse response,            Object command, BindException errors) throws Exception {        // cast the bean        FileUploadBean bean = (FileUploadBean) command;        // let\'s see if there\'s content there        String file = bean.getFile();        if (file == null) {            // hmm, that\'s strange, the user did not upload anything        }        // do something with the file here    }    protected void initBinder(        PortletRequest request, PortletRequestDataBinder binder) throws Exception {        // to actually be able to convert Multipart instance to a String        // we have to register a custom editor        binder.registerCustomEditor(String.class,            new StringMultipartFileEditor());        // now Spring knows how to handle multipart objects and convert    }}public class FileUploadBean {    private String file;    public void setFile(String file) {        this.file = file;    }    public String getFile() {        return file;    }}      \n\r\n\rOf course, this last example only makes (logical) sense in the      context of uploading a plain text file (it wouldn\'t work so well in      the case of uploading an image file).      \n\r\n\rThe third (and final) option is where one binds directly to a      MultipartFile property declared on      the (form backing) object\'s class. In this case one does not need to      register any custom property editor because there is no type      conversion to be performed.      public class FileUploadController extends SimpleFormController {    public void onSubmitAction(ActionRequest request, ActionResponse response,            Object command, BindException errors) throws Exception {        // cast the bean        FileUploadBean bean = (FileUploadBean) command;        // let\'s see if there\'s content there        MultipartFile file = bean.getFile();        if (file == null) {            // hmm, that\'s strange, the user did not upload anything        }        // do something with the file here    }}public class FileUploadBean {    private MultipartFile file;    public void setFile(MultipartFile file) {        this.file = file;    }    public MultipartFile getFile() {        return file;    }}        20.8&nbsp;Handling exceptions        \n\r\n\rJust like Servlet MVC, Portlet MVC provides    HandlerExceptionResolvers to ease the    pain of unexpected exceptions that occur while your request is being    processed by a handler that matched the request. Portlet MVC also    provides a portlet-specific, concrete    SimpleMappingExceptionResolver that enables you    to take the class name of any exception that might be thrown and map it    to a view name.    20.9&nbsp;Annotation-based controller configuration        \n\r\n\rSpring 2.5 introduced an annotation-based programming model for MVC    controllers, using annotations such as    @RequestMapping,    @RequestParam,    @ModelAttribute, etc. This annotation    support is available for both Servlet MVC and Portlet MVC. Controllers    implemented in this style do not have to extend specific base classes or    implement specific interfaces. Furthermore, they do not usually have    direct dependencies on Servlet or Portlet API\'s, although they can easily    get access to Servlet or Portlet facilities if desired.            \n\r\n\rThe following sections document these annotations and how they are    most commonly used in a Portlet environment.    20.9.1&nbsp;Setting up the dispatcher for annotation support            \n\r\n\r@RequestMapping will only be processed      if a corresponding HandlerMapping (for type level annotations)      and/or HandlerAdapter (for method level annotations) is      present in the dispatcher. This is the case by default in both      DispatcherServlet and DispatcherPortlet.      \n\r\n\rHowever, if you are defining custom HandlerMappings or      HandlerAdapters, then you need to make sure that a      corresponding custom DefaultAnnotationHandlerMapping      and/or AnnotationMethodHandlerAdapter is defined as well      - provided that you intend to use @RequestMapping.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean class=\"org.springframework.web.portlet.mvc.annotation.DefaultAnnotationHandlerMapping\"/&gt;    &lt;bean class=\"org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter\"/&gt;    // ... (controller bean definitions) ...&lt;/beans&gt;      \n\r\n\rDefining a DefaultAnnotationHandlerMapping      and/or AnnotationMethodHandlerAdapter explicitly      also makes sense if you would like to customize the mapping strategy, e.g.      specifying a custom WebBindingInitializer (see below).        20.9.2&nbsp;Defining a controller with      @Controller            \n\r\n\rThe @Controller annotation indicates      that a particular class serves the role of a controller.      There is no need to extend any controller base class or reference the      Portlet API. You are of course still able to reference Portlet-specific      features if you need to.      \n\r\n\rThe basic purpose of the @Controller      annotation is to act as a stereotype for the annotated class, indicating      its role. The dispatcher will scan such annotated classes for mapped      methods, detecting @RequestMapping      annotations (see the next section).      \n\r\n\rAnnotated controller beans may be defined explicitly,      using a standard Spring bean definition in the dispatcher\'s context.      However, the @Controller stereotype also      allows for autodetection, aligned with Spring 2.5\'s general support for      detecting component classes in the classpath and auto-registering bean      definitions for them.      \n\r\n\rTo enable autodetection of such annotated controllers, you have to add      component scanning to your configuration. This is easily achieved by using      the spring-context schema as shown in the following      XML snippet:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:p=\"http://www.springframework.org/schema/p\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"org.springframework.samples.petportal.portlet\"/&gt;    // ...&lt;/beans&gt;        20.9.3&nbsp;Mapping requests with      @RequestMapping            \n\r\n\rThe @RequestMapping annotation is used      to map portlet modes like \'VIEW\'/\'EDIT\' onto an entire class or a particular      handler method. Typically the type-level annotation maps a specific mode      (or mode plus parameter condition) onto a form controller, with additional      method-level annotations \'narrowing\' the primary mapping for specific      portlet request parameters.      Tip        \n\r\n\r@RequestMapping at the type        level may be used for plain implementations of the        Controller interface as well.        In this case, the request processing code would follow the        traditional handle(Action|Render)Request signature,        while the controller\'s mapping would be expressed through an        @RequestMapping annotation.        This works for pre-built Controller        base classes, such as SimpleFormController,        too.        \n\r\n\rIn the following discussion, we\'ll focus on controllers        that are based on annotated handler methods.            \n\r\n\rThe following is an example of a form controller from the      PetPortal sample application using this annotation:      @Controller@RequestMapping(\"EDIT\")@SessionAttributes(\"site\")public class PetSitesEditController {    private Properties petSites;    public void setPetSites(Properties petSites) {        this.petSites = petSites;    }    @ModelAttribute(\"petSites\")    public Properties getPetSites() {        return this.petSites;    }    @RequestMapping  // default (action=list)    public String showPetSites() {        return \"petSitesEdit\";    }    @RequestMapping(params = \"action=add\")  // render phase    public String showSiteForm(Model model) {        // Used for the initial form as well as for redisplaying with errors.        if (!model.containsAttribute(\"site\")) {            model.addAttribute(\"site\", new PetSite());        }        return \"petSitesAdd\";    }    @RequestMapping(params = \"action=add\")  // action phase    public void populateSite(            @ModelAttribute(\"site\") PetSite petSite, BindingResult result,            SessionStatus status, ActionResponse response) {        new PetSiteValidator().validate(petSite, result);        if (!result.hasErrors()) {            this.petSites.put(petSite.getName(), petSite.getUrl());            status.setComplete();            response.setRenderParameter(\"action\", \"list\");        }    }    @RequestMapping(params = \"action=delete\")    public void removeSite(@RequestParam(\"site\") String site, ActionResponse response) {        this.petSites.remove(site);        response.setRenderParameter(\"action\", \"list\");    }}        20.9.4&nbsp;Supported handler method arguments            \n\r\n\rHandler methods which are annotated with      @RequestMapping are allowed to have very flexible      signatures. They may have arguments of the following types, in arbitrary      order (except for validation results, which need to follow right after      the corresponding command object, if desired):      \n\r          \n\r\n\rRequest and/or response objects (Portlet API).          You may choose any specific request/response type, e.g. PortletRequest /          ActionRequest / RenderRequest. An explicitly declared action/render          argument is also used for mapping specific request types onto a handler          method (in case of no other information given that differentiates          between action and render requests).        \n\r          \n\r\n\rSession object (Portlet API): of type PortletSession. An argument          of this type will enforce the presence of a corresponding session.          As a consequence, such an argument will never be null.        \n\r          \n\r\n\rorg.springframework.web.context.request.WebRequest          or org.springframework.web.context.request.NativeWebRequest.          Allows for generic request parameter access as well as request/session          attribute access, without ties to the native Servlet/Portlet API.        \n\r          \n\r\n\rjava.util.Locale for the current request          locale (the portal locale in a Portlet environment).        \n\r          \n\r\n\rjava.io.InputStream /          java.io.Reader for access to the request\'s content.          This will be the raw InputStream/Reader as exposed by the Portlet API.        \n\r          \n\r\n\rjava.io.OutputStream /          java.io.Writer for generating the response\'s content.          This will be the raw OutputStream/Writer as exposed by the Portlet API.        \n\r          \n\r\n\r@RequestParam annotated parameters          for access to specific Portlet request parameters. Parameter values          will be converted to the declared method argument type.        \n\r          \n\r\n\rjava.util.Map /          org.springframework.ui.Model /          org.springframework.ui.ModelMap for          enriching the implicit model that will be exposed to the web view.        \n\r          \n\r\n\rCommand/form objects to bind parameters to: as bean          properties or fields, with customizable type conversion, depending          on @InitBinder methods and/or the          HandlerAdapter configuration - see the          \"webBindingInitializer\" property on          AnnotationMethodHandlerAdapter. Such          command objects along with their validation results will be          exposed as model attributes, by default using the non-qualified          command class name in property notation (e.g. \"orderAddress\" for          type \"mypackage.OrderAddress\"). Specify a parameter-level          ModelAttribute annotation for declaring a          specific model attribute name.        \n\r          \n\r\n\rorg.springframework.validation.Errors /          org.springframework.validation.BindingResult          validation results for a preceding command/form object (the          immediate preceding argument).        \n\r          \n\r\n\rorg.springframework.web.bind.support.SessionStatus          status handle for marking form processing as complete (triggering          the cleanup of session attributes that have been indicated by the          @SessionAttributes annotation at the          handler type level).        \n\r      \n\r\n\rThe following return types are supported for handler methods:      \n\r          \n\r\n\rA ModelAndView object, with the model implicitly          enriched with command objects and the results of @ModelAttribute          annotated reference data accessor methods.        \n\r          \n\r\n\rA Model object, with the view name implicitly          determined through a RequestToViewNameTranslator          and the model implicitly enriched with command objects and the results of          @ModelAttribute annotated reference data accessor methods.        \n\r          \n\r\n\rA Map object for exposing a model, with the view name          implicitly determined through a RequestToViewNameTranslator          and the model implicitly enriched with command objects and the results of          @ModelAttribute annotated reference data accessor methods.        \n\r          \n\r\n\rA View object, with the model implicitly          determined through command objects and @ModelAttribute          annotated reference data accessor methods. The handler method may also          programmatically enrich the model by declaring a Model          argument (see above).        \n\r          \n\r\n\rA String value which is interpreted as view name,          with the model implicitly determined through command objects and          @ModelAttribute annotated reference data accessor methods.          The handler method may also programmatically enrich the model by declaring a          Model argument (see above).        \n\r          \n\r\n\rvoid if the method handles the response itself          (e.g. by writing the response content directly).        \n\r          \n\r\n\rAny other return type will be considered a single model attribute          to be exposed to the view, using the attribute name specified through          @ModelAttribute at the method level (or the default          attribute name based on the return type\'s class name otherwise). The model          will be implicitly enriched with command objects and the results of          @ModelAttribute annotated reference data accessor methods.        \n\r        20.9.5&nbsp;Binding request parameters to method parameters with      @RequestParam            \n\r\n\rThe @RequestParam annotation is used to      bind request parameters to a method parameter in your controller.      \n\r\n\rThe following code snippet from the PetPortal sample application      shows the usage:      @Controller@RequestMapping(\"EDIT\")@SessionAttributes(\"site\")public class PetSitesEditController {    // ...    public void removeSite(@RequestParam(\"site\") String site, ActionResponse response) {        this.petSites.remove(site);        response.setRenderParameter(\"action\", \"list\");    }    // ...}      \n\r\n\rParameters using this annotation are required by default, but you      can specify that a parameter is optional by setting      @RequestParam\'s      required attribute to false (e.g.,      @RequestParam(value=\"id\", required=false)).        20.9.6&nbsp;Providing a link to data from the model with      @ModelAttribute            \n\r\n\r@ModelAttribute has two usage scenarios in      controllers. When placed on a method parameter,      @ModelAttribute is used to map a model attribute      to the specific, annotated method parameter (see the      populateSite() method below). This is how the      controller gets a reference to the object holding the data entered in      the form. In addition, the parameter can be declared as the specific      type of the form backing object rather than as a generic      java.lang.Object, thus increasing type      safety.      \n\r\n\r@ModelAttribute is also used at the method      level to provide reference data for the model (see      the getPetSites() method below). For this usage      the method signature can contain the same types as documented above for      the @RequestMapping annotation.      \n\r\n\rNote: @ModelAttribute      annotated methods will be executed before the      chosen @RequestMapping annotated handler method.      They effectively pre-populate the implicit model with specific attributes,      often loaded from a database. Such an attribute can then already be      accessed through @ModelAttribute annotated      handler method parameters in the chosen handler method, potentially      with binding and validation applied to it.      \n\r\n\rThe following code snippet shows these two usages of this      annotation:      @Controller@RequestMapping(\"EDIT\")@SessionAttributes(\"site\")public class PetSitesEditController {    // ...    @ModelAttribute(\"petSites\")    public Properties getPetSites() {        return this.petSites;    }    @RequestMapping(params = \"action=add\")  // action phase    public void populateSite(            @ModelAttribute(\"site\") PetSite petSite, BindingResult result,            SessionStatus status, ActionResponse response) {        new PetSiteValidator().validate(petSite, result);        if (!result.hasErrors()) {            this.petSites.put(petSite.getName(), petSite.getUrl());            status.setComplete();            response.setRenderParameter(\"action\", \"list\");        }    }}        20.9.7&nbsp;Specifying attributes to store in a Session with      @SessionAttributes            \n\r\n\rThe type-level @SessionAttributes      annotation declares session attributes used by a specific handler.      This will typically list the names of model attributes or types of      model attributes which should be      transparently stored in the session or some conversational storage,      serving as form-backing beans between subsequent requests.      \n\r\n\rThe following code snippet shows the usage of this      annotation:      @Controller@RequestMapping(\"EDIT\")@SessionAttributes(\"site\")public class PetSitesEditController {  // ...}        20.9.8&nbsp;Customizing WebDataBinder      initialization            \n\r\n\rTo customize request parameter binding with PropertyEditors, etc.      via Spring\'s WebDataBinder, you can either use      @InitBinder-annotated methods within your      controller or externalize your configuration by providing a custom      WebBindingInitializer.      Customizing data binding with        @InitBinder                \n\r\n\rAnnotating controller methods with        @InitBinder allows you to configure web        data binding directly within your controller class.        @InitBinder identifies methods which        initialize the WebDataBinder which will be used        for populating command and form object arguments of annotated handler        methods.        \n\r\n\rSuch init-binder methods support all arguments that        @RequestMapping supports, except for        command/form objects and corresponding validation result objects.        Init-binder methods must not have a return value. Thus, they are        usually declared as void. Typical arguments include        WebDataBinder in combination with        WebRequest or        java.util.Locale, allowing code to register        context-specific editors.        \n\r\n\rThe following example demonstrates the use of        @InitBinder for configuring a        CustomDateEditor for all        java.util.Date form properties.        @Controllerpublic class MyFormController {    @InitBinder    public void initBinder(WebDataBinder binder) {        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");        dateFormat.setLenient(false);        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));    }    // ...}            Configuring a custom        WebBindingInitializer                \n\r\n\rTo externalize data binding initialization, you can provide a        custom implementation of the        WebBindingInitializer interface, which        you then enable by supplying a custom bean configuration for an        AnnotationMethodHandlerAdapter, thus overriding        the default configuration.              20.10&nbsp;Portlet application deployment        \n\r\n\rThe process of deploying a Spring Portlet MVC application is no    different than deploying any JSR-168 Portlet application. However, this    area is confusing enough in general that it is worth talking about here    briefly.    \n\r\n\rGenerally, the portal/portlet container runs in one webapp in your    servlet container and your portlets run in another webapp in your    servlet container. In order for the portlet container webapp to make    calls into your portlet webapp it must make cross-context calls to a    well-known servlet that provides access to the portlet services defined    in your portlet.xml file.    \n\r\n\rThe JSR-168 specification does not specify exactly how this should    happen, so each portlet container has its own mechanism for this, which    usually involves some kind of &#8220;deployment process&#8221; that makes changes to    the portlet webapp itself and then registers the portlets within the    portlet container.    \n\r\n\rAt a minimum, the web.xml file in your portlet    webapp is modified to inject the well-known servlet that the portlet    container will call. In some cases a single servlet will service all    portlets in the webapp, in other cases there will be an instance of the    servlet for each portlet.    \n\r\n\rSome portlet containers will also inject libraries and/or    configuration files into the webapp as well. The portlet container must    also make its implementation of the Portlet JSP Tag Library available to    your webapp.    \n\r\n\rThe bottom line is that it is important to understand the    deployment needs of your target portal and make sure they are met    (usually by following the automated deployment process it provides).    Be sure to carefully review the documentation from your portal for this    process.    \n\r\n\rOnce you have deployed your portlet, review the resulting    web.xml file for sanity. Some older portals have    been known to corrupt the definition of the    ViewRendererServlet, thus breaking the rendering    of your portlets.  Prev&nbsp;Up&nbsp;Next19.&nbsp;Integrating with other web frameworks&nbsp;Home&nbsp;Part&nbsp;VI.&nbsp;Integration","20. Portlet MVC Framework","scr\\portlet.html","         21.&nbsp;Remoting and web services using SpringPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next21.&nbsp;Remoting and web services using Spring    21.1&nbsp;Introduction        \n\r\n\rSpring features integration classes for remoting support using    various technologies. The remoting support eases the development of    remote-enabled services, implemented by your usual (Spring) POJOs.    Currently, Spring supports the following remoting technologies: \n\r          \n\r\n\rRemote Method Invocation (RMI). Through          the use of the RmiProxyFactoryBean and the          RmiServiceExporter Spring supports both          traditional RMI (with java.rmi.Remote          interfaces and          java.rmi.RemoteException) and          transparent remoting via RMI invokers (with any Java          interface).        \n\r          \n\r\n\rSpring\'s HTTP invoker. Spring provides a          special remoting strategy which allows for Java serialization via          HTTP, supporting any Java interface (just like the RMI invoker). The          corresponding support classes are          HttpInvokerProxyFactoryBean and          HttpInvokerServiceExporter.        \n\r          \n\r\n\rHessian. By using Spring\'s          HessianProxyFactoryBean and the          HessianServiceExporter you can transparently          expose your services using the lightweight binary HTTP-based          protocol provided by Caucho.        \n\r          \n\r\n\rBurlap. Burlap is Caucho\'s XML-based          alternative to Hessian. Spring provides support classes such as          BurlapProxyFactoryBean and          BurlapServiceExporter.        \n\r          \n\r\n\rJAX-RPC. Spring provides remoting support          for web services via JAX-RPC (J2EE 1.4\'s web service API).        \n\r          \n\r\n\rJAX-WS. Spring provides remoting support          for web services via JAX-WS (the successor of JAX-RPC, as introduced          in Java EE 5 and Java 6).        \n\r          \n\r\n\rJMS. Remoting using JMS as the underlying          protocol is supported via the          JmsInvokerServiceExporter and          JmsInvokerProxyFactoryBean classes.        \n\r    \n\r\n\rWhile discussing the remoting capabilities of Spring, we\'ll use the    following domain model and corresponding services:    public class Account implements Serializable{    private String name;    public String getName(){        return name;    }    public void setName(String name) {      this.name = name;    }}    public interface AccountService {    public void insertAccount(Account account);    public List&lt;Account&gt; getAccounts(String name);}    public interface RemoteAccountService extends Remote {    public void insertAccount(Account account) throws RemoteException;    public List&lt;Account&gt; getAccounts(String name) throws RemoteException;}    // the implementation doing nothing at the momentpublic class AccountServiceImpl implements AccountService {    public void insertAccount(Account acc) {        // do something...    }    public List&lt;Account&gt; getAccounts(String name) {        // do something...    }}    \n\r\n\rWe will start exposing the service to a remote client by using RMI    and talk a bit about the drawbacks of using RMI. We\'ll then continue to    show an example using Hessian as the protocol.    21.2&nbsp;Exposing services using RMI        \n\r\n\rUsing Spring\'s support for RMI, you can transparently expose your    services through the RMI infrastructure. After having this set up, you    basically have a configuration similar to remote EJBs, except for the fact    that there is no standard support for security context propagation or    remote transaction propagation. Spring does provide hooks for such    additional invocation context when using the RMI invoker, so you can for    example plug in security frameworks or custom security credentials    here.    21.2.1&nbsp;Exporting the service using the      RmiServiceExporter            \n\r\n\rUsing the RmiServiceExporter, we can expose      the interface of our AccountService object as RMI object. The interface      can be accessed by using RmiProxyFactoryBean, or      via plain RMI in case of a traditional RMI service. The      RmiServiceExporter explicitly supports the      exposing of any non-RMI services via RMI invokers.      \n\r\n\rOf course, we first have to set up our service in the Spring      container:      &lt;bean id=\"accountService\" class=\"example.AccountServiceImpl\"&gt;    &lt;!-- any additional properties, maybe a DAO? --&gt;&lt;/bean&gt;      \n\r\n\rNext we\'ll have to expose our service using the      RmiServiceExporter:      &lt;bean class=\"org.springframework.remoting.rmi.RmiServiceExporter\"&gt;    &lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;    &lt;property name=\"serviceName\" value=\"AccountService\"/&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;    &lt;!-- defaults to 1099 --&gt;    &lt;property name=\"registryPort\" value=\"1199\"/&gt;&lt;/bean&gt;      \n\r\n\rAs you can see, we\'re overriding the port for the RMI registry.      Often, your application server also maintains an RMI registry and it is      wise to not interfere with that one. Furthermore, the service name is      used to bind the service under. So right now, the service will be bound      at \'rmi://HOST:1199/AccountService\'. We\'ll use the      URL later on to link in the service at the client side.      Note        \n\r\n\rThe servicePort property has been omitted (it        defaults to 0). This means that an anonymous port will be used to        communicate with the service.              21.2.2&nbsp;Linking in the service at the client            \n\r\n\rOur client is a simple object using the      AccountService to manage accounts:      public class SimpleObject {    private AccountService accountService;    public void setAccountService(AccountService accountService) {        this.accountService = accountService;    }    // additional methods using the accountService}      \n\r\n\rTo link in the service on the client, we\'ll create a separate      Spring container, containing the simple object and the service linking      configuration bits:      &lt;bean class=\"example.SimpleObject\"&gt;    &lt;property name=\"accountService\" ref=\"accountService\"/&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" class=\"org.springframework.remoting.rmi.RmiProxyFactoryBean\"&gt;    &lt;property name=\"serviceUrl\" value=\"rmi://HOST:1199/AccountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rThat\'s all we need to do to support the remote account service on      the client. Spring will transparently create an invoker and remotely      enable the account service through the      RmiServiceExporter. At the client we\'re linking      it in using the RmiProxyFactoryBean.        21.3&nbsp;Using Hessian or Burlap to remotely call services via HTTP        \n\r\n\rHessian offers a binary HTTP-based remoting protocol. It is    developed by Caucho and more information about Hessian itself can be found    at http://www.caucho.com.    21.3.1&nbsp;Wiring up the DispatcherServlet for      Hessian and co.            \n\r\n\rHessian communicates via HTTP and does so using a custom servlet.      Using Spring\'s DispatcherServlet principles, as      known from Spring Web MVC usage, you can easily wire up such a servlet      exposing your services. First we\'ll have to create a new servlet in your      application (this is an excerpt from      \'web.xml\'):      &lt;servlet&gt;    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;    &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;      \n\r\n\rYou\'re probably familiar with Spring\'s      DispatcherServlet principles and if so, you know      that now you\'ll have to create a Spring container configuration resource      named \'remoting-servlet.xml\' (after the name of      your servlet) in the \'WEB-INF\'      directory. The application context will be used in the next      section.      \n\r\n\rAlternatively, consider the use of Spring\'s simpler      HttpRequestHandlerServlet. This allows you to      embed the remote exporter definitions in your root application context      (by default in \'WEB-INF/applicationContext.xml\'),      with individual servlet definitions pointing to specific exporter beans.      Each servlet name needs to match the bean name of its target exporter in      this case.        21.3.2&nbsp;Exposing your beans by using the      HessianServiceExporter            \n\r\n\rIn the newly created application context called      remoting-servlet.xml, we\'ll create a      HessianServiceExporter exporting your      services:      &lt;bean id=\"accountService\" class=\"example.AccountServiceImpl\"&gt;    &lt;!-- any additional properties, maybe a DAO? --&gt;&lt;/bean&gt;&lt;bean name=\"/AccountService\" class=\"org.springframework.remoting.caucho.HessianServiceExporter\"&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rNow we\'re ready to link in the service at the client. No explicit      handler mapping is specified, mapping request URLs onto services, so      BeanNameUrlHandlerMapping will be used: Hence,      the service will be exported at the URL indicated through its bean name      within the containing DispatcherServlet\'s mapping      (as defined above):      \'http://HOST:8080/remoting/AccountService\'.      \n\r\n\rAlternatively, create a      HessianServiceExporter in your root application      context (e.g. in      \'WEB-INF/applicationContext.xml\'):      &lt;bean name=\"accountExporter\" class=\"org.springframework.remoting.caucho.HessianServiceExporter\"&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rIn the latter case, define a corresponding servlet for this      exporter in \'web.xml\', with the same end result:      The exporter getting mapped to the request path      /remoting/AccountService. Note that the servlet name      needs to match the bean name of the target exporter.      &lt;servlet&gt;    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;        21.3.3&nbsp;Linking in the service on the client            \n\r\n\rUsing the HessianProxyFactoryBean we can      link in the service at the client. The same principles apply as with the      RMI example. We\'ll create a separate bean factory or application context      and mention the following beans where the      SimpleObject is using the      AccountService to manage accounts:      &lt;bean class=\"example.SimpleObject\"&gt;    &lt;property name=\"accountService\" ref=\"accountService\"/&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" class=\"org.springframework.remoting.caucho.HessianProxyFactoryBean\"&gt;    &lt;property name=\"serviceUrl\" value=\"http://remotehost:8080/remoting/AccountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;        21.3.4&nbsp;Using Burlap            \n\r\n\rWe won\'t discuss Burlap, the XML-based equivalent of Hessian, in      detail here, since it is configured and set up in exactly the same way      as the Hessian variant explained above. Just replace the word      Hessian with Burlap and you\'re all      set to go.        21.3.5&nbsp;Applying HTTP basic authentication to a service exposed through      Hessian or Burlap            \n\r\n\rOne of the advantages of Hessian and Burlap is that we can easily      apply HTTP basic authentication, because both protocols are HTTP-based.      Your normal HTTP server security mechanism can easily be applied through      using the web.xml security features, for example.      Usually, you don\'t use per-user security credentials here, but rather      shared credentials defined at the      Hessian/BurlapProxyFactoryBean level (similar to a      JDBC DataSource).      &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt;    &lt;property name=\"interceptors\" ref=\"authorizationInterceptor\"/&gt;&lt;/bean&gt;&lt;bean id=\"authorizationInterceptor\"      class=\"org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor\"&gt;    &lt;property name=\"authorizedRoles\" value=\"administrator,operator\"/&gt;&lt;/bean&gt;      \n\r\n\rThis is an example where we explicitly mention the      BeanNameUrlHandlerMapping and set an interceptor      allowing only administrators and operators to call the beans mentioned      in this application context.      Note        \n\r\n\rOf course, this example doesn\'t show a flexible kind of security        infrastructure. For more options as far as security is concerned, have        a look at the Spring Security project at http://static.springsource.org/spring-security/site/.              21.4&nbsp;Exposing services using HTTP invokers        \n\r\n\rAs opposed to Burlap and Hessian, which are both lightweight    protocols using their own slim serialization mechanisms, Spring HTTP    invokers use the standard Java serialization mechanism to expose services    through HTTP. This has a huge advantage if your arguments and return types    are complex types that cannot be serialized using the serialization    mechanisms Hessian and Burlap use (refer to the next section for more    considerations when choosing a remoting technology).    \n\r\n\rUnder the hood, Spring uses either the standard facilities provided    by J2SE to perform HTTP calls or Commons    HttpClient. Use the latter if you need more    advanced and easy-to-use functionality. Refer to jakarta.apache.org/commons/httpclient    for more info.    21.4.1&nbsp;Exposing the service object            \n\r\n\rSetting up the HTTP invoker infrastructure for a service object      resembles closely the way you would do the same using Hessian or Burlap.      Just as Hessian support provides the      HessianServiceExporter, Spring\'s HttpInvoker      support provides the      org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter.      \n\r\n\rTo expose the AccountService (mentioned above)      within a Spring Web MVC DispatcherServlet, the      following configuration needs to be in place in the dispatcher\'s      application context:      &lt;bean name=\"/AccountService\" class=\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\"&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rSuch an exporter definition will be exposed through the      DispatcherServlet\'s standard mapping facilities,      as explained in the section on Hessian.      \n\r\n\rAlternatively, create an      HttpInvokerServiceExporter in your root      application context (e.g. in      \'WEB-INF/applicationContext.xml\'):      &lt;bean name=\"accountExporter\" class=\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\"&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rIn addition, define a corresponding servlet for this exporter in      \'web.xml\', with the servlet name matching the bean      name of the target exporter:      &lt;servlet&gt;    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;      \n\r\n\rIf you are running outside of a servlet container and are using      Sun\'s Java 6, then you can use the built-in HTTP server implementation.      You can configure the SimpleHttpServerFactoryBean together with a      SimpleHttpInvokerServiceExporter as is shown in this example:      &lt;bean name=\"accountExporter\"    class=\"org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter\"&gt;    &lt;property name=\"service\" ref=\"accountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;&lt;bean id=\"httpServer\"        class=\"org.springframework.remoting.support.SimpleHttpServerFactoryBean\"&gt;    &lt;property name=\"contexts\"&gt;        &lt;util:map&gt;            &lt;entry key=\"/remoting/AccountService\" value-ref=\"accountExporter\"/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=\"port\" value=\"8080\" /&gt;&lt;/bean&gt;        21.4.2&nbsp;Linking in the service at the client            \n\r\n\rAgain, linking in the service from the client much resembles the      way you would do it when using Hessian or Burlap. Using a proxy, Spring      will be able to translate your calls to HTTP POST requests to the URL      pointing to the exported service.      &lt;bean id=\"httpInvokerProxy\" class=\"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean\"&gt;    &lt;property name=\"serviceUrl\" value=\"http://remotehost:8080/remoting/AccountService\"/&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;&lt;/bean&gt;      \n\r\n\rAs mentioned before, you can choose what HTTP client you want to      use. By default, the HttpInvokerProxy uses the      J2SE HTTP functionality, but you can also use the Commons      HttpClient by setting the      httpInvokerRequestExecutor property:      &lt;property name=\"httpInvokerRequestExecutor\"&gt;    &lt;bean class=\"org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor\"/&gt;&lt;/property&gt;        21.5&nbsp;Web services        \n\r\n\rSpring provides full support for standard Java web services    APIs:    \n\r        \n\r\n\rExposing web services using JAX-RPC      \n\r        \n\r\n\rAccessing web services using JAX-RPC      \n\r        \n\r\n\rExposing web services using JAX-WS      \n\r        \n\r\n\rAccessing web services using JAX-WS      \n\r    Note      \n\r\n\rWhy two standard Java web services APIs?      \n\r\n\rJAX-RPC 1.1 is the standard web service API in J2EE 1.4. As its      name indicates, it focuses on on RPC bindings, which became less and      less popular in the past couple of years. As a consequence, it has been      superseded by JAX-WS 2.0 in Java EE 5, being more flexible in terms of      bindings but also being heavily annotation-based. JAX-WS 2.1 is also      included in Java 6 (or more specifically, in Sun\'s JDK 1.6.0_04 and      above; previous Sun JDK 1.6.0 releases included JAX-WS 2.0), integrated      with the JDK\'s built-in HTTP server.      \n\r\n\rSpring can work with both standard Java web services APIs. On Java      EE 5 / Java 6, the obvious choice is JAX-WS. On J2EE 1.4 environments      that run on Java 5, you might have the option to plug in a JAX-WS      provider; check your Java EE server\'s documentation.        \n\r\n\rIn addition to stock support for JAX-RPC and JAX-WS in Spring Core,    the Spring portfolio also features Spring Web    Services, a solution for contract-first, document-driven web    services - highly recommended for building modern, future-proof web    services.    21.5.1&nbsp;Exposing servlet-based web services using JAX-RPC            \n\r\n\rSpring provides a convenience base class for JAX-RPC servlet      endpoint implementations -      ServletEndpointSupport. To expose our      AccountService we extend Spring\'s      ServletEndpointSupport class and implement our      business logic here, usually delegating the call to the business      layer.      /** * JAX-RPC compliant RemoteAccountService implementation that simply delegates * to the AccountService implementation in the root web application context. * * This wrapper class is necessary because JAX-RPC requires working with dedicated * endpoint classes. If an existing service needs to be exported, a wrapper that * extends ServletEndpointSupport for simple application context access is * the simplest JAX-RPC compliant way. * * This is the class registered with the server-side JAX-RPC implementation. * In the case of Axis, this happens in \"server-config.wsdd\" respectively via * deployment calls. The web service engine manages the lifecycle of instances * of this class: A Spring application context can just be accessed here. */import org.springframework.remoting.jaxrpc.ServletEndpointSupport;public class AccountServiceEndpoint extends ServletEndpointSupport implements RemoteAccountService {    private AccountService biz;    protected void onInit() {        this.biz = (AccountService) getWebApplicationContext().getBean(\"accountService\");    }    public void insertAccount(Account acc) throws RemoteException {        biz.insertAccount(acc);    }    public Account[] getAccounts(String name) throws RemoteException {        return biz.getAccounts(name);    }}      \n\r\n\rOur AccountServletEndpoint needs to run in      the same web application as the Spring context to allow for access to      Spring\'s facilities. In case of Axis, copy the      AxisServlet definition into your      \'web.xml\', and set up the endpoint in      \'server-config.wsdd\' (or use the deploy tool). See      the sample application JPetStore where the      OrderService is exposed as a web service      using Axis.        21.5.2&nbsp;Accessing web services using JAX-RPC            \n\r\n\rSpring provides two factory beans to create JAX-RPC web service      proxies, namely LocalJaxRpcServiceFactoryBean and      JaxRpcPortProxyFactoryBean. The former can only      return a JAX-RPC service class for us to work with. The latter is the      full-fledged version that can return a proxy that implements our      business service interface. In this example we use the latter to create      a proxy for the AccountService endpoint      we exposed in the previous section. You will see that Spring has great      support for web services requiring little coding efforts - most of the      setup is done in the Spring configuration file as usual:      &lt;bean id=\"accountWebService\" class=\"org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean\"&gt;    &lt;property name=\"serviceInterface\" value=\"example.RemoteAccountService\"/&gt;    &lt;property name=\"wsdlDocumentUrl\" value=\"http://localhost:8080/account/services/accountService?WSDL\"/&gt;    &lt;property name=\"namespaceUri\" value=\"http://localhost:8080/account/services/accountService\"/&gt;    &lt;property name=\"serviceName\" value=\"AccountService\"/&gt;    &lt;property name=\"portName\" value=\"AccountPort\"/&gt;&lt;/bean&gt;      \n\r\n\rWhere serviceInterface is our remote business      interface the clients will use. wsdlDocumentUrl is      the URL for the WSDL file. Spring needs this at startup time to create      the JAX-RPC Service. namespaceUri corresponds to the      targetNamespace in the .wsdl file. serviceName      corresponds to the service name in the .wsdl file.      portName corresponds to the port name in the .wsdl      file.      \n\r\n\rAccessing the web service is now very easy as we have a bean      factory for it that will expose it as      RemoteAccountService interface. We can wire this up      in Spring:      &lt;bean id=\"client\" class=\"example.AccountClientImpl\"&gt;    ...    &lt;property name=\"service\" ref=\"accountWebService\"/&gt;&lt;/bean&gt;      \n\r\n\rFrom the client code we can access the web service just as if it      was a normal class, except that it throws      RemoteException.      public class AccountClientImpl {    private RemoteAccountService service;    public void setService(RemoteAccountService service) {        this.service = service;    }    public void foo() {        try {            service.insertAccount(...);        }        catch (RemoteException ex) {            // ouch        }    }}      \n\r\n\rWe can get rid of the checked      RemoteException since Spring supports      automatic conversion to its corresponding unchecked      RemoteException. This requires that we      provide a non-RMI interface also. Our configuration is now:      &lt;bean id=\"accountWebService\" class=\"org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean\"&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;    &lt;property name=\"portInterface\" value=\"example.RemoteAccountService\"/&gt;    ...&lt;/bean&gt;      \n\r\n\rWhere serviceInterface is changed to our non      RMI interface. Our RMI interface is now defined using the property      portInterface. Our client code can now avoid handling      java.rmi.RemoteException:      public class AccountClientImpl {    private AccountService service;    public void setService(AccountService service) {        this.service = service;    }    public void foo() {        service.insertAccount(...);    }}      \n\r\n\rNote that you can also drop the \"portInterface\" part and specify a      plain business interface as \"serviceInterface\". In this case,      JaxRpcPortProxyFactoryBean will automatically      switch to the JAX-RPC \"Dynamic Invocation Interface\", performing dynamic      invocations without a fixed port stub. The advantage is that you don\'t      even need to have an RMI-compliant Java port interface around (e.g. in      case of a non-Java target web service); all you need is a matching      business interface. Check out      JaxRpcPortProxyFactoryBean\'s javadoc for details      on the runtime implications.        21.5.3&nbsp;Registering JAX-RPC Bean Mappings            \n\r\n\rTo transfer complex objects over the wire such as      Account we must register bean mappings on the      client side.      Note        \n\r\n\rOn the server side using Axis registering bean mappings is        usually done in the \'server-config.wsdd\'        file.            \n\r\n\rWe will use Axis to register bean mappings on the client side. To      do this we need to register the bean mappings programmatically:      public class AxisPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {    protected void postProcessJaxRpcService(Service service) {        TypeMappingRegistry registry = service.getTypeMappingRegistry();        TypeMapping mapping = registry.createTypeMapping();        registerBeanMapping(mapping, Account.class, \"Account\");        registry.register(\"http://schemas.xmlsoap.org/soap/encoding/\", mapping);    }    protected void registerBeanMapping(TypeMapping mapping, Class type, String name) {        QName qName = new QName(\"http://localhost:8080/account/services/accountService\", name);        mapping.register(type, qName,                new BeanSerializerFactory(type, qName),                new BeanDeserializerFactory(type, qName));    }}        21.5.4&nbsp;Registering your own JAX-RPC Handler            \n\r\n\rIn this section we will register our own      javax.rpc.xml.handler.Handler to the web      service proxy where we can do custom code before the SOAP message is      sent over the wire. The Handler is a      callback interface. There is a convenience base class provided in      jaxrpc.jar, namely      javax.rpc.xml.handler.GenericHandler that we will      extend:      public class AccountHandler extends GenericHandler {    public QName[] getHeaders() {        return null;    }    public boolean handleRequest(MessageContext context) {        SOAPMessageContext smc = (SOAPMessageContext) context;        SOAPMessage msg = smc.getMessage();        try {            SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();            SOAPHeader header = envelope.getHeader();            ...        }        catch (SOAPException ex) {            throw new JAXRPCException(ex);        }        return true;    }}      \n\r\n\rWhat we need to do now is to register our AccountHandler to      JAX-RPC Service so it would invoke      handleRequest(..) before the message is sent      over the wire. Spring has at this time of writing no declarative support      for registering handlers, so we must use the programmatic approach.      However Spring has made it very easy for us to do this as we can      override the postProcessJaxRpcService(..)      method that is designed for this:      public class AccountHandlerJaxRpcPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {    protected void postProcessJaxRpcService(Service service) {        QName port = new QName(this.getNamespaceUri(), this.getPortName());        List list = service.getHandlerRegistry().getHandlerChain(port);        list.add(new HandlerInfo(AccountHandler.class, null, null));        logger.info(\"Registered JAX-RPC AccountHandler on port \" + port);    }}      \n\r\n\rThe last thing we must remember to do is to change the Spring      configuration to use our factory bean:      &lt;bean id=\"accountWebService\" class=\"example.AccountHandlerJaxRpcPortProxyFactoryBean\"&gt;    ...&lt;/bean&gt;        21.5.5&nbsp;Exposing servlet-based web services using JAX-WS            \n\r\n\rSpring provides a convenient base class for JAX-WS servlet      endpoint implementations -      SpringBeanAutowiringSupport. To expose our      AccountService we extend Spring\'s      SpringBeanAutowiringSupport class and implement      our business logic here, usually delegating the call to the business      layer. We\'ll simply use Spring 2.5\'s @Autowired      annotation for expressing such dependencies on Spring-managed      beans.      /** * JAX-WS compliant AccountService implementation that simply delegates * to the AccountService implementation in the root web application context. * * This wrapper class is necessary because JAX-WS requires working with dedicated * endpoint classes. If an existing service needs to be exported, a wrapper that * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through * the @Autowired annotation) is the simplest JAX-WS compliant way. * * This is the class registered with the server-side JAX-WS implementation. * In the case of a Java EE 5 server, this would simply be defined as a servlet * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting * accordingly. The servlet name usually needs to match the specified WS service name. * * The web service engine manages the lifecycle of instances of this class. * Spring bean references will just be wired in here. */import org.springframework.web.context.support.SpringBeanAutowiringSupport;@WebService(serviceName=\"AccountService\")public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {    @Autowired    private AccountService biz;    @WebMethod    public void insertAccount(Account acc) {       biz.insertAccount(acc);    }    @WebMethod    public Account[] getAccounts(String name) {       return biz.getAccounts(name);    }}      \n\r\n\rOur AccountServletEndpoint needs to run in      the same web application as the Spring context to allow for access to      Spring\'s facilities. This is the case by default in Java EE 5      environments, using the standard contract for JAX-WS servlet endpoint      deployment. See Java EE 5 web service tutorials for details.        21.5.6&nbsp;Exporting standalone web services using JAX-WS            \n\r\n\rThe built-in JAX-WS provider that comes with Sun\'s JDK 1.6      supports exposure of web services using the built-in HTTP server that\'s      included in JDK 1.6 as well. Spring\'s      SimpleJaxWsServiceExporter detects all      @WebService annotated beans in the Spring application      context, exporting them through the default JAX-WS server (the JDK 1.6      HTTP server).      \n\r\n\rIn this scenario, the endpoint instances are defined and managed      as Spring beans themselves; they will be registered with the JAX-WS      engine but their lifecycle will be up to the Spring application context.      This means that Spring functionality like explicit dependency injection      may be applied to the endpoint instances. Of course, annotation-driven      injection through @Autowired will work as      well.      &lt;bean class=\"org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter\"&gt;    &lt;property name=\"baseAddress\" value=\"http://localhost:8080/\"/&gt;&lt;/bean&gt;&lt;bean id=\"accountServiceEndpoint\" class=\"example.AccountServiceEndpoint\"&gt;    ...&lt;/bean&gt;...      \n\r\n\rThe AccountServiceEndpoint may derive from      Spring\'s SpringBeanAutowiringSupport but doesn\'t      have to since the endpoint is a fully Spring-managed bean here. This      means that the endpoint implementation may look like as follows, without      any superclass declared - and Spring\'s @Autowired      configuration annotation still being honored:      @WebService(serviceName=\"AccountService\")public class AccountServiceEndpoint {    @Autowired    private AccountService biz;    @WebMethod    public void insertAccount(Account acc) {       biz.insertAccount(acc);    }    @WebMethod    public List&lt;Account&gt; getAccounts(String name) {       return biz.getAccounts(name);    }}        21.5.7&nbsp;Exporting web services using the JAX-WS RI\'s Spring      support            \n\r\n\rSun\'s JAX-WS RI, developed as part of the GlassFish project, ships      Spring support as part of its JAX-WS Commons project. This allows for      defining JAX-WS endpoints as Spring-managed beans, similar to the      standalone mode discussed in the previous section - but this time in a      Servlet environment. Note that this is not portable in a Java      EE 5 environment; it is mainly intended for non-EE environments such as      Tomcat, embedding the JAX-WS RI as part of the web      application.      \n\r\n\rThe difference to the standard style of exporting servlet-based      endpoints is that the lifecycle of the endpoint instances themselves      will be managed by Spring here, and that there will be only one JAX-WS      servlet defined in web.xml. With the standard Java EE      5 style (as illustrated above), you\'ll have one servlet definition per      service endpoint, with each endpoint typically delegating to Spring      beans (through the use of @Autowired, as shown      above).      \n\r\n\rCheck out https://jax-ws-commons.dev.java.net/spring/      for the details on setup and usage style.        21.5.8&nbsp;Accessing web services using JAX-WS            \n\r\n\rAnalogous to the JAX-RPC support, Spring provides two factory      beans to create JAX-WS web service proxies, namely      LocalJaxWsServiceFactoryBean and      JaxWsPortProxyFactoryBean. The former can only      return a JAX-WS service class for us to work with. The latter is the      full-fledged version that can return a proxy that implements our      business service interface. In this example we use the latter to create      a proxy for the AccountService endpoint      (again):      &lt;bean id=\"accountWebService\" class=\"org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean\"&gt;    &lt;property name=\"serviceInterface\" value=\"example.AccountService\"/&gt;    &lt;property name=\"wsdlDocumentUrl\" value=\"http://localhost:8888/AccountServiceEndpoint?WSDL\"/&gt;    &lt;property name=\"namespaceUri\" value=\"http://example/\"/&gt;    &lt;property name=\"serviceName\" value=\"AccountService\"/&gt;    &lt;property name=\"portName\" value=\"AccountServiceEndpointPort\"/&gt;&lt;/bean&gt;      \n\r\n\rWhere serviceInterface is our business      interface the clients will use. wsdlDocumentUrl is      the URL for the WSDL file. Spring needs this a startup time to create      the JAX-WS Service. namespaceUri corresponds to the      targetNamespace in the .wsdl file. serviceName      corresponds to the service name in the .wsdl file.      portName corresponds to the port name in the .wsdl      file.      \n\r\n\rAccessing the web service is now very easy as we have a bean      factory for it that will expose it as AccountService      interface. We can wire this up in Spring:      &lt;bean id=\"client\" class=\"example.AccountClientImpl\"&gt;    ...    &lt;property name=\"service\" ref=\"accountWebService\"/&gt;&lt;/bean&gt;      \n\r\n\rFrom the client code we can access the web service just as if it      was a normal class:      public class AccountClientImpl {    private AccountService service;    public void setService(AccountService service) {        this.service = service;    }    public void foo() {        service.insertAccount(...);    }}      \n\r\n\rNOTE: The above is slightly simplified in      that JAX-WS requires endpoint interfaces and implementation classes to      be annotated with @WebService,      @SOAPBinding etc annotations. This means that you      cannot (easily) use plain Java interfaces and implementation classes as      JAX-WS endpoint artifacts; you need to annotate them accordingly first.      Check the JAX-WS documentation for details on those requirements.        21.6&nbsp;JMS        \n\r\n\rIt is also possible to expose services transparently using JMS as    the underlying communication protocol. The JMS remoting support in the    Spring Framework is pretty basic - it sends and receives on the    same thread and in the same    non-transactional Session, and    as such throughput will be very implementation dependent. Note that    these single-threaded and non-transactional constraints apply only to    Spring\'s JMS remoting support. See    Chapter&nbsp;23, JMS (Java Message Service) for information on Spring\'s rich support for    JMS-based messaging.    \n\r\n\rThe following interface is used on both the server and the client    side.    package com.foo;public interface CheckingAccountService {    public void cancelAccount(Long accountId);}    \n\r\n\rThe following simple implementation of the above interface is used    on the server-side.    package com.foo;public class SimpleCheckingAccountService implements CheckingAccountService {    public void cancelAccount(Long accountId) {        System.out.println(\"Cancelling account [\" + accountId + \"]\");    }}    \n\r\n\rThis configuration file contains the JMS-infrastructure beans that    are shared on both the client and server.    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"connectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt;        &lt;property name=\"brokerURL\" value=\"tcp://ep-t43:61616\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"queue\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt;        &lt;constructor-arg value=\"mmm\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;    21.6.1&nbsp;Server-side configuration            \n\r\n\rOn the server, you just need to expose the service object using      the JmsInvokerServiceExporter.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"checkingAccountService\"          class=\"org.springframework.jms.remoting.JmsInvokerServiceExporter\"&gt;        &lt;property name=\"serviceInterface\" value=\"com.foo.CheckingAccountService\"/&gt;        &lt;property name=\"service\"&gt;            &lt;bean class=\"com.foo.SimpleCheckingAccountService\"/&gt;        &lt;/property&gt;   &lt;/bean&gt;   &lt;bean class=\"org.springframework.jms.listener.SimpleMessageListenerContainer\"&gt;       &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;       &lt;property name=\"destination\" ref=\"queue\"/&gt;       &lt;property name=\"concurrentConsumers\" value=\"3\"/&gt;       &lt;property name=\"messageListener\" ref=\"checkingAccountService\"/&gt;   &lt;/bean&gt;&lt;/beans&gt;      package com.foo;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Server {    public static void main(String[] args) throws Exception {        new ClassPathXmlApplicationContext(new String[]{\"com/foo/server.xml\", \"com/foo/jms.xml\"});    }}        21.6.2&nbsp;Client-side configuration            \n\r\n\rThe client merely needs to create a client-side proxy that will      implement the agreed upon interface      (CheckingAccountService). The resulting      object created off the back of the following bean definition can be      injected into other client side objects, and the proxy will take care of      forwarding the call to the server-side object via JMS.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"checkingAccountService\"          class=\"org.springframework.jms.remoting.JmsInvokerProxyFactoryBean\"&gt;        &lt;property name=\"serviceInterface\" value=\"com.foo.CheckingAccountService\"/&gt;        &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt;        &lt;property name=\"queue\" ref=\"queue\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;      package com.foo;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Client {    public static void main(String[] args) throws Exception {        ApplicationContext ctx = new ClassPathXmlApplicationContext(                new String[] {\"com/foo/client.xml\", \"com/foo/jms.xml\"});        CheckingAccountService service = (CheckingAccountService) ctx.getBean(\"checkingAccountService\");        service.cancelAccount(new Long(10));    }}    \n\r\n\rYou may also wish to investigate the support provided by the Lingo project, which (to quote    the homepage blurb) &#8220;        ... is a lightweight POJO based remoting and messaging        library based on the Spring Framework\'s remoting libraries which        extends it to support JMS.      &#8221;        21.7&nbsp;Auto-detection is not implemented for remote interfaces        \n\r\n\rThe main reason why auto-detection of implemented interfaces does    not occur for remote interfaces is to avoid opening too many doors to    remote callers. The target object might implement internal callback    interfaces like InitializingBean or    DisposableBean which one would not want to    expose to callers.    \n\r\n\rOffering a proxy with all interfaces implemented by the target    usually does not matter in the local case. But when exporting a remote    service, you should expose a specific service interface, with specific    operations intended for remote usage. Besides internal callback    interfaces, the target might implement multiple business interfaces, with    just one of them intended for remote exposure. For these reasons, we    require such a service interface to be    specified.    \n\r\n\rThis is a trade-off between configuration convenience and the risk    of accidental exposure of internal methods. Always specifying a service    interface is not too much effort, and puts you on the safe side regarding    controlled exposure of specific methods.    21.8&nbsp;Considerations when choosing a technology        \n\r\n\rEach and every technology presented here has its drawbacks. You    should carefully consider your needs, the services you are exposing and the    objects you\'ll be sending over the wire when choosing a technology.    \n\r\n\rWhen using RMI, it\'s not possible to access the objects through the    HTTP protocol, unless you\'re tunneling the RMI traffic. RMI is a fairly    heavy-weight protocol in that it supports full-object serialization which    is important when using a complex data model that needs serialization over    the wire. However, RMI-JRMP is tied to Java clients: It is a Java-to-Java    remoting solution.    \n\r\n\rSpring\'s HTTP invoker is a good choice if you need HTTP-based    remoting but also rely on Java serialization. It shares the basic    infrastructure with RMI invokers, just using HTTP as transport. Note that    HTTP invokers are not only limited to Java-to-Java remoting but also to    Spring on both the client and server side. (The latter also applies to    Spring\'s RMI invoker for non-RMI interfaces.)    \n\r\n\rHessian and/or Burlap might provide significant value when operating    in a heterogeneous environment, because they explicitly allow for non-Java    clients. However, non-Java support is still limited. Known issues include    the serialization of Hibernate objects in combination with    lazily-initialized collections. If you have such a data model, consider    using RMI or HTTP invokers instead of Hessian.    \n\r\n\rJMS can be useful for providing clusters of services and allowing    the JMS broker to take care of load balancing, discovery and    auto-failover. By default: Java serialization is used when using JMS    remoting but the JMS provider could use a different mechanism for the wire    formatting, such as XStream to allow servers to be implemented in other    technologies.    \n\r\n\rLast but not least, EJB has an advantage over RMI in that it    supports standard role-based authentication and authorization and remote    transaction propagation. It is possible to get RMI invokers or HTTP    invokers to support security context propagation as well, although this is    not provided by core Spring: There are just appropriate hooks for plugging    in third-party or custom solutions here.    21.9&nbsp;Accessing RESTful services on the Client        \n\r\n\rThe RestTemplate is the core class for    client-side access to RESTful services. It is conceptually similar to    other template classes in Spring, such as    JdbcTemplate and JmsTemplate    and other template classes found in other Spring portfolio projects.    RestTemplate\'s behavior is customized by providing    callback methods and configuring the    HttpMessageConverter used to marshal    objects into the HTTP request body and to unmarshal any response back    into an object. As it is common to use XML as a message format, Spring    provides a MarshallingHttpMessageConverter that    uses the Object-to-XML framework that is part of the    org.springframework.oxm package. This gives you a    wide range of choices of XML to Object mapping technologies to choose    from.    \n\r\n\rThis section describes how to use the    RestTemplate and its associated    HttpMessageConverters.    21.9.1&nbsp;RestTemplate            \n\r\n\rInvoking RESTful services in Java is typically done using a helper      class such as Jakarta Commons HttpClient. For      common REST operations this approach is too low level as shown      below.      String uri = \"http://example.com/hotels/1/bookings\";PostMethod post = new PostMethod(uri);String request = // create booking request contentpost.setRequestEntity(new StringRequestEntity(request));httpClient.executeMethod(post);if (HttpStatus.SC_CREATED == post.getStatusCode()) {  Header location = post.getRequestHeader(\"Location\");  if (location != null) {    System.out.println(\"Created new booking at :\" + location.getValue());  }}      \n\r\n\rRestTemplate provides higher level methods that correspond to each      of the six main HTTP methods that make invoking many RESTful services a      one-liner and enforce REST best practices.      \n\r\n\rTable&nbsp;21.1.&nbsp;Overview of RestTemplate methods                HTTP MethodRestTemplate              MethodDELETEdeleteGETgetForObject&nbsp;getForEntityHEADheadForHeaders(String              url, String&#8230; urlVariables)OPTIONSoptionsForAllow(String              url, String&#8230; urlVariables)POSTpostForLocation(String              url, Object request, String&#8230; urlVariables)&nbsp;postForObject(String                  url, Object request, Class&lt;T&gt; responseType, String&#8230;                  uriVariables)PUTput(String              url, Object request, String&#8230;urlVariables)      \n\r      \n\r\n\rThe names of RestTemplate methods follow a      naming convention, the first part indicates what HTTP method is being      invoked and the second part indicates what is returned. For example, the      method getForObject() will perform a GET, convert      the HTTP response into an object type of your choice and return that      object. The method postForLocation() will do a      POST, converting the given object into a HTTP request and return the      response HTTP Location header where the newly created object can be      found. In case of an exception processing the HTTP request, an exception      of the type RestClientException will be      thrown; this behavior can be changed by plugging in another ResponseErrorHandler      implementation into the RestTemplate.      \n\r\n\rObjects passed to and returned from these methods are converted to      and from HTTP messages by      HttpMessageConverter instances.      Converters for the main mime types are registered by default, but you      can also write your own converter and register it via the      messageConverters() bean property. The default      converter instances registered with the template are      ByteArrayHttpMessageConverter,      StringHttpMessageConverter,      FormHttpMessageConverter and      SourceHttpMessageConverter. You can override      these defaults using the messageConverters() bean      property as would be required if using the      MarshallingHttpMessageConverter or      MappingJackson2HttpMessageConverter.      \n\r\n\rEach method takes URI template arguments in two forms, either as a      String variable length argument or a      Map&lt;String,String&gt;. For example,      String result = restTemplate.getForObject(\"http://example.com/hotels/{hotel}/bookings/{booking}\",                                          String.class,\"42\", \"21\");      \n\r\n\rusing variable length arguments and      Map&lt;String, String&gt; vars = Collections.singletonMap(\"hotel\", \"42\");String result =  restTemplate.getForObject(\"http://example.com/hotels/{hotel}/rooms/{hotel}\", String.class, vars);      \n\r\n\rusing a Map&lt;String,String&gt;.      \n\r\n\rTo create an instance of RestTemplate you can      simply call the default no-arg constructor. This will use standard Java      classes from the java.net package as the underlying      implementation to create HTTP requests. This can be overridden by      specifying an implementation of      ClientHttpRequestFactory. Spring provides      the implementation      HttpComponentsClientHttpRequestFactory that uses the      Apache HttpComponents HttpClient to create requests.      HttpComponentsClientHttpRequestFactory is configured      using an instance of      org.apache.http.client.HttpClient which      can in turn be configured with credentials information or connection      pooling functionality.      Tip\n\r\n\rNote that the java.net implementation for      HTTP requests may raise an exception when accessing the status of a response      that represents an error (e.g. 401). If this is an issue, switch to      HttpComponentsClientHttpRequestFactory instead.            \n\r\n\rThe previous example using Apache HttpComponents      HttpClient directly rewritten to use the      RestTemplate is shown below      uri = \"http://example.com/hotels/{id}/bookings\";RestTemplate template = new RestTemplate();Booking booking = // create booking objectURI location = template.postForLocation(uri, booking, \"1\");      \n\r\n\rThe general callback interface is      RequestCallback and is called when the      execute method is invoked.      public &lt;T&gt; T execute(String url, HttpMethod method, RequestCallback requestCallback,                     ResponseExtractor&lt;T&gt; responseExtractor,                     String... urlVariables)// also has an overload with urlVariables as a Map&lt;String, String&gt;.      \n\r\n\rThe RequestCallback interface is      defined as      public interface RequestCallback { void doWithRequest(ClientHttpRequest request) throws IOException;}      \n\r\n\rand allows you to manipulate the request headers and write to the      request body. When using the execute method you do not have to worry      about any resource management, the template will always close the      request and handle any errors. Refer to the API documentation for more      information on using the execute method and the meaning of its other      method arguments.      Working with the URI                \n\r\n\rFor each of the main HTTP methods, the RestTemplate        provides variants that either take a String URI or java.net.URI        as the first argument.                \n\r\n\rThe String URI variants accept template arguments as a        String variable length argument or as a Map&lt;String,String&gt;.        They also assume the URL String is not encoded and needs to be encoded.        For example the following:                restTemplate.getForObject(\"http://example.com/hotel list\", String.class);        \n\r\n\rwill perform a GET on http://example.com/hotel%20list.        That means if the input URL String is already encoded, it will be encoded twice --        i.e. http://example.com/hotel%20list will become        http://example.com/hotel%2520list.        If this is not the intended effect, use the        java.net.URI method variant, which assumes        the URL is already encoded is also generally useful if you want        to reuse a single (fully expanded) URI        multiple times.        \n\r\n\rThe UriComponentsBuilder class can be used        to build and encode the URI including support        for URI templates. For example you can start with a URL String:                UriComponents uriComponents =        UriComponentsBuilder.fromUriString(\"http://example.com/hotels/{hotel}/bookings/{booking}\").build()            .expand(\"42\", \"21\")            .encode();URI uri = uriComponents.toUri();        \n\r\n\rOr specify each URI component individually:        UriComponents uriComponents =        UriComponentsBuilder.newInstance()            .scheme(\"http\").host(\"example.com\").path(\"/hotels/{hotel}/bookings/{booking}\").build()            .expand(\"42\", \"21\")            .encode();URI uri = uriComponents.toUri();            Dealing with request and response headers                \n\r\n\rBesides the methods described above, the RestTemplate        also has the exchange() method, which can be        used for arbitrary HTTP method execution based on the HttpEntity        class.        \n\r\n\rPerhaps most importantly, the exchange()        method can be used to add request headers and read response headers.        For example:        HttpHeaders requestHeaders = new HttpHeaders();requestHeaders.set(\"MyRequestHeader\", \"MyValue\");HttpEntity&lt;?&gt; requestEntity = new HttpEntity(requestHeaders);HttpEntity&lt;String&gt; response = template.exchange(\"http://example.com/hotels/{hotel}\",  HttpMethod.GET, requestEntity, String.class, \"42\");String responseHeader = response.getHeaders().getFirst(\"MyResponseHeader\");String body = response.getBody();        \n\r\n\rIn the above example, we first prepare a request entity that contains the        MyRequestHeader header. We then retrieve the response, and        read the MyResponseHeader and body.                21.9.2&nbsp;HTTP Message Conversion            \n\r\n\rObjects passed to and returned from the methods      getForObject(),      postForLocation(), and      put() are converted to HTTP requests and from      HTTP responses by HttpMessageConverters.      The HttpMessageConverter interface is      shown below to give you a better feel for its functionality      public interface HttpMessageConverter&lt;T&gt; {      // Indicate whether the given class and media type can be read by this converter.      boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType);      // Indicate whether the given class and media type can be written by this converter.      boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType);      // Return the list of MediaType objects supported by this converter.      List&lt;MediaType&gt; getSupportedMediaTypes();      // Read an object of the given type from the given input message, and returns it.      T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException,                                                                   HttpMessageNotReadableException;      // Write an given object to the given output message.      void write(T t, HttpOutputMessage outputMessage) throws IOException,                                                              HttpMessageNotWritableException;    }      \n\r\n\rConcrete implementations for the main media (mime) types are      provided in the framework and are registered by default with the      RestTemplate on the client-side and with      AnnotationMethodHandlerAdapter on the      server-side.      \n\r\n\rThe implementations of      HttpMessageConverters are described in the      following sections. For all converters a default media type is used but      can be overridden by setting the      supportedMediaTypes bean property      StringHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write Strings from the HTTP request        and response. By default, this converter supports all text media types        (text/*), and writes with a        Content-Type of        text/plain.            FormHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write form data from the HTTP request        and response. By default, this converter reads and writes the media        type application/x-www-form-urlencoded. Form data        is read from and written into a MultiValueMap&lt;String,        String&gt;.            ByteArrayHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write byte arrays from the HTTP        request and response. By default, this converter supports all media        types (*/*), and writes with a        Content-Type of        application/octet-stream. This can be overridden by        setting the supportedMediaTypes property, and        overriding getContentType(byte[]).            MarshallingHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write XML using Spring\'s        Marshaller and        Unmarshaller abstractions from the        org.springframework.oxm package. This converter        requires a Marshaller and        Unmarshaller before it can be used.        These can be injected via constructor or bean properties. By default        this converter supports (text/xml) and        (application/xml).            MappingJackson2HttpMessageConverter (or MappingJacksonHttpMessageConverter with Jackson 1.x)                \n\r\n\rAn HttpMessageConverter        implementation that can read and write JSON using Jackson\'s        ObjectMapper. JSON mapping can be        customized as needed through the use of Jackson\'s provided annotations. When        further control is needed, a custom        ObjectMapper can be injected through        the ObjectMapper property for cases where custom        JSON serializers/deserializers need to be provided for specific types.        By default this converter supports (application/json).            SourceHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write        javax.xml.transform.Source from the HTTP        request and response. Only DOMSource,        SAXSource, and        StreamSource are supported. By default, this        converter supports (text/xml) and        (application/xml).            BufferedImageHttpMessageConverter                \n\r\n\rAn HttpMessageConverter        implementation that can read and write        java.awt.image.BufferedImage from the HTTP        request and response. This converter reads and writes the media type        supported by the Java I/O API.            Prev&nbsp;Up&nbsp;NextPart&nbsp;VI.&nbsp;Integration&nbsp;Home&nbsp;22.&nbsp;Enterprise JavaBeans (EJB) integration","21. Remoting and web services using Spring","scr\\remoting.html","         6.&nbsp;ResourcesPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next6.&nbsp;Resources    6.1&nbsp;Introduction        \n\r\n\rJava\'s standard java.net.URL class and    standard handlers for various URL prefixes unfortunately are not quite    adequate enough for all access to low-level resources. For example,    there is no standardized URL implementation    that may be used to access a resource that needs to be obtained from    the classpath, or relative to a    ServletContext. While it is possible    to register new handlers for specialized URL    prefixes (similar to existing handlers for prefixes such as    http:), this is generally quite complicated, and the    URL interface still lacks some desirable    functionality, such as a method to check for the existence of the    resource being pointed to.    6.2&nbsp;The Resource interface        \n\r\n\rSpring\'s Resource interface is meant    to be a more capable interface for abstracting access to low-level    resources.    public interface Resource extends InputStreamSource {    boolean exists();    boolean isOpen();    URL getURL() throws IOException;    File getFile() throws IOException;    Resource createRelative(String relativePath) throws IOException;    String getFilename();    String getDescription();}    public interface InputStreamSource {    InputStream getInputStream() throws IOException;}    \n\r\n\rSome of the most important methods from the    Resource interface are:    \n\r        \n\r\n\rgetInputStream(): locates and opens the        resource, returning an InputStream for reading        from the resource. It is expected that each invocation returns a        fresh InputStream. It is the responsibility of        the caller to close the stream.      \n\r        \n\r\n\rexists(): returns a        boolean indicating whether this resource actually        exists in physical form.      \n\r        \n\r\n\risOpen(): returns a        boolean indicating whether this resource represents        a handle with an open stream. If true, the        InputStream cannot be read multiple times, and        must be read once only and then closed to avoid resource leaks. Will        be false for all usual resource implementations,        with the exception of        InputStreamResource.      \n\r        \n\r\n\rgetDescription(): returns a description        for this resource, to be used for error output when working with the        resource. This is often the fully qualified file name or the actual        URL of the resource.      \n\r    \n\r\n\rOther methods allow you to obtain an actual    URL or File object    representing the resource (if the underlying implementation is compatible,    and supports that functionality).    \n\r\n\rThe Resource abstraction is used    extensively in Spring itself, as an argument type in many method    signatures when a resource is needed. Other methods in some Spring APIs    (such as the constructors to various    ApplicationContext implementations), take a    String which in unadorned or simple form is used to    create a Resource appropriate to that    context implementation, or via special prefixes on the    String path, allow the caller to specify that a    specific Resource implementation must be    created and used.    \n\r\n\rWhile the Resource interface is used    a lot with Spring and by Spring, it\'s actually very useful to use as a    general utility class by itself in your own code, for access to resources,    even when your code doesn\'t know or care about any other parts of Spring.    While this couples your code to Spring, it really only couples it to this    small set of utility classes, which are serving as a more capable    replacement for URL, and can be considered    equivalent to any other library you would use for this purpose.    \n\r\n\rIt is important to note that the    Resource abstraction does not replace    functionality: it wraps it where possible. For example, a    UrlResource wraps a URL, and uses the wrapped    URL to do its work.    6.3&nbsp;Built-in Resource implementations        \n\r\n\rThere are a number of Resource    implementations that come supplied straight out of the box in    Spring:    6.3.1&nbsp;UrlResource            \n\r\n\rThe UrlResource wraps a      java.net.URL, and may be used to access any      object that is normally accessible via a URL, such as files, an HTTP      target, an FTP target, etc. All URLs have a standardized      String representation, such that appropriate      standardized prefixes are used to indicate one URL type from another.      This includes file: for accessing filesystem paths,      http: for accessing resources via the HTTP protocol,      ftp: for accessing resources via FTP, etc.      \n\r\n\rA UrlResource is created by Java code      explicitly using the UrlResource constructor, but      will often be created implicitly when you call an API method which takes      a String argument which is meant to represent a      path. For the latter case, a JavaBeans      PropertyEditor will ultimately decide      which type of Resource to create. If the      path string contains a few well-known (to it, that is) prefixes such as      classpath:, it will create an appropriate specialized      Resource for that prefix. However, if it      doesn\'t recognize the prefix, it will assume the this is just a standard      URL string, and will create a UrlResource.        6.3.2&nbsp;ClassPathResource            \n\r\n\rThis class represents a resource which should be obtained from the      classpath. This uses either the thread context class loader, a given      class loader, or a given class for loading resources.      \n\r\n\rThis Resource implementation      supports resolution as java.io.File if the class      path resource resides in the file system, but not for classpath      resources which reside in a jar and have not been expanded (by the      servlet engine, or whatever the environment is) to the filesystem. To      address this the various Resource      implementations always support resolution as a      java.net.URL.      \n\r\n\rA ClassPathResource is created by Java code      explicitly using the ClassPathResource      constructor, but will often be created implicitly when you call an API      method which takes a String argument which is      meant to represent a path. For the latter case, a JavaBeans      PropertyEditor will recognize the special      prefix classpath:on the string path, and create a      ClassPathResource in that case.        6.3.3&nbsp;FileSystemResource            \n\r\n\rThis is a Resource implementation      for java.io.File handles. It obviously supports      resolution as a File, and as a      URL.        6.3.4&nbsp;ServletContextResource            \n\r\n\rThis is a Resource implementation      for ServletContext resources,      interpreting relative paths within the relevant web application\'s root      directory.      \n\r\n\rThis always supports stream access and URL access, but only allows      java.io.File access when the web application      archive is expanded and the resource is physically on the filesystem.      Whether or not it\'s expanded and on the filesystem like this, or      accessed directly from the JAR or somewhere else like a DB (it\'s      conceivable) is actually dependent on the Servlet container.        6.3.5&nbsp;InputStreamResource            \n\r\n\rA Resource implementation for a      given InputStream. This should only be      used if no specific Resource      implementation is applicable. In particular, prefer      ByteArrayResource or any of the file-based      Resource implementations where      possible.      \n\r\n\rIn contrast to other Resource      implementations, this is a descriptor for an      already opened resource - therefore returning      true from isOpen(). Do not      use it if you need to keep the resource descriptor somewhere, or if you      need to read a stream multiple times.        6.3.6&nbsp;ByteArrayResource            \n\r\n\rThis is a Resource implementation      for a given byte array. It creates a      ByteArrayInputStream for the given byte      array.      \n\r\n\rIt\'s useful for loading content from any given byte array, without      having to resort to a single-use      InputStreamResource.        6.4&nbsp;The ResourceLoader        \n\r\n\rThe ResourceLoader interface is meant    to be implemented by objects that can return (i.e. load)    Resource instances.    public interface ResourceLoader {    Resource getResource(String location);}    \n\r\n\rAll application contexts implement the    ResourceLoader interface, and therefore all    application contexts may be used to obtain    Resource instances.    \n\r\n\rWhen you call getResource() on a specific    application context, and the location path specified doesn\'t have a    specific prefix, you will get back a    Resource type that is appropriate to that    particular application context. For example, assume the following snippet    of code was executed against a    ClassPathXmlApplicationContext instance:    Resource template = ctx.getResource(\"some/resource/path/myTemplate.txt\");    \n\r\n\rWhat would be returned would be a    ClassPathResource; if the same method was executed    against a FileSystemXmlApplicationContext instance,    you\'d get back a FileSystemResource. For a    WebApplicationContext, you\'d get back a    ServletContextResource, and so on.    \n\r\n\rAs such, you can load resources in a fashion appropriate to the    particular application context.    \n\r\n\rOn the other hand, you may also force    ClassPathResource to be used, regardless of the    application context type, by specifying the special    classpath: prefix:    Resource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\");    \n\r\n\rSimilarly, one can force a UrlResource to be    used by specifying any of the standard java.net.URL    prefixes:    Resource template = ctx.getResource(\"file:/some/resource/path/myTemplate.txt\");    Resource template = ctx.getResource(\"http://myhost.com/resource/path/myTemplate.txt\");    \n\r\n\rThe following table summarizes the strategy for converting    Strings to    Resources:    \n\r\n\rTable&nbsp;6.1.&nbsp;Resource strings            PrefixExampleExplanation\n\r\n\rclasspath:\n\r\n\r classpath:com/myapp/config.xml            \n\r\n\rLoaded from the classpath.\n\r\n\rfile:\n\r\n\r file:/data/config.xml            \n\r\n\r Loaded as a URL, from the            filesystem. [1] \n\r\n\rhttp:\n\r\n\r http://myserver/logo.png            \n\r\n\rLoaded as a            URL.\n\r\n\r(none)\n\r\n\r /data/config.xml \n\r\n\r Depends on the underlying            ApplicationContext.                 \n\r\n\r[1] But see also                Section&nbsp;6.7.3, &#8220;FileSystemResource caveats&#8221;.                  \n\r    6.5&nbsp;The ResourceLoaderAware interface        \n\r\n\rThe ResourceLoaderAware interface is    a special marker interface, identifying objects that expect to be provided    with a ResourceLoader reference.    public interface ResourceLoaderAware {   void setResourceLoader(ResourceLoader resourceLoader);}    \n\r\n\rWhen a class implements    ResourceLoaderAware and is deployed into an    application context (as a Spring-managed bean), it is recognized as    ResourceLoaderAware by the application    context. The application context will then invoke the    setResourceLoader(ResourceLoader), supplying    itself as the argument (remember, all application contexts in Spring    implement the ResourceLoader    interface).    \n\r\n\rOf course, since an    ApplicationContext is a    ResourceLoader, the bean could also    implement the ApplicationContextAware    interface and use the supplied application context directly to load    resources, but in general, it\'s better to use the specialized    ResourceLoader interface if that\'s all    that\'s needed. The code would just be coupled to the resource loading    interface, which can be considered a utility interface, and not the whole    Spring ApplicationContext interface.    \n\r\n\rAs of Spring 2.5, you can rely upon autowiring of the    ResourceLoader as an alternative to    implementing the ResourceLoaderAware interface.    The \"traditional\" constructor and byType    autowiring modes (as described in Section&nbsp;5.4.5, &#8220;Autowiring collaborators&#8221;)    are now capable of providing a dependency of type    ResourceLoader for either a    constructor argument or setter method parameter respectively. For more flexibility    (including the ability to autowire fields and multiple parameter methods), consider    using the new annotation-based autowiring features. In that case, the    ResourceLoader will be autowired into a field,    constructor argument, or method parameter that is expecting the    ResourceLoader type as long as the field,    constructor, or method in question carries the    @Autowired annotation. For more information,    see Section&nbsp;5.9.2, &#8220;@Autowired&#8221;.    6.6&nbsp;Resources as dependencies        \n\r\n\rIf the bean itself is going to determine and supply the resource    path through some sort of dynamic process, it probably makes sense for the    bean to use the ResourceLoader interface to    load resources. Consider as an example the loading of a template of some    sort, where the specific resource that is needed depends on the role of    the user. If the resources are static, it makes sense to eliminate the use    of the ResourceLoader interface completely,    and just have the bean expose the Resource    properties it needs, and expect that they will be injected into it.    \n\r\n\rWhat makes it trivial to then inject these properties, is that all    application contexts register and use a special JavaBeans    PropertyEditor which can convert    String paths to    Resource objects. So if    myBean has a template property of type    Resource, it can be configured with a    simple string for that resource, as follows:    &lt;bean id=\"myBean\" class=\"...\"&gt;  &lt;property name=\"template\" value=\"some/resource/path/myTemplate.txt\"/&gt;&lt;/bean&gt;    \n\r\n\rNote that the resource path has no prefix, so because the    application context itself is going to be used as the    ResourceLoader, the resource itself will be    loaded via a ClassPathResource,    FileSystemResource, or    ServletContextResource (as appropriate)    depending on the exact type of the context.    \n\r\n\rIf there is a need to force a specific    Resource type to be used, then a prefix may    be used. The following two examples show how to force a    ClassPathResource and a    UrlResource (the latter being used to access a    filesystem file).    &lt;property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\"&gt;    &lt;property name=\"template\" value=\"file:/some/resource/path/myTemplate.txt\"/&gt;    6.7&nbsp;Application contexts and Resource paths        6.7.1&nbsp;Constructing application contexts            \n\r\n\rAn application context constructor (for a specific application      context type) generally takes a string or array of strings as the      location path(s) of the resource(s) such as XML files that make up the      definition of the context.      \n\r\n\rWhen such a location path doesn\'t have a prefix, the specific      Resource type built from that path and      used to load the bean definitions, depends on and is appropriate to the      specific application context. For example, if you create a      ClassPathXmlApplicationContext as follows:      ApplicationContext ctx = new ClassPathXmlApplicationContext(\"conf/appContext.xml\");      \n\r\n\rThe bean definitions will be loaded from the classpath, as a      ClassPathResource will be      used. But if you create a      FileSystemXmlApplicationContext as      follows:      ApplicationContext ctx =    new FileSystemXmlApplicationContext(\"conf/appContext.xml\");      \n\r\n\rThe bean definition will be loaded from a filesystem location, in      this case relative to the current working directory.      \n\r\n\rNote that the use of the special classpath prefix or a standard      URL prefix on the location path will override the default type of      Resource created to load the definition.      So this FileSystemXmlApplicationContext...      ApplicationContext ctx =    new FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\");      \n\r\n\r... will actually load its bean definitions from the classpath.      However, it is still a FileSystemXmlApplicationContext. If it is      subsequently used as a ResourceLoader,      any unprefixed paths will still be treated as filesystem paths.      Constructing ClassPathXmlApplicationContext instances - shortcuts                \n\r\n\rThe ClassPathXmlApplicationContext        exposes a number of constructors to enable convenient instantiation.        The basic idea is that one supplies merely a string array containing        just the filenames of the XML files themselves (without the leading        path information), and one also supplies a        Class; the        ClassPathXmlApplicationContext will derive the        path information from the supplied class.        \n\r\n\rAn example will hopefully make this clear. Consider a directory        layout that looks like this:        com/  foo/    services.xml    daos.xml    MessengerService.class        \n\r\n\rA ClassPathXmlApplicationContext instance        composed of the beans defined in the \'services.xml\'        and \'daos.xml\' could be instantiated like        so...        ApplicationContext ctx = new ClassPathXmlApplicationContext(    new String[] {\"services.xml\", \"daos.xml\"}, MessengerService.class);        \n\r\n\rPlease do consult the Javadocs for the        ClassPathXmlApplicationContext class for        details of the various constructors.              6.7.2&nbsp;Wildcards in application context constructor resource paths            \n\r\n\rThe resource paths in application context constructor values may      be a simple path (as shown above) which has a one-to-one mapping to a      target Resource, or alternately may contain the special \"classpath*:\"      prefix and/or internal Ant-style regular expressions (matched using      Spring\'s PathMatcher utility). Both of the latter      are effectively wildcards      \n\r\n\rOne use for this mechanism is when doing component-style      application assembly. All components can \'publish\' context definition      fragments to a well-known location path, and when the final application      context is created using the same path prefixed via      classpath*:, all component fragments will be picked      up automatically.      \n\r\n\rNote that this wildcarding is specific to use of resource paths in      application context constructors (or when using the      PathMatcher utility class hierarchy directly),      and is resolved at construction time. It has nothing to do with the      Resource type itself. It\'s not possible      to use the classpath*: prefix to construct an actual      Resource, as a resource points to just      one resource at a time.      Ant-style Patterns                \n\r\n\rWhen the path location contains an Ant-style pattern, for example:             /WEB-INF/*-context.xml     com/mycompany/**/applicationContext.xml     file:C:/some/path/*-context.xml     classpath:com/mycompany/**/applicationContext.xml        \n\r\n\r... the resolver follows a more complex but defined procedure to        try to resolve the wildcard. It produces a Resource for the path up to        the last non-wildcard segment and obtains a URL from it. If this URL        is not a \"jar:\" URL or container-specific variant (e.g.        \"zip:\" in WebLogic, \"wsjar\" in        WebSphere, etc.), then a java.io.File is        obtained from it and used to resolve the wildcard by traversing the        filesystem. In the case of a jar URL, the resolver either gets a        java.net.JarURLConnection from it or manually        parses the jar URL and then traverses the contents of the jar file        to resolve the wildcards.        Implications on portability                    \n\r\n\rIf the specified path is already a file URL (either          explicitly, or implicitly because the base          ResourceLoader is a          filesystem one, then wildcarding is guaranteed to work in a          completely portable fashion.          \n\r\n\rIf the specified path is a classpath location, then the          resolver must obtain the last non-wildcard path segment URL via a          Classloader.getResource() call. Since this          is just a node of the path (not the file at the end) it is actually          undefined (in the ClassLoader Javadocs)          exactly what sort of a URL is returned in this case. In practice, it          is always a java.io.File representing the          directory, where the classpath resource resolves to a filesystem          location, or a jar URL of some sort, where the classpath resource          resolves to a jar location. Still, there is a portability concern on          this operation.          \n\r\n\rIf a jar URL is obtained for the last non-wildcard segment,          the resolver must be able to get a          java.net.JarURLConnection from it, or          manually parse the jar URL, to be able to walk the contents of the          jar, and resolve the wildcard. This will work in most environments,          but will fail in others, and it is strongly recommended that the          wildcard resolution of resources coming from jars be thoroughly          tested in your specific environment before you rely on it.                    The classpath*: prefix                \n\r\n\rWhen constructing an XML-based application context, a location        string may use the special classpath*:        prefix:        ApplicationContext ctx =    new ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\");        \n\r\n\rThis special prefix specifies that all classpath resources that        match the given name must be obtained (internally, this essentially        happens via a ClassLoader.getResources(...)        call), and then merged to form the final application context        definition.        Classpath*: portability                    \n\r\n\rThe wildcard classpath relies on the getResources() method of the          underlying classloader. As most application servers nowadays supply          their own classloader implementation, the behavior might differ          especially when dealing with jar files. A simple test to check if          classpath* works is to use the classloader to load a file from          within a jar on the classpath:          getClass().getClassLoader().getResources(\"&lt;someFileInsideTheJar&gt;\").          Try this test with files that have the same name but are placed          inside two different locations. In case an inappropriate result is          returned, check the application server documentation for settings          that might affect the classloader behavior.                \n\r\n\rThe \"classpath*:\" prefix can also be combined        with a PathMatcher pattern in the rest of the location path, for        example \"classpath*:META-INF/*-beans.xml\". In this        case, the resolution strategy is fairly simple: a        ClassLoader.getResources() call is used on the last non-wildcard path        segment to get all the matching resources in the class loader        hierarchy, and then off each resource the same PathMatcher resolution        strategy described above is used for the wildcard subpath.            Other notes relating to wildcards                \n\r\n\rPlease note that \"classpath*:\" when        combined with Ant-style patterns will only work reliably with at least        one root directory before the pattern starts, unless the actual target        files reside in the file system. This means that a pattern like        \"classpath*:*.xml\" will not retrieve files from the        root of jar files but rather only from the root of expanded        directories. This originates from a limitation in the JDK\'s        ClassLoader.getResources() method which only        returns file system locations for a passed-in empty string (indicating        potential roots to search).        \n\r\n\rAnt-style patterns with \"classpath:\"        resources are not guaranteed to find matching resources if the root        package to search is available in multiple class path locations. This        is because a resource such as            com/mycompany/package1/service-context.xml        \n\r\n\rmay be in only one location, but when a path such as            classpath:com/mycompany/**/service-context.xml        \n\r\n\ris used to try to resolve it, the resolver will work off the (first) URL        returned by getResource(\"com/mycompany\");. If        this base package node exists in multiple classloader locations, the        actual end resource may not be underneath. Therefore, preferably, use        \"classpath*:\" with the same Ant-style pattern in        such a case, which will search all class path locations that contain        the root package.              6.7.3&nbsp;FileSystemResource caveats            \n\r\n\rA FileSystemResource that is not attached      to a FileSystemApplicationContext (that is, a      FileSystemApplicationContext is not the actual      ResourceLoader) will treat absolute vs.      relative paths as you would expect. Relative paths are relative to the      current working directory, while absolute paths are relative to the root      of the filesystem.      \n\r\n\rFor backwards compatibility (historical) reasons however, this      changes when the FileSystemApplicationContext is      the ResourceLoader. The      FileSystemApplicationContext simply forces all      attached FileSystemResource instances to treat      all location paths as relative, whether they start with a leading slash      or not. In practice, this means the following are equivalent:      ApplicationContext ctx =    new FileSystemXmlApplicationContext(\"conf/context.xml\");      ApplicationContext ctx =    new FileSystemXmlApplicationContext(\"/conf/context.xml\");      \n\r\n\rAs are the following: (Even though it would make sense for them to      be different, as one case is relative and the other absolute.)      FileSystemXmlApplicationContext ctx = ...;ctx.getResource(\"some/resource/path/myTemplate.txt\");      FileSystemXmlApplicationContext ctx = ...;ctx.getResource(\"/some/resource/path/myTemplate.txt\");      \n\r\n\rIn practice, if true absolute filesystem paths are needed, it is      better to forgo the use of absolute paths with      FileSystemResource /      FileSystemXmlApplicationContext, and just force      the use of a UrlResource, by using the      file: URL prefix.      // actual context type doesn\'t matter, the Resource will always be UrlResourcectx.getResource(\"file:/some/resource/path/myTemplate.txt\");      // force this FileSystemXmlApplicationContext to load its definition via a UrlResourceApplicationContext ctx =    new FileSystemXmlApplicationContext(\"file:/conf/context.xml\");      Prev&nbsp;Up&nbsp;Next5.&nbsp;The IoC container&nbsp;Home&nbsp;7.&nbsp;Validation, Data Binding, and Type Conversion","6. Resources","scr\\resources.html","         27.&nbsp;Task Execution and SchedulingPrev&nbsp;Part&nbsp;VI.&nbsp;Integration&nbsp;Next27.&nbsp;Task Execution and Scheduling    27.1&nbsp;Introduction        \n\r\n\rThe Spring Framework provides abstractions for asynchronous    execution and scheduling of tasks with the    TaskExecutor and    TaskScheduler interfaces, respectively.    Spring also features implementations of those interfaces that support    thread pools or delegation to CommonJ within an application server    environment. Ultimately the use of these implementations behind the common    interfaces abstracts away the differences between Java SE 5, Java SE 6 and    Java EE environments.    \n\r\n\rSpring also features integration classes for supporting scheduling    with the Timer, part of the JDK since 1.3, and the    Quartz Scheduler (http://quartz-scheduler.org). Both of those    schedulers are set up using a FactoryBean    with optional references to Timer or    Trigger instances, respectively. Furthermore, a    convenience class for both the Quartz Scheduler and the    Timer is available that allows you to invoke a    method of an existing target object (analogous to the normal    MethodInvokingFactoryBean operation).    27.2&nbsp;The Spring TaskExecutor    abstraction        \n\r\n\rSpring 2.0 introduces a new abstraction for dealing with executors.    Executors are the Java 5 name for the concept of thread pools. The    \"executor\" naming is due to the fact that there is no guarantee that the    underlying implementation is actually a pool; an executor may be    single-threaded or even synchronous. Spring\'s abstraction hides    implementation details between Java SE 1.4, Java SE 5 and Java EE    environments.    \n\r\n\rSpring\'s TaskExecutor interface is    identical to the java.util.concurrent.Executor    interface. In fact, its primary reason for existence is to abstract away    the need for Java 5 when using thread pools. The interface has a single    method execute(Runnable task) that accepts a task    for execution based on the semantics and configuration of the thread    pool.    \n\r\n\rThe TaskExecutor was originally    created to give other Spring components an abstraction for thread pooling    where needed. Components such as the    ApplicationEventMulticaster, JMS\'s    AbstractMessageListenerContainer, and Quartz    integration all use the TaskExecutor    abstraction to pool threads. However, if your beans need thread pooling    behavior, it is possible to use this abstraction for your own    needs.    27.2.1&nbsp;TaskExecutor types            \n\r\n\rThere are a number of pre-built implementations of      TaskExecutor included with the Spring      distribution. In all likelihood, you shouldn\'t ever need to implement      your own.      \n\r          \n\r\n\rSimpleAsyncTaskExecutor          \n\r\n\rThis implementation does not reuse any threads, rather it          starts up a new thread for each invocation. However, it does support          a concurrency limit which will block any invocations that are over          the limit until a slot has been freed up. If you\'re looking for true          pooling, keep scrolling further down the page.        \n\r          \n\r\n\rSyncTaskExecutor          \n\r\n\rThis implementation doesn\'t execute invocations          asynchronously. Instead, each invocation takes place in the calling          thread. It is primarily used in situations where multithreading          isn\'t necessary such as simple test cases.        \n\r          \n\r\n\rConcurrentTaskExecutor          \n\r\n\rThis implementation is a wrapper for a Java 5          java.util.concurrent.Executor. There is an          alternative, ThreadPoolTaskExecutor, that          exposes the Executor configuration parameters          as bean properties. It is rare to need to use the          ConcurrentTaskExecutor but if the ThreadPoolTaskExecutor          isn\'t robust enough for your needs, the          ConcurrentTaskExecutor is an          alternative.        \n\r          \n\r\n\rSimpleThreadPoolTaskExecutor          \n\r\n\rThis implementation is actually a subclass of Quartz\'s          SimpleThreadPool which listens to Spring\'s          lifecycle callbacks. This is typically used when you have a thread          pool that may need to be shared by both Quartz and non-Quartz          components.        \n\r          \n\r\n\rThreadPoolTaskExecutor          \n\r\n\r            \n\r\n\rIt is not possible to use any backport or alternate versions            of the java.util.concurrent package with            this implementation. Both Doug Lea\'s and Dawid Kurzyniec\'s            implementations use different package structures which will            prevent them from working correctly.                    \n\r\n\rThis implementation can only be used in a Java 5 environment          but is also the most commonly used one in that environment. It          exposes bean properties for configuring a          java.util.concurrent.ThreadPoolExecutor and          wraps it in a TaskExecutor. If you          need something advanced such as a          ScheduledThreadPoolExecutor, it is          recommended that you use a ConcurrentTaskExecutor          instead.        \n\r          \n\r\n\rTimerTaskExecutor          \n\r\n\rThis implementation uses a single          TimerTask as its backing implementation. It\'s          different from the SyncTaskExecutor          in that the method invocations are executed in a separate thread,          although they are synchronous in that thread.        \n\r          \n\r\n\rWorkManagerTaskExecutor          \n\r\n\r            \n\r\n\rCommonJ is a set of specifications jointly developed between            BEA and IBM. These specifications are not Java EE standards, but            are standard across BEA\'s and IBM\'s Application Server            implementations.                    \n\r\n\rThis implementation uses the CommonJ WorkManager as its          backing implementation and is the central convenience class for          setting up a CommonJ WorkManager reference in a Spring context.          Similar to the SimpleThreadPoolTaskExecutor,          this class implements the WorkManager interface and therefore can be          used directly as a WorkManager as well.        \n\r        27.2.2&nbsp;Using a TaskExecutor            \n\r\n\rSpring\'s TaskExecutor      implementations are used as simple JavaBeans. In the example below, we      define a bean that uses the      ThreadPoolTaskExecutor to asynchronously print      out a set of messages.      import org.springframework.core.task.TaskExecutor;public class TaskExecutorExample {  private class MessagePrinterTask implements Runnable {    private String message;    public MessagePrinterTask(String message) {      this.message = message;    }    public void run() {      System.out.println(message);    }  }  private TaskExecutor taskExecutor;  public TaskExecutorExample(TaskExecutor taskExecutor) {    this.taskExecutor = taskExecutor;  }  public void printMessages() {    for(int i = 0; i &lt; 25; i++) {      taskExecutor.execute(new MessagePrinterTask(\"Message\" + i));    }  }}      \n\r\n\rAs you can see, rather than retrieving a thread from the pool and      executing yourself, you add your Runnable to the      queue and the TaskExecutor uses its      internal rules to decide when the task gets executed.      \n\r\n\rTo configure the rules that the      TaskExecutor will use, simple bean      properties have been exposed.      &lt;bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\"&gt;  &lt;property name=\"corePoolSize\" value=\"5\" /&gt;  &lt;property name=\"maxPoolSize\" value=\"10\" /&gt;  &lt;property name=\"queueCapacity\" value=\"25\" /&gt;&lt;/bean&gt;&lt;bean id=\"taskExecutorExample\" class=\"TaskExecutorExample\"&gt;  &lt;constructor-arg ref=\"taskExecutor\" /&gt;&lt;/bean&gt;        27.3&nbsp;The Spring TaskScheduler    abstraction        \n\r\n\rIn addition to the TaskExecutor    abstraction, Spring 3.0 introduces a    TaskScheduler with a variety of methods for    scheduling tasks to run at some point in the future.    public interface TaskScheduler {    ScheduledFuture schedule(Runnable task, Trigger trigger);    ScheduledFuture schedule(Runnable task, Date startTime);    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);}    \n\r\n\rThe simplest method is the one named \'schedule\' that takes a    Runnable and Date    only. That will cause the task to run once after the specified time. All    of the other methods are capable of scheduling tasks to run repeatedly.    The fixed-rate and fixed-delay methods are for simple, periodic execution,    but the method that accepts a Trigger is much more flexible.    27.3.1&nbsp;The Trigger interface            \n\r\n\rThe Trigger interface is      essentially inspired by JSR-236, which, as of Spring 3.0, has not yet      been officially implemented. The basic idea of the      Trigger is that execution times may be      determined based on past execution outcomes or even arbitrary      conditions. If these determinations do take into account the outcome of      the preceding execution, that information is available within a      TriggerContext. The      Trigger interface itself is quite      simple:      public interface Trigger {    Date nextExecutionTime(TriggerContext triggerContext);}      \n\r\n\rAs you can see, the TriggerContext      is the most important part. It encapsulates all of the relevant data,      and is open for extension in the future if necessary. The      TriggerContext is an interface (a      SimpleTriggerContext implementation is used by      default). Here you can see what methods are available for      Trigger implementations.      public interface TriggerContext {    Date lastScheduledExecutionTime();    Date lastActualExecutionTime();    Date lastCompletionTime();}        27.3.2&nbsp;Trigger implementations            \n\r\n\rSpring provides two implementations of the      Trigger interface. The most interesting      one is the CronTrigger. It enables the scheduling      of tasks based on cron expressions. For example the following task is      being scheduled to run 15 minutes past each hour but only during the      9-to-5 \"business hours\" on weekdays.      scheduler.schedule(task, new CronTrigger(\"* 15 9-17 * * MON-FRI\"));      \n\r\n\rThe other out-of-the-box implementation is a      PeriodicTrigger that accepts a fixed period, an      optional initial delay value, and a boolean to indicate whether the      period should be interpreted as a fixed-rate or a fixed-delay. Since the      TaskScheduler interface already defines      methods for scheduling tasks at a fixed-rate or with a fixed-delay,      those methods should be used directly whenever possible. The value of      the PeriodicTrigger implementation is that it can      be used within components that rely on the      Trigger abstraction. For example, it may      be convenient to allow periodic triggers, cron-based triggers, and even      custom trigger implementations to be used interchangeably. Such a      component could take advantage of dependency injection so that such      Triggers could be configured      externally.        27.3.3&nbsp;TaskScheduler      implementations            \n\r\n\rAs with Spring\'s TaskExecutor      abstraction, the primary benefit of the      TaskScheduler is that code relying on      scheduling behavior need not be coupled to a particular scheduler      implementation. The flexibility this provides is particularly relevant      when running within Application Server environments where threads should      not be created directly by the application itself. For such cases,      Spring provides a TimerManagerTaskScheduler that      delegates to a CommonJ TimerManager instance, typically configured with      a JNDI-lookup.      \n\r\n\rA simpler alternative, the      ThreadPoolTaskScheduler, can be used whenever      external thread management is not a requirement. Internally, it      delegates to a ScheduledExecutorService      instance. ThreadPoolTaskScheduler actually      implements Spring\'s TaskExecutor      interface as well, so that a single instance can be used for      asynchronous execution as soon as possible as well      as scheduled, and potentially recurring, executions.        27.4&nbsp;Annotation Support for Scheduling and Asynchronous    Execution        \n\r\n\rSpring provides annotation support for both task scheduling and    asynchronous method execution.    27.4.1&nbsp;Enable scheduling annotations            \n\r\n\rTo enable support for @Scheduled and      @Async annotations add      @EnableScheduling and      @EnableAsync to one of your      @Configuration classes:      @Configuration@EnableAsync@EnableSchedulingpublic class AppConfig {}      \n\r\n\rYou are free to pick and choose the relevant annotations      for your application. For example, if you only need support      for @Scheduled, simply omit      @EnableAsync. For more fine-grained      control you can additionally implement the      SchedulingConfigurer and/or      AsyncConfigurer interfaces. See      the Javadoc for full details.      \n\r\n\rIf you prefer XML configuration use the      &lt;task:annotation-driven&gt; element.      &lt;task:annotation-driven executor=\"myExecutor\" scheduler=\"myScheduler\"/&gt;&lt;task:executor id=\"myExecutor\" pool-size=\"5\"/&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt;}      \n\r\n\rNotice with the above XML that an executor reference is provided      for handling those tasks that correspond to methods with the      @Async annotation, and the scheduler      reference is provided for managing those methods annotated      with @Scheduled.        27.4.2&nbsp;The @Scheduled Annotation            \n\r\n\rThe @Scheduled annotation can be added to a method along with      trigger metadata. For example, the following method would be invoked      every 5 seconds with a fixed delay, meaning that the period will be      measured from the completion time of each preceding invocation.      @Scheduled(fixedDelay=5000)public void doSomething() {    // something that should execute periodically}      \n\r\n\rIf a fixed rate execution is desired, simply change the property      name specified within the annotation. The following would be executed      every 5 seconds measured between the successive start times of each      invocation.      @Scheduled(fixedRate=5000)public void doSomething() {    // something that should execute periodically}      \n\r\n\rFor fixed-delay and fixed-rate tasks, an initial delay may be      specified indicating the number of milliseconds to wait before the first      execution of the method.            @Scheduled(initialDelay=1000, fixedRate=5000)public void doSomething() {    // something that should execute periodically}      \n\r\n\rIf simple periodic scheduling is not expressive enough, then a      cron expression may be provided. For example, the following will only      execute on weekdays.      @Scheduled(cron=\"*/5 * * * * MON-FRI\")public void doSomething() {    // something that should execute on weekdays only}      \n\r\n\rNotice that the methods to be scheduled must have void returns and      must not expect any arguments. If the method needs to interact with      other objects from the Application Context, then those would typically      have been provided through dependency injection.      Note        \n\r\n\rMake sure that you are not initializing multiple instances of        the same @Scheduled annotation class at runtime, unless you do want to        schedule callbacks to each such instance. Related to this, make sure        that you do not use @Configurable on bean classes which are annotated        with @Scheduled and registered as regular Spring beans with the        container: You would get double initialization otherwise, once through        the container and once through the @Configurable aspect, with the        consequence of each @Scheduled method being invoked twice.              27.4.3&nbsp;The @Async Annotation            \n\r\n\rThe @Async annotation can be      provided on a method so that invocation of that method will occur      asynchronously. In other words, the caller will return immediately upon      invocation and the actual execution of the method will occur in a task      that has been submitted to a Spring      TaskExecutor. In the simplest case, the      annotation may be applied to a void-returning      method.      @Asyncvoid doSomething() {    // this will be executed asynchronously}      \n\r\n\rUnlike the methods annotated with the      @Scheduled annotation, these methods can      expect arguments, because they will be invoked in the \"normal\" way by      callers at runtime rather than from a scheduled task being managed by      the container. For example, the following is a legitimate application of      the @Async annotation.      @Asyncvoid doSomething(String s) {    // this will be executed asynchronously}      \n\r\n\rEven methods that return a value can be invoked asynchronously.      However, such methods are required to have a      Future typed return value. This still      provides the benefit of asynchronous execution so that the caller can      perform other tasks prior to calling get() on      that Future.      @AsyncFuture&lt;String&gt; returnSomething(int i) {    // this will be executed asynchronously}      \n\r\n\r@Async can not be used in      conjunction with lifecycle callbacks such as      @PostConstruct. To asynchronously      initialize Spring beans you currently have to use a separate      initializing Spring bean that invokes the      @Async annotated method on the target      then.      public class SampleBeanImpl implements SampleBean {  @Async  void doSomething() { &#8230; }}public class SampleBeanInititalizer {  private final SampleBean bean;  public SampleBeanInitializer(SampleBean bean) {    this.bean = bean;  }  @PostConstruct  public void initialize() {    bean.doSomething();  }}        27.4.4&nbsp;Executor qualification with @Async            \n\r\n\rBy default when specifying @Async on      a method, the executor that will be used is the one supplied to the      \'annotation-driven\' element as described above. However, the      value attribute of the      @Async annotation can be used when needing      to indicate that an executor other than the default should be used when      executing a given method.      @Async(\"otherExecutor\")void doSomething(String s) {    // this will be executed asynchronously by \"otherExecutor\"}      \n\r\n\rIn this case, \"otherExecutor\" may be the name of any      Executor bean in the Spring container, or      may be the name of a qualifier associated with any      Executor, e.g. as specified with the      &lt;qualifier&gt; element or Spring\'s      @Qualifier annotation.        27.5&nbsp;The Task Namespace        \n\r\n\rBeginning with Spring 3.0, there is an XML namespace for configuring    TaskExecutor and    TaskScheduler instances. It also provides a    convenient way to configure tasks to be scheduled with a trigger.    27.5.1&nbsp;The \'scheduler\' element            \n\r\n\rThe following element will create a      ThreadPoolTaskScheduler instance with the      specified thread pool size.      &lt;task:scheduler id=\"scheduler\" pool-size=\"10\"/&gt;      \n\r\n\rThe value provided for the \'id\' attribute will be used as the      prefix for thread names within the pool. The \'scheduler\' element is      relatively straightforward. If you do not provide a \'pool-size\'      attribute, the default thread pool will only have a single thread. There      are no other configuration options for the scheduler.        27.5.2&nbsp;The \'executor\' element            \n\r\n\rThe following will create a      ThreadPoolTaskExecutor instance: &lt;task:executor id=\"executor\" pool-size=\"10\"/&gt;      \n\r\n\rAs with the scheduler above, the value provided for the \'id\'      attribute will be used as the prefix for thread names within the pool.      As far as the pool size is concerned, the \'executor\' element supports      more configuration options than the \'scheduler\' element. For one thing,      the thread pool for a ThreadPoolTaskExecutor is      itself more configurable. Rather than just a single size, an executor\'s      thread pool may have different values for the core      and the max size. If a single value is provided      then the executor will have a fixed-size thread pool (the core and max      sizes are the same). However, the \'executor\' element\'s \'pool-size\'      attribute also accepts a range in the form of \"min-max\". &lt;task:executor id=\"executorWithPoolSizeRange\"                 pool-size=\"5-25\"                 queue-capacity=\"100\"/&gt;      \n\r\n\rAs you can see from that configuration, a \'queue-capacity\' value      has also been provided. The configuration of the thread pool should also      be considered in light of the executor\'s queue capacity. For the full      description of the relationship between pool size and queue capacity,      consult the documentation for ThreadPoolExecutor.      The main idea is that when a task is submitted, the executor will first      try to use a free thread if the number of active threads is currently      less than the core size. If the core size has been reached, then the      task will be added to the queue as long as its capacity has not yet been      reached. Only then, if the queue\'s capacity has      been reached, will the executor create a new thread beyond the core      size. If the max size has also been reached, then the executor will      reject the task.      \n\r\n\rBy default, the queue is unbounded, but this      is rarely the desired configuration, because it can lead to      OutOfMemoryErrors if enough tasks are added to      that queue while all pool threads are busy. Furthermore, if the queue is      unbounded, then the max size has no effect at all. Since the executor      will always try the queue before creating a new thread beyond the core      size, a queue must have a finite capacity for the thread pool to grow      beyond the core size (this is why a fixed size pool      is the only sensible case when using an unbounded queue).      \n\r\n\rIn a moment, we will review the effects of the keep-alive setting      which adds yet another factor to consider when providing a pool size      configuration. First, let\'s consider the case, as mentioned above, when      a task is rejected. By default, when a task is rejected, a thread pool      executor will throw a TaskRejectedException.      However, the rejection policy is actually configurable. The exception is      thrown when using the default rejection policy which is the      AbortPolicy implementation. For applications      where some tasks can be skipped under heavy load, either the      DiscardPolicy or      DiscardOldestPolicy may be configured instead.      Another option that works well for applications that need to throttle      the submitted tasks under heavy load is the      CallerRunsPolicy. Instead of throwing an      exception or discarding tasks, that policy will simply force the thread      that is calling the submit method to run the task itself. The idea is      that such a caller will be busy while running that task and not able to      submit other tasks immediately. Therefore it provides a simple way to      throttle the incoming load while maintaining the limits of the thread      pool and queue. Typically this allows the executor to \"catch up\" on the      tasks it is handling and thereby frees up some capacity on the queue, in      the pool, or both. Any of these options can be chosen from an      enumeration of values available for the \'rejection-policy\' attribute on      the \'executor\' element.      &lt;task:executor id=\"executorWithCallerRunsPolicy\"               pool-size=\"5-25\"               queue-capacity=\"100\"               rejection-policy=\"CALLER_RUNS\"/&gt;        27.5.3&nbsp;The \'scheduled-tasks\' element            \n\r\n\rThe most powerful feature of Spring\'s task namespace is the      support for configuring tasks to be scheduled within a Spring      Application Context. This follows an approach similar to other      \"method-invokers\" in Spring, such as that provided by the JMS namespace      for configuring Message-driven POJOs. Basically a \"ref\" attribute can      point to any Spring-managed object, and the \"method\" attribute provides      the name of a method to be invoked on that object. Here is a simple      example.      &lt;task:scheduled-tasks scheduler=\"myScheduler\"&gt;    &lt;task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\"/&gt;&lt;/task:scheduled-tasks&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt;      \n\r\n\rAs you can see, the scheduler is referenced by the outer element,      and each individual task includes the configuration of its trigger      metadata. In the preceding example, that metadata defines a periodic      trigger with a fixed delay indicating the number of milliseconds to wait      after each task execution has completed. Another option is \'fixed-rate\',      indicating how often the method should be executed regardless of how long      any previous execution takes. Additionally, for both fixed-delay and      fixed-rate tasks an \'initial-delay\' parameter may be specified indicating      the number of milliseconds to wait before the first execution of the      method. For more control, a \"cron\" attribute may be provided instead.      Here is an example demonstrating these other options.      &lt;task:scheduled-tasks scheduler=\"myScheduler\"&gt;    &lt;task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\" initial-delay=\"1000\"/&gt;    &lt;task:scheduled ref=\"beanB\" method=\"methodB\" fixed-rate=\"5000\"/&gt;    &lt;task:scheduled ref=\"beanC\" method=\"methodC\" cron=\"*/5 * * * * MON-FRI\"/&gt;&lt;/task:scheduled-tasks&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt;        27.6&nbsp;Using the Quartz Scheduler        \n\r\n\rQuartz uses Trigger,    Job and JobDetail objects to    realize scheduling of all kinds of jobs. For the basic concepts behind    Quartz, have a look at http://quartz-scheduler.org. For convenience    purposes, Spring offers a couple of classes that simplify the usage of    Quartz within Spring-based applications.    27.6.1&nbsp;Using the JobDetailBean            \n\r\n\rJobDetail objects contain all information      needed to run a job. The Spring Framework provides a      JobDetailBean that makes the      JobDetail more of an actual JavaBean with      sensible defaults. Let\'s have a look at an example:      &lt;bean name=\"exampleJob\" class=\"org.springframework.scheduling.quartz.JobDetailBean\"&gt;  &lt;property name=\"jobClass\" value=\"example.ExampleJob\" /&gt;  &lt;property name=\"jobDataAsMap\"&gt;    &lt;map&gt;      &lt;entry key=\"timeout\" value=\"5\" /&gt;    &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rThe job detail bean has all information it needs to run the job      (ExampleJob). The timeout is specified in the job      data map. The job data map is available through the      JobExecutionContext (passed to you at execution      time), but the JobDetailBean also maps the      properties from the job data map to properties of the actual job. So in      this case, if the ExampleJob contains a property      named timeout, the      JobDetailBean will automatically apply it:      package example;public class ExampleJob extends QuartzJobBean {  private int timeout;  /**   * Setter called after the ExampleJob is instantiated   * with the value from the JobDetailBean (5)   */  public void setTimeout(int timeout) {    this.timeout = timeout;  }  protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {      // do the actual work  }}      \n\r\n\rAll additional settings from the job detail bean are of course      available to you as well.      \n\r\n\rNote: Using the name and      group properties, you can modify the name and the      group of the job, respectively. By default, the name of the job matches      the bean name of the job detail bean (in the example above, this is      exampleJob).        27.6.2&nbsp;Using the      MethodInvokingJobDetailFactoryBean            \n\r\n\rOften you just need to invoke a method on a specific object. Using      the MethodInvokingJobDetailFactoryBean you can do      exactly this:      &lt;bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"exampleBusinessObject\" /&gt;  &lt;property name=\"targetMethod\" value=\"doIt\" /&gt;&lt;/bean&gt;      \n\r\n\rThe above example will result in the doIt      method being called on the exampleBusinessObject      method (see below):      public class ExampleBusinessObject {  // properties and collaborators  public void doIt() {    // do the actual work  }}      &lt;bean id=\"exampleBusinessObject\" class=\"examples.ExampleBusinessObject\"/&gt;      \n\r\n\rUsing the      MethodInvokingJobDetailFactoryBean, you don\'t      need to create one-line jobs that just invoke a method, and you only      need to create the actual business object and wire up the detail      object.      \n\r\n\rBy default, Quartz Jobs are stateless, resulting in the      possibility of jobs interfering with each other. If you specify two      triggers for the same JobDetail, it might be      possible that before the first job has finished, the second one will      start. If JobDetail classes implement the      Stateful interface, this won\'t happen.      The second job will not start before the first one has finished. To make      jobs resulting from the      MethodInvokingJobDetailFactoryBean      non-concurrent, set the concurrent flag to      false.      &lt;bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"exampleBusinessObject\" /&gt;  &lt;property name=\"targetMethod\" value=\"doIt\" /&gt;  &lt;property name=\"concurrent\" value=\"false\" /&gt;&lt;/bean&gt;      Note        \n\r\n\rBy default, jobs will run in a concurrent fashion.              27.6.3&nbsp;Wiring up jobs using triggers and the      SchedulerFactoryBean            \n\r\n\rWe\'ve created job details and jobs. We\'ve also reviewed the      convenience bean that allows you to invoke a method on a specific      object. Of course, we still need to schedule the jobs themselves. This      is done using triggers and a      SchedulerFactoryBean. Several triggers are      available within Quartz and Spring offers two Quartz FactoryBean      implementations with convenient defaults: CronTriggerFactoryBean and      SimpleTriggerFactoryBean.      \n\r\n\rTriggers need to be scheduled. Spring offers a      SchedulerFactoryBean that exposes triggers to be      set as properties. SchedulerFactoryBean schedules      the actual jobs with those triggers.      \n\r\n\rFind below a couple of examples:      &lt;bean id=\"simpleTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"&gt;    &lt;!-- see the example of method invoking job above --&gt;    &lt;property name=\"jobDetail\" ref=\"jobDetail\" /&gt;    &lt;!-- 10 seconds --&gt;    &lt;property name=\"startDelay\" value=\"10000\" /&gt;    &lt;!-- repeat every 50 seconds --&gt;    &lt;property name=\"repeatInterval\" value=\"50000\" /&gt;&lt;/bean&gt;&lt;bean id=\"cronTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt;    &lt;property name=\"jobDetail\" ref=\"exampleJob\" /&gt;    &lt;!-- run every morning at 6 AM --&gt;    &lt;property name=\"cronExpression\" value=\"0 0 6 * * ?\" /&gt;&lt;/bean&gt;      \n\r\n\rNow we\'ve set up two triggers, one running every 50 seconds with a      starting delay of 10 seconds and one every morning at 6 AM. To finalize      everything, we need to set up the      SchedulerFactoryBean:      &lt;bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt;    &lt;property name=\"triggers\"&gt;        &lt;list&gt;            &lt;ref bean=\"cronTrigger\" /&gt;            &lt;ref bean=\"simpleTrigger\" /&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rMore properties are available for the      SchedulerFactoryBean for you to set, such as the      calendars used by the job details, properties to customize Quartz with,      etc. Have a look at the SchedulerFactoryBean      Javadoc for more information.      Prev&nbsp;Up&nbsp;Next26.&nbsp;Email&nbsp;Home&nbsp;28.&nbsp;Dynamic language support","27. Task Execution and Scheduling","scr\\scheduling.html","         Appendix&nbsp;G.&nbsp;spring.tldPrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;G.&nbsp;spring.tld      G.1&nbsp;Introduction             \n\r\n\rOne of the view technologies you can use with the Spring Framework                    is Java Server Pages (JSPs). To help you implement views using Java Server Pages                    the Spring Framework provides you with some tags for evaluating errors, setting                    themes and outputting internationalized messages.       \n\r\n\rPlease note that the various tags generated by this form tag library                    are compliant with the XHTML-1.0-Strict specification and attendant DTD.       \n\r\n\rThis appendix describes the spring.tld tag library.       \n\r             Section&nbsp;G.2, &#8220;The bind tag&#8221;          \n\r             Section&nbsp;G.3, &#8220;The escapeBody tag&#8221;          \n\r             Section&nbsp;G.4, &#8220;The hasBindErrors tag&#8221;          \n\r             Section&nbsp;G.5, &#8220;The htmlEscape tag&#8221;          \n\r             Section&nbsp;G.6, &#8220;The message tag&#8221;          \n\r             Section&nbsp;G.7, &#8220;The nestedPath tag&#8221;          \n\r             Section&nbsp;G.8, &#8220;The theme tag&#8221;          \n\r             Section&nbsp;G.9, &#8220;The transform tag&#8221;          \n\r             Section&nbsp;G.10, &#8220;The url tag&#8221;          \n\r             Section&nbsp;G.11, &#8220;The eval tag&#8221;          \n\r      G.2&nbsp;The bind tag            \n\r\n\r            Provides BindStatus object for the given bind path.            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \"defaultHtmlEscape\" context-param in web.xml).              \n\r\n\rTable&nbsp;G.1.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value. Overrides            the default HTML escaping setting for the current page.                                       \n\r\n\rignoreNestedPath                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet whether to ignore a nested path, if any. Default is to not ignore.                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe path to the bean or bean property to bind status            information for. For instance account.name, company.address.zipCode            or just employee. The status object will exported to the page scope,            specifically for this bean or bean property                        \n\r      G.3&nbsp;The escapeBody tag            \n\r\n\r            Escapes its enclosed body content, applying HTML escaping and/or JavaScript escaping.            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \"defaultHtmlEscape\" context-param in web.xml).              \n\r\n\rTable&nbsp;G.2.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value. Overrides the            default HTML escaping setting for the current page.                                       \n\r\n\rjavaScriptEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet JavaScript escaping for this tag, as boolean value.            Default is false.                        \n\r      G.4&nbsp;The hasBindErrors tag            \n\r\n\r            Provides Errors instance in case of bind errors.            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \"defaultHtmlEscape\" context-param in web.xml).              \n\r\n\rTable&nbsp;G.3.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value.            Overrides the default HTML escaping setting for the current page.                                       \n\r\n\rname                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe name of the bean in the request, that needs to be            inspected for errors. If errors are available for this bean, they            will be bound under the \'errors\' key.                        \n\r      G.5&nbsp;The htmlEscape tag            \n\r\n\r            Sets default HTML escape value for the current page.            Overrides a \"defaultHtmlEscape\" context-param in web.xml, if any.              \n\r\n\rTable&nbsp;G.4.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rdefaultHtmlEscape                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rSet the default value for HTML escaping, to be put                into the current PageContext.                        \n\r      G.6&nbsp;The message tag            \n\r\n\r            Retrieves the message with the given code, or text if code isn\'t resolvable.            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \"defaultHtmlEscape\" context-param in web.xml).              \n\r\n\rTable&nbsp;G.5.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rarguments                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet optional message arguments for this tag, as a            (comma-)delimited String (each String argument can contain JSP EL),            an Object array (used as argument array), or a single Object (used            as single argument).                                       \n\r\n\rargumentSeparator                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe separator character to be used for splitting the            arguments string value; defaults to a \'comma\' (\',\').                                       \n\r\n\rcode                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe code (key) to use when looking up the message.            If code is not provided, the text attribute will be used.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value.            Overrides the default HTML escaping setting for the current page.                                       \n\r\n\rjavaScriptEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet JavaScript escaping for this tag, as boolean value. Default is false.                                       \n\r\n\rmessage                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rA MessageSourceResolvable argument (direct or through JSP EL).                Fits nicely when used in conjunction with Spring\'s own validation error                classes which all implement the MessageSourceResolvable interface. For                example, this allows you to iterate over all of the errors in a form,                passing each error (using a runtime expression) as the value of this                \'message\' attribute, thus effecting the easy display of such error                messages.                                       \n\r\n\rscope                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe scope to use when exporting the result to a variable.            This attribute is only used when var is also set. Possible values are            page, request, session and application.                                       \n\r\n\rtext                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rDefault text to output when a message for the given code            could not be found. If both text and code are not set, the tag will            output null.                                       \n\r\n\rvar                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe string to use when binding the result to the page,            request, session or application scope. If not specified, the result            gets outputted to the writer (i.e. typically directly to the JSP).                        \n\r      G.7&nbsp;The nestedPath tag            \n\r\n\r            Sets a nested path to be used by the bind tag\'s path.              \n\r\n\rTable&nbsp;G.6.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rSet the path that this tag should apply. E.g. \'customer\'            to allow bind paths like \'address.street\' rather than            \'customer.address.street\'.                        \n\r      G.8&nbsp;The theme tag            \n\r\n\r            Retrieves the theme message with the given code, or text if code isn\'t resolvable.            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \"defaultHtmlEscape\" context-param in web.xml).              \n\r\n\rTable&nbsp;G.7.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rarguments                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet optional message arguments for this tag, as a            (comma-)delimited String (each String argument can contain JSP EL),            an Object array (used as argument array), or a single Object (used            as single argument).                                       \n\r\n\rargumentSeparator                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe separator character to be used for splitting the            arguments string value; defaults to a \'comma\' (\',\').                                       \n\r\n\rcode                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe code (key) to use when looking up the message.            If code is not provided, the text attribute will be used.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value.            Overrides the default HTML escaping setting for the current page.                                       \n\r\n\rjavaScriptEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet JavaScript escaping for this tag, as boolean value. Default is false.                                       \n\r\n\rmessage                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rA MessageSourceResolvable argument (direct or through JSP EL).                                       \n\r\n\rscope                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe scope to use when exporting the result to a variable.            This attribute is only used when var is also set. Possible values are            page, request, session and application.                                       \n\r\n\rtext                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rDefault text to output when a message for the given code            could not be found. If both text and code are not set, the tag will            output null.                                       \n\r\n\rvar                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe string to use when binding the result to the page,            request, session or application scope. If not specified, the result            gets outputted to the writer (i.e. typically directly to the JSP).                        \n\r      G.9&nbsp;The transform tag            \n\r\n\r            Provides transformation of variables to Strings, using an appropriate            custom PropertyEditor from BindTag (can only be used inside BindTag).            The HTML escaping flag participates in a page-wide or application-wide setting            (i.e. by HtmlEscapeTag or a \'defaultHtmlEscape\' context-param in web.xml).              \n\r\n\rTable&nbsp;G.8.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as boolean value. Overrides            the default HTML escaping setting for the current page.                                       \n\r\n\rscope                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe scope to use when exported the result to a variable.            This attribute is only used when var is also set. Possible values are            page, request, session and application.                                       \n\r\n\rvalue                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe value to transform. This is the actual object you want            to have transformed (for instance a Date). Using the PropertyEditor that            is currently in use by the \'spring:bind\' tag.                                       \n\r\n\rvar                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe string to use when binding the result to the page,            request, session or application scope. If not specified, the result gets            outputted to the writer (i.e. typically directly to the JSP).                        \n\r      G.10&nbsp;The url tag            \n\r\n\r            Creates URLs with support for URI template variables, HTML/XML escaping, and Javascript escaping.            Modeled after the JSTL c:url tag with backwards compatibility in mind.              \n\r\n\rTable&nbsp;G.9.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rurl                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe URL to build. This value can include template {placeholders}            that are replaced with the URL encoded value of the named parameter.  Parameters            must be defined using the param tag inside the body of this tag.                                       \n\r\n\rcontext                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSpecifies a remote application context path.  The default is the            current application context path.                                       \n\r\n\rvar                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe name of the variable to export the URL value to.                     If not specified the URL is written as output.                                       \n\r\n\rscope                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe scope for the var.  \'application\', \'session\', \'request\' and            \'page\' scopes are supported.  Defaults to page scope.  This attribute has no            effect unless the var attribute is also defined.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as a boolean value. Overrides the            default HTML escaping setting for the current page.                                       \n\r\n\rjavaScriptEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet JavaScript escaping for this tag, as a boolean value.            Default is false.                        \n\r      G.11&nbsp;The eval tag            \n\r\n\r            Evaluates a Spring expression (SpEL) and either prints the result or assigns it to a variable.              \n\r\n\rTable&nbsp;G.10.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rexpression                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe expression to evaluate.                                       \n\r\n\rvar                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe name of the variable to export the evaluation result to.                     If not specified the evaluation result is converted to a String and written as output.                                       \n\r\n\rscope                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe scope for the var.  \'application\', \'session\', \'request\' and            \'page\' scopes are supported.  Defaults to page scope.  This attribute has no            effect unless the var attribute is also defined.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet HTML escaping for this tag, as a boolean value. Overrides the            default HTML escaping setting for the current page.                                       \n\r\n\rjavaScriptEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSet JavaScript escaping for this tag, as a boolean value.            Default is false.                        \n\r   Prev&nbsp;Up&nbsp;NextAppendix&nbsp;F.&nbsp;Extensible XML authoring&nbsp;Home&nbsp;Appendix&nbsp;H.&nbsp;spring-form.tld","G. spring.tld","scr\\spring.tld.html","         Part&nbsp;VII.&nbsp;AppendicesPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;VII.&nbsp;Appendices                                      Prev&nbsp;&nbsp;&nbsp;Next29.&nbsp;Cache Abstraction&nbsp;Home&nbsp;Appendix&nbsp;A.&nbsp;Classic Spring Usage","VII. Appendices","scr\\spring-appendices.html","         Part&nbsp;III.&nbsp;Core TechnologiesPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;III.&nbsp;Core Technologies              \n\r\n\rThis part of the reference documentation covers all of those      technologies that are absolutely integral to the Spring      Framework.      \n\r\n\rForemost amongst these is the Spring Framework\'s Inversion of      Control (IoC) container. A thorough treatment of the Spring Framework\'s      IoC container is closely followed by comprehensive coverage of Spring\'s      Aspect-Oriented Programming (AOP) technologies. The Spring Framework has      its own AOP framework, which is conceptually easy to understand, and      which successfully addresses the 80% sweet spot of AOP requirements in      Java enterprise programming.      \n\r\n\rCoverage of Spring\'s integration with AspectJ (currently the      richest - in terms of features - and certainly most mature AOP      implementation in the Java enterprise space) is also provided.      \n\r\n\rFinally, the adoption of the test-driven-development (TDD)      approach to software development is certainly advocated by the Spring      team, and so coverage of Spring\'s support for integration testing is      covered (alongside best practices for unit testing). The Spring team has      found that the correct use of IoC certainly does make both unit and      integration testing easier (in that the presence of setter methods and      appropriate constructors on classes makes them easier to wire together      in a test without having to set up service locator registries and      suchlike)... the chapter dedicated solely to testing will hopefully      convince you of this as well.      \n\r          \n\r\n\rChapter&nbsp;5, The IoC container        \n\r          \n\r\n\rChapter&nbsp;6, Resources        \n\r          \n\r\n\rChapter&nbsp;7, Validation, Data Binding, and Type Conversion        \n\r          \n\r\n\rChapter&nbsp;8, Spring Expression Language (SpEL)        \n\r          \n\r\n\rChapter&nbsp;9, Aspect Oriented Programming with Spring        \n\r          \n\r\n\rChapter&nbsp;10, Spring AOP APIs        \n\r          \n\r\n\rChapter&nbsp;11, Testing        \n\r                                  Prev&nbsp;&nbsp;&nbsp;Next4.&nbsp;New Features and Enhancements in Spring Framework 3.2&nbsp;Home&nbsp;5.&nbsp;The IoC container","III. Core Technologies","scr\\spring-core.html","         Part&nbsp;IV.&nbsp;Data AccessPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;IV.&nbsp;Data Access              \n\r\n\rThis part of the reference documentation is concerned with data      access and the interaction between the data access layer and the      business or service layer.      \n\r\n\rSpring\'s comprehensive transaction management support is covered      in some detail, followed by thorough coverage of the various data access      frameworks and technologies that the Spring Framework integrates      with.      \n\r          \n\r\n\rChapter&nbsp;12, Transaction Management        \n\r          \n\r\n\rChapter&nbsp;13, DAO support        \n\r          \n\r\n\rChapter&nbsp;14, Data access with JDBC        \n\r          \n\r\n\rChapter&nbsp;15, Object Relational Mapping (ORM) Data Access        \n\r          \n\r\n\rChapter&nbsp;16, Marshalling XML using O/X Mappers        \n\r                          Prev&nbsp;&nbsp;&nbsp;Next11.&nbsp;Testing&nbsp;Home&nbsp;12.&nbsp;Transaction Management","IV. Data Access","scr\\spring-data-tier.html","         Appendix&nbsp;H.&nbsp;spring-form.tldPrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;Appendix&nbsp;H.&nbsp;spring-form.tld      H.1&nbsp;Introduction             \n\r\n\rOne of the view technologies you can use with the Spring Framework                    is Java Server Pages (JSPs). To help you implement views using Java Server Pages                    the Spring Framework provides you with some tags for evaluating errors, setting                    themes and outputting internationalized messages.       \n\r\n\rPlease note that the various tags generated by this form tag library                    are compliant with the XHTML-1.0-Strict specification and attendant DTD.       \n\r\n\rThis appendix describes the spring-form.tld tag library.       \n\r             Section&nbsp;H.2, &#8220;The checkbox tag&#8221;          \n\r             Section&nbsp;H.3, &#8220;The checkboxes tag&#8221;          \n\r             Section&nbsp;H.4, &#8220;The errors tag&#8221;          \n\r             Section&nbsp;H.5, &#8220;The form tag&#8221;          \n\r             Section&nbsp;H.6, &#8220;The hidden tag&#8221;          \n\r             Section&nbsp;H.7, &#8220;The input tag&#8221;          \n\r             Section&nbsp;H.8, &#8220;The label tag&#8221;          \n\r             Section&nbsp;H.9, &#8220;The option tag&#8221;          \n\r             Section&nbsp;H.10, &#8220;The options tag&#8221;          \n\r             Section&nbsp;H.11, &#8220;The password tag&#8221;          \n\r             Section&nbsp;H.12, &#8220;The radiobutton tag&#8221;          \n\r             Section&nbsp;H.13, &#8220;The radiobuttons tag&#8221;          \n\r             Section&nbsp;H.14, &#8220;The select tag&#8221;          \n\r             Section&nbsp;H.15, &#8220;The textarea tag&#8221;          \n\r      H.2&nbsp;The checkbox tag            \n\r\n\rRenders an HTML \'input\' tag with type \'checkbox\'.      \n\r\n\rTable&nbsp;H.1.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rValue to be displayed as part of the tag                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rvalue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                        \n\r      H.3&nbsp;The checkboxes tag            \n\r\n\rRenders multiple HTML \'input\' tags with type \'checkbox\'.      \n\r\n\rTable&nbsp;H.2.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdelimiter                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rDelimiter to use between each \'input\' tag with type \'checkbox\'. There is no delimiter by default.                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\relement                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSpecifies the HTML element that is used to enclose each \'input\' tag with type \'checkbox\'.  Defaults to \'span\'.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ritemLabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rValue to be displayed as part of the \'input\' tags with type \'checkbox\'                                       \n\r\n\ritems                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe Collection, Map or array of objects used to generate the \'input\' tags with type \'checkbox\'                                       \n\r\n\ritemValue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to \'value\' attribute of the \'input\' tags with type \'checkbox\'                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.4&nbsp;The errors tag            \n\r\n\rRenders field errors in an HTML \'span\' tag.      \n\r\n\rTable&nbsp;H.3.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdelimiter                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rDelimiter for displaying multiple error messages. Defaults to the br tag.                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\relement                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSpecifies the HTML element that is used to render the enclosing errors.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rPath to errors object for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.5&nbsp;The form tag            \n\r\n\rRenders an HTML \'form\' tag and exposes a binding path to inner tags for binding.      \n\r\n\rTable&nbsp;H.4.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\racceptCharset                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSpecifies the list of character encodings for input data that is accepted by the server processing this form. The value is a space- and/or comma-delimited list of charset values. The client must interpret this list as an exclusive-or list, i.e., the server is able to accept any single character encoding per entity received.                                       \n\r\n\raction                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Required Attribute                                       \n\r\n\rcommandName                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the model attribute under which the form object is exposed.                Defaults to \'command\'.                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\renctype                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rmethod                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rmodelAttribute                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the model attribute under which the form object is exposed.                Defaults to \'command\'.                                       \n\r\n\rname                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute - added for backwards compatibility cases                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronreset                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronsubmit                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rtarget                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.6&nbsp;The hidden tag            \n\r\n\rRenders an HTML \'input\' tag with type \'hidden\' using the bound value.      \n\r\n\rTable&nbsp;H.5.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                        \n\r      H.7&nbsp;The input tag            \n\r\n\rRenders an HTML \'input\' tag with type \'text\' using the bound value.      \n\r\n\rTable&nbsp;H.6.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ralt                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rautocomplete                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rCommon Optional Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rmaxlength                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronselect                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rreadonly                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will make the HTML element readonly.                                       \n\r\n\rsize                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.8&nbsp;The label tag            \n\r\n\rRenders a form field label in an HTML \'label\' tag.      \n\r\n\rTable&nbsp;H.7.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute.                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used only when errors are present.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rfor                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to errors object for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.9&nbsp;The option tag            \n\r\n\rRenders a single HTML \'option\'. Sets \'selected\' as appropriate based on bound value.      \n\r\n\rTable&nbsp;H.8.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rvalue                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                        \n\r      H.10&nbsp;The options tag            \n\r\n\rRenders a list of HTML \'option\' tags. Sets \'selected\' as appropriate based on bound value.      \n\r\n\rTable&nbsp;H.9.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ritemLabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to the inner text of the \'option\' tag                                       \n\r\n\ritems                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe Collection, Map or array of objects used to generate the inner \'option\' tags                                       \n\r\n\ritemValue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to \'value\' attribute of the \'option\' tag                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.11&nbsp;The password tag            \n\r\n\rRenders an HTML \'input\' tag with type \'password\' using the bound value.      \n\r\n\rTable&nbsp;H.10.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ralt                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rautocomplete                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rCommon Optional Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rmaxlength                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronselect                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rreadonly                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will make the HTML element readonly.                                       \n\r\n\rshowPassword                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rIs the password value to be shown? Defaults to false.                                       \n\r\n\rsize                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.12&nbsp;The radiobutton tag            \n\r\n\rRenders an HTML \'input\' tag with type \'radio\'.      \n\r\n\rTable&nbsp;H.11.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rValue to be displayed as part of the tag                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rvalue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                        \n\r      H.13&nbsp;The radiobuttons tag            \n\r\n\rRenders multiple HTML \'input\' tags with type \'radio\'.      \n\r\n\rTable&nbsp;H.12.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdelimiter                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rDelimiter to use between each \'input\' tag with type \'radio\'. There is no delimiter by default.                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\relement                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rSpecifies the HTML element that is used to enclose each \'input\' tag with type \'radio\'.  Defaults to \'span\'.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ritemLabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rValue to be displayed as part of the \'input\' tags with type \'radio\'                                       \n\r\n\ritems                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rThe Collection, Map or array of objects used to generate the \'input\' tags with type \'radio\'                                       \n\r\n\ritemValue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to \'value\' attribute of the \'input\' tags with type \'radio\'                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.14&nbsp;The select tag            \n\r\n\rRenders an HTML \'select\' element. Supports databinding to the selected option.      \n\r\n\rTable&nbsp;H.13.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ritemLabel                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to the inner text of the \'option\' tag                                       \n\r\n\ritems                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rThe Collection, Map or array of objects used to generate the inner \'option\' tags                                       \n\r\n\ritemValue                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rName of the property mapped to \'value\' attribute of the \'option\' tag                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rmultiple                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rsize                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r      H.15&nbsp;The textarea tag            \n\r\n\rRenders an HTML \'textarea\'.      \n\r\n\rTable&nbsp;H.14.&nbsp;Attributes                  AttributeRequired?Runtime Expression?Description                     \n\r\n\raccesskey                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rcols                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Required Attribute                                       \n\r\n\rcssClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute                                       \n\r\n\rcssErrorClass                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"class\" - HTML Optional Attribute. Used when the bound field has errors.                                       \n\r\n\rcssStyle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEquivalent to \"style\" - HTML Optional Attribute                                       \n\r\n\rdir                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rdisabled                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will disable the HTML element.                                       \n\r\n\rhtmlEscape                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rEnable/disable HTML escaping of rendered values.                                       \n\r\n\rid                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rlang                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\ronblur                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronchange                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rondblclick                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronfocus                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeydown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeypress                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronkeyup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousedown                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmousemove                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseout                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseover                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronmouseup                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\ronselect                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Event Attribute                                       \n\r\n\rpath                                       \n\r\n\rtrue                                       \n\r\n\rtrue                                       \n\r\n\rPath to property for data binding                                       \n\r\n\rreadonly                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Optional Attribute. Setting the value of this attribute to \'true\' (without the quotes) will make the HTML element readonly.                                       \n\r\n\rrows                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Required Attribute                                       \n\r\n\rtabindex                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                                       \n\r\n\rtitle                                       \n\r\n\rfalse                                       \n\r\n\rtrue                                       \n\r\n\rHTML Standard Attribute                        \n\r   Prev&nbsp;Up&nbsp;Appendix&nbsp;G.&nbsp;spring.tld&nbsp;Home&nbsp;","H. spring-form.tld","scr\\spring-form.tld.html","         Part&nbsp;VI.&nbsp;IntegrationPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;VI.&nbsp;Integration              \n\r\n\rThis part of the reference documentation covers the Spring      Framework\'s integration with a number of Java EE (and related)      technologies.      \n\r          \n\r\n\rChapter&nbsp;21, Remoting and web services using Spring        \n\r          \n\r\n\rChapter&nbsp;22, Enterprise JavaBeans (EJB) integration        \n\r          \n\r\n\rChapter&nbsp;23, JMS (Java Message Service)        \n\r          \n\r\n\rChapter&nbsp;24, JMX        \n\r          \n\r\n\rChapter&nbsp;25, JCA CCI        \n\r          \n\r\n\rChapter&nbsp;26, Email        \n\r          \n\r\n\rChapter&nbsp;27, Task Execution and Scheduling        \n\r          \n\r\n\rChapter&nbsp;28, Dynamic language support        \n\r          \n\r\n\rChapter&nbsp;29, Cache Abstraction        \n\r                                          Prev&nbsp;&nbsp;&nbsp;Next20.&nbsp;Portlet MVC Framework&nbsp;Home&nbsp;21.&nbsp;Remoting and web services using Spring","VI. Integration","scr\\spring-integration.html","         Part&nbsp;I.&nbsp;Overview of Spring FrameworkPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;I.&nbsp;Overview of Spring Framework              \n\r\n\rThe Spring Framework is a lightweight solution and a potential      one-stop-shop for building your enterprise-ready applications. However,      Spring is modular, allowing you to use only those parts that you need,      without having to bring in the rest. You can use the IoC container, with      Struts on top, but you can also use only the Hibernate integration code or the JDBC abstraction layer. The Spring      Framework supports declarative transaction management, remote access to      your logic through RMI or web services, and various options for      persisting your data. It offers a full-featured MVC framework, and enables you to      integrate AOP transparently into      your software.      \n\r\n\rSpring is designed to be non-intrusive, meaning that your domain      logic code generally has no dependencies on the framework itself. In      your integration layer (such as the data access layer), some      dependencies on the data access technology and the Spring libraries will      exist. However, it should be easy to isolate these dependencies from the      rest of your code base.      \n\r\n\rThis document is a reference guide to Spring Framework features.      If you have any requests, comments, or questions on this document,      please post them on the user mailing list or on the support forums at      http://forum.springsource.org/.          Prev&nbsp;&nbsp;&nbsp;NextSpring Framework Reference Documentation&nbsp;Home&nbsp;1.&nbsp;Introduction to Spring Framework","I. Overview of Spring Framework","scr\\spring-introduction.html","         Part&nbsp;V.&nbsp;The WebPrev&nbsp;&nbsp;&nbsp;NextPart&nbsp;V.&nbsp;The Web              \n\r\n\rThis part of the reference documentation covers the Spring      Framework\'s support for the presentation tier (and specifically      web-based presentation tiers).      \n\r\n\rThe Spring Framework\'s own web framework, Spring Web MVC, is covered in the first couple of      chapters. A number of the remaining chapters in this part of the      reference documentation are concerned with the Spring Framework\'s      integration with other web technologies, such as Struts and JSF (to      name but two).      \n\r\n\rThis section concludes with coverage of Spring\'s MVC portlet framework.      \n\r          \n\r\n\rChapter&nbsp;17, Web MVC framework        \n\r          \n\r\n\rChapter&nbsp;18, View technologies        \n\r          \n\r\n\rChapter&nbsp;19, Integrating with other web frameworks        \n\r          \n\r\n\rChapter&nbsp;20, Portlet MVC Framework        \n\r                      Prev&nbsp;&nbsp;&nbsp;Next16.&nbsp;Marshalling XML using O/X Mappers&nbsp;Home&nbsp;17.&nbsp;Web MVC framework","V. The Web","scr\\spring-web.html","         Part&nbsp;II.&nbsp;What\'s New in Spring 3Prev&nbsp;&nbsp;&nbsp;NextPart&nbsp;II.&nbsp;What\'s New in Spring 3                  Prev&nbsp;&nbsp;&nbsp;Next1.&nbsp;Introduction to Spring Framework&nbsp;Home&nbsp;2.&nbsp;New Features and Enhancements in Spring Framework 3.0","II. What\'s New in Spring 3","scr\\spring-whats-new.html","         11.&nbsp;TestingPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next11.&nbsp;Testing    11.1&nbsp;Introduction to Spring Testing        \n\r\n\rTesting is an integral part of enterprise software development. This    chapter focuses on the value-add of the IoC principle to unit testing and on the benefits of the Spring    Framework\'s support for integration    testing. (A thorough treatment of testing in the enterprise    is beyond the scope of this reference manual.)    11.2&nbsp;Unit Testing        \n\r\n\rDependency Injection should make your code less dependent on the    container than it would be with traditional Java EE development. The POJOs    that make up your application should be testable in JUnit or TestNG tests,    with objects simply instantiated using the new operator,    without Spring or any other container. You can use    mock objects (in conjunction with other    valuable testing techniques) to test your code in isolation. If you follow    the architecture recommendations for Spring, the resulting clean layering    and componentization of your codebase will facilitate easier unit testing.    For example, you can test service layer objects by stubbing or mocking DAO    or Repository interfaces, without needing to access persistent data while    running unit tests.    \n\r\n\rTrue unit tests typically run extremely quickly, as there is no    runtime infrastructure to set up. Emphasizing true unit tests as part of    your development methodology will boost your productivity. You may not need    this section of the testing chapter to help you write effective unit tests    for your IoC-based applications. For certain unit testing scenarios,    however, the Spring Framework provides the following mock objects and    testing support classes.    11.2.1&nbsp;Mock Objects            Environment                \n\r\n\rThe org.springframework.mock.env package        contains mock implementations of the        Environment and        PropertySource abstractions introduced in        Spring 3.1 (see Section&nbsp;3.3, &#8220;Environment Abstraction&#8221; and        Section&nbsp;3.4, &#8220;PropertySource Abstraction&#8221;).        MockEnvironment and        MockPropertySource are useful for developing        out-of-container tests for code that depends on        environment-specific properties.            JNDI                \n\r\n\rThe org.springframework.mock.jndi package        contains an implementation of the JNDI SPI, which you can use to set up        a simple JNDI environment for test suites or stand-alone applications.        If, for example, JDBC DataSources get bound to        the same JNDI names in test code as within a Java EE container, you can        reuse both application code and configuration in testing scenarios        without modification.            Servlet API                \n\r\n\rThe org.springframework.mock.web package        contains a comprehensive set of Servlet API mock objects, targeted at        usage with Spring\'s Web MVC framework, which are useful for testing web        contexts and controllers. These mock objects are generally more        convenient to use than dynamic mock objects such as EasyMock or existing Servlet        API mock objects such as MockObjects.            Portlet API                \n\r\n\rThe org.springframework.mock.web.portlet        package contains a set of Portlet API mock objects, targeted at usage        with Spring\'s Portlet MVC framework.              11.2.2&nbsp;Unit Testing support Classes            General utilities                \n\r\n\rThe org.springframework.test.util package        contains ReflectionTestUtils, which is a        collection of reflection-based utility methods. Developers use these        methods in unit and integration testing scenarios in which they need to        set a non-public field or invoke a        non-public setter method when testing application        code involving, for example:        \n\r            \n\r\n\rORM frameworks such as JPA and Hibernate that condone            private or protected field            access as opposed to public setter methods for            properties in a domain entity.          \n\r            \n\r\n\rSpring\'s support for annotations such as            @Autowired,            @Inject, and            @Resource, which provides dependency            injection for private or            protected fields, setter methods, and            configuration methods.          \n\r            Spring MVC                \n\r\n\rThe org.springframework.test.web package        contains ModelAndViewAssert, which you can use in        combination with JUnit, TestNG, or any other testing framework for unit        tests dealing with Spring MVC ModelAndView        objects.        Unit testing Spring MVC Controllers                    \n\r\n\rTo test your Spring MVC Controllers, use          ModelAndViewAssert combined with          MockHttpServletRequest,          MockHttpSession, and so on from the           org.springframework.mock.web package.                      11.3&nbsp;Integration Testing        11.3.1&nbsp;Overview            \n\r\n\rIt is important to be able to perform some integration testing      without requiring deployment to your application server or connecting to      other enterprise infrastructure. This will enable you to test things such      as:      \n\r          \n\r\n\rThe correct wiring of your Spring IoC container contexts.        \n\r          \n\r\n\rData access using JDBC or an ORM tool. This would include such          things as the correctness of SQL statements, Hibernate queries, JPA          entity mappings, etc.        \n\r      \n\r\n\rThe Spring Framework provides first-class support for integration      testing in the spring-test      module. The name of the actual JAR file might include the release version      and might also be in the long      org.springframework.test form, depending on where you      get it from (see the section on      Dependency Management for an explanation). This library includes      the org.springframework.test package, which contains      valuable classes for integration testing with a Spring container. This      testing does not rely on an application server or other deployment      environment. Such tests are slower to run than unit tests but much faster      than the equivalent Cactus tests or remote tests that rely on deployment      to an application server.      \n\r\n\rIn Spring 2.5 and later, unit and integration testing support is      provided in the form of the annotation-driven Spring TestContext Framework. The      TestContext framework is agnostic of the actual testing framework in use,      thus allowing instrumentation of tests in various environments including      JUnit, TestNG, and so on.      JUnit 3.8 support is deprecated                \n\r\n\rAs of Spring 3.0, the legacy JUnit 3.8 base class hierarchy (i.e.,        AbstractDependencyInjectionSpringContextTests,        AbstractTransactionalDataSourceSpringContextTests,        etc.) is officially deprecated and will be removed in a later release.        Any test classes based on this code should be migrated to the Spring TestContext        Framework.        \n\r\n\rAs of Spring 3.1, the JUnit 3.8 base classes in the Spring        TestContext Framework (i.e.,        AbstractJUnit38SpringContextTests and        AbstractTransactionalJUnit38SpringContextTests)        and @ExpectedException have been        officially deprecated and will be removed in a later release. Any test        classes based on this code should be migrated to the JUnit 4 or TestNG        support provided by the Spring        TestContext Framework. Similarly, any test methods annotated with        @ExpectedException should be modified to        use the built-in support for expected exceptions in JUnit and        TestNG.              11.3.2&nbsp;Goals of Integration Testing            \n\r\n\rSpring\'s integration testing support has the following primary      goals:      \n\r          \n\r\n\rTo manage Spring IoC          container caching between test execution.        \n\r          \n\r\n\rTo provide Dependency          Injection of test fixture instances.        \n\r          \n\r\n\rTo provide transaction          management appropriate to integration testing.        \n\r          \n\r\n\rTo supply Spring-specific base classes          that assist developers in writing integration tests.        \n\r      \n\r\n\rThe next few sections describe each goal and provide links to      implementation and configuration details.      Context management and caching                \n\r\n\rThe Spring TestContext Framework provides consistent loading of        Spring ApplicationContexts and        WebApplicationContexts as well as caching of        those contexts. Support for the caching of loaded contexts is important,        because startup time can become an issue &#8212; not because of the overhead        of Spring itself, but because the objects instantiated by the Spring        container take time to instantiate. For example, a project with 50 to        100 Hibernate mapping files might take 10 to 20 seconds to load the        mapping files, and incurring that cost before running every test in        every test fixture leads to slower overall test runs that reduce        developer productivity.        \n\r\n\rTest classes typically declare either an array of        resource locations for XML configuration metadata &#8212;        often in the classpath &#8212; or an array of annotated        classes that is used to configure the application. These        locations or classes are the same as or similar to those specified in        web.xml or other deployment configuration        files.        \n\r\n\rBy default, once loaded, the configured        ApplicationContext is reused for each        test. Thus the setup cost is incurred only once per test suite, and        subsequent test execution is much faster. In this context, the term        test suite means all tests run in the same JVM &#8212;        for example, all tests run from an Ant, Maven, or Gradle build for a        given project or module. In the unlikely case that a test corrupts the        application context and requires reloading &#8212; for example, by modifying a        bean definition or the state of an application object &#8212; the TestContext        framework can be configured to reload the configuration and rebuild the        application context before executing the next test.        \n\r\n\rSee the section called &#8220;Context management&#8221; and the section called &#8220;Context caching&#8221; with the TestContext        framework.            Dependency Injection of test fixtures                \n\r\n\rWhen the TestContext framework loads your application context, it        can optionally configure instances of your test classes via Dependency        Injection. This provides a convenient mechanism for setting up test        fixtures using preconfigured beans from your application context. A        strong benefit here is that you can reuse application contexts across        various testing scenarios (e.g., for configuring Spring-managed object        graphs, transactional proxies, DataSources,        etc.), thus avoiding the need to duplicate complex test fixture setup        for individual test cases.        \n\r\n\rAs an example, consider the scenario where we have a class,        HibernateTitleRepository, that implements data        access logic for a Title domain entity. We want        to write integration tests that test the following areas:        \n\r            \n\r\n\rThe Spring configuration: basically, is everything related to            the configuration of the            HibernateTitleRepository bean correct and            present?          \n\r            \n\r\n\rThe Hibernate mapping file configuration: is everything mapped            correctly, and are the correct lazy-loading settings in            place?          \n\r            \n\r\n\rThe logic of the            HibernateTitleRepository: does the configured            instance of this class perform as anticipated?          \n\r        \n\r\n\rSee dependency injection of test fixtures with the TestContext framework.            Transaction management                \n\r\n\rOne common issue in tests that access a real database is their        effect on the state of the persistence store. Even when you\'re using a        development database, changes to the state may affect future tests.        Also, many operations &#8212; such as inserting or modifying persistent data &#8212;        cannot be performed (or verified) outside a transaction.        \n\r\n\rThe TestContext framework addresses this issue. By default, the        framework will create and roll back a transaction for each test. You        simply write code that can assume the existence of a transaction. If you        call transactionally proxied objects in your tests, they will behave        correctly, according to their configured transactional semantics. In        addition, if a test method deletes the contents of selected tables while        running within the transaction managed for the test, the transaction        will roll back by default, and the database will return to its state        prior to execution of the test. Transactional support is provided to a        test via a PlatformTransactionManager bean        defined in the test\'s application context.        \n\r\n\rIf you want a transaction to commit &#8212; unusual, but occasionally        useful when you want a particular test to populate or modify the        database &#8212; the TestContext framework can be instructed to cause the        transaction to commit instead of roll back via the @TransactionConfiguration        and @Rollback        annotations.        \n\r\n\rSee transaction management with the TestContext framework.            Support classes for integration testing                \n\r\n\rThe Spring TestContext Framework provides several        abstract support classes that simplify the writing of        integration tests. These base test classes provide well-defined hooks        into the testing framework as well as convenient instance variables and        methods, which enable you to access:        \n\r            \n\r\n\rThe ApplicationContext, for performing            explicit bean lookups or testing the state of the context as a            whole.          \n\r            \n\r\n\rA JdbcTemplate, for executing SQL            statements to query the database. Such queries can be used to            confirm database state both prior to and            after execution of database-related application            code, and Spring ensures that such queries run in the scope of the            same transaction as the application code. When used in conjunction            with an ORM tool, be sure to avoid false            positives.          \n\r        \n\r\n\rIn addition, you may want to create your own custom,        application-wide superclass with instance variables and methods specific        to your project.        \n\r\n\rSee support classes for the TestContext        framework.              11.3.3&nbsp;JDBC Testing Support            \n\r\n\rThe org.springframework.test.jdbc package      contains JdbcTestUtils, which is a collection of      JDBC related utility functions intended to simplify standard database      testing scenarios. Note that AbstractTransactionalJUnit4SpringContextTests      and AbstractTransactionalTestNGSpringContextTests      provide convenience methods which delegate to      JdbcTestUtils internally.      \n\r\n\rThe spring-jdbc module provides support for      configuring and launching an embedded database which can be used in      integration tests that interact with a database. For details, see Section&nbsp;14.8, &#8220;Embedded database support&#8221; and Section&nbsp;14.8.8, &#8220;Testing data access logic with an embedded database&#8221;.        11.3.4&nbsp;Annotations            Spring Testing Annotations                \n\r\n\rThe Spring Framework provides the following set of        Spring-specific annotations that you can use in        your unit and integration tests in conjunction with the TestContext        framework. Refer to the respective Javadoc for further information,        including default attribute values, attribute aliases, and so on.        \n\r            \n\r\n\r            @ContextConfiguration                        \n\r\n\rDefines class-level metadata that is used to determine how to            load and configure an            ApplicationContext for integration            tests. Specifically,            @ContextConfiguration declares            either the application context resource            locations or the annotated            classes that will be used to load the            context.            \n\r\n\rResource locations are typically XML configuration files            located in the classpath; whereas, annotated classes are typically            @Configuration classes. However,            resource locations can also refer to files in the file system, and            annotated classes can be component classes, etc.            @ContextConfiguration(\"/test-config.xml\")public class XmlApplicationContextTests {    // class body...}            @ContextConfiguration(classes = TestConfig.class)public class ConfigClassApplicationContextTests {    // class body...}            \n\r\n\rAs an alternative or in addition to declaring resource            locations or annotated classes,            @ContextConfiguration may be used to            declare ApplicationContextInitializer            classes.            @ContextConfiguration(initializers = CustomContextIntializer.class)public class ContextInitializerTests {    // class body...}            \n\r\n\r@ContextConfiguration may            optionally be used to declare the            ContextLoader strategy as well. Note,            however, that you typically do not need to explicitly configure the            loader since the default loader supports either resource            locations or annotated classes            as well as initializers.            @ContextConfiguration(locations = \"/test-context.xml\", loader = CustomContextLoader.class)public class CustomLoaderXmlApplicationContextTests {    // class body...}            Note              \n\r\n\r@ContextConfiguration              provides support for inheriting resource              locations or configuration classes as well as context initializers              declared by superclasses by default.                        \n\r\n\rSee the section called &#8220;Context management&#8221; and the            Javadoc for @ContextConfiguration for            further details.          \n\r            \n\r\n\r@WebAppConfiguration            \n\r\n\rA class-level annotation that is used to declare that the            ApplicationContext loaded for an            integration test should be a            WebApplicationContext. The mere            presence of @WebAppConfiguration on a            test class ensures that a            WebApplicationContext will be loaded            for the test, using the default value of            \"file:src/main/webapp\" for the path to the root            of the web application (i.e., the resource base            path). The resource base path is used behind the scenes            to create a MockServletContext which serves            as the ServletContext for the test\'s            WebApplicationContext.            @ContextConfiguration@WebAppConfigurationpublic class WebAppTests {    // class body...}            \n\r\n\rTo override the default, specify a different base resource            path via the implicit            value attribute. Both            classpath: and file: resource            prefixes are supported. If no resource prefix is supplied the path            is assumed to be a file system resource.            @ContextConfiguration@WebAppConfiguration(\"classpath:test-web-resources\")public class WebAppTests {    // class body...}            \n\r\n\rNote that @WebAppConfiguration            must be used in conjunction with            @ContextConfiguration, either within            a single test class or within a test class hierarchy. See the            Javadoc for @WebAppConfiguration for            further details.          \n\r            \n\r\n\r            @ContextHierarchy            \n\r\n\rA class-level annotation that is used to define a hierarchy of            ApplicationContexts for integration            tests. @ContextHierarchy should be            declared with a list of one or more            @ContextConfiguration instances, each            of which defines a level in the context hierarchy. The following            examples demonstrate the use of            @ContextHierarchy within a single            test class; however,            @ContextHierarchy can also be used            within a test class hierarchy.            @ContextHierarchy({    @ContextConfiguration(\"/parent-config.xml\"),    @ContextConfiguration(\"/child-config.xml\")})public class ContextHierarchyTests {    // class body...}            @WebAppConfiguration@ContextHierarchy({    @ContextConfiguration(classes = AppConfig.class),    @ContextConfiguration(classes = WebConfig.class)})public class WebIntegrationTests {    // class body...}            \n\r\n\rIf you need to merge or override the configuration for a given            level of the context hierarchy within a test class hierarchy, you            must explicitly name that level by supplying the same value to the            name attribute in            @ContextConfiguration at each            corresponding level in the class hierarchy. See the section called &#8220;Context hierarchies&#8221; and the            Javadoc for @ContextHierarchy for            further examples.          \n\r            \n\r\n\r            @ActiveProfiles             \n\r\n\rA class-level annotation that is used to declare which            bean definition profiles should be active when            loading an ApplicationContext for            test classes.            @ContextConfiguration@ActiveProfiles(\"dev\")public class DeveloperTests {    // class body...}            @ContextConfiguration@ActiveProfiles({\"dev\", \"integration\"})public class DeveloperIntegrationTests {    // class body...}            Note              \n\r\n\r@ActiveProfiles provides              support for inheriting active bean definition              profiles declared by superclasses by default.                        \n\r\n\rSee the section called &#8220;Context configuration with environment profiles&#8221;            and the Javadoc for @ActiveProfiles            for examples and further details.          \n\r            \n\r\n\r            @DirtiesContext             \n\r\n\rIndicates that the underlying Spring            ApplicationContext has been            dirtied during the execution of a test (i.e.,            modified or corrupted in some manner &#8212; for example, by changing the            state of a singleton bean) and should be closed, regardless of            whether the test passed. When an application context is marked            dirty, it is removed from the testing            framework\'s cache and closed. As a consequence, the underlying            Spring container will be rebuilt for any subsequent test that            requires a context with the same configuration metadata.            \n\r\n\r@DirtiesContext can be used as            both a class-level and method-level annotation within the same test            class. In such scenarios, the            ApplicationContext is marked as            dirty after any such annotated method as well            as after the entire class. If the ClassMode            is set to AFTER_EACH_TEST_METHOD, the context is            marked dirty after each test method in the class.            \n\r\n\rThe following examples explain when the context would be            dirtied for various configuration scenarios:            \n\r                \n\r\n\rAfter the current test class, when declared on a class                with class mode set to AFTER_CLASS (i.e., the                default class mode).                @DirtiesContextpublic class ContextDirtyingTests {    // some tests that result in the Spring container being dirtied}              \n\r                \n\r\n\rAfter each test method in the current test class, when                declared on a class with class mode set to                AFTER_EACH_TEST_METHOD.@DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)public class ContextDirtyingTests {    // some tests that result in the Spring container being dirtied}              \n\r                \n\r\n\rAfter the current test, when declared on a method.                @DirtiesContext@Testpublic void testProcessWhichDirtiesAppCtx() {    // some logic that results in the Spring container being dirtied}              \n\r            \n\r\n\rIf @DirtiesContext is used in a            test whose context is configured as part of a context hierarchy via            @ContextHierarchy, the            hierarchyMode flag can be used to control how the            context cache is cleared. By default an            exhaustive algorithm will be used that clears            the context cache including not only the current level but also all            other context hierarchies that share an ancestor context common to            the current test; all            ApplicationContexts that reside in a            sub-hierarchy of the common ancestor context will be removed from            the context cache and closed. If the exhaustive            algorithm is overkill for a particular use case, the simpler            current level algorithm can be specified            instead, as seen below.            @ContextHierarchy({    @ContextConfiguration(\"/parent-config.xml\"),    @ContextConfiguration(\"/child-config.xml\")})public class BaseTests {    // class body...}public class ExtendedTests extends BaseTests {    @Test    @DirtiesContext(hierarchyMode = HierarchyMode.CURRENT_LEVEL)    public void test() {        // some logic that results in the child context being dirtied    }}            \n\r\n\rFor further details regarding the            EXHAUSTIVE and            CURRENT_LEVEL algorithms see the Javadoc for            DirtiesContext.HierarchyMode.          \n\r            \n\r\n\r            @TestExecutionListeners                        \n\r\n\rDefines class-level metadata for configuring which            TestExecutionListeners should be            registered with the TestContextManager.            Typically, @TestExecutionListeners is            used in conjunction with            @ContextConfiguration.            @ContextConfiguration@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class})public class CustomTestExecutionListenerTests {    // class body...}            \n\r\n\r@TestExecutionListeners            supports inherited listeners by default. See            the Javadoc for an example and further details.          \n\r            \n\r\n\r            @TransactionConfiguration                        \n\r\n\rDefines class-level metadata for configuring transactional            tests. Specifically, the bean name of the            PlatformTransactionManager that            should be used to drive transactions can be explicitly specified if            there are multiple beans of type            PlatformTransactionManager in the            test\'s ApplicationContext and if the            bean name of the desired            PlatformTransactionManager is not            \"transactionManager\". In addition, you can change the            defaultRollback flag to false.            Typically, @TransactionConfiguration            is used in conjunction with            @ContextConfiguration.            @ContextConfiguration@TransactionConfiguration(transactionManager = \"txMgr\", defaultRollback = false)public class CustomConfiguredTransactionalTests {    // class body...}            Note              \n\r\n\rIf the default conventions are sufficient for your test              configuration, you can avoid using              @TransactionConfiguration              altogether. In other words, if you have only one transaction              manger &#8212; or if you have multiple transaction mangers but the              transaction manager for tests is named \"transactionManager\" or              specified via a              TransactionManagementConfigurer &#8212;              and if you want transactions to roll back automatically, then              there is no need to annotate your test class with              @TransactionConfiguration.                      \n\r            \n\r\n\r            @Rollback             \n\r\n\rIndicates whether the transaction for the annotated test            method should be rolled back after the test            method has completed. If true, the transaction is            rolled back; otherwise, the transaction is committed. Use            @Rollback to override the default            rollback flag configured at the class level.            @Rollback(false)@Testpublic void testProcessWithoutRollback() {    // ...}          \n\r            \n\r\n\r            @BeforeTransaction             \n\r\n\rIndicates that the annotated public void            method should be executed before a transaction            is started for test methods configured to run within a transaction            via the @Transactional            annotation.            @BeforeTransactionpublic void beforeTransaction() {    // logic to be executed before a transaction is started}          \n\r            \n\r\n\r            @AfterTransaction             \n\r\n\rIndicates that the annotated public void            method should be executed after a transaction            has ended for test methods configured to run within a transaction            via the @Transactional            annotation.            @AfterTransactionpublic void afterTransaction() {    // logic to be executed after a transaction has ended}          \n\r            \n\r\n\r            @NotTransactional             \n\r\n\rThe presence of this annotation indicates that the annotated            test method must not execute in a transactional            context.            @NotTransactional@Testpublic void testProcessWithoutTransaction() {    // ...}            @NotTransactional is deprecated                            \n\r\n\rAs of Spring 3.0,              @NotTransactional is deprecated in              favor of moving the non-transactional test              method to a separate (non-transactional) test class or to a              @BeforeTransaction or              @AfterTransaction method. As an              alternative to annotating an entire class with              @Transactional, consider annotating              individual methods with              @Transactional; doing so allows a              mix of transactional and non-transactional methods in the same              test class without the need for using              @NotTransactional.                      \n\r            Standard Annotation Support                \n\r\n\rThe following annotations are supported with standard semantics        for all configurations of the Spring TestContext Framework. Note that        these annotations are not specific to tests and can be used anywhere in        the Spring Framework.        \n\r            \n\r\n\r            @Autowired           \n\r            \n\r\n\r            @Qualifier           \n\r            \n\r\n\r            @Resource             (javax.annotation) if JSR-250 is present          \n\r            \n\r\n\r @Inject             (javax.inject) if JSR-330 is            present          \n\r            \n\r\n\r @Named             (javax.inject) if JSR-330 is            present          \n\r            \n\r\n\r            @PersistenceContext             (javax.persistence) if JPA is present          \n\r            \n\r\n\r            @PersistenceUnit             (javax.persistence) if JPA is present          \n\r            \n\r\n\r            @Required           \n\r            \n\r\n\r            @Transactional           \n\r        JSR-250 Lifecycle Annotations                    \n\r\n\rIn the Spring TestContext Framework          @PostConstruct and          @PreDestroy may be used with standard          semantics on any application components configured in the          ApplicationContext; however, these          lifecycle annotations have limited usage within an actual test          class.          \n\r\n\rIf a method within a test class is annotated with          @PostConstruct, that method will be          executed before any before methods of the          underlying test framework (e.g., methods annotated with JUnit\'s          @Before), and that will apply for every          test method in the test class. On the other hand, if a method within a          test class is annotated with          @PreDestroy, that method will never be executed. Within a test class it is          therefore recommended to use test lifecycle callbacks from the          underlying test framework instead of          @PostConstruct and          @PreDestroy.                    Spring JUnit Testing Annotations                \n\r\n\rThe following annotations are only supported        when used in conjunction with the SpringJUnit4ClassRunner or        the JUnit        support classes.        \n\r            \n\r\n\r            @IfProfileValue             \n\r\n\rIndicates that the annotated test is enabled for a specific            testing environment. If the configured            ProfileValueSource returns a matching            value for the provided name,            the test is enabled. This annotation can be applied to an entire            class or to individual methods. Class-level usage overrides            method-level usage.            @IfProfileValue(name=\"java.vendor\", value=\"Sun Microsystems Inc.\")@Testpublic void testProcessWhichRunsOnlyOnSunJvm() {    // some logic that should run only on Java VMs from Sun Microsystems}            \n\r\n\rAlternatively, you can configure            @IfProfileValue with a list of            values (with OR semantics)            to achieve TestNG-like support for test groups            in a JUnit environment. Consider the following example:            @IfProfileValue(name=\"test-groups\", values={\"unit-tests\", \"integration-tests\"})@Testpublic void testProcessWhichRunsForUnitOrIntegrationTestGroups() {    // some logic that should run only for unit and integration test groups}          \n\r            \n\r\n\r            @ProfileValueSourceConfiguration                        \n\r\n\rClass-level annotation that specifies what type of            ProfileValueSource to use when retrieving            profile values configured through the            @IfProfileValue annotation. If            @ProfileValueSourceConfiguration is            not declared for a test,            SystemProfileValueSource is used by            default.            @ProfileValueSourceConfiguration(CustomProfileValueSource.class)public class CustomProfileValueSourceTests {    // class body...}          \n\r            \n\r\n\r @Timed                        \n\r\n\rIndicates that the annotated test method must finish execution            in a specified time period (in milliseconds). If the text execution            time exceeds the specified time period, the test fails.            \n\r\n\rThe time period includes execution of the test method itself,            any repetitions of the test (see            @Repeat), as well as any            set up or tear down of the            test fixture.            @Timed(millis=1000)public void testProcessWithOneSecondTimeout() {    // some logic that should not take longer than 1 second to execute}            \n\r\n\rSpring\'s @Timed annotation has            different semantics than JUnit\'s            @Test(timeout=...) support.            Specifically, due to the manner in which JUnit handles test            execution timeouts (that is, by executing the test method in a            separate Thread),            @Test(timeout=...) applies to            each iteration in the case of repetitions and            preemptively fails the test if the test takes too long. Spring\'s            @Timed, on the other hand, times the            total test execution time (including all            repetitions) and does not preemptively fail the test but rather            waits for the test to complete before failing.          \n\r            \n\r\n\r @Repeat                        \n\r\n\rIndicates that the annotated test method must be executed            repeatedly. The number of times that the test method is to be            executed is specified in the annotation.            \n\r\n\rThe scope of execution to be repeated includes execution of            the test method itself as well as any set up or            tear down of the test fixture.            @Repeat(10)@Testpublic void testProcessRepeatedly() {    // ...}          \n\r              11.3.5&nbsp;Spring TestContext Framework            \n\r\n\rThe Spring TestContext      Framework (located in the      org.springframework.test.context package) provides      generic, annotation-driven unit and integration testing support that is      agnostic of the testing framework in use. The TestContext framework also      places a great deal of importance on convention over      configuration with reasonable defaults that can be overridden      through annotation-based configuration.      \n\r\n\rIn addition to generic testing infrastructure, the TestContext      framework provides explicit support for JUnit and TestNG in the form of      abstract support classes. For JUnit, Spring also      provides a custom JUnit Runner that allows      one to write so-called POJO test classes. POJO test      classes are not required to extend a particular class hierarchy.      \n\r\n\rThe following section provides an overview of the internals of the      TestContext framework. If you are only interested in using the framework      and not necessarily interested in extending it with your own custom      listeners or custom loaders, feel free to go directly to the configuration      (context management,      dependency injection, transaction management), support classes, and annotation support      sections.      Key abstractions                \n\r\n\rThe core of the framework consists of the        TestContext and        TestContextManager classes and the        TestExecutionListener,        ContextLoader, and        SmartContextLoader interfaces. A        TestContextManager is created on a per-test basis        (e.g., for the execution of a single test method in JUnit). The        TestContextManager in turn manages a        TestContext that holds the context of the current        test. The TestContextManager also updates the        state of the TestContext as the test progresses        and delegates to TestExecutionListeners,        which instrument the actual test execution by providing dependency        injection, managing transactions, and so on. A        ContextLoader (or        SmartContextLoader) is responsible for        loading an ApplicationContext for a given        test class. Consult the Javadoc and the Spring test suite for further        information and examples of various implementations.        \n\r            \n\r\n\rTestContext: Encapsulates the context            in which a test is executed, agnostic of the actual testing            framework in use, and provides context management and caching            support for the test instance for which it is responsible. The            TestContext also delegates to a            ContextLoader (or            SmartContextLoader) to load an            ApplicationContext if            requested.          \n\r            \n\r\n\rTestContextManager: The main entry            point into the Spring TestContext Framework,            which manages a single TestContext and            signals events to all registered            TestExecutionListeners at            well-defined test execution points:            \n\r                \n\r\n\rprior to any before class methods of                a particular testing framework              \n\r                \n\r\n\rtest instance preparation              \n\r                \n\r\n\rprior to any before methods of a                particular testing framework              \n\r                \n\r\n\rafter any after methods of a                particular testing framework              \n\r                \n\r\n\rafter any after class methods of a                particular testing framework              \n\r          \n\r            \n\r\n\rTestExecutionListener: Defines            a listener API for reacting to test execution            events published by the TestContextManager            with which the listener is registered.            \n\r\n\rSpring provides four            TestExecutionListener implementations            that are configured by default:            ServletTestExecutionListener,            DependencyInjectionTestExecutionListener,            DirtiesContextTestExecutionListener, and            TransactionalTestExecutionListener.            Respectively, they support Servlet API mocks for a            WebApplicationContext, dependency            injection of the test instance, handling of the            @DirtiesContext annotation, and            transactional test execution with default rollback semantics.          \n\r            \n\r\n\rContextLoader: Strategy            interface introduced in Spring 2.5 for loading an            ApplicationContext for an integration            test managed by the Spring TestContext Framework.            \n\r\n\rAs of Spring 3.1, implement            SmartContextLoader instead of this            interface in order to provide support for annotated classes and            active bean definition profiles.          \n\r            \n\r\n\rSmartContextLoader: Extension            of the ContextLoader interface            introduced in Spring 3.1.            \n\r\n\rThe SmartContextLoader SPI            supersedes the ContextLoader SPI that            was introduced in Spring 2.5. Specifically, a            SmartContextLoader can choose to            process resource locations, annotated            classes, or context            initializers. Furthermore, a            SmartContextLoader can set active            bean definition profiles in the context that it loads.            \n\r\n\rSpring provides the following implementations:            \n\r                \n\r\n\rDelegatingSmartContextLoader: one                of two default loaders which delegates internally to an                AnnotationConfigContextLoader or a                GenericXmlContextLoader depending either                on the configuration declared for the test class or on the                presence of default locations or default configuration                classes.              \n\r                \n\r\n\rWebDelegatingSmartContextLoader:                one of two default loaders which delegates internally to an                AnnotationConfigWebContextLoader or a                GenericXmlWebContextLoader depending                either on the configuration declared for the test class or on                the presence of default locations or default configuration                classes. A web ContextLoader will                only be used if                @WebAppConfiguration is present                on the test class.              \n\r                \n\r\n\rAnnotationConfigContextLoader:                loads a standard                ApplicationContext from                annotated classes.              \n\r                \n\r\n\rAnnotationConfigWebContextLoader:                loads a WebApplicationContext                from annotated classes.              \n\r                \n\r\n\rGenericXmlContextLoader: loads a                standard ApplicationContext from                XML resource locations.              \n\r                \n\r\n\rGenericXmlWebContextLoader: loads a                WebApplicationContext from XML                resource locations.              \n\r                \n\r\n\rGenericPropertiesContextLoader:                loads a standard                ApplicationContext from Java                Properties files.              \n\r          \n\r        \n\r\n\rThe following sections explain how to configure the        TestContext framework through annotations and        provide working examples of how to write unit and integration tests with        the framework.            Context management                \n\r\n\rEach TestContext provides context        management and caching support for the test instance it is responsible        for. Test instances do not automatically receive access to the        configured ApplicationContext. However,        if a test class implements the        ApplicationContextAware interface, a        reference to the ApplicationContext is supplied        to the test instance. Note that        AbstractJUnit4SpringContextTests and        AbstractTestNGSpringContextTests implement        ApplicationContextAware and therefore        provide access to the ApplicationContext        automatically.        @Autowired ApplicationContext                    \n\r\n\rAs an alternative to implementing the          ApplicationContextAware interface, you          can inject the application context for your test class through the          @Autowired annotation on either a field          or setter method. For example:          @RunWith(SpringJUnit4ClassRunner.class)@ContextConfigurationpublic class MyTest {    @Autowired    private ApplicationContext applicationContext;    // class body...}          \n\r\n\rSimilarly, if your test is configured to load a          WebApplicationContext, you can inject          the web application context into your test as follows:          @RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfigurationpublic class MyWebAppTest {    @Autowired    private WebApplicationContext wac;    // class body...}          \n\r\n\rDependency injection via          @Autowired is provided by the          DependencyInjectionTestExecutionListener which          is configured by default (see the section called &#8220;Dependency injection of test fixtures&#8221;).                \n\r\n\rTest classes that use the TestContext framework do not need to        extend any particular class or implement a specific interface to        configure their application context. Instead, configuration is achieved        simply by declaring the        @ContextConfiguration annotation at the        class level. If your test class does not explicitly declare application        context resource locations or annotated        classes, the configured        ContextLoader determines how to load a        context from a default location or default configuration classes. In        addition to context resource locations and annotated        classes, an application context can also be        configured via application context        initializers.        \n\r\n\rThe following sections explain how to configure an        ApplicationContext via XML configuration        files, annotated classes (typically        @Configuration classes), or context        initializers using Spring\'s        @ContextConfiguration annotation.        Alternatively, you can implement and configure your own custom        SmartContextLoader for advanced use        cases.        Context configuration with XML resources                    \n\r\n\rTo load an ApplicationContext for          your tests using XML configuration files, annotate your test class          with @ContextConfiguration and          configure the locations attribute with an array          that contains the resource locations of XML configuration metadata. A          plain or relative path &#8212; for example \"context.xml\"          &#8212; will be treated as a classpath resource that is relative to the          package in which the test class is defined. A path starting with a          slash is treated as an absolute classpath location, for example          \"/org/example/config.xml\". A path which represents          a resource URL (i.e., a path prefixed with          classpath:, file:,          http:, etc.) will be used as          is.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from \"/app-config.xml\" and// \"/test-config.xml\" in the root of the classpath@ContextConfiguration(locations={\"/app-config.xml\", \"/test-config.xml\"})public class MyTest {    // class body...}          \n\r\n\r@ContextConfiguration supports an          alias for the locations attribute through the          standard Java value attribute. Thus, if you do not          need to declare additional attributes in          @ContextConfiguration, you can omit the          declaration of the locations attribute name and          declare the resource locations by using the shorthand format          demonstrated in the following example.          @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration({\"/app-config.xml\", \"/test-config.xml\"})public class MyTest {    // class body...}          \n\r\n\rIf you omit both the locations and          value attributes from the          @ContextConfiguration annotation, the          TestContext framework will attempt to detect a default XML resource          location. Specifically, GenericXmlContextLoader          detects a default location based on the name of the test class. If          your class is named com.example.MyTest,          GenericXmlContextLoader loads your application          context from          \"classpath:/com/example/MyTest-context.xml\".          package com.example;@RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from// \"classpath:/com/example/MyTest-context.xml\"@ContextConfigurationpublic class MyTest {    // class body...}                Context configuration with annotated classes                    \n\r\n\rTo load an ApplicationContext for          your tests using annotated classes (see Section&nbsp;5.12, &#8220;Java-based container configuration&#8221;), annotate your test class with          @ContextConfiguration and configure the          classes attribute with an array that contains          references to annotated classes.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from AppConfig and TestConfig@ContextConfiguration(classes = {AppConfig.class, TestConfig.class})public class MyTest {    // class body...}          \n\r\n\rIf you omit the classes attribute from the          @ContextConfiguration annotation, the          TestContext framework will attempt to detect the presence of default          configuration classes. Specifically,          AnnotationConfigContextLoader will detect all          static inner classes of the test class that meet the requirements for          configuration class implementations as specified in the Javadoc for          @Configuration. In the following          example, the OrderServiceTest class declares a          static inner configuration class named Config          that will be automatically used to load the          ApplicationContext for the test class.          Note that the name of the configuration class is arbitrary. In          addition, a test class can contain more than one static inner          configuration class if desired.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from the// static inner Config class@ContextConfigurationpublic class OrderServiceTest {    @Configuration    static class Config {        // this bean will be injected into the OrderServiceTest class        @Bean        public OrderService orderService() {            OrderService orderService = new OrderServiceImpl();            // set properties, etc.            return orderService;        }    }    @Autowired    private OrderService orderService;    @Test    public void testOrderService() {        // test the orderService    }}                Mixing XML resources and annotated classes                    \n\r\n\rIt may sometimes be desirable to mix XML resources and annotated          classes (i.e., typically @Configuration          classes) to configure an          ApplicationContext for your tests. For          example, if you use XML configuration in production, you may decide          that you want to use @Configuration          classes to configure specific Spring-managed components for your          tests, or vice versa. As mentioned in the section called &#8220;Spring Testing Annotations&#8221; the TestContext          framework does not allow you to declare both via          @ContextConfiguration, but this does          not mean that you cannot use both.          \n\r\n\rIf you want to use XML and          @Configuration classes to configure          your tests, you will have to pick one as the entry          point, and that one will have to include or import the          other. For example, in XML you can include          @Configuration classes via component          scanning or define them as normal Spring beans in XML; whereas, in a          @Configuration class you can use          @ImportResource to import XML          configuration files. Note that this behavior is semantically          equivalent to how you configure your application in production: in          production configuration you will define either a set of XML resource          locations or a set of @Configuration          classes that your production          ApplicationContext will be loaded from,          but you still have the freedom to include or import the other type of          configuration.                Context configuration with context initializers                    \n\r\n\rTo configure an          ApplicationContext for your tests using          context initializers, annotate your test class with          @ContextConfiguration and configure the          initializers attribute with an array that contains          references to classes that implement          ApplicationContextInitializer. The          declared context initializers will then be used to initialize the          ConfigurableApplicationContext that is          loaded for your tests. Note that the concrete          ConfigurableApplicationContext type          supported by each declared initializer must be compatible with the          type of ApplicationContext created by          the SmartContextLoader in use (i.e.,          typically a GenericApplicationContext).          Furthermore, the order in which the initializers are invoked depends          on whether they implement Spring\'s          Ordered interface or are annotated with          Spring\'s @Order annotation.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from TestConfig// and initialized by TestAppCtxInitializer@ContextConfiguration(    classes = TestConfig.class,    initializers = TestAppCtxInitializer.class)public class MyTest {    // class body...}          \n\r\n\rIt is also possible to omit the declaration of XML configuration          files or annotated classes in          @ContextConfiguration entirely and          instead declare only          ApplicationContextInitializer classes          which are then responsible for registering beans in the context &#8212; for          example, by programmatically loading bean definitions from XML files          or configuration classes.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be initialized by EntireAppInitializer// which presumably registers beans in the context@ContextConfiguration(initializers = EntireAppInitializer.class)public class MyTest {    // class body...}                Context configuration inheritance                    \n\r\n\r@ContextConfiguration supports          boolean inheritLocations and          inheritInitializers attributes that denote whether          resource locations or annotated classes and context initializers          declared by superclasses should be inherited. The          default value for both flags is true. This means          that a test class inherits the resource locations or annotated classes          as well as the context initializers declared by any superclasses.          Specifically, the resource locations or annotated classes for a test          class are appended to the list of resource locations or annotated          classes declared by superclasses. Similarly, the initializers for a          given test class will be added to the set of initializers defined by          test superclasses. Thus, subclasses have the option of          extending the resource locations, annotated          classes, or context initializers.          \n\r\n\rIf @ContextConfiguration\'s          inheritLocations or          inheritInitializers attribute is set to          false, the resource locations or annotated classes          and the context initializers, respectively, for the test class          shadow and effectively replace the configuration          defined by superclasses.          \n\r\n\rIn the following example that uses XML resource locations, the          ApplicationContext for          ExtendedTest will be loaded from          \"base-config.xml\" and \"extended-config.xml\",          in that order. Beans defined in          \"extended-config.xml\" may therefore          override (i.e., replace) those defined in          \"base-config.xml\".          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from \"/base-config.xml\"// in the root of the classpath@ContextConfiguration(\"/base-config.xml\")public class BaseTest {    // class body...}// ApplicationContext will be loaded from \"/base-config.xml\" and// \"/extended-config.xml\" in the root of the classpath@ContextConfiguration(\"/extended-config.xml\")public class ExtendedTest extends BaseTest {    // class body...}          \n\r\n\rSimilarly, in the following example that uses annotated classes,          the ApplicationContext for          ExtendedTest will be loaded from the          BaseConfig and          ExtendedConfig classes, in that order. Beans          defined in ExtendedConfig may therefore          override (i.e., replace) those defined in          BaseConfig.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from BaseConfig@ContextConfiguration(classes = BaseConfig.class)public class BaseTest {    // class body...}// ApplicationContext will be loaded from BaseConfig and ExtendedConfig@ContextConfiguration(classes = ExtendedConfig.class)public class ExtendedTest extends BaseTest {    // class body...}          \n\r\n\rIn the following example that uses context initializers, the          ApplicationContext for          ExtendedTest will be initialized using          BaseInitializer and ExtendedInitializer.          Note, however, that the order in which the initializers are invoked          depends on whether they implement Spring\'s          Ordered interface or are annotated with          Spring\'s @Order annotation.          @RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be initialized by BaseInitializer@ContextConfiguration(initializers=BaseInitializer.class)public class BaseTest {    // class body...}// ApplicationContext will be initialized by BaseInitializer// and ExtendedInitializer@ContextConfiguration(initializers=ExtendedInitializer.class)public class ExtendedTest extends BaseTest {    // class body...}                Context configuration with environment profiles                    \n\r\n\rSpring 3.1 introduced first-class support in the framework for          the notion of environments and profiles (a.k.a., bean          definition profiles), and integration tests can be          configured to activate particular bean definition profiles for various          testing scenarios. This is achieved by annotating a test class with          the @ActiveProfiles annotation and          supplying a list of profiles that should be activated when loading the          ApplicationContext for the test.          Note            \n\r\n\r@ActiveProfiles may be used            with any implementation of the new            SmartContextLoader SPI, but            @ActiveProfiles is not supported with            implementations of the older            ContextLoader SPI.                    \n\r\n\rLet\'s take a look at some examples with XML configuration and          @Configuration classes.          &lt;!-- app-config.xml --&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"    xmlns:jee=\"http://www.springframework.org/schema/jee\"    xsi:schemaLocation=\"...\"&gt;    &lt;bean id=\"transferService\"        class=\"com.bank.service.internal.DefaultTransferService\"&gt;        &lt;constructor-arg ref=\"accountRepository\"/&gt;        &lt;constructor-arg ref=\"feePolicy\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"accountRepository\"        class=\"com.bank.repository.internal.JdbcAccountRepository\"&gt;        &lt;constructor-arg ref=\"dataSource\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"feePolicy\"        class=\"com.bank.service.internal.ZeroFeePolicy\"/&gt;    &lt;beans profile=\"dev\"&gt;        &lt;jdbc:embedded-database id=\"dataSource\"&gt;            &lt;jdbc:script                location=\"classpath:com/bank/config/sql/schema.sql\"/&gt;            &lt;jdbc:script                location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt;        &lt;/jdbc:embedded-database&gt;    &lt;/beans&gt;    &lt;beans profile=\"production\"&gt;        &lt;jee:jndi-lookup id=\"dataSource\"            jndi-name=\"java:comp/env/jdbc/datasource\"/&gt;    &lt;/beans&gt;&lt;/beans&gt;          package com.bank.service;@RunWith(SpringJUnit4ClassRunner.class)// ApplicationContext will be loaded from \"classpath:/app-config.xml\"@ContextConfiguration(\"/app-config.xml\")@ActiveProfiles(\"dev\")public class TransferServiceTest {   @Autowired   private TransferService transferService;   @Test   public void testTransferService() {       // test the transferService   }}          \n\r\n\rWhen TransferServiceTest is run, its          ApplicationContext will be loaded from          the app-config.xml configuration file in the root          of the classpath. If you inspect app-config.xml          you\'ll notice that the accountRepository bean has a          dependency on a dataSource bean; however,          dataSource is not defined as a top-level bean.          Instead, dataSource is defined twice: once in the          production profile and once in the          dev profile.          \n\r\n\rBy annotating TransferServiceTest with          @ActiveProfiles(\"dev\") we instruct the          Spring TestContext Framework to load the          ApplicationContext with the active          profiles set to {\"dev\"}. As a result, an embedded          database will be created, and the accountRepository          bean will be wired with a reference to the development          DataSource. And that\'s likely what we          want in an integration test.          \n\r\n\rThe following code listings demonstrate how to implement the          same configuration and integration test but using          @Configuration classes instead of          XML.          @Configuration@Profile(\"dev\")public class StandaloneDataConfig {    @Bean    public DataSource dataSource() {        return new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(\"classpath:com/bank/config/sql/schema.sql\")            .addScript(\"classpath:com/bank/config/sql/test-data.sql\")            .build();    }}          @Configuration@Profile(\"production\")public class JndiDataConfig {    @Bean    public DataSource dataSource() throws Exception {        Context ctx = new InitialContext();        return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");    }}          @Configurationpublic class TransferServiceConfig {    @Autowired DataSource dataSource;    @Bean    public TransferService transferService() {        return new DefaultTransferService(accountRepository(),            feePolicy());    }    @Bean    public AccountRepository accountRepository() {        return new JdbcAccountRepository(dataSource);    }    @Bean    public FeePolicy feePolicy() {        return new ZeroFeePolicy();    }}          package com.bank.service;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(   classes = {       TransferServiceConfig.class,       StandaloneDataConfig.class,       JndiDataConfig.class})@ActiveProfiles(\"dev\")public class TransferServiceTest {   @Autowired   private TransferService transferService;   @Test   public void testTransferService() {       // test the transferService   }}          \n\r\n\rIn this variation, we have split the XML configuration into          three independent @Configuration          classes:          \n\r              \n\r\n\rTransferServiceConfig: acquires a              dataSource via dependency injection using              @Autowired            \n\r              \n\r\n\rStandaloneDataConfig: defines a              dataSource for an embedded database suitable              for developer tests            \n\r              \n\r\n\rJndiDataConfig: defines a              dataSource that is retrieved from JNDI in a              production environment            \n\r          \n\r\n\rAs with the XML-based configuration example, we still annotate          TransferServiceTest with          @ActiveProfiles(\"dev\"), but this time          we specify all three configuration classes via the          @ContextConfiguration annotation. The          body of the test class itself remains completely unchanged.                          Loading a WebApplicationContext                    \n\r\n\rSpring 3.2 introduces support for loading a          WebApplicationContext in integration          tests. To instruct the TestContext framework to load a          WebApplicationContext instead of a          standard ApplicationContext, simply          annotate the respective test class with          @WebAppConfiguration.          \n\r\n\rThe presence of          @WebAppConfiguration on your test class          instructs the TestContext framework (TCF) that a          WebApplicationContext (WAC) should be          loaded for your integration tests. In the background the TCF makes          sure that a MockServletContext is          created and supplied to your test\'s WAC. By default the base resource          path for your MockServletContext will          be set to \"src/main/webapp\". This is interpreted          as a path relative to the root of your JVM (i.e., normally the path to          your project). If you\'re familiar with the directory structure of a          web application in a Maven project, you\'ll know that          \"src/main/webapp\" is the default location for the          root of your WAR. If you need to override this default, simply provide          an alternate path to the          @WebAppConfiguration annotation (e.g.,          @WebAppConfiguration(\"src/test/webapp\")).          If you wish to reference a base resource path from the classpath          instead of the file system, just use Spring\'s          classpath: prefix.          \n\r\n\rPlease note that Spring\'s testing support for          WebApplicationContexts is on par with          its support for standard          ApplicationContexts. When testing with          a WebApplicationContext you are free to          declare either XML configuration files or          @Configuration classes via          @ContextConfiguration. You are of          course also free to use any other test annotations such as          @TestExecutionListeners,          @TransactionConfiguration,          @ActiveProfiles, etc.          \n\r\n\rThe following examples demonstrate some of the various          configuration options for loading a          WebApplicationContext.          \n\r\n\rExample&nbsp;11.1.&nbsp;Conventions                        @RunWith(SpringJUnit4ClassRunner.class)// defaults to \"file:src/main/webapp\"@WebAppConfiguration// detects \"WacTests-context.xml\" in same package// or static nested @Configuration class@ContextConfigurationpublic class WacTests {    //...}          \n\r          \n\r\n\rThe above example demonstrates the TestContext framework\'s          support for convention over configuration. If you          annotate a test class with          @WebAppConfiguration without specifying          a resource base path, the resource path will effectively default to          \"file:src/main/webapp\". Similarly, if you declare          @ContextConfiguration without          specifying resource locations,          annotated classes, or context          initializers, Spring will attempt to          detect the presence of your configuration using conventions (i.e.,          \"WacTests-context.xml\" in the same package as the          WacTests class or static nested          @Configuration classes).          \n\r\n\rExample&nbsp;11.2.&nbsp;Default resource semantics                        @RunWith(SpringJUnit4ClassRunner.class)// file system resource@WebAppConfiguration(\"webapp\")// classpath resource@ContextConfiguration(\"/spring/test-servlet-config.xml\")public class WacTests {    //...}          \n\r          \n\r\n\rThis example demonstrates how to explicitly declare a resource          base path with @WebAppConfiguration and          an XML resource location with          @ContextConfiguration. The important          thing to note here is the different semantics for paths with these two          annotations. By default,          @WebAppConfiguration resource paths are          file system based; whereas,          @ContextConfiguration resource          locations are classpath based.          \n\r\n\rExample&nbsp;11.3.&nbsp;Explicit resource semantics                        @RunWith(SpringJUnit4ClassRunner.class)// classpath resource@WebAppConfiguration(\"classpath:test-web-resources\")// file system resource@ContextConfiguration(\"file:src/main/webapp/WEB-INF/servlet-config.xml\")public class WacTests {    //...}          \n\r          \n\r\n\rIn this third example, we see that we can override the default          resource semantics for both annotations by specifying a Spring          resource prefix. Contrast the comments in this example with the          previous example.          Working with Web Mocks                        \n\r\n\rTo provide comprehensive web testing support, Spring 3.2            introduces a new            ServletTestExecutionListener that is            enabled by default. When testing against a            WebApplicationContext this TestExecutionListener            sets up default thread-local state via Spring Web\'s            RequestContextHolder before each test            method and creates a            MockHttpServletRequest,            MockHttpServletResponse, and            ServletWebRequest based on the base            resource path configured via            @WebAppConfiguration.            ServletTestExecutionListener also            ensures that the            MockHttpServletResponse and            ServletWebRequest can be injected            into the test instance, and once the test is complete it cleans up            thread-local state.            \n\r\n\rOnce you have a            WebApplicationContext loaded for your            test you might find that you need to interact with the web mocks &#8212;            for example, to set up your test fixture or to perform assertions            after invoking your web component. The following example            demonstrates which mocks can be autowired into your test instance.            Note that the WebApplicationContext            and MockServletContext are both            cached across the test suite; whereas, the other mocks are managed            per test method by the            ServletTestExecutionListener.            \n\r\n\rExample&nbsp;11.4.&nbsp;Injecting mocks                            @WebAppConfiguration@ContextConfigurationpublic class WacTests {    @Autowired WebApplicationContext wac; // cached    @Autowired MockServletContext servletContext; // cached    @Autowired MockHttpSession session;    @Autowired MockHttpServletRequest request;    @Autowired MockHttpServletResponse response;    @Autowired ServletWebRequest webRequest;    //...}            \n\r                          Context caching                    \n\r\n\rOnce the TestContext framework loads an          ApplicationContext (or          WebApplicationContext) for a test, that          context will be cached and reused for all subsequent tests that declare the same          unique context configuration within the same test suite. To understand          how caching works, it is important to understand what is meant by          unique and test          suite.          \n\r\n\rAn ApplicationContext can be          uniquely identified by the combination of          configuration parameters that are used to load it. Consequently, the          unique combination of configuration parameters are used to generate a          key under which the context is cached. The          TestContext framework uses the following configuration parameters to          build the context cache key:          \n\r              \n\r\n\rlocations (from              @ContextConfiguration)            \n\r              \n\r\n\rclasses (from              @ContextConfiguration)            \n\r              \n\r\n\rcontextInitializerClasses (from              @ContextConfiguration)            \n\r              \n\r\n\rcontextLoader (from              @ContextConfiguration)            \n\r              \n\r\n\ractiveProfiles (from              @ActiveProfiles)            \n\r              \n\r\n\rresourceBasePath (from              @WebAppConfiguration)            \n\r          \n\r\n\rFor example, if TestClassA specifies          {\"app-config.xml\", \"test-config.xml\"} for the          locations (or value) attribute          of @ContextConfiguration, the          TestContext framework will load the corresponding          ApplicationContext and store it in a          static context cache under a key that is based          solely on those locations. So if TestClassB          also defines {\"app-config.xml\", \"test-config.xml\"}          for its locations (either explicitly or implicitly through          inheritance) but does not define          @WebAppConfiguration, a different          ContextLoader, different active          profiles, or different context initializers, then the same          ApplicationContext will be shared by          both test classes. This means that the setup cost for loading an          application context is incurred only once (per test suite), and          subsequent test execution is much faster.          Test suites and forked processes                        \n\r\n\rThe Spring TestContext framework stores application contexts            in a static cache. This means that the context            is literally stored in a static variable. In            other words, if tests execute in separate processes the static cache            will be cleared between each test execution, and this will            effectively disable the caching mechanism.            \n\r\n\rTo benefit from the caching mechanism, all tests must run            within the same process or test suite. This can be achieved by            executing all tests as a group within an IDE. Similarly, when            executing tests with a build framework such as Ant, Maven, or Gradle            it is important to make sure that the build framework does not            fork between tests. For example, if the forkMode            for the Maven Surefire plug-in is set to always            or pertest, the TestContext framework will not be            able to cache application contexts between test classes and the            build process will run significantly slower as a result.                    \n\r\n\rIn the unlikely case that a test corrupts the application          context and requires reloading &#8212; for example, by modifying a bean          definition or the state of an application object &#8212; you can annotate          your test class or test method with          @DirtiesContext (see the discussion of          @DirtiesContext in the section called &#8220;Spring Testing Annotations&#8221;). This instructs          Spring to remove the context from the cache and rebuild the          application context before executing the next test. Note that support          for the @DirtiesContext annotation is          provided by the          DirtiesContextTestExecutionListener which is          enabled by default.                Context hierarchies                    \n\r\n\rWhen writing integration tests that rely on a loaded Spring          ApplicationContext, it is often          sufficient to test against a single context; however, there are times          when it is beneficial or even necessary to test against a hierarchy of          ApplicationContexts. For example, if          you are developing a Spring MVC web application you will typically          have a root WebApplicationContext          loaded via Spring\'s ContextLoaderListener and a          child WebApplicationContext loaded via          Spring\'s DispatcherServlet. This results in a          parent-child context hierarchy where shared components and          infrastructure configuration are declared in the root context and          consumed in the child context by web-specific components. Another use          case can be found in Spring Batch applications where you often have a          parent context that provides configuration for shared batch          infrastructure and a child context for the configuration of a specific          batch job.          \n\r\n\rAs of Spring Framework 3.2.2, it is possible to write          integration tests that use context hierarchies by declaring context          configuration via the @ContextHierarchy          annotation, either on an individual test class or within a test class          hierarchy. If a context hierarchy is declared on multiple classes          within a test class hierarchy it is also possible to merge or override          the context configuration for a specific, named level in the context          hierarchy. When merging configuration for a given level in the          hierarchy the configuration resource type (i.e., XML configuration          files or annotated classes) must be consistent; otherwise, it is          perfectly acceptable to have different levels in a context hierarchy          configured using different resource types.          \n\r\n\rThe following JUnit-based examples demonstrate common          configuration scenarios for integration tests that require the use of          context hierarchies.          \n\r\n\rExample&nbsp;11.5.&nbsp;Single test class with context hierarchy                        \n\r\n\rControllerIntegrationTests represents a            typical integration testing scenario for a Spring MVC web            application by declaring a context hierarchy consisting of two            levels, one for the root WebApplicationContext            (loaded using the TestAppConfig            @Configuration class) and one for the            dispatcher servlet            WebApplicationContext (loaded using            the WebConfig            @Configuration class). The            WebApplicationContext that is            autowired into the test instance is the one for            the child context (i.e., the lowest context in the            hierarchy).            @RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextHierarchy({    @ContextConfiguration(classes = TestAppConfig.class),    @ContextConfiguration(classes = WebConfig.class)})public class ControllerIntegrationTests {    @Autowired    private WebApplicationContext wac;    // ...}          \n\r          \n\r\n\rExample&nbsp;11.6.&nbsp;Class hierarchy with implicit parent context                        \n\r\n\rThe following test classes define a context hierarchy within a            test class hierarchy. AbstractWebTests            declares the configuration for a root            WebApplicationContext in a            Spring-powered web application. Note, however, that            AbstractWebTests does not declare            @ContextHierarchy; consequently,            subclasses of AbstractWebTests can optionally            participate in a context hierarchy or simply follow the standard            semantics for @ContextConfiguration.            SoapWebServiceTests and            RestWebServiceTests both extend            AbstractWebTests and define a context            hierarchy via @ContextHierarchy. The            result is that three application contexts will be loaded (one for            each declaration of            @ContextConfiguration), and the            application context loaded based on the configuration in            AbstractWebTests will be set as the parent            context for each of the contexts loaded for the concrete            subclasses.            @RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(\"file:src/main/webapp/WEB-INF/applicationContext.xml\")public abstract class AbstractWebTests {}@ContextHierarchy(@ContextConfiguration(\"/spring/soap-ws-config.xml\")public class SoapWebServiceTests extends AbstractWebTests {}@ContextHierarchy(@ContextConfiguration(\"/spring/rest-ws-config.xml\")public class RestWebServiceTests extends AbstractWebTests {}          \n\r          \n\r\n\rExample&nbsp;11.7.&nbsp;Class hierarchy with merged context hierarchy            configuration                        \n\r\n\rThe following classes demonstrate the use of            named hierarchy levels in order to            merge the configuration for specific levels in            a context hierarchy. BaseTests defines two            levels in the hierarchy, parent and            child. ExtendedTests            extends BaseTests and instructs the Spring            TestContext Framework to merge the context configuration for the            child hierarchy level, simply by ensuring that            the names declared via            ContextConfiguration\'s            name attribute are both            \"child\". The result is that three application            contexts will be loaded: one for            \"/app-config.xml\", one for            \"/user-config.xml\", and one for            {\"/user-config.xml\", \"/order-config.xml\"}. As            with the previous example, the application context loaded from            \"/app-config.xml\" will be set as the parent            context for the contexts loaded from            \"/user-config.xml\" and            {\"/user-config.xml\", \"/order-config.xml\"}.            @RunWith(SpringJUnit4ClassRunner.class)@ContextHierarchy({    @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"),    @ContextConfiguration(name = \"child\",  locations = \"/user-config.xml\")})public class BaseTests {}@ContextHierarchy(    @ContextConfiguration(name = \"child\",  locations = \"/order-config.xml\"))public class ExtendedTests extends BaseTests {}          \n\r          \n\r\n\rExample&nbsp;11.8.&nbsp;Class hierarchy with overridden context hierarchy            configuration                        \n\r\n\rIn contrast to the previous example, this example demonstrates            how to override the configuration for a given            named level in a context hierarchy by setting            ContextConfiguration\'s            inheritLocations flag to            false. Consequently, the application context for            ExtendedTests will be loaded only from            \"/test-user-config.xml\" and will have its parent            set to the context loaded from            \"/app-config.xml\".            @RunWith(SpringJUnit4ClassRunner.class)@ContextHierarchy({    @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"),    @ContextConfiguration(name = \"child\",  locations = \"/user-config.xml\")})public class BaseTests {}@ContextHierarchy(    @ContextConfiguration(        name = \"child\",        locations = \"/test-user-config.xml\",        inheritLocations = false))public class ExtendedTests extends BaseTests {}          \n\r          Dirtying a context within a context hierarchy                        \n\r\n\rIf @DirtiesContext is used in a            test whose context is configured as part of a context hierarchy, the            hierarchyMode flag can be used to control how the            context cache is cleared. For further details consult the discussion            of @DirtiesContext in the section called &#8220;Spring Testing Annotations&#8221; and the Javadoc            for @DirtiesContext.                              Dependency injection of test fixtures                \n\r\n\rWhen you use the        DependencyInjectionTestExecutionListener &#8212; which        is configured by default &#8212; the dependencies of your test instances are        injected from beans in the application context that        you configured with        @ContextConfiguration. You may use setter        injection, field injection, or both, depending on which annotations you        choose and whether you place them on setter methods or fields. For        consistency with the annotation support introduced in Spring 2.5 and        3.0, you can use Spring\'s @Autowired        annotation or the @Inject annotation from        JSR 300.        Tip          \n\r\n\rThe TestContext framework does not instrument the manner in          which a test instance is instantiated. Thus the use of          @Autowired or          @Inject for constructors has no effect          for test classes.                \n\r\n\rBecause @Autowired is used to        perform  autowiring by        type , if you have multiple bean definitions of the        same type, you cannot rely on this approach for those particular beans.        In that case, you can use @Autowired in        conjunction with @Qualifier. As of Spring        3.0 you may also choose to use @Inject in        conjunction with @Named. Alternatively,        if your test class has access to its        ApplicationContext, you can perform an explicit        lookup by using (for example) a call to        applicationContext.getBean(\"titleRepository\").        \n\r\n\rIf you do not want dependency injection applied to your test        instances, simply do not annotate fields or setter methods with        @Autowired or        @Inject. Alternatively, you can disable        dependency injection altogether by explicitly configuring your class        with @TestExecutionListeners and omitting        DependencyInjectionTestExecutionListener.class from        the list of listeners.        \n\r\n\rConsider the scenario of testing a        HibernateTitleRepository class, as outlined in        the Goals section. The        next two code listings demonstrate the use of        @Autowired on fields and setter methods.        The application context configuration is presented after all sample code        listings.        Note          \n\r\n\rThe dependency injection behavior in the following code listings          is not specific to JUnit. The same DI techniques can be used in          conjunction with any testing framework.          \n\r\n\rThe following examples make calls to static assertion methods          such as assertNotNull() but without prepending the          call with Assert. In such cases, assume that the          method was properly imported through an import          static declaration that is not shown in the example.                \n\r\n\rThe first code listing shows a JUnit-based implementation of the        test class that uses @Autowired for field        injection.        @RunWith(SpringJUnit4ClassRunner.class)// specifies the Spring configuration to load for this test fixture@ContextConfiguration(\"repository-config.xml\")public class HibernateTitleRepositoryTests {    // this instance will be dependency injected by type    @Autowired    private HibernateTitleRepository titleRepository;    @Test    public void findById() {        Title title = titleRepository.findById(new Long(10));        assertNotNull(title);    }}        \n\r\n\rAlternatively, you can configure the class to use        @Autowired for setter injection as seen        below.        @RunWith(SpringJUnit4ClassRunner.class)// specifies the Spring configuration to load for this test fixture@ContextConfiguration(\"repository-config.xml\")public class HibernateTitleRepositoryTests {    // this instance will be dependency injected by type    private HibernateTitleRepository titleRepository;    @Autowired    public void setTitleRepository(HibernateTitleRepository titleRepository) {        this.titleRepository = titleRepository;    }    @Test    public void findById() {        Title title = titleRepository.findById(new Long(10));        assertNotNull(title);    }}        \n\r\n\rThe preceding code listings use the same XML context file        referenced by the @ContextConfiguration        annotation (that is, repository-config.xml), which        looks like this:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;    &lt;bean id=\"titleRepository\" class=\"com.foo.repository.hibernate.HibernateTitleRepository\"&gt;        &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"sessionFactory\"            class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;        &lt;!-- configuration elided for brevity --&gt;    &lt;/bean&gt;&lt;/beans&gt;        Note          \n\r\n\rIf you are extending from a Spring-provided test base class that          happens to use @Autowired on one of its          setter methods, you might have multiple beans of the affected type          defined in your application context: for example, multiple          DataSource beans. In such a case, you          can override the setter method and use the          @Qualifier annotation to indicate a          specific target bean as follows, but make sure to delegate to the          overridden method in the superclass as well.          // ...    @Autowired    @Override    public void setDataSource(@Qualifier(\"myDataSource\") DataSource dataSource) {        super.setDataSource(dataSource);    }// ...          \n\r\n\rThe specified qualifier value indicates the specific          DataSource bean to inject, narrowing          the set of type matches to a specific bean. Its value is matched          against &lt;qualifier&gt; declarations within the          corresponding &lt;bean&gt; definitions. The bean          name is used as a fallback qualifier value, so you may effectively          also point to a specific bean by name there (as shown above, assuming          that \"myDataSource\" is the bean id).                    Testing request and session scoped beans                \n\r\n\rRequest and session        scoped beans have been supported by Spring for several years now,        but it\'s always been a bit non-trivial to test them. As of Spring 3.2        it\'s now a breeze to test your request-scoped and session-scoped beans        by following these steps.        \n\r            \n\r\n\rEnsure that a            WebApplicationContext is loaded for            your test by annotating your test class with            @WebAppConfiguration.          \n\r            \n\r\n\rInject the mock request or session into your test instance and            prepare your test fixture as appropriate.          \n\r            \n\r\n\rInvoke your web component that you retrieved from the            configured WebApplicationContext            (i.e., via dependency injection).          \n\r            \n\r\n\rPerform assertions against the mocks.          \n\r        \n\r\n\rThe following code snippet displays the XML configuration for a        login use case. Note that the userService bean has a        dependency on a request-scoped loginAction bean.        Also, the LoginAction is instantiated using SpEL expressions that retrieve the username        and password from the current HTTP request. In our test, we will want to        configure these request parameters via the mock managed by the        TestContext framework.        \n\r\n\rExample&nbsp;11.9.&nbsp;Request-scoped bean configuration                    &lt;beans&gt;  &lt;bean id=\"userService\"      class=\"com.example.SimpleUserService\"      c:loginAction-ref=\"loginAction\" /&gt;  &lt;bean id=\"loginAction\" class=\"com.example.LoginAction\"      c:username=\"#{request.getParameter(\'user\')}\"      c:password=\"#{request.getParameter(\'pswd\')}\"      scope=\"request\"&gt;    &lt;aop:scoped-proxy /&gt;  &lt;/bean&gt;&lt;/beans&gt;        \n\r        \n\r\n\rIn RequestScopedBeanTests we inject both        the UserService (i.e., the subject under test)        and the MockHttpServletRequest into our test        instance. Within our requestScope() test method we        set up our test fixture by setting request parameters in the provided        MockHttpServletRequest. When the        loginUser() method is invoked on our        userService we are assured that the user service has        access to the request-scoped loginAction for the        current MockHttpServletRequest (i.e., the one we        just set parameters in). We can then perform assertions against the        results based on the known inputs for the username and password.        \n\r\n\rExample&nbsp;11.10.&nbsp;Request-scoped bean test                    @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration@WebAppConfigurationpublic class RequestScopedBeanTests {    @Autowired UserService userService;    @Autowired MockHttpServletRequest request;    @Test    public void requestScope() {        request.setParameter(\"user\", \"enigma\");        request.setParameter(\"pswd\", \"$pr!ng\");        LoginResults results = userService.loginUser();        // assert results    }}        \n\r        \n\r\n\rThe following code snippet is similar to the one we saw above for        a request-scoped bean; however, this time the        userService bean has a dependency on a session-scoped        userPreferences bean. Note that the        UserPreferences bean is instantiated using a SpEL        expression that retrieves the theme from the        current HTTP session. In our test, we will need to configure a theme in        the mock session managed by the TestContext framework.        \n\r\n\rExample&nbsp;11.11.&nbsp;Session-scoped bean configuration                    &lt;beans&gt;  &lt;bean id=\"userService\"      class=\"com.example.SimpleUserService\"      c:userPreferences-ref=\"userPreferences\" /&gt;  &lt;bean id=\"userPreferences\"      class=\"com.example.UserPreferences\"      c:theme=\"#{session.getAttribute(\'theme\')}\"      scope=\"session\"&gt;    &lt;aop:scoped-proxy /&gt;  &lt;/bean&gt;&lt;/beans&gt;        \n\r        \n\r\n\rIn SessionScopedBeanTests we inject the        UserService and the        MockHttpSession into our test instance. Within        our sessionScope() test method we set up our test        fixture by setting the expected \"theme\" attribute in the provided        MockHttpSession. When the        processUserPreferences() method is invoked on our        userService we are assured that the user service has        access to the session-scoped userPreferences for the        current MockHttpSession, and we can perform        assertions against the results based on the configured theme.        \n\r\n\rExample&nbsp;11.12.&nbsp;Session-scoped bean test                    @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration@WebAppConfigurationpublic class SessionScopedBeanTests {  @Autowired UserService userService;  @Autowired MockHttpSession session;  @Test  public void sessionScope() throws Exception {    session.setAttribute(\"theme\", \"blue\");    Results results = userService.processUserPreferences();    // assert results  }}        \n\r            Transaction management                \n\r\n\rIn the TestContext framework, transactions are managed by the        TransactionalTestExecutionListener. Note that        TransactionalTestExecutionListener is configured        by default, even if you do not explicitly declare        @TestExecutionListeners on your test        class. To enable support for transactions, however, you must provide a        PlatformTransactionManager bean in the        application context loaded by        @ContextConfiguration semantics. In        addition, you must declare @Transactional        either at the class or method level for your tests.        \n\r\n\rFor class-level transaction configuration (i.e., setting an        explicit bean name for the transaction manager and the default rollback        flag), see the @TransactionConfiguration        entry in the annotation        support section.        \n\r\n\rIf transactions are not enabled for the entire test class, you can        annotate methods explicitly with        @Transactional. To control whether a        transaction should commit for a particular test method, you can use the        @Rollback annotation to override the        class-level default rollback setting.        \n\r\n\r        AbstractTransactionalJUnit4SpringContextTests         and         AbstractTransactionalTestNGSpringContextTests         are preconfigured for transactional support at the class        level.        \n\r\n\rOccasionally you need to execute certain code before or after a        transactional test method but outside the transactional context, for        example, to verify the initial database state prior to execution of your        test or to verify expected transactional commit behavior after test        execution (if the test was configured not to roll back the transaction).        TransactionalTestExecutionListener supports the        @BeforeTransaction and        @AfterTransaction annotations exactly for        such scenarios. Simply annotate any public void        method in your test class with one of these annotations, and the        TransactionalTestExecutionListener ensures that        your before transaction method or after        transaction method is executed at the appropriate        time.        Tip          \n\r\n\rAny before methods (such as methods          annotated with JUnit\'s @Before) and any          after methods (such as methods annotated with          JUnit\'s @After) are executed within a transaction. In addition, methods          annotated with @BeforeTransaction or          @AfterTransaction are naturally not          executed for tests annotated with          @NotTransactional. However,          @NotTransactional is deprecated as of          Spring 3.0.                \n\r\n\rThe following JUnit-based example displays a fictitious        integration testing scenario highlighting several transaction-related        annotations. Consult the annotation support        section for further information and configuration examples.        @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration@TransactionConfiguration(transactionManager=\"txMgr\", defaultRollback=false)@Transactionalpublic class FictitiousTransactionalTest {    @BeforeTransaction    public void verifyInitialDatabaseState() {        // logic to verify the initial state before a transaction is started    }    @Before    public void setUpTestDataWithinTransaction() {        // set up test data within the transaction    }    @Test    // overrides the class-level defaultRollback setting    @Rollback(true)    public void modifyDatabaseWithinTransaction() {        // logic which uses the test data and modifies database state    }    @After    public void tearDownWithinTransaction() {        // execute \"tear down\" logic within the transaction    }    @AfterTransaction    public void verifyFinalDatabaseState() {        // logic to verify the final state after transaction has rolled back    }}                Avoid false positives when testing ORM code                    \n\r\n\rWhen you test application code that manipulates the state of the          Hibernate session, make sure to flush the          underlying session within test methods that execute that code. Failing          to flush the underlying session can produce false          positives: your test may pass, but the same code throws an          exception in a live, production environment. In the following          Hibernate-based example test case, one method demonstrates a false          positive, and the other method correctly exposes the results of          flushing the session. Note that this applies to JPA and any other ORM          frameworks that maintain an in-memory unit of          work.          // ...@Autowiredprivate SessionFactory sessionFactory;@Test // no expected exception!public void falsePositive() {    updateEntityInHibernateSession();    // False positive: an exception will be thrown once the session is    // finally flushed (i.e., in production code)}@Test(expected = GenericJDBCException.class)public void updateWithSessionFlush() {    updateEntityInHibernateSession();    // Manual flush is required to avoid false positive in test    sessionFactory.getCurrentSession().flush();}// ...                    TestContext Framework support classes                JUnit support classes                    \n\r\n\rThe org.springframework.test.context.junit4          package provides support classes for JUnit 4.5+ based test          cases.          \n\r              \n\r\n\rAbstractJUnit4SpringContextTests:              Abstract base test class that integrates the Spring              TestContext Framework with explicit              ApplicationContext testing support in a              JUnit 4.5+ environment.              \n\r\n\rWhen you extend              AbstractJUnit4SpringContextTests, you can              access the following protected instance              variable:              \n\r                  \n\r\n\rapplicationContext: Use this variable                  to perform explicit bean lookups or to test the state of the                  context as a whole.                \n\r            \n\r              \n\r\n\rAbstractTransactionalJUnit4SpringContextTests:              Abstract transactional extension of              AbstractJUnit4SpringContextTests that also              adds some convenience functionality for JDBC access. Expects a              javax.sql.DataSource bean and a              PlatformTransactionManager bean to              be defined in the ApplicationContext. When              you extend              AbstractTransactionalJUnit4SpringContextTests              you can access the following protected instance              variables:              \n\r                  \n\r\n\rapplicationContext: Inherited from                  the AbstractJUnit4SpringContextTests                  superclass. Use this variable to perform explicit bean lookups                  or to test the state of the context as a whole.                \n\r                  \n\r\n\rjdbcTemplate: Use this variable to                  execute SQL statements to query the database. Such queries can                  be used to confirm database state both prior                  to and after execution of                  database-related application code, and Spring ensures that                  such queries run in the scope of the same transaction as the                  application code. When used in conjunction with an ORM tool,                  be sure to avoid false                  positives.                \n\r            \n\r          Tip            \n\r\n\rThese classes are a convenience for extension. If you do not            want your test classes to be tied to a Spring-specific class            hierarchy &#8212; for example, if you want to directly extend the class            you are testing &#8212; you can configure your own custom test classes by            using            @RunWith(SpringJUnit4ClassRunner.class),            @ContextConfiguration,            @TestExecutionListeners, and so            on.                          Spring JUnit Runner                    \n\r\n\rThe Spring TestContext Framework offers          full integration with JUnit 4.5+ through a custom runner (tested on          JUnit 4.5 &#8211; 4.10). By annotating test classes with          @RunWith(SpringJUnit4ClassRunner.class), developers          can implement standard JUnit-based unit and integration tests and          simultaneously reap the benefits of the TestContext framework such as          support for loading application contexts, dependency injection of test          instances, transactional test method execution, and so on. The          following code listing displays the minimal requirements for          configuring a test class to run with the custom Spring Runner.          @TestExecutionListeners is configured          with an empty list in order to disable the default listeners, which          otherwise would require an ApplicationContext to be configured through          @ContextConfiguration.          @RunWith(SpringJUnit4ClassRunner.class)@TestExecutionListeners({})public class SimpleTest {    @Test    public void testMethod() {        // execute test logic...    }}                TestNG support classes                    \n\r\n\rThe org.springframework.test.context.testng          package provides support classes for TestNG based test cases.          \n\r              \n\r\n\rAbstractTestNGSpringContextTests:              Abstract base test class that integrates the Spring              TestContext Framework with explicit              ApplicationContext testing support in a              TestNG environment.              \n\r\n\rWhen you extend              AbstractTestNGSpringContextTests, you can              access the following protected instance              variable:              \n\r                  \n\r\n\rapplicationContext: Use this variable                  to perform explicit bean lookups or to test the state of the                  context as a whole.                \n\r            \n\r              \n\r\n\rAbstractTransactionalTestNGSpringContextTests:              Abstract transactional extension of              AbstractTestNGSpringContextTests that adds              some convenience functionality for JDBC access. Expects a              javax.sql.DataSource bean and a              PlatformTransactionManager bean to              be defined in the ApplicationContext. When              you extend              AbstractTransactionalTestNGSpringContextTests,              you can access the following protected instance              variables:              \n\r                  \n\r\n\rapplicationContext: Inherited from                  the AbstractTestNGSpringContextTests                  superclass. Use this variable to perform explicit bean lookups                  or to test the state of the context as a whole.                \n\r                  \n\r\n\rjdbcTemplate: Use this variable to                  execute SQL statements to query the database. Such queries can                  be used to confirm database state both prior                  to and after execution of                  database-related application code, and Spring ensures that                  such queries run in the scope of the same transaction as the                  application code. When used in conjunction with an ORM tool,                  be sure to avoid false                  positives.                \n\r            \n\r          Tip            \n\r\n\rThese classes are a convenience for extension. If you do not            want your test classes to be tied to a Spring-specific class            hierarchy &#8212; for example, if you want to directly extend the class            you are testing &#8212; you can configure your own custom test classes by            using @ContextConfiguration,            @TestExecutionListeners, and so on,            and by manually instrumenting your test class with a            TestContextManager. See the source code of            AbstractTestNGSpringContextTests for an            example of how to instrument your test class.                                11.3.6&nbsp;Spring MVC Test Framework            \n\r\n\rStandalone project                \n\r\n\rBefore inclusion in Spring Framework 3.2, the Spring MVC Test        framework had already existed as a separate project on GitHub where it        grew and evolved through actual use, feedback, and the contribution of        many.        \n\r\n\rThe standalone spring-test-mvc        project is still available on GitHub and can be used in        conjunction with Spring Framework 3.1.x. Applications upgrading to 3.2        should replace the spring-test-mvc dependency with        a dependency on spring-test.        \n\r\n\rThe spring-test module uses a different        package org.springframework.test.web but        otherwise is nearly identical with two exceptions. One is support for        features new in 3.2 (e.g. asynchronous web requests). The other relates        to the options for creating a MockMvc instance.        In Spring Framework 3.2, this can only be done through the TestContext        framework, which provides caching benefits for the loaded        configuration.            \n\r\n\rThe Spring MVC Test framework provides first      class JUnit support for testing client and server-side Spring MVC code      through a fluent API. Typically it loads the actual Spring configuration      through the TestContext framework and always uses the      DispatcherServlet to process requests thus      approximating full integration tests without requiring a running Servlet      container.      \n\r\n\rClient-side tests are RestTemplate-based and      allow tests for code that relies on the      RestTemplate without requiring a running server to      respond to the requests.      Server-Side Tests                \n\r\n\rBefore Spring Framework 3.2, the most likely way to test a Spring        MVC controller was to write a unit test that instantiates the        controller, injects it with mock or stub dependencies, and then calls        its methods directly, using a        MockHttpServletRequest and        MockHttpServletResponse where necessary.        \n\r\n\rAlthough this is pretty easy to do, controllers have many        annotations, and much remains untested. Request mappings, data binding,        type conversion, and validation are just a few examples of what isn\'t        tested. Furthermore, there are other types of annotated methods such as        @InitBinder,        @ModelAttribute, and        @ExceptionHandler that get invoked as        part of request processing.        \n\r\n\rThe idea behind Spring MVC Test is to be able to re-write those        controller tests by performing actual requests and generating responses,        as they would be at runtime, along the way invoking controllers through        the Spring MVC DispatcherServlet. Controllers can        still be injected with mock dependencies, so tests can remain focused on        the web layer.        \n\r\n\rSpring MVC Test builds on the familiar \"mock\" implementations of        the Servlet API available in the spring-test        module. This allows performing requests and generating responses without        the need for running in a Servlet container. For the most part        everything should work as it does at runtime with the exception of JSP        rendering, which is not available outside a Servlet container.        Furthermore, if you are familiar with how the        MockHttpServletResponse works, you\'ll know that        forwards and redirects are not actually executed. Instead \"forwarded\"        and \"redirected\" URLs are saved and can be asserted in tests. This means        if you are using JSPs, you can verify the JSP page to which the request        was forwarded.        \n\r\n\rAll other means of rendering including        @ResponseBody methods and        View types (besides JSPs) such as        Freemarker, Velocity, Thymeleaf, and others for rendering HTML, JSON,        XML, and so on should work as expected, and the response will contain        the generated content.        \n\r\n\rBelow is an example of a test requesting account information in        JSON format:        import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(\"test-servlet-context.xml\")public class ExampleTests {    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Before    public void setup() {        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();    }    @Test    public void getAccount() throws Exception {        this.mockMvc.perform(get(\"/accounts/1\").accept(MediaType.parseMediaType(\"application/json;charset=UTF-8\")))          .andExpect(status().isOk())          .andExpect(content().contentType(\"application/json\"))          .andExpect(jsonPath(\"$.name\").value(\"Lee\"));    }}        \n\r\n\rThe test relies on the        WebApplicationContext support of the        TestContext framework. It loads Spring        configuration from an XML configuration file located in the same package        as the test class (also supports JavaConfig) and injects the created        WebApplicationContext into the test so a        MockMvc instance can be created with it.        \n\r\n\rThe MockMvc is then used to perform a        request to \"/accounts/1\" and verify the resulting        response status is 200, the response content type is        \"application/json\", and response content has a JSON        property called \"name\" with the value \"Lee\". JSON content is inspected        with the help of Jayway\'s JsonPath project.        There are lots of other options for verifying the result of the        performed request and those will be discussed later.        Static Imports                    \n\r\n\rThe fluent API in the example above requires a few static          imports such as MockMvcRequestBuilders.*,          MockMvcResultMatchers.*, and          MockMvcBuilders.*. An easy way to find these          classes is to search for types matching          \"MockMvc*\". If using Eclipse, be sure to add them          as \"favorite static members\" in the Eclipse preferences under          Java -&gt; Editor -&gt; Content Assist -&gt;          Favorites. That will allow use of content assist after          typing the first character of the static method name. Other IDEs (e.g.          IntelliJ) may not require any additional configuration. Just check the          support for code completion on static members.                Setup Options                    \n\r\n\rThe goal of server-side test setup is to create an instance of          MockMvc that can be used to perform requests.          There are two main options.          \n\r\n\rThe first option is to point to Spring MVC configuration through          the TestContext framework, which loads the Spring          configuration and injects a          WebApplicationContext into the test to          use to create a MockMvc:          @RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(\"my-servlet-context.xml\")public class MyWebTests {    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Before    public void setup() {        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();    }    // ...}          \n\r\n\rThe second option is to simply register a controller instance          without loading any Spring configuration. Instead basic Spring MVC          configuration suitable for testing annotated controllers is          automatically created. The created configuration is comparable to that          of the MVC JavaConfig (and the MVC namespace) and can be customized to          a degree through builder-style methods:          public class MyWebTests {    private MockMvc mockMvc;    @Before    public void setup() {        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();    }    // ...}          \n\r\n\rWhich option should you use?          \n\r\n\rThe \"webAppContextSetup\" loads the actual          Spring MVC configuration resulting in a more complete integration          test. Since the TestContext framework caches the          loaded Spring configuration, it helps to keep tests running fast even          as more tests get added. Furthermore, you can inject mock services          into controllers through Spring configuration, in order to remain          focused on testing the web layer. Here is an example of declaring a          mock service with Mockito:          &lt;bean id=\"accountService\" class=\"org.mockito.Mockito\" factory-method=\"mock\"&gt;    &lt;constructor-arg value=\"org.example.AccountService\"/&gt;&lt;/bean&gt;          \n\r\n\rThen you can inject the mock service into the test in order set          up and verify expectations:          @RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(\"test-servlet-context.xml\")public class AccountTests {    @Autowired    private WebApplicationContext wac;    private MockMvc mockMvc;    @Autowired    private AccountService accountService;    // ...}          \n\r\n\rThe \"standaloneSetup\" on the other hand is          a little closer to a unit test. It tests one controller at a time, the          controller can be injected with mock dependencies manually, and it          doesn\'t involve loading Spring configuration. Such tests are more          focused in style and make it easier to see which controller is being          tested, whether any specific Spring MVC configuration is required to          work, and so on. The \"standaloneSetup\" is also a very convenient way          to write ad-hoc tests to verify some behavior or to debug an          issue.          \n\r\n\rJust like with integration vs unit testing, there is no right or          wrong answer. Using the \"standaloneSetup\" does imply the need for some          additional \"webAppContextSetup\" tests to verify the Spring MVC          configuration. Alternatively, you can decide write all tests with          \"webAppContextSetup\" and always test against actual Spring MVC          configuration.                Performing Requests                    \n\r\n\rTo perform requests, use the appropriate HTTP method and          additional builder-style methods corresponding to properties of          MockHttpServletRequest. For example:          mockMvc.perform(post(\"/hotels/{id}\", 42).accept(MediaType.APPLICATION_JSON));          \n\r\n\rIn addition to all the HTTP methods, you can also perform file          upload requests, which internally creates an instance of          MockMultipartHttpServletRequest:          mockMvc.perform(fileUpload(\"/doc\").file(\"a1\", \"ABC\".getBytes(\"UTF-8\")));          \n\r\n\rQuery string parameters can be specified in the URI          template:          mockMvc.perform(get(\"/hotels?foo={foo}\", \"bar\"));          \n\r\n\rOr by adding Servlet request parameters:          mockMvc.perform(get(\"/hotels\").param(\"foo\", \"bar\"));          \n\r\n\rIf application code relies on Servlet request parameters, and          doesn\'t check the query string, as is most often the case, then it          doesn\'t matter how parameters are added. Keep in mind though that          parameters provided in the URI template will be decoded while          parameters provided through the param(...) method          are expected to be decoded.          \n\r\n\rIn most cases it\'s preferable to leave out the context path and          the Servlet path from the request URI. If you must test with the full          request URI, be sure to set the contextPath and          servletPath accordingly so that request mappings          will work:          mockMvc.perform(get(\"/app/main/hotels/{id}\").contextPath(\"/app\").servletPath(\"/main\"))          \n\r\n\rLooking at the above example, it would be cumbersome to set the          contextPath and servletPath with every performed request. That\'s why          you can define default request properties when building the          MockMvc:          public class MyWebTests {    private MockMvc mockMvc;    @Before    public void setup() {        mockMvc = standaloneSetup(new AccountController())            .defaultRequest(get(\"/\")                .contextPath(\"/app\").servletPath(\"/main\")                .accept(MediaType.APPLICATION_JSON).build();    }}          \n\r\n\rThe above properties will apply to every request performed          through the MockMvc. If the same property is          also specified on a given request, it will override the default value.          That is why, the HTTP method and URI don\'t matter, when setting          default request properties, since they must be specified on every          request.                Defining Expectations                    \n\r\n\rExpectations can be defined by appending one or more          .andExpect(..) after call to perform the          request:          mockMvc.perform(get(\"/accounts/1\")).andExpect(status().isOk());          \n\r\n\rMockMvcResultMatchers.* defines a number of          static members, some of which return types with additional methods,          for asserting the result of the performed request. The assertions fall          in two general categories.          \n\r\n\rThe first category of assertions verify properties of the          response, i.e the response status, headers, and content. Those are the          most important things to test for.          \n\r\n\rThe second category of assertions go beyond the response, and          allow inspecting Spring MVC specific constructs such as which          controller method processed the request, whether an exception was          raised and handled, what the content of the model is, what view was          selected, what flash attributes were added, and so on. It is also          possible to verify Servlet specific constructs such as request and          session attributes. The following test asserts that binding/validation          failed:          mockMvc.perform(post(\"/persons\"))  .andExpect(status().isOk())  .andExpect(model().attributeHasErrors(\"person\"));          \n\r\n\rMany times when writing tests, it\'s useful to dump the result of          the performed request. This can be done as follows, where          print() is a static import from          MockMvcResultHandlers:          mockMvc.perform(post(\"/persons\"))  .andDo(print())  .andExpect(status().isOk())  .andExpect(model().attributeHasErrors(\"person\"));          \n\r\n\rAs long as request processing causes an unhandled exception, the          print() method will print all the available          result data to System.out.          \n\r\n\rIn some cases, you may want to get direct access to the result          and verify something that cannot be verified otherwise. This can be          done by appending .andReturn() at the end after          all expectations:          MvcResult mvcResult = mockMvc.perform(post(\"/persons\")).andExpect(status().isOk()).andReturn();// ...          \n\r\n\rWhen all tests repeat the same expectations, you can define the          common expectations once when building the          MockMvc:          standaloneSetup(new SimpleController())    .alwaysExpect(status().isOk())    .alwaysExpect(content().contentType(\"application/json;charset=UTF-8\"))    .build()          \n\r\n\rNote that the expectation is always applied          and cannot be overridden without creating a separate          MockMvc instance.          \n\r\n\rWhen JSON response content contains hypermedia links created          with Spring          HATEOAS, the resulting links can be verified:          mockMvc.perform(get(\"/people\").accept(MediaType.APPLICATION_JSON))  .andExpect(jsonPath(\"$.links[?(@.rel == \'self\')].href\").value(\"http://localhost:8080/people\"));          \n\r\n\rWhen XML response content contains hypermedia links created with          Spring          HATEOAS, the resulting links can be verified:          Map&lt;String, String&gt; ns = Collections.singletonMap(\"ns\", \"http://www.w3.org/2005/Atom\");mockMvc.perform(get(\"/handle\").accept(MediaType.APPLICATION_XML))  .andExpect(xpath(\"/person/ns:link[@rel=\'self\']/@href\", ns).string(\"http://localhost:8080/people\"));                Filter Registrations                    \n\r\n\rWhen setting up a MockMvc, you can          register one or more Filter          instances:          mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();          \n\r\n\rRegistered filters will be invoked through          MockFilterChain from          spring-test and the last filter will delegates to          the DispatcherServlet.                Further Server-Side Test Examples                    \n\r\n\rThe framework\'s own tests include many          sample tests intended to demonstrate how to use Spring MVC          Test. Browse these examples for further ideas. Also the spring-mvc-showcase          has full test coverage based on Spring MVC Test.                    Client-Side REST Tests                \n\r\n\rClient-side tests are for code using the        RestTemplate. The goal is to define expected        requests and provide \"stub\" responses:        RestTemplate restTemplate = new RestTemplate();MockRestServiceServer mockServer =  MockRestServiceServer.createServer(restTemplate);mockServer.expect(requestTo(\"/greeting\")).andRespond(withSuccess(\"Hello world\", \"text/plain\"));// use RestTemplate ...mockServer.verify();        \n\r\n\rIn the above example, MockRestServiceServer        -- the central class for client-side REST tests -- configures the        RestTemplate with a custom        ClientHttpRequestFactory that asserts        actual requests against expectations and returns \"stub\" responses. In        this case we expect a single request to \"/greeting\" and want to return a        200 response with \"text/plain\" content. We could define as many        additional requests and stub responses as necessary.        \n\r\n\rOnce expected requests and stub responses have been defined, the        RestTemplate can be used in client-side code as        usual. At the end of the tests mockServer.verify()        can be used to verify that all expected requests were performed.        Static Imports                    \n\r\n\rJust like with server-side tests, the fluent API for client-side          tests requires a few static imports. Those are easy to find by          searching \"MockRest*\". Eclipse users should add          \"MockRestRequestMatchers.*\" and          \"MockRestResponseCreators.*\" as \"favorite          static members\" in the Eclipse preferences under Java -&gt;          Editor -&gt; Content Assist -&gt; Favorites. That allows          using content assist after typing the first character of the static          method name. Other IDEs (e.g. IntelliJ) may not require any additional          configuration. Just check the support for code completion on static          members.                Further Examples of Client-side REST Tests                    \n\r\n\rSpring MVC Test\'s own tests include example          tests of client-side REST tests.                      11.3.7&nbsp;PetClinic Example            \n\r\n\rThe PetClinic application, available from the samples repository, illustrates      several features of the Spring TestContext Framework      in a JUnit 4.5+ environment. Most test functionality is included in the      AbstractClinicTests, for which a partial listing is      shown below:      import static org.junit.Assert.assertEquals;// import ...@ContextConfigurationpublic abstract class AbstractClinicTests extends AbstractTransactionalJUnit4SpringContextTests {    @Autowired    protected Clinic clinic;    @Test    public void getVets() {        Collection&lt;Vet&gt; vets = this.clinic.getVets();        assertEquals(\"JDBC query must show the same number of vets\",            super.countRowsInTable(\"VETS\"), vets.size());        Vet v1 = EntityUtils.getById(vets, Vet.class, 2);        assertEquals(\"Leary\", v1.getLastName());        assertEquals(1, v1.getNrOfSpecialties());        assertEquals(\"radiology\", (v1.getSpecialties().get(0)).getName());        // ...    }    // ...}      \n\r\n\rNotes:      \n\r          \n\r\n\rThis test case extends the          AbstractTransactionalJUnit4SpringContextTests          class, from which it inherits configuration for Dependency Injection          (through the          DependencyInjectionTestExecutionListener) and          transactional behavior (through the          TransactionalTestExecutionListener).        \n\r          \n\r\n\rThe clinic instance variable &#8212; the          application object being tested &#8212; is set by Dependency Injection          through @Autowired semantics.        \n\r          \n\r\n\rThe testGetVets() method illustrates          how you can use the inherited          countRowsInTable() method to easily verify          the number of rows in a given table, thus verifying correct behavior          of the application code being tested. This allows for stronger tests          and lessens dependency on the exact test data. For example, you can          add additional rows in the database without breaking tests.        \n\r          \n\r\n\rLike many integration tests that use a database, most of the          tests in AbstractClinicTests depend on a          minimum amount of data already in the database before the test cases          run. Alternatively, you might choose to populate the database within          the test fixture set up of your test cases &#8212; again, within the same          transaction as the tests.        \n\r      \n\r\n\rThe PetClinic application supports three data access technologies:      JDBC, Hibernate, and JPA. By declaring      @ContextConfiguration without any specific      resource locations, the AbstractClinicTests class      will have its application context loaded from the default location,      AbstractClinicTests-context.xml, which declares a      common DataSource. Subclasses specify additional      context locations that must declare a      PlatformTransactionManager and a concrete      implementation of Clinic.      \n\r\n\rFor example, the Hibernate implementation of the PetClinic tests      contains the following implementation. For this example,      HibernateClinicTests does not contain a single line      of code: we only need to declare      @ContextConfiguration, and the tests are      inherited from AbstractClinicTests. Because      @ContextConfiguration is declared without      any specific resource locations, the Spring TestContext      Framework loads an application context from all the beans      defined in AbstractClinicTests-context.xml (i.e., the      inherited locations) and      HibernateClinicTests-context.xml, with      HibernateClinicTests-context.xml possibly overriding      beans defined in      AbstractClinicTests-context.xml.      @ContextConfigurationpublic class HibernateClinicTests extends AbstractClinicTests { }      \n\r\n\rIn a large-scale application, the Spring configuration is often      split across multiple files. Consequently, configuration locations are      typically specified in a common base class for all application-specific      integration tests. Such a base class may also add useful instance      variables &#8212; populated by Dependency Injection, naturally &#8212; such as a      SessionFactory in the case of an application using      Hibernate.      \n\r\n\rAs far as possible, you should have exactly the same Spring      configuration files in your integration tests as in the deployed      environment. One likely point of difference concerns database connection      pooling and transaction infrastructure. If you are deploying to a      full-blown application server, you will probably use its connection pool      (available through JNDI) and JTA implementation. Thus in production you      will use a JndiObjectFactoryBean or      &lt;jee:jndi-lookup&gt; for the      DataSource and      JtaTransactionManager. JNDI and JTA will not be      available in out-of-container integration tests, so you should use a      combination like the Commons DBCP BasicDataSource      and DataSourceTransactionManager or      HibernateTransactionManager for them. You can      factor out this variant behavior into a single XML file, having the choice      between application server and a \'local\' configuration separated from all      other configuration, which will not vary between the test and production      environments. In addition, it is advisable to use properties files for      connection settings. See the PetClinic application for an example.        11.4&nbsp;Further Resources        \n\r\n\rConsult the following resources for more information about    testing:    \n\r        \n\r\n\rJUnit: &#8220;        A programmer-oriented testing framework for Java        &#8221;. Used by the Spring Framework in its test suite.      \n\r        \n\r\n\rTestNG: A testing        framework inspired by JUnit with added support for Java 5 annotations,        test groups, data-driven testing, distributed testing, etc.      \n\r        \n\r\n\rMockObjects.com: Web site        dedicated to mock objects, a technique for improving the design of code        within test-driven development.      \n\r        \n\r\n\r\"Mock        Objects\": Article in Wikipedia.      \n\r        \n\r\n\rEasyMock: Java        library &#8220; that provides Mock Objects for interfaces (and        objects through the class extension) by generating them on the fly using        Java\'s proxy mechanism. &#8221; Used by the Spring Framework        in its test suite.      \n\r        \n\r\n\rJMock: Library that        supports test-driven development of Java code with mock objects.      \n\r        \n\r\n\rMockito: Java mock        library based on the test spy        pattern.      \n\r        \n\r\n\rDbUnit:        JUnit extension (also usable with Ant and Maven) targeted for        database-driven projects that, among other things, puts your database        into a known state between test runs.      \n\r        \n\r\n\rThe        Grinder: Java load testing framework.      \n\r  Prev&nbsp;Up&nbsp;Next10.&nbsp;Spring AOP APIs&nbsp;Home&nbsp;Part&nbsp;IV.&nbsp;Data Access","11. Testing","scr\\testing.html","         12.&nbsp;Transaction ManagementPrev&nbsp;Part&nbsp;IV.&nbsp;Data Access&nbsp;Next12.&nbsp;Transaction Management    12.1&nbsp;Introduction to Spring Framework transaction management        \n\r\n\rComprehensive transaction support is among the most compelling    reasons to use the Spring Framework. The Spring Framework provides a    consistent abstraction for transaction management that delivers the    following benefits:    \n\r        \n\r\n\rConsistent programming model across different transaction APIs        such as Java Transaction API (JTA), JDBC, Hibernate, Java Persistence        API (JPA), and Java Data Objects (JDO).      \n\r        \n\r\n\rSupport for declarative        transaction management.      \n\r        \n\r\n\rSimpler API for programmatic transaction        management than complex transaction APIs such as JTA.      \n\r        \n\r\n\rExcellent integration with Spring\'s data access        abstractions.      \n\r    \n\r\n\rThe following sections describe the Spring Framework\'s transaction    value-adds and technologies. (The chapter also includes discussions of    best practices, application server integration, and solutions to common    problems.)    \n\r        \n\r\n\rAdvantages of the Spring        Framework\'s transaction support model describes        why you would use the Spring Framework\'s        transaction abstraction instead of EJB Container-Managed Transactions        (CMT) or choosing to drive local transactions through a proprietary        API such as Hibernate.              \n\r        \n\r\n\rUnderstanding the Spring        Framework transaction abstraction outlines the core classes and        describes how to configure and obtain        DataSource instances from a variety of        sources.      \n\r        \n\r\n\rSynchronizing        resources with transactions describes how the application code        ensures that resources are created, reused, and cleaned up        properly.      \n\r        \n\r\n\rDeclarative transaction        management describes support for declarative transaction        management.      \n\r        \n\r\n\rProgrammatic        transaction management covers support for programmatic (that        is, explicitly coded) transaction management.      \n\r    12.2&nbsp;Advantages of the Spring Framework\'s transaction support model        \n\r\n\rTraditionally, Java EE developers have had two choices for    transaction management: global or    local transactions, both of which have profound    limitations. Global and local transaction management is reviewed in the    next two sections, followed by a discussion of how the Spring Framework\'s    transaction management support addresses the limitations of the global and    local transaction models.        12.2.1&nbsp;Global transactions            \n\r\n\rGlobal transactions enable you to work with multiple transactional      resources, typically relational databases and message queues. The      application server manages global transactions through the JTA, which is      a cumbersome API to use (partly due to its exception model).      Furthermore, a JTA UserTransaction      normally needs to be sourced from JNDI, meaning that you      also need to use JNDI in order to use JTA.      Obviously the use of global transactions would limit any potential reuse      of application code, as JTA is normally only available in an application      server environment.      \n\r\n\rPreviously, the preferred way to use global transactions was via      EJB CMT (Container Managed      Transaction): CMT is a form of declarative transaction management (as      distinguished from programmatic transaction      management). EJB CMT removes the need for transaction-related      JNDI lookups, although of course the use of EJB itself necessitates the      use of JNDI. It removes most but not all of the need to write Java code      to control transactions. The significant downside is that CMT is tied to      JTA and an application server environment. Also, it is only available if      one chooses to implement business logic in EJBs, or at least behind a      transactional EJB facade. The negatives of EJB in general are so great      that this is not an attractive proposition, especially in the face of      compelling alternatives for declarative transaction management.        12.2.2&nbsp;Local transactions            \n\r\n\rLocal transactions are resource-specific, such as a transaction      associated with a JDBC connection. Local transactions may be easier to      use, but have significant disadvantages: they cannot work across      multiple transactional resources. For example, code that manages      transactions using a JDBC connection cannot run within a global JTA      transaction. Because the application server is not involved in      transaction management, it cannot help ensure correctness across      multiple resources. (It is worth noting that most applications use a      single transaction resource.) Another downside is that local      transactions are invasive to the programming model.        12.2.3&nbsp;Spring Framework\'s consistent programming model            \n\r\n\rSpring resolves the disadvantages of global and local      transactions. It enables application developers to use a      consistent programming model in any      environment. You write your code once, and it can benefit      from different transaction management strategies in different      environments. The Spring Framework provides both declarative and      programmatic transaction management. Most users prefer declarative      transaction management, which is recommended in most cases.            \n\r\n\rWith programmatic transaction management, developers work with the      Spring Framework transaction abstraction, which can run over any      underlying transaction infrastructure. With the preferred declarative model, developers typically write little or      no code related to transaction management, and hence do not depend on      the Spring Framework transaction API, or any other transaction      API.      \n\r\n\rDo you need an application server for transaction        management?                \n\r\n\rThe Spring Framework\'s transaction management support changes        traditional rules as to when an enterprise Java application requires        an application server.        \n\r\n\rIn particular, you do not need an application server simply for        declarative transactions through EJBs. In fact, even if your        application server has powerful JTA capabilities, you may decide that        the Spring Framework\'s declarative transactions offer more power and a        more productive programming model than EJB CMT.        \n\r\n\rTypically you need an application server\'s JTA capability only        if your application needs to handle transactions across multiple        resources, which is not a requirement for many applications. Many        high-end applications use a single, highly scalable database (such as        Oracle RAC) instead. Standalone transaction managers such as Atomikos Transactions and        JOTM are other        options. Of course, you may need other application server capabilities        such as Java Message Service (JMS) and J2EE Connector Architecture        (JCA).        \n\r\n\rThe Spring Framework gives you the choice of when to        scale your application to a fully loaded application        server. Gone are the days when the only alternative to        using EJB CMT or JTA was to write code with local transactions such as        those on JDBC connections, and face a hefty rework if you need that        code to run within global, container-managed transactions. With the        Spring Framework, only some of the bean definitions in your        configuration file, rather than your code, need to change.                      12.3&nbsp;Understanding the Spring Framework transaction abstraction        \n\r\n\rThe key to the Spring transaction abstraction is the notion of a    transaction strategy. A transaction strategy is    defined by the    org.springframework.transaction.PlatformTransactionManager    interface:    public interface PlatformTransactionManager {  TransactionStatus getTransaction(TransactionDefinition definition)    throws TransactionException;  void commit(TransactionStatus status) throws TransactionException;  void rollback(TransactionStatus status) throws TransactionException;}    \n\r\n\rThis is primarily a service provider interface (SPI), although it    can be used programmatically from your    application code. Because    PlatformTransactionManager is an    interface, it can be easily mocked or stubbed as    necessary. It is not tied to a lookup strategy such as JNDI.    PlatformTransactionManager implementations    are defined like any other object (or bean) in the Spring Framework IoC    container. This benefit alone makes Spring Framework transactions a    worthwhile abstraction even when you work with JTA. Transactional code can    be tested much more easily than if it used JTA directly.    \n\r\n\rAgain in keeping with Spring\'s philosophy, the    TransactionException that can be thrown by    any of the PlatformTransactionManager    interface\'s methods is unchecked (that is, it extends    the java.lang.RuntimeException class).    Transaction infrastructure failures are almost invariably fatal. In rare    cases where application code can actually recover from a transaction    failure, the application developer can still choose to catch and handle    TransactionException. The salient point is    that developers are not forced to do so.    \n\r\n\rThe getTransaction(..) method returns a    TransactionStatus object, depending on a    TransactionDefinition parameter. The    returned TransactionStatus might represent    a new transaction, or can represent an existing transaction if a matching    transaction exists in the current call stack. The implication in this    latter case is that, as with Java EE transaction contexts, a    TransactionStatus is associated with a    thread of execution.    \n\r\n\rThe TransactionDefinition interface    specifies:    \n\r        \n\r\n\rIsolation: The degree to which        this transaction is isolated from the work of other transactions. For        example, can this transaction see uncommitted writes from other        transactions?      \n\r        \n\r\n\rPropagation: Typically, all        code executed within a transaction scope will run in that transaction.        However, you have the option of specifying the behavior in the event        that a transactional method is executed when a transaction context        already exists. For        example, code can continue running in the existing transaction (the        common case); or the existing transaction can be suspended and a new        transaction created. Spring offers all of the transaction        propagation options familiar from EJB CMT. To read about        the semantics of transaction propagation in Spring, see Section&nbsp;12.5.7, &#8220;Transaction propagation&#8221;.      \n\r        \n\r\n\rTimeout: How long this        transaction runs before timing out and being rolled back automatically        by the underlying transaction infrastructure.      \n\r        \n\r\n\rRead-only status: A read-only        transaction can be used when your code reads but does not modify data.        Read-only transactions can be a useful optimization in some cases,        such as when you are using Hibernate.              \n\r    \n\r\n\rThese settings reflect standard transactional concepts. If    necessary, refer to resources that discuss transaction isolation levels    and other core transaction concepts. Understanding these concepts is    essential to using the Spring Framework or any transaction management    solution.    \n\r\n\rThe TransactionStatus interface    provides a simple way for transactional code to control transaction    execution and query transaction status. The concepts should be familiar,    as they are common to all transaction APIs:    public interface TransactionStatus extends SavepointManager {    boolean isNewTransaction();    boolean hasSavepoint();    void setRollbackOnly();    boolean isRollbackOnly();    void flush();    boolean isCompleted();}    \n\r\n\rRegardless of whether you opt for declarative or programmatic    transaction management in Spring, defining the correct    PlatformTransactionManager implementation    is absolutely essential. You typically define this implementation through    dependency injection.        \n\r\n\rPlatformTransactionManager    implementations normally require knowledge of the environment in which    they work: JDBC, JTA, Hibernate, and so on. The following examples show    how you can define a local    PlatformTransactionManager implementation.    (This example works with plain JDBC.)    \n\r\n\rYou define a JDBC DataSource    &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;  &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" /&gt;  &lt;property name=\"url\" value=\"${jdbc.url}\" /&gt;  &lt;property name=\"username\" value=\"${jdbc.username}\" /&gt;  &lt;property name=\"password\" value=\"${jdbc.password}\" /&gt;&lt;/bean&gt;    \n\r\n\rThe related PlatformTransactionManager    bean definition will then have a reference to the    DataSource definition. It will look like this:    &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;  &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;    \n\r\n\rIf you use JTA in a Java EE container then you use a container    DataSource, obtained through JNDI, in    conjunction with Spring\'s JtaTransactionManager.    This is what the JTA and JNDI lookup version would look like:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:jee=\"http://www.springframework.org/schema/jee\"     xsi:schemaLocation=\"     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/jee     http://www.springframework.org/schema/jee/spring-jee.xsd\"&gt;  &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/jpetstore\"/&gt;  &lt;bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\" /&gt;  &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt;    \n\r\n\rThe JtaTransactionManager does not need to    know about the DataSource, or any other    specific resources, because it uses the container\'s global transaction    management infrastructure.    Note      \n\r\n\rThe above definition of the dataSource bean      uses the &lt;jndi-lookup/&gt; tag from the      jee namespace. For more information on schema-based      configuration, see Appendix&nbsp;E, XML Schema-based configuration, and for more      information on the &lt;jee/&gt; tags see the section      entitled Section&nbsp;E.2.3, &#8220;The jee schema&#8221;.        \n\r\n\rYou can also use Hibernate local transactions easily, as shown in    the following examples. In this case, you need to define a Hibernate    LocalSessionFactoryBean, which your application    code will use to obtain Hibernate Session    instances.    \n\r\n\rThe DataSource bean definition will    be similar to the local JDBC example shown previously and thus is not    shown in the following example.        Note      \n\r\n\rIf the DataSource, used by any      non-JTA transaction manager, is looked up via JNDI and managed by a Java      EE container, then it should be non-transactional because the Spring      Framework, rather than the Java EE container, will manage the      transactions.        \n\r\n\rThe txManager bean in this case is of the    HibernateTransactionManager type. In the same way    as the DataSourceTransactionManager needs a    reference to the DataSource, the    HibernateTransactionManager needs a reference to    the SessionFactory.    &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;  &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;  &lt;property name=\"mappingResources\"&gt;  &lt;list&gt;    &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;  &lt;/list&gt;  &lt;/property&gt;  &lt;property name=\"hibernateProperties\"&gt;    &lt;value&gt;      hibernate.dialect=${hibernate.dialect}    &lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"txManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;  &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;&lt;/bean&gt;    \n\r\n\rIf you are using Hibernate and Java EE container-managed JTA    transactions, then you should simply use the same    JtaTransactionManager as in the previous JTA    example for JDBC.    &lt;bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;    Note      \n\r\n\rIf you use JTA , then your transaction manager definition will      look the same regardless of what data access technology you use, be it      JDBC, Hibernate JPA or any other supported technology. This is due to      the fact that JTA transactions are global transactions, which can enlist      any transactional resource.        \n\r\n\rIn all these cases, application code does not need to change. You    can change how transactions are managed merely by changing configuration,    even if that change means moving from local to global transactions or vice    versa.    12.4&nbsp;Synchronizing resources with transactions        \n\r\n\rIt should now be clear how you create different transaction    managers, and how they are linked to related resources that need to be    synchronized to transactions (for example    DataSourceTransactionManager to a JDBC    DataSource,    HibernateTransactionManager to a Hibernate    SessionFactory, and so forth). This section    describes how the application code, directly or indirectly using a    persistence API such as JDBC, Hibernate, or JDO, ensures that these    resources are created, reused, and cleaned up properly. The section also    discusses how transaction synchronization is triggered (optionally)    through the relevant    PlatformTransactionManager.    12.4.1&nbsp;High-level synchronization approach            \n\r\n\rThe preferred approach is to use Spring\'s highest level template      based persistence integration APIs or to use native ORM APIs with      transaction- aware factory beans or proxies for managing the native      resource factories. These transaction-aware solutions internally handle      resource creation and reuse, cleanup, optional transaction      synchronization of the resources, and exception mapping. Thus user data      access code does not have to address these tasks, but can be focused      purely on non-boilerplate persistence logic. Generally, you use the      native ORM API or take a template approach for JDBC      access by using the JdbcTemplate. These solutions      are detailed in subsequent chapters of this reference documentation.        12.4.2&nbsp;Low-level synchronization approach            \n\r\n\rClasses such as DataSourceUtils (for JDBC),      EntityManagerFactoryUtils (for JPA),      SessionFactoryUtils (for Hibernate),      PersistenceManagerFactoryUtils (for JDO), and so      on exist at a lower level. When you want the application code to deal      directly with the resource types of the native persistence APIs, you use      these classes to ensure that proper Spring Framework-managed instances      are obtained, transactions are (optionally) synchronized, and exceptions      that occur in the process are properly mapped to a consistent      API.      \n\r\n\rFor example, in the case of JDBC, instead of the traditional JDBC      approach of calling the getConnection() method on the      DataSource, you instead use Spring\'s      org.springframework.jdbc.datasource.DataSourceUtils      class as follows:      Connection conn = DataSourceUtils.getConnection(dataSource);      \n\r\n\rIf an existing transaction already has a connection synchronized      (linked) to it, that instance is returned. Otherwise, the method call      triggers the creation of a new connection, which is (optionally)      synchronized to any existing transaction, and made available for      subsequent reuse in that same transaction. As mentioned, any      SQLException is wrapped in a Spring      Framework      CannotGetJdbcConnectionException, one of      the Spring Framework\'s hierarchy of unchecked DataAccessExceptions. This      approach gives you more information than can be obtained easily from the      SQLException, and ensures portability      across databases, even across different persistence technologies.      \n\r\n\rThis approach also works without Spring transaction management      (transaction synchronization is optional), so you can use it whether or      not you are using Spring for transaction management.      \n\r\n\rOf course, once you have used Spring\'s JDBC support, JPA support      or Hibernate support, you will generally prefer not to use      DataSourceUtils or the other helper classes,      because you will be much happier working through the Spring abstraction      than directly with the relevant APIs. For example, if you use the Spring      JdbcTemplate or jdbc.object      package to simplify your use of JDBC, correct connection retrieval      occurs behind the scenes and you won\'t need to write any special      code.              12.4.3&nbsp;TransactionAwareDataSourceProxy            \n\r\n\rAt the very lowest level exists the      TransactionAwareDataSourceProxy class. This is a      proxy for a target DataSource, which      wraps the target DataSource to add      awareness of Spring-managed transactions. In this respect, it is similar      to a transactional JNDI DataSource as      provided by a Java EE server.      \n\r\n\rIt should almost never be necessary or desirable to use this      class, except when existing code must be called and passed a standard      JDBC DataSource interface implementation.      In that case, it is possible that this code is usable, but participating      in Spring managed transactions. It is preferable to write your new code      by using the higher level abstractions mentioned above.        12.5&nbsp;Declarative transaction management        Note      \n\r\n\rMost Spring Framework users choose declarative transaction      management. This option has the least impact on application code, and      hence is most consistent with the ideals of a      non-invasive lightweight container.        \n\r\n\rThe Spring Framework\'s declarative transaction management is made    possible with Spring aspect-oriented programming (AOP), although, as the    transactional aspects code comes with the Spring Framework distribution    and may be used in a boilerplate fashion, AOP concepts do not generally    have to be understood to make effective use of this code.    \n\r\n\rThe Spring Framework\'s declarative transaction management is similar    to EJB CMT in that you can specify transaction behavior (or lack of it)    down to individual method level. It is possible to make a    setRollbackOnly() call within a transaction    context if necessary. The differences between the two types of transaction    management are:    \n\r        \n\r\n\rUnlike EJB CMT, which is tied to JTA, the Spring Framework\'s        declarative transaction management works in any environment. It can        work with JTA transactions or local transactions using JDBC, JPA,        Hibernate or JDO by simply adjusting the configuration files.      \n\r        \n\r\n\rYou can apply the Spring Framework declarative transaction        management to any class, not merely special classes such as        EJBs.      \n\r        \n\r\n\rThe Spring Framework offers declarative rollback        rules, a feature with no EJB equivalent. Both        programmatic and declarative support for rollback rules is        provided.      \n\r        \n\r\n\rThe Spring Framework enables you to customize transactional        behavior, by using AOP. For example, you can insert custom behavior in        the case of transaction rollback. You can also add arbitrary advice,        along with the transactional advice. With EJB CMT, you cannot influence        the container\'s transaction management except with        setRollbackOnly().      \n\r        \n\r\n\rThe Spring Framework does not support propagation of transaction        contexts across remote calls, as do high-end application servers. If        you need this feature, we recommend that you use EJB. However,        consider carefully before using such a feature, because normally, one        does not want transactions to span remote calls.      \n\r    \n\r\n\rWhere is      TransactionProxyFactoryBean?            \n\r\n\rDeclarative transaction configuration in versions of Spring 2.0      and above differs considerably from previous versions of Spring. The      main difference is that there is no longer any need to configure      TransactionProxyFactoryBean beans.      \n\r\n\rThe pre-Spring 2.0 configuration style is still 100% valid      configuration; think of the new &lt;tx:tags/&gt; as      simply defining TransactionProxyFactoryBean beans      on your behalf.        \n\r\n\rThe concept of rollback rules is important: they enable you to    specify which exceptions (and throwables) should    cause automatic rollback. You specify this declaratively, in    configuration, not in Java code. So, although you can still call    setRollbackOnly()on the    TransactionStatus object to roll back the    current transaction back, most often you can specify a rule that    MyApplicationException must always result    in rollback. The significant advantage to this option is that business    objects do not depend on the transaction infrastructure. For example, they    typically do not need to import Spring transaction APIs or other Spring    APIs.    \n\r\n\rAlthough EJB container default behavior automatically rolls back the    transaction on a system exception (usually a runtime    exception), EJB CMT does not roll back the transaction automatically on an    application exception (that is, a checked exception    other than java.rmi.RemoteException). While    the Spring default behavior for declarative transaction management follows    EJB convention (roll back is automatic only on unchecked exceptions), it    is often useful to customize this behavior.        12.5.1&nbsp;Understanding the Spring Framework\'s declarative transaction      implementation            \n\r\n\rIt is not sufficient to tell you simply to annotate your classes      with the @Transactional annotation, add      @EnableTransactionManagement to your      configuration, and then expect you to understand how it all works. This      section explains the inner workings of the Spring Framework\'s      declarative transaction infrastructure in the event of      transaction-related issues.      \n\r\n\rThe most important concepts to grasp with regard to the Spring      Framework\'s declarative transaction support are that this support is      enabled via AOP      proxies, and that the transactional advice is driven      by metadata (currently XML- or annotation-based).      The combination of AOP with transactional metadata yields an AOP proxy      that uses a TransactionInterceptor in conjunction      with an appropriate PlatformTransactionManager      implementation to drive transactions around method      invocations.      Note        \n\r\n\rSpring AOP is covered in Chapter&nbsp;9, Aspect Oriented Programming with Spring.            \n\r\n\rConceptually, calling a method on a transactional proxy looks like      this...                    12.5.2&nbsp;Example of declarative transaction implementation            \n\r\n\rConsider the following interface, and its attendant      implementation. This example uses Foo and      Bar classes as placeholders so that you can      concentrate on the transaction usage without focusing on a particular      domain model. For the purposes of this example, the fact that the      DefaultFooService class throws      UnsupportedOperationException instances      in the body of each implemented method is good; it allows you to see      transactions created and then rolled back in response to the      UnsupportedOperationException instance.            // the service interface that we want to make transactionalpackage x.y.service;public interface FooService {  Foo getFoo(String fooName);  Foo getFoo(String fooName, String barName);  void insertFoo(Foo foo);  void updateFoo(Foo foo);}      // an implementation of the above interfacepackage x.y.service;public class DefaultFooService implements FooService {  public Foo getFoo(String fooName) {    throw new UnsupportedOperationException();  }  public Foo getFoo(String fooName, String barName) {    throw new UnsupportedOperationException();  }  public void insertFoo(Foo foo) {    throw new UnsupportedOperationException();  }  public void updateFoo(Foo foo) {    throw new UnsupportedOperationException();  }}      \n\r\n\rAssume that the first two methods of the      FooService interface,      getFoo(String) and getFoo(String, String),      must execute in the context of a transaction with read-only      semantics, and that the other methods,insertFoo(Foo)      and updateFoo(Foo), must execute in the context of a      transaction with read-write semantics. The following configuration is      explained in detail in the next few paragraphs.      &lt;!-- from the file \'context.xml\' --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd     http://www.springframework.org/schema/aop     http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;!-- this is the service object that we want to make transactional --&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;!-- the transactional advice (what \'happens\'; see the &lt;aop:advisor/&gt; bean below) --&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;  &lt;!-- the transactional semantics... --&gt;  &lt;tx:attributes&gt;    &lt;!-- all methods starting with \'get\' are read-only --&gt;    &lt;tx:method name=\"get*\" read-only=\"true\"/&gt;    &lt;!-- other methods use the default transaction settings (see below) --&gt;    &lt;tx:method name=\"*\"/&gt;  &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;!-- ensure that the above transactional advice runs for any execution    of an operation defined by the FooService interface --&gt;  &lt;aop:config&gt;  &lt;aop:pointcut id=\"fooServiceOperation\" expression=\"execution(* x.y.service.FooService.*(..))\"/&gt;  &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/&gt;  &lt;/aop:config&gt;  &lt;!-- don\'t forget the DataSource --&gt;  &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;  &lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/&gt;  &lt;property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/&gt;  &lt;property name=\"username\" value=\"scott\"/&gt;  &lt;property name=\"password\" value=\"tiger\"/&gt;  &lt;/bean&gt;  &lt;!-- similarly, don\'t forget the PlatformTransactionManager --&gt;  &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;  &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;  &lt;/bean&gt;  &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt;      \n\r\n\rExamine the preceding configuration. You want to make a service      object, the fooService bean, transactional. The      transaction semantics to apply are encapsulated in the      &lt;tx:advice/&gt; definition. The      &lt;tx:advice/&gt; definition reads as      &#8220;... all methods on starting with      \'get\' are to execute in the context of a read-only      transaction, and all other methods are to execute with the default      transaction semantics&#8221;. The      transaction-manager attribute of the      &lt;tx:advice/&gt; tag is set to the name of the      PlatformTransactionManager bean that is      going to drive the transactions, in this case, the      txManager bean.      Tip        \n\r\n\rYou can omit the transaction-manager        attribute in the transactional advice        (&lt;tx:advice/&gt;) if the bean name of the        PlatformTransactionManager that you        want to wire in has the name transactionManager. If        the PlatformTransactionManager bean        that you want to wire in has any other name, then you must use the        transaction-manager attribute explicitly, as in the        preceding example.            \n\r\n\rThe &lt;aop:config/&gt; definition ensures that      the transactional advice defined by the txAdvice bean      executes at the appropriate points in the program. First you define a      pointcut that matches the execution of any operation defined in the      FooService interface      (fooServiceOperation). Then you associate the      pointcut with the txAdvice using an advisor. The      result indicates that at the execution of a      fooServiceOperation, the advice defined by      txAdvice will be run.      \n\r\n\rThe expression defined within the      &lt;aop:pointcut/&gt; element is an AspectJ pointcut      expression; see Chapter&nbsp;9, Aspect Oriented Programming with Spring for more details on pointcut      expressions in Spring 2.0.      \n\r\n\rA common requirement is to make an entire service layer      transactional. The best way to do this is simply to change the pointcut      expression to match any operation in your service layer. For      example:      &lt;aop:config&gt;  &lt;aop:pointcut id=\"fooServiceMethods\" expression=\"execution(* x.y.service.*.*(..))\"/&gt;  &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceMethods\"/&gt;&lt;/aop:config&gt;      Note          \n\r\n\rIn this example it is assumed that all your service          interfaces are defined in the x.y.service          package; see Chapter&nbsp;9, Aspect Oriented Programming with Spring for more          details.              \n\r\n\rNow that we\'ve analyzed the configuration, you may be asking      yourself, &#8220;Okay... but what does all this configuration      actually do?&#8221;.      \n\r\n\rThe above configuration will be used to create a transactional      proxy around the object that is created from the      fooService bean definition. The      proxy will be configured with the transactional advice, so that when an      appropriate method is invoked on the proxy, a      transaction is started, suspended, marked as read-only, and so on,      depending on the transaction configuration associated with that method.      Consider the following program that test drives the above      configuration:      public final class Boot {  public static void main(final String[] args) throws Exception {    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"context.xml\", Boot.class);    FooService fooService = (FooService) ctx.getBean(\"fooService\");    fooService.insertFoo (new Foo());  }}      \n\r\n\rThe output from running the preceding program will resemble the      following. (The Log4J output and the stack trace from the      UnsupportedOperationException thrown by the insertFoo(..) method of the      DefaultFooService class have been truncated for clarity.)        &lt;!-- the Spring container is starting up... --&gt;[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy    for bean \'fooService\' with 0 common interceptors and 1 specific interceptors  &lt;!-- the DefaultFooService is actually proxied --&gt;[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]  &lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo  &lt;!-- the transactional advice kicks in here... --&gt;[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo][DataSourceTransactionManager] - Acquired Connection    [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction  &lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should    rollback on java.lang.UnsupportedOperationException[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo    due to throwable [java.lang.UnsupportedOperationException]   &lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection    [org.apache.commons.dbcp.PoolableConnection@a53de4][DataSourceTransactionManager] - Releasing JDBC Connection after transaction[DataSourceUtils] - Returning JDBC Connection to DataSourceException in thread \"main\" java.lang.UnsupportedOperationException    at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)   &lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;    at $Proxy0.insertFoo(Unknown Source)    at Boot.main(Boot.java:11)        12.5.3&nbsp;Rolling back a declarative transaction            \n\r\n\rThe previous section outlined the basics of how to specify      transactional settings for classes, typically service layer classes,      declaratively in your application. This section describes how you can      control the rollback of transactions in a simple declarative      fashion.      \n\r\n\rThe recommended way to indicate to the Spring Framework\'s      transaction infrastructure that a transaction\'s work is to be rolled      back is to throw an Exception from code      that is currently executing in the context of a transaction. The Spring      Framework\'s transaction infrastructure code will catch any unhandled      Exception as it bubbles up the call      stack, and make a determination whether to mark the transaction for      rollback.      \n\r\n\rIn its default configuration, the Spring Framework\'s transaction      infrastructure code only marks a transaction for      rollback in the case of runtime, unchecked exceptions; that is, when the      thrown exception is an instance or subclass of      RuntimeException.      (Errors will also - by default - result      in a rollback). Checked exceptions that are thrown from a transactional      method do not result in rollback in the default      configuration.      \n\r\n\rYou can configure exactly which      Exception types mark a transaction for      rollback, including checked exceptions. The following XML snippet      demonstrates how you configure rollback for a checked,      application-specific Exception      type.      &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;  &lt;tx:attributes&gt;  &lt;tx:method name=\"get*\" read-only=\"true\" rollback-for=\"NoProductInStockException\"/&gt;  &lt;tx:method name=\"*\"/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;      \n\r\n\rYou can also specify \'no rollback rules\', if you do      not want a transaction rolled back when an      exception is thrown. The following example tells the Spring Framework\'s      transaction infrastructure to commit the attendant transaction even in      the face of an unhandled      InstrumentNotFoundException.      &lt;tx:advice id=\"txAdvice\"&gt;  &lt;tx:attributes&gt;  &lt;tx:method name=\"updateStock\" no-rollback-for=\"InstrumentNotFoundException\"/&gt;  &lt;tx:method name=\"*\"/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;      \n\r\n\rWhen the Spring Framework\'s transaction infrastructure catches an      exception and is consults configured rollback rules to determine whether      to mark the transaction for rollback, the strongest      matching rule wins. So in the case of the following configuration, any      exception other than an      InstrumentNotFoundException results in a      rollback of the attendant transaction.      &lt;tx:advice id=\"txAdvice\"&gt;  &lt;tx:attributes&gt;  &lt;tx:method name=\"*\" rollback-for=\"Throwable\" no-rollback-for=\"InstrumentNotFoundException\"/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;      \n\r\n\rYou can also indicate a required rollback      programmatically. Although very simple, this      process is quite invasive, and tightly couples your code to the Spring      Framework\'s transaction infrastructure:      public void resolvePosition() {  try {    // some business logic...  } catch (NoProductInStockException ex) {    // trigger rollback programmatically    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  }}      \n\r\n\rYou are strongly encouraged to use the declarative approach to      rollback if at all possible. Programmatic rollback is available should      you absolutely need it, but its usage flies in the face of achieving a      clean POJO-based architecture.        12.5.4&nbsp;Configuring different transactional semantics for different      beans            \n\r\n\rConsider the scenario where you have a number of service layer      objects, and you want to apply a totally different      transactional configuration to each of them. You do this by defining      distinct &lt;aop:advisor/&gt; elements with differing      pointcut and advice-ref attribute      values.      \n\r\n\rAs a point of comparison, first assume that all of your service      layer classes are defined in a root x.y.service      package. To make all beans that are instances of classes defined in that      package (or in subpackages) and that have names ending in      Service have the default transactional configuration,      you would write the following:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:aop=\"http://www.springframework.org/schema/aop\"  xmlns:tx=\"http://www.springframework.org/schema/tx\"  xsi:schemaLocation=\"  http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx.xsd  http://www.springframework.org/schema/aop  http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"serviceOperation\"          expression=\"execution(* x.y.service..*Service.*(..))\"/&gt;    &lt;aop:advisor pointcut-ref=\"serviceOperation\" advice-ref=\"txAdvice\"/&gt;  &lt;/aop:config&gt;  &lt;!-- these two beans will be transactional... --&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;bean id=\"barService\" class=\"x.y.service.extras.SimpleBarService\"/&gt;  &lt;!-- ... and these two beans won\'t --&gt;  &lt;bean id=\"anotherService\" class=\"org.xyz.SomeService\"/&gt; &lt;!-- (not in the right package) --&gt;  &lt;bean id=\"barManager\" class=\"x.y.service.SimpleBarManager\"/&gt; &lt;!-- (doesn\'t end in \'Service\') --&gt;  &lt;tx:advice id=\"txAdvice\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"get*\" read-only=\"true\"/&gt;      &lt;tx:method name=\"*\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;&lt;/beans&gt;      \n\r\n\rThe following example shows how to configure two distinct beans      with totally different transactional settings.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:aop=\"http://www.springframework.org/schema/aop\"  xmlns:tx=\"http://www.springframework.org/schema/tx\"  xsi:schemaLocation=\"  http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx.xsd  http://www.springframework.org/schema/aop  http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"defaultServiceOperation\"          expression=\"execution(* x.y.service.*Service.*(..))\"/&gt;    &lt;aop:pointcut id=\"noTxServiceOperation\"          expression=\"execution(* x.y.service.ddl.DefaultDdlManager.*(..))\"/&gt;    &lt;aop:advisor pointcut-ref=\"defaultServiceOperation\" advice-ref=\"defaultTxAdvice\"/&gt;    &lt;aop:advisor pointcut-ref=\"noTxServiceOperation\" advice-ref=\"noTxAdvice\"/&gt;  &lt;/aop:config&gt;  &lt;!-- this bean will be transactional (see the \'defaultServiceOperation\' pointcut) --&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;  &lt;bean id=\"anotherFooService\" class=\"x.y.service.ddl.DefaultDdlManager\"/&gt;  &lt;tx:advice id=\"defaultTxAdvice\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"get*\" read-only=\"true\"/&gt;      &lt;tx:method name=\"*\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;tx:advice id=\"noTxAdvice\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"*\" propagation=\"NEVER\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;&lt;/beans&gt;        12.5.5&nbsp;&lt;tx:advice/&gt; settings            \n\r\n\rThis section summarizes the various transactional settings that      can be specified using the &lt;tx:advice/&gt; tag.      The default &lt;tx:advice/&gt; settings are:      \n\r            \n\r\n\rPropagation setting is            REQUIRED.          \n\r            \n\r\n\rIsolation level is DEFAULT.          \n\r            \n\r\n\rTransaction is read/write.          \n\r            \n\r\n\rTransaction timeout defaults to the default timeout of the            underlying transaction system, or none if timeouts are not            supported.          \n\r            \n\r\n\rAny RuntimeException triggers            rollback, and any checked Exception            does not.          \n\r      \n\r\n\rYou can change these default settings; the various attributes of      the &lt;tx:method/&gt; tags that are nested within      &lt;tx:advice/&gt; and      &lt;tx:attributes/&gt; tags are summarized      below:      \n\r\n\rTable&nbsp;12.1.&nbsp;&lt;tx:method/&gt; settings                    AttributeRequired?DefaultDescriptionnameYes&nbsp;\n\r\n\rMethod name(s) with which the transaction                attributes are to be associated. The wildcard (*) character                can be used to associate the same transaction attribute                settings with a number of methods; for example,                get*, handle*,                on*Event, and so forth.propagationNoREQUIREDTransaction propagation behavior.isolationNoDEFAULTTransaction isolation level.timeoutNo-1Transaction timeout value (in seconds).read-onlyNofalseIs this transaction read-only?rollback-forNo&nbsp;\n\r\n\rException(s) that trigger                rollback; comma-delimited. For example,                com.foo.MyBusinessException,ServletException.no-rollback-forNo&nbsp;\n\r\n\rException(s) that do                not trigger rollback; comma-delimited.                For example,                com.foo.MyBusinessException,ServletException.        \n\r\n\r\n\r        12.5.6&nbsp;Using @Transactional            \n\r\n\rIn addition to the XML-based declarative approach to transaction      configuration, you can use an annotation-based approach. Declaring      transaction semantics directly in the Java source code puts the      declarations much closer to the affected code. There is not much danger      of undue coupling, because code that is meant to be used transactionally      is almost always deployed that way anyway.      \n\r\n\rThe ease-of-use afforded by the use of the      @Transactional annotation is best      illustrated with an example, which is explained in the text that      follows. Consider the following class definition:      // the service class that we want to make transactional@Transactionalpublic class DefaultFooService implements FooService {  Foo getFoo(String fooName);  Foo getFoo(String fooName, String barName);  void insertFoo(Foo foo);  void updateFoo(Foo foo);}      \n\r\n\rWhen the above POJO is defined as a bean in a Spring IoC      container, the bean instance can be made transactional by adding merely      one line of XML configuration:      &lt;!-- from the file \'context.xml\' --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd     http://www.springframework.org/schema/aop     http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;!-- this is the service object that we want to make transactional --&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;  &lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt;  &lt;!-- a PlatformTransactionManager is still required --&gt;  &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;  &lt;!-- (this dependency is defined somewhere else) --&gt;  &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;  &lt;/bean&gt;  &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt;      Tip        \n\r\n\rYou can omit the transaction-manager        attribute in the &lt;tx:annotation-driven/&gt; tag        if the bean name of the        PlatformTransactionManager that you        want to wire in has the name transactionManager. If        the PlatformTransactionManager bean        that you want to dependency-inject has any other name, then you have        to use the transaction-manager attribute        explicitly, as in the preceding example.            Note        \n\r\n\rThe @EnableTransactionManagement        annotation provides equivalent support if you are using Java based        configuration. Simply add the annotation to a        @Configuration class. See Javadoc        for full details.            \n\r\n\rMethod visibility and        @Transactional                \n\r\n\rWhen using proxies, you should apply the        @Transactional annotation only to        methods with public visibility. If you do        annotate protected, private or package-visible methods with the        @Transactional annotation, no error is        raised, but the annotated method does not exhibit the configured        transactional settings. Consider the use of AspectJ (see below) if you        need to annotate non-public methods.            \n\r\n\rYou can place the @Transactional      annotation before an interface definition, a method on an interface, a      class definition, or a public method on a class.      However, the mere presence of the      @Transactional annotation is not enough      to activate the transactional behavior. The      @Transactional annotation is simply      metadata that can be consumed by some runtime infrastructure that is      @Transactional-aware and that can use the      metadata to configure the appropriate beans with transactional behavior.      In the preceding example, the      &lt;tx:annotation-driven/&gt; element      switches on the transactional behavior.      Tip          \n\r\n\rSpring recommends that you only annotate concrete classes (and          methods of concrete classes) with the          @Transactional annotation, as opposed          to annotating interfaces. You certainly can place the          @Transactional annotation on an          interface (or an interface method), but this works only as you would          expect it to if you are using interface-based proxies. The fact that          Java annotations are not inherited from interfaces          means that if you are using class-based proxies          (proxy-target-class=\"true\") or the weaving-based          aspect (mode=\"aspectj\"), then the transaction          settings are not recognized by the proxying and weaving          infrastructure, and the object will not be wrapped in a          transactional proxy, which would be decidedly          bad.              Note        \n\r\n\rIn proxy mode (which is the default), only external method calls        coming in through the proxy are intercepted. This means that        self-invocation, in effect, a method within the target object calling        another method of the target object, will not lead to an actual        transaction at runtime even if the invoked method is marked with        @Transactional.            \n\r\n\rConsider the use of AspectJ mode (see mode attribute in table      below) if you expect self-invocations to be wrapped with transactions as      well. In      this case, there will not be a proxy in the first place; instead, the      target class will be weaved (that is, its byte code will be modified) in      order to turn @Transactional into runtime      behavior on any kind of method.      \n\r\n\rTable&nbsp;12.2.&nbsp;Annotation driven transaction settings                    XML AttributeAnnotation AttributeDefaultDescriptiontransaction-managerN/A (See                TransactionManagementConfigurer                Javadoc)transactionManager\n\r\n\rName of transaction manager to use. Only required                if the name of the transaction manager is not                transactionManager, as in the example                above.modemodeproxy\n\r\n\rThe default mode \"proxy\" processes annotated                beans to be proxied using Spring\'s AOP framework (following                proxy semantics, as discussed above, applying to method calls                coming in through the proxy only). The alternative mode                \"aspectj\" instead weaves the affected classes with Spring\'s                AspectJ transaction aspect, modifying the target class byte                code to apply to any kind of method call. AspectJ weaving                requires spring-aspects.jar in the classpath as well as                load-time weaving (or compile-time weaving) enabled. (See                the section called &#8220;Spring configuration&#8221; for details on how to set                up load-time weaving.)proxy-target-classproxyTargetClassfalse\n\r\n\rApplies to proxy mode only. Controls what type of                transactional proxies are created for classes annotated with                the @Transactional annotation.                If the proxy-target-class attribute is set                to true, then class-based proxies are                created. If proxy-target-class is                false or if the attribute is omitted, then                standard JDK interface-based proxies are created. (See Section&nbsp;9.6, &#8220;Proxying mechanisms&#8221; for a detailed examination of the                different proxy types.)orderorderOrdered.LOWEST_PRECEDENCE\n\r\n\rDefines the order of the transaction advice that                is applied to beans annotated with                @Transactional. (For more                information about the rules related to ordering of AOP advice,                see the section called &#8220;Advice ordering&#8221;.) No                specified ordering means that the AOP subsystem determines the                order of the advice.        \n\r\n\r\n\r      Note        \n\r\n\rThe proxy-target-class attribute controls what        type of transactional proxies are created for classes annotated with        the @Transactional annotation. If        proxy-target-class is set to        true, class-based proxies are created. If        proxy-target-class is false or        if the attribute is omitted, standard JDK interface-based proxies are        created. (See Section&nbsp;9.6, &#8220;Proxying mechanisms&#8221; for a discussion of the        different proxy types.)            Note        \n\r\n\r@EnableTransactionManagement and        &lt;tx:annotation-driven/&gt; only looks for        @Transactional on beans in the same        application context they are defined in. This means that, if you put        annotation driven configuration in a        WebApplicationContext for a        DispatcherServlet, it only checks for        @Transactional beans in your        controllers, and not your services. See Section&nbsp;17.2, &#8220;The DispatcherServlet&#8221; for more information.            \n\r\n\rThe most derived location takes precedence when evaluating the      transactional settings for a method. In      the case of the following example, the      DefaultFooService class is annotated at the class      level with the settings for a read-only transaction, but the      @Transactional annotation on the      updateFoo(Foo) method in the same class takes      precedence over the transactional settings defined at the class      level.      @Transactional(readOnly = true)public class DefaultFooService implements FooService {  public Foo getFoo(String fooName) {    // do something  }  // these settings have precedence for this method  @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)  public void updateFoo(Foo foo) {    // do something  }}      @Transactional settings                \n\r\n\rThe @Transactional annotation is        metadata that specifies that an interface, class, or method must have        transactional semantics; for example, &#8220;start a brand        new read-only transaction when this method is invoked, suspending any        existing transaction&#8221;. The default        @Transactional settings are as        follows:        \n\r            \n\r\n\rPropagation setting is            PROPAGATION_REQUIRED.          \n\r            \n\r\n\rIsolation level is            ISOLATION_DEFAULT.          \n\r            \n\r\n\rTransaction is read/write.          \n\r            \n\r\n\rTransaction timeout defaults to the default timeout of the            underlying transaction system, or to none if timeouts are not            supported.          \n\r            \n\r\n\rAny RuntimeException triggers            rollback, and any checked Exception            does not.          \n\r        \n\r\n\rThese default settings can be changed; the various properties of        the @Transactional annotation are        summarized in the following table:        \n\r\n\rTable&nbsp;12.3.&nbsp;@Transactional            properties                        PropertyTypeDescriptionvalueString                    Optional qualifier specifying the transaction manager to be used.                  propagationenum: PropagationOptional propagation setting.isolationenum: IsolationOptional isolation level.readOnlybooleanRead/write vs. read-only transactiontimeoutint (in seconds granularity)Transaction timeout.rollbackForArray of Class objects, which                  must be derived from                  Throwable.Optional array of exception classes that must cause rollback.rollbackForClassNameArray of class names. Classes must be derived from                  Throwable.Optional array of names of exception classes that                  must cause                  rollback.noRollbackForArray of Class objects, which                  must be derived from                  Throwable.Optional array of exception classes that must not cause rollback.noRollbackForClassNameArray of String class names,                  which must be derived from                  Throwable.Optional array of names of exception classes that                  must not cause                  rollback.          \n\r\n\r\n\r        \n\r\n\rCurrently you cannot have explicit control over the name of a        transaction, where \'name\' means the transaction name that will be        shown in a transaction monitor, if applicable (for example, WebLogic\'s        transaction monitor), and in logging output. For declarative        transactions, the transaction name is always the fully-qualified class        name + \".\" + method        name of the transactionally-advised class. For example, if the        handlePayment(..) method of the        BusinessService class started a transaction,        the name of the transaction would be:        com.foo.BusinessService.handlePayment.            Multiple Transaction Managers with @Transactional                \n\r\n\r          Most Spring applications only need a single transaction manager, but there may be situations          where you want multiple independent transaction managers in a single application.          The value attribute of the @Transactional annotation can          be used to optionally specify the identity of the PlatformTransactionManager          to be used. This can either be the bean name or the qualifier value of the transaction manager bean.          For example, using the qualifier notation, the following Java code  public class TransactionalService {    @Transactional(\"order\")    public void setSomething(String name) { ... }    @Transactional(\"account\")    public void doSomething() { ... }  }\n\r\n\r          could be combined with the following transaction manager bean declarations in the application context.  &lt;tx:annotation-driven/&gt;  &lt;bean id=\"transactionManager1\" class=\"org.springframework.jdbc.DataSourceTransactionManager\"&gt;    ...    &lt;qualifier value=\"order\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"transactionManager2\" class=\"org.springframework.jdbc.DataSourceTransactionManager\"&gt;    ...    &lt;qualifier value=\"account\"/&gt;  &lt;/bean&gt;\n\r\n\r          In this case, the two methods on TransactionalService will run under separate          transaction managers, differentiated by the \"order\" and \"account\" qualifiers.          The default &lt;tx:annotation-driven&gt; target bean name transactionManager will          still be used if no specifically qualified PlatformTransactionManager bean is found.                    Custom shortcut annotations                \n\r\n\r          If you find you are repeatedly using the same attributes with @Transactional          on many different methods, then Spring\'s meta-annotation support allows you to define custom shortcut          annotations for your specific use cases. For example, defining the following annotations  @Target({ElementType.METHOD, ElementType.TYPE})  @Retention(RetentionPolicy.RUNTIME)  @Transactional(\"order\")  public @interface OrderTx {  }  @Target({ElementType.METHOD, ElementType.TYPE})  @Retention(RetentionPolicy.RUNTIME)  @Transactional(\"account\")  public @interface AccountTx {  }\n\r\n\r          allows us to write the example from the previous section as  public class TransactionalService {    @OrderTx    public void setSomething(String name) { ... }    @AccountTx    public void doSomething() { ... }  }\n\r\n\r          Here we have used the syntax to define the transaction manager qualifier, but could also have          included propagation behavior, rollback rules, timeouts etc.                      12.5.7&nbsp;Transaction propagation                  \n\r\n\rThis section describes some semantics of transaction propagation      in Spring. Please note that this section is not an introduction to      transaction propagation proper; rather it details some of the semantics      regarding transaction propagation in Spring.      \n\r\n\rIn Spring-managed transactions, be aware of the difference between      physical and logical      transactions, and how the propagation setting applies to this      difference.      Required                PROPAGATION_REQUIRED        \n\r\n\rWhen the propagation setting is        PROPAGATION_REQUIRED, a        logical transaction scope is created for each        method upon which the setting is applied. Each such logical        transaction scope can determine rollback-only status individually,        with an outer transaction scope being logically independent from the        inner transaction scope. Of course, in case of standard        PROPAGATION_REQUIRED behavior, all these scopes        will be mapped to the same physical transaction. So a rollback-only        marker set in the inner transaction scope does affect the outer        transaction\'s chance to actually commit (as you would expect it        to).        \n\r\n\rHowever, in the case where an inner transaction scope sets the        rollback-only marker, the outer transaction has not decided on the        rollback itself, and so the rollback (silently triggered by the inner        transaction scope) is unexpected. A corresponding        UnexpectedRollbackException is thrown at that        point. This is expected behavior so that the        caller of a transaction can never be misled to assume that a commit        was performed when it really was not. So if an inner transaction (of        which the outer caller is not aware) silently marks a transaction as        rollback-only, the outer caller still calls commit. The outer caller        needs to receive an UnexpectedRollbackException        to indicate clearly that a rollback was performed instead.            RequiresNew                \n\r\n\rPROPAGATION_REQUIRES_NEW        \n\r\n\rPROPAGATION_REQUIRES_NEW, in contrast to        PROPAGATION_REQUIRED, uses a        completely independent transaction for each        affected transaction scope. In that case, the underlying physical        transactions are different and hence can commit or roll back        independently, with an outer transaction not affected by an inner        transaction\'s rollback status.            Nested                \n\r\n\rPROPAGATION_NESTED uses a        single physical transaction with multiple        savepoints that it can roll back to. Such partial rollbacks allow an        inner transaction scope to trigger a rollback for its        scope, with the outer transaction being able to continue        the physical transaction despite some operations having been rolled        back. This setting is typically mapped onto JDBC savepoints, so will        only work with JDBC resource transactions. See Spring\'s        DataSourceTransactionManager.              12.5.8&nbsp;Advising transactional operations            \n\r\n\rSuppose you want to execute both      transactional and some basic profiling advice. How      do you effect this in the context of      &lt;tx:annotation-driven/&gt;?      \n\r\n\rWhen you invoke the updateFoo(Foo)      method, you want to see the following actions:      \n\r          \n\r\n\rConfigured profiling aspect starts up.        \n\r          \n\r\n\rTransactional advice executes.        \n\r          \n\r\n\rMethod on the advised object executes.        \n\r          \n\r\n\rTransaction commits.        \n\r          \n\r\n\rProfiling aspect reports exact duration of the whole          transactional method invocation.        \n\r      Note        \n\r\n\rThis chapter is not concerned with explaining AOP in any great        detail (except as it applies to transactions). See Chapter&nbsp;9, Aspect Oriented Programming with Spring for detailed coverage of the following AOP        configuration and AOP in general.            \n\r\n\rHere is the code for a simple profiling aspect discussed above.      The      ordering of advice is controlled through the      Ordered interface. For full details on      advice ordering, see the section called &#8220;Advice ordering&#8221;.      package x.y;import org.aspectj.lang.ProceedingJoinPoint;import org.springframework.util.StopWatch;import org.springframework.core.Ordered;public class SimpleProfiler implements Ordered {  private int order;  // allows us to control the ordering of advice  public int getOrder() {    return this.order;  }  public void setOrder(int order) {    this.order = order;  }  // this method *is* the around advice  public Object profile(ProceedingJoinPoint call) throws Throwable {    Object returnValue;    StopWatch clock = new StopWatch(getClass().getName());    try {      clock.start(call.toShortString());      returnValue = call.proceed();    } finally {      clock.stop();      System.out.println(clock.prettyPrint());    }    return returnValue;  }}      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"   http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx.xsd   http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;!-- this is the aspect --&gt;  &lt;bean id=\"profiler\" class=\"x.y.SimpleProfiler\"&gt;    &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;    &lt;property name=\"order\" value=\"1\"/&gt;  &lt;/bean&gt;  &lt;tx:annotation-driven transaction-manager=\"txManager\" order=\"200\"/&gt;  &lt;aop:config&gt;    &lt;!-- this advice will execute around the transactional advice --&gt;    &lt;aop:aspect id=\"profilingAspect\" ref=\"profiler\"&gt;      &lt;aop:pointcut id=\"serviceMethodWithReturnValue\"              expression=\"execution(!void x.y..*Service.*(..))\"/&gt;      &lt;aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/&gt;    &lt;/aop:aspect&gt;  &lt;/aop:config&gt;  &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;    &lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/&gt;    &lt;property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/&gt;    &lt;property name=\"username\" value=\"scott\"/&gt;    &lt;property name=\"password\" value=\"tiger\"/&gt;  &lt;/bean&gt;  &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;  &lt;/bean&gt;&lt;/beans&gt;      \n\r\n\rThe result of the above configuration is a      fooService bean that has profiling and transactional      aspects applied to it in the desired order. You      configure any number of additional aspects in similar fashion.      \n\r\n\rThe following example effects the same setup as above, but uses      the purely XML declarative approach.      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"   http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx.xsd   http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;  &lt;!-- the profiling advice --&gt;  &lt;bean id=\"profiler\" class=\"x.y.SimpleProfiler\"&gt;    &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;    &lt;property name=\"order\" value=\"1\"/&gt;  &lt;/bean&gt;  &lt;aop:config&gt;    &lt;aop:pointcut id=\"entryPointMethod\" expression=\"execution(* x.y..*Service.*(..))\"/&gt;    &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;    &lt;aop:advisor        advice-ref=\"txAdvice\"        pointcut-ref=\"entryPointMethod\"        order=\"2\"/&gt; &lt;!-- order value is higher than the profiling aspect --&gt;    &lt;aop:aspect id=\"profilingAspect\" ref=\"profiler\"&gt;      &lt;aop:pointcut id=\"serviceMethodWithReturnValue\"              expression=\"execution(!void x.y..*Service.*(..))\"/&gt;      &lt;aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/&gt;    &lt;/aop:aspect&gt;  &lt;/aop:config&gt;  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;    &lt;tx:attributes&gt;      &lt;tx:method name=\"get*\" read-only=\"true\"/&gt;      &lt;tx:method name=\"*\"/&gt;    &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;  &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;&lt;/beans&gt;      \n\r\n\rThe result of the above configuration will be a      fooService bean that has profiling and transactional      aspects applied to it in that order. If you want      the profiling advice to execute after the      transactional advice on the way in, and before the      transactional advice on the way out, then you simply swap the value of      the profiling aspect bean\'s order property so that it      is higher than the transactional advice\'s order value.      \n\r\n\rYou configure additional aspects in similar fashion.        12.5.9&nbsp;Using @Transactional with      AspectJ            \n\r\n\rIt is also possible to use the Spring Framework\'s      @Transactional support outside of a      Spring container by means of an AspectJ aspect. To do so, you first      annotate your classes (and optionally your classes\' methods) with the      @Transactional annotation, and then you      link (weave) your application with the      org.springframework.transaction.aspectj.AnnotationTransactionAspect      defined in the spring-aspects.jar file. The aspect must      also be configured with a transaction manager. You can of course use the      Spring Framework\'s IoC container to take care of dependency-injecting      the aspect. The simplest way to configure the transaction management      aspect is to use the &lt;tx:annotation-driven/&gt;      element and specify the mode attribute to      aspectj as described in Section&nbsp;12.5.6, &#8220;Using @Transactional&#8221;. Because we\'re focusing      here on applications running outside of a Spring container, we\'ll show      you how to do it programmatically.      Note        \n\r\n\rPrior to continuing, you may want to read Section&nbsp;12.5.6, &#8220;Using @Transactional&#8221; and Chapter&nbsp;9, Aspect Oriented Programming with Spring respectively.            // construct an appropriate transaction manager DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methodsAnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);       Note        \n\r\n\rWhen using this aspect, you must annotate the        implementation class (and/or methods within that        class), not the interface (if any) that the class        implements. AspectJ follows Java\'s rule that annotations on interfaces        are not inherited.            \n\r\n\rThe @Transactional annotation on a      class specifies the default transaction semantics for the execution of      any method in the class.      \n\r\n\rThe @Transactional annotation on a      method within the class overrides the default transaction semantics      given by the class annotation (if present). Any method may be annotated,      regardless of visibility.      \n\r\n\rTo weave your applications with the      AnnotationTransactionAspect you must either build      your application with AspectJ (see the AspectJ      Development Guide) or use load-time weaving. See Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221; for a discussion of load-time weaving with      AspectJ.        12.6&nbsp;Programmatic transaction management        \n\r\n\rThe Spring Framework provides two means of programmatic transaction    management:    \n\r        \n\r\n\rUsing the TransactionTemplate.      \n\r        \n\r\n\rUsing a        PlatformTransactionManager        implementation directly.      \n\r    \n\r\n\rThe Spring team generally recommends the    TransactionTemplate for programmatic transaction    management. The second approach is similar to using the JTA    UserTransaction API, although exception    handling is less cumbersome.    12.6.1&nbsp;Using the TransactionTemplate            \n\r\n\rThe TransactionTemplate adopts the same      approach as other Spring templates such as the      JdbcTemplate. It uses a callback approach, to      free application code from having to do the boilerplate acquisition and      release of transactional resources, and results in code that is      intention driven, in that the code that is written focuses solely on      what the developer wants to do.      Note        \n\r\n\rAs you will see in the examples that follow, using the        TransactionTemplate absolutely couples you to        Spring\'s transaction infrastructure and APIs. Whether or not        programmatic transaction management is suitable for your development        needs is a decision that you will have to make yourself.            \n\r\n\rApplication code that must execute in a transactional context, and      that will use the TransactionTemplate explicitly,      looks like the following. You, as an application developer, write a      TransactionCallback implementation      (typically expressed as an anonymous inner class) that contains the code      that you need to execute in the context of a transaction. You then pass      an instance of your custom      TransactionCallback to the      execute(..) method exposed on the      TransactionTemplate.      public class SimpleService implements Service {  // single TransactionTemplate shared amongst all methods in this instance  private final TransactionTemplate transactionTemplate;  // use constructor-injection to supply the PlatformTransactionManager  public SimpleService(PlatformTransactionManager transactionManager) {    Assert.notNull(transactionManager, \"The \'transactionManager\' argument must not be null.\");    this.transactionTemplate = new TransactionTemplate(transactionManager);  }  public Object someServiceMethod() {    return transactionTemplate.execute(new TransactionCallback() {      // the code in this method executes in a transactional context      public Object doInTransaction(TransactionStatus status) {        updateOperation1();        return resultOfUpdateOperation2();      }    });  }}      \n\r\n\rIf there is no return value, use the convenient      TransactionCallbackWithoutResult class with an      anonymous class as follows:      transactionTemplate.execute(new TransactionCallbackWithoutResult() {  protected void doInTransactionWithoutResult(TransactionStatus status) {    updateOperation1();    updateOperation2();  }});      \n\r\n\rCode within the callback can roll the transaction back by calling      the setRollbackOnly() method on the supplied      TransactionStatus object:      transactionTemplate.execute(new TransactionCallbackWithoutResult() {  protected void doInTransactionWithoutResult(TransactionStatus status) {    try {      updateOperation1();      updateOperation2();    } catch (SomeBusinessExeption ex) {      status.setRollbackOnly();    }  }});      Specifying transaction settings                \n\r\n\rYou can specify transaction settings such as the propagation        mode, the isolation level, the timeout, and so forth on the        TransactionTemplate either programmatically or        in configuration. TransactionTemplate instances        by default have the default        transactional settings. The following example shows the        programmatic customization of the transactional settings for a        specific TransactionTemplate:        public class SimpleService implements Service {  private final TransactionTemplate transactionTemplate;  public SimpleService(PlatformTransactionManager transactionManager) {    Assert.notNull(transactionManager, \"The \'transactionManager\' argument must not be null.\");    this.transactionTemplate = new TransactionTemplate(transactionManager);    // the transaction settings can be set here explicitly if so desired    this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);    this.transactionTemplate.setTimeout(30); // 30 seconds    // and so forth...  }}        \n\r\n\rThe following example defines a        TransactionTemplate with some custom        transactional settings, using Spring XML configuration. The        sharedTransactionTemplate can then be injected into        as many services as are required.        &lt;bean id=\"sharedTransactionTemplate\"    class=\"org.springframework.transaction.support.TransactionTemplate\"&gt;  &lt;property name=\"isolationLevelName\" value=\"ISOLATION_READ_UNCOMMITTED\"/&gt;  &lt;property name=\"timeout\" value=\"30\"/&gt;&lt;/bean&gt;\"          \n\r\n\rFinally, instances of the          TransactionTemplate class are threadsafe, in that          instances do not maintain any conversational state.          TransactionTemplate instances          do however maintain configuration state, so while a          number of classes may share a single instance of a          TransactionTemplate, if a class needs to use a          TransactionTemplate with different settings (for          example, a different isolation level), then you need to create two          distinct TransactionTemplate instances.              12.6.2&nbsp;Using the      PlatformTransactionManager            \n\r\n\rYou can also use the      org.springframework.transaction.PlatformTransactionManager      directly to manage your transaction. Simply pass the implementation of      the PlatformTransactionManager you are      using to your bean through a bean reference. Then, using the      TransactionDefinition and      TransactionStatus objects you can      initiate transactions, roll back, and commit.      DefaultTransactionDefinition def = new DefaultTransactionDefinition();// explicitly setting the transaction name is something that can only be done programmaticallydef.setName(\"SomeTxName\");def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);TransactionStatus status = txManager.getTransaction(def);try {  // execute your business logic here}catch (MyException ex) {  txManager.rollback(status);  throw ex;}txManager.commit(status);        12.7&nbsp;Choosing between programmatic and declarative transaction    management        \n\r\n\rProgrammatic transaction management is usually a good idea only if    you have a small number of transactional operations. For example, if you    have a web application that require transactions only for certain update    operations, you may not want to set up transactional proxies using Spring    or any other technology. In this case, using the    TransactionTemplate may be a    good approach. Being able to set the transaction name explicitly is also    something that can only be done using the programmatic approach to    transaction management.    \n\r\n\rOn the other hand, if your application has numerous transactional    operations, declarative transaction management is usually worthwhile. It    keeps transaction management out of business logic, and is not difficult    to configure. When using the Spring Framework, rather than EJB CMT, the    configuration cost of declarative transaction management is greatly    reduced.    12.8&nbsp;Application server-specific integration        \n\r\n\rSpring\'s transaction abstraction generally is application server    agnostic. Additionally, Spring\'s    JtaTransactionManager class, which can optionally    perform a JNDI lookup for the JTA    UserTransaction and    TransactionManager objects, autodetects the    location for the latter object, which varies by application server. Having    access to the JTA TransactionManager allows    for enhanced transaction semantics, in particular supporting transaction    suspension. See the JtaTransactionManager Javadocs    for details.    \n\r\n\rSpring\'s JtaTransactionManager is the    standard choice to run on Java EE application servers, and is known to    work on all common servers. Advanced functionality such as transaction    suspension works on many servers as well -- including GlassFish, JBoss,    Geronimo, and Oracle OC4J -- without any special configuration required.    However, for fully supported transaction suspension and further advanced    integration, Spring ships special adapters for IBM WebSphere, BEA WebLogic    Server, and Oracle OC4J. These adapters are discussed in the following    sections.    \n\r\n\rFor standard scenarios, including WebLogic Server,    WebSphere and OC4J, consider using the convenient    &lt;tx:jta-transaction-manager/&gt; configuration    element. When configured, this element automatically detects    the underlying server and chooses the best transaction manager available    for the platform. This means that you won\'t have to configure    server-specific adapter classes (as discussed in the following sections)    explicitly; rather, they are chosen automatically, with the standard    JtaTransactionManager as default fallback.    12.8.1&nbsp;IBM WebSphere            \n\r\n\rOn WebSphere 6.1.0.9 and above, the recommended Spring JTA      transaction manager to use is      WebSphereUowTransactionManager. This special      adapter leverages IBM\'s UOWManager API,      which is available in WebSphere Application Server 6.0.2.19 and later      and 6.1.0.9 and later. With this adapter, Spring-driven transaction      suspension (suspend/resume as initiated by      PROPAGATION_REQUIRES_NEW) is officially supported by      IBM!        12.8.2&nbsp;BEA WebLogic Server            \n\r\n\rOn WebLogic Server 9.0 or above, you typically would use the      WebLogicJtaTransactionManager instead of the      stock JtaTransactionManager class. This special      WebLogic-specific subclass of the normal      JtaTransactionManager supports the full power of      Spring\'s transaction definitions in a WebLogic-managed transaction      environment, beyond standard JTA semantics: Features include transaction      names, per-transaction isolation levels, and proper resuming of      transactions in all cases.        12.8.3&nbsp;Oracle OC4J            \n\r\n\rSpring ships a special adapter class for OC4J 10.1.3 or later      called OC4JJtaTransactionManager. This class is      analogous to the WebLogicJtaTransactionManager      class discussed in the previous section, providing similar value-adds on      OC4J: transaction names and per-transaction isolation levels.      \n\r\n\rThe full JTA functionality, including transaction suspension,      works fine with Spring\'s JtaTransactionManager on      OC4J as well. The special      OC4JJtaTransactionManager adapter simply provides      value-adds beyond standard JTA.        12.9&nbsp;Solutions to common problems        12.9.1&nbsp;Use of the wrong transaction manager for a specific      DataSource            \n\r\n\rUse the correct      PlatformTransactionManager implementation      based on your choice of transactional technologies and requirements.      Used properly, the Spring Framework merely provides a straightforward      and portable abstraction. If you are using global transactions, you      must use the      org.springframework.transaction.jta.JtaTransactionManager      class (or an application      server-specific subclass of it) for all your transactional      operations. Otherwise the transaction infrastructure attempts to perform      local transactions on resources such as container      DataSource instances. Such local      transactions do not make sense, and a good application server treats      them as errors.        12.10&nbsp;Further Resources        \n\r\n\rFor more information about the Spring Framework\'s transaction    support:    \n\r        \n\r\n\rDistributed        transactions in Spring, with and without XA is a JavaWorld        presentation in which SpringSource\'s David Syer guides you through        seven patterns for distributed transactions in Spring applications,        three of them with XA and four without.      \n\r        \n\r\n\rJava        Transaction Design Strategies is a book available from InfoQ that provides a well-paced        introduction to transactions in Java. It also includes side-by-side        examples of how to configure and use transactions with both the Spring        Framework and EJB3.      \n\r  Prev&nbsp;Up&nbsp;NextPart&nbsp;IV.&nbsp;Data Access&nbsp;Home&nbsp;13.&nbsp;DAO support","12. Transaction Management","scr\\transaction.html","         7.&nbsp;Validation, Data Binding, and Type ConversionPrev&nbsp;Part&nbsp;III.&nbsp;Core Technologies&nbsp;Next7.&nbsp;Validation, Data Binding, and Type Conversion    7.1&nbsp;Introduction        \n\r\n\rJSR-303 Bean Validation            \n\r\n\rThe Spring Framework supports JSR-303 Bean Validation adapting      it to Spring\'s Validator interface.      \n\r\n\rAn application can choose to enable JSR-303 Bean Validation once globally,      as described in Section&nbsp;7.8, &#8220;Spring 3 Validation&#8221;, and use it      exclusively for all validation needs.      \n\r\n\rAn application can also register      additional Spring Validator instances      per DataBinder instance, as described in      Section&nbsp;7.8.3, &#8220;Configuring a DataBinder&#8221;. This may be useful for      plugging in validation logic without the use of annotations.        \n\r\n\rThere are pros and cons for considering validation as business logic,      and Spring offers a design for validation (and data binding) that does not      exclude either one of them. Specifically validation should not be tied to      the web tier, should be easy to localize and it should be possible to plug      in any validator available. Considering the above, Spring has come up with      a Validator interface that is both basic      ands eminently usable in every layer of an application.     \n\r\n\rData binding is useful for allowing user input to be dynamically bound      to the domain model of an application (or whatever objects you use to      process user input). Spring provides the so-called      DataBinder to do exactly that. The      Validator and the      DataBinder make up the      validation package, which is primarily used in but not      limited to the MVC framework.     \n\r\n\rThe BeanWrapper is a fundamental      concept in the Spring Framework and is used in a lot of places. However,      you probably will not have the need to use the      BeanWrapper directly. Because this is      reference documentation however, we felt that some explanation might be in      order. We will explain the BeanWrapper in      this chapter since, if you were going to use it at all, you would most      likely do so when trying to bind data to objects.    \n\r\n\rSpring\'s DataBinder and the lower-level BeanWrapper both use      PropertyEditors to parse and format property values. The      PropertyEditor concept is part of the      JavaBeans specification, and is also explained in this chapter. Spring 3      introduces a \"core.convert\" package that provides a general type      conversion facility, as well as a higher-level \"format\" package for      formatting UI field values. These new packages may be used as simpler      alternatives to PropertyEditors, and will also be discussed in this      chapter.    7.2&nbsp;Validation using Spring\'s Validator      interface        \n\r\n\rSpring features a Validator interface      that you can use to validate objects. The      Validator interface works using an      Errors object so that while validating,      validators can report validation failures to the      Errors object.    \n\r\n\rLet\'s consider a small data object:    public class Person {  private String name;  private int age;  // the usual getters and setters...}    \n\r\n\rWe\'re going to provide validation behavior for the      Person class by implementing the following two      methods of the      org.springframework.validation.Validator      interface: \n\r        \n\r\n\rsupports(Class) - Can this          Validator validate instances of the          supplied Class?      \n\r        \n\r\n\rvalidate(Object,          org.springframework.validation.Errors) - validates the          given object and in case of validation errors, registers those with          the given Errors object      \n\r\n\r\n\r     \n\r\n\r Implementing a Validator is fairly      straightforward, especially when you know of the      ValidationUtils helper class that the Spring      Framework also provides.    public class PersonValidator implements Validator {    /**    * This Validator validates *just* Person instances    */    public boolean supports(Class clazz) {        return Person.class.equals(clazz);    }    public void validate(Object obj, Errors e) {        ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\");        Person p = (Person) obj;        if (p.getAge() &lt; 0) {            e.rejectValue(\"age\", \"negativevalue\");        } else if (p.getAge() &gt; 110) {            e.rejectValue(\"age\", \"too.darn.old\");        }    }}    \n\r\n\rAs you can see, the static      rejectIfEmpty(..) method on the      ValidationUtils class is used to reject the      \'name\' property if it is null or the      empty string. Have a look at the Javadoc for the      ValidationUtils class to see what functionality it      provides besides the example shown previously.    \n\r\n\rWhile it is certainly possible to implement a single      Validator class to validate each of the      nested objects in a rich object, it may be better to encapsulate the      validation logic for each nested class of object in its own      Validator implementation. A simple example      of a \'rich\' object would be a      Customer that is composed of two      String properties (a first and second name) and a      complex Address object.      Address objects may be used independently of      Customer objects, and so a distinct      AddressValidator has been implemented. If you want      your CustomerValidator to reuse the logic contained      within the AddressValidator class without resorting      to copy-and-paste, you can dependency-inject or instantiate an      AddressValidator within your      CustomerValidator, and use it like so:    public class CustomerValidator implements Validator {    private final Validator addressValidator;    public CustomerValidator(Validator addressValidator) {        if (addressValidator == null) {            throw new IllegalArgumentException(              \"The supplied [Validator] is required and must not be null.\");        }        if (!addressValidator.supports(Address.class)) {            throw new IllegalArgumentException(              \"The supplied [Validator] must support the validation of [Address] instances.\");        }        this.addressValidator = addressValidator;    }    /**    * This Validator validates Customer instances, and any subclasses of Customer too    */    public boolean supports(Class clazz) {        return Customer.class.isAssignableFrom(clazz);    }    public void validate(Object target, Errors errors) {        ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\");        ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\");        Customer customer = (Customer) target;        try {            errors.pushNestedPath(\"address\");            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);        } finally {            errors.popNestedPath();        }    }}    \n\r\n\rValidation errors are reported to the      Errors object passed to the validator. In      case of Spring Web MVC you can use &lt;spring:bind/&gt;      tag to inspect the error messages, but of course you can also inspect the      errors object yourself. More information about the methods it offers can      be found from the Javadoc.    7.3&nbsp;Resolving codes to error messages        \n\r\n\rWe\'ve talked about databinding and validation. Outputting messages      corresponding to validation errors is the last thing we need to discuss.      In the example we\'ve shown above, we rejected the name      and the age field. If we\'re going to output the error      messages by using a MessageSource, we will      do so using the error code we\'ve given when rejecting the field (\'name\'      and \'age\' in this case). When you call (either directly, or indirectly,      using for example the ValidationUtils class)      rejectValue or one of the other      reject methods from the      Errors interface, the underlying      implementation will not only register the code you\'ve passed in, but also      a number of additional error codes. What error codes it registers is      determined by the MessageCodesResolver that      is used. By default, the      DefaultMessageCodesResolver is used, which for      example not only registers a message with the code you gave, but also      messages that include the field name you passed to the reject method. So      in case you reject a field using rejectValue(\"age\",      \"too.darn.old\"), apart from the too.darn.old      code, Spring will also register too.darn.old.age and      too.darn.old.age.int (so the first will include the      field name and the second will include the type of the field); this is      done as a convenience to aid developers in targeting error messages and      suchlike.    \n\r\n\rMore information on the      MessageCodesResolver and the default      strategy can be found online with the Javadocs for MessageCodesResolver and DefaultMessageCodesResolver respectively.    7.4&nbsp;Bean manipulation and the      BeanWrapper        \n\r\n\rThe org.springframework.beans package adheres to      the JavaBeans standard provided by Sun. A JavaBean is simply a class with      a default no-argument constructor, which follows a naming convention where      (by way of an example) a property named bingoMadness      would have a setter method setBingoMadness(..)      and a getter method getBingoMadness(). For more      information about JavaBeans and the specification, please refer to Sun\'s      website ( java.sun.com/products/javabeans).    \n\r\n\rOne quite important class in the beans package is the      BeanWrapper interface and its corresponding      implementation (BeanWrapperImpl). As quoted from      the Javadoc, the BeanWrapper offers      functionality to set and get property values (individually or in bulk),      get property descriptors, and to query properties to determine if they are      readable or writable. Also, the BeanWrapper      offers support for nested properties, enabling the setting of properties      on sub-properties to an unlimited depth. Then, the      BeanWrapper supports the ability to add      standard JavaBeans PropertyChangeListeners      and VetoableChangeListeners, without the      need for supporting code in the target class. Last but not least, the      BeanWrapper provides support for the      setting of indexed properties. The      BeanWrapper usually isn\'t used by      application code directly, but by the      DataBinder and the      BeanFactory.    \n\r\n\rThe way the BeanWrapper works is partly      indicated by its name: it wraps a bean to perform      actions on that bean, like setting and retrieving properties.    7.4.1&nbsp;Setting and getting basic and nested properties            \n\r\n\rSetting and getting properties is done using the        setPropertyValue(s) and        getPropertyValue(s) methods that both come with a        couple of overloaded variants. They\'re all described in more detail in        the Javadoc Spring comes with. What\'s important to know is that there        are a couple of conventions for indicating properties of an object. A        couple of examples:      \n\r\n\rTable&nbsp;7.1.&nbsp;Examples of properties                ExpressionExplanationnameIndicates the property name                corresponding to the methods getName()                or isName() and                setName(..)account.nameIndicates the nested property name of                the property account corresponding e.g. to                the methods getAccount().setName() or                getAccount().getName()account[2]Indicates the third element of the                indexed property account. Indexed properties                can be of type array, list                or other naturally ordered                collectionaccount[COMPANYNAME]Indicates the value of the map entry indexed by the key                COMPANYNAME of the Map property                account      \n\r      \n\r\n\rBelow you\'ll find some examples of working with the        BeanWrapper to get and set        properties.      \n\r\n\r(This next section is not vitally important to you if        you\'re not planning to work with the        BeanWrapper directly. If you\'re just        using the DataBinder and the        BeanFactory and their out-of-the-box        implementation, you should skip ahead to the section about        PropertyEditors.)      \n\r\n\rConsider the following two classes:      public class Company {    private String name;    private Employee managingDirector;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }    public Employee getManagingDirector() {        return this.managingDirector;    }    public void setManagingDirector(Employee managingDirector) {        this.managingDirector = managingDirector;    }}      public class Employee {    private String name;    private float salary;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }    public float getSalary() {        return salary;    }    public void setSalary(float salary) {        this.salary = salary;    }}      \n\r\n\rThe following code snippets show some examples of how to retrieve        and manipulate some of the properties of instantiated        Companies and Employees:      BeanWrapper company = BeanWrapperImpl(new Company());// setting the company name..company.setPropertyValue(\"name\", \"Some Company Inc.\");// ... can also be done like this:PropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\");company.setPropertyValue(value);// ok, let\'s create the director and tie it to the company:BeanWrapper jim = BeanWrapperImpl(new Employee());jim.setPropertyValue(\"name\", \"Jim Stravinsky\");company.setPropertyValue(\"managingDirector\", jim.getWrappedInstance());// retrieving the salary of the managingDirector through the companyFloat salary = (Float) company.getPropertyValue(\"managingDirector.salary\");        7.4.2&nbsp;Built-in PropertyEditor        implementations            \n\r\n\rSpring uses the concept of PropertyEditors to        effect the conversion between an Object and a        String. If you think about it, it sometimes might        be handy to be able to represent properties in a different way than the        object itself. For example, a Date can be        represented in a human readable way (as the        String \'2007-14-09\'), while        we\'re still able to convert the human readable form back to the original        date (or even better: convert any date entered in a human readable form,        back to Date objects). This behavior can be        achieved by registering custom editors, of type        java.beans.PropertyEditor. Registering        custom editors on a BeanWrapper or        alternately in a specific IoC container as mentioned in the previous        chapter, gives it the knowledge of how to convert properties to the        desired type. Read more about        PropertyEditors in the Javadoc of the        java.beans package provided by Sun.      \n\r\n\rA couple of examples where property editing is used in Spring:        \n\r          \n\r\n\rsetting properties on beans is done using            PropertyEditors. When mentioning            java.lang.String as the value of a property of            some bean you\'re declaring in XML file, Spring will (if the setter            of the corresponding property has a            Class-parameter) use the            ClassEditor to try to resolve the parameter            to a Class object.        \n\r          \n\r\n\rparsing HTTP request parameters in Spring\'s            MVC framework is done using all kinds of            PropertyEditors that you can manually bind in all            subclasses of the CommandController.        \n\r\n\r\n\r       \n\r\n\rSpring has a number of built-in PropertyEditors        to make life easy. Each of those is listed below and they are all        located in the        org.springframework.beans.propertyeditors package.        Most, but not all (as indicated below), are registered by default by        BeanWrapperImpl. Where the property editor is        configurable in some fashion, you can of course still register your own        variant to override the default one:      \n\r\n\rTable&nbsp;7.2.&nbsp;Built-in PropertyEditors                ClassExplanationByteArrayPropertyEditorEditor for byte arrays. Strings will simply be converted to                their corresponding byte representations. Registered by default                by BeanWrapperImpl.ClassEditorParses Strings representing classes to actual classes and                the other way around. When a class is not found, an                IllegalArgumentException is thrown.                Registered by default by                BeanWrapperImpl.CustomBooleanEditorCustomizable property editor for                Boolean properties. Registered by default                by BeanWrapperImpl, but, can be                overridden by registering custom instance of it as custom                editor.CustomCollectionEditorProperty editor for Collections, converting any source                Collection to a given target                Collection type.CustomDateEditorCustomizable property editor for java.util.Date, supporting                a custom DateFormat. NOT registered by default. Must be user                registered as needed with appropriate format.CustomNumberEditorCustomizable property editor for any Number subclass like                Integer, Long,                Float, Double.                Registered by default by BeanWrapperImpl,                but can be overridden by registering custom instance of it as a                custom editor.FileEditorCapable of resolving Strings to                java.io.File objects. Registered by                default by BeanWrapperImpl. InputStreamEditorOne-way property editor, capable of taking a text string                and producing (via an intermediate                ResourceEditor and                Resource) an                InputStream, so                InputStream properties may be                directly set as Strings. Note that the default usage will not                close the InputStream for you!                Registered by default by                BeanWrapperImpl.LocaleEditorCapable of resolving Strings to                Locale objects and vice versa (the String                format is [language]_[country]_[variant], which is the same                thing the toString() method of Locale provides). Registered by                default by BeanWrapperImpl.PatternEditorCapable of resolving Strings to JDK 1.5                Pattern objects and vice versa.PropertiesEditorCapable of converting Strings (formatted using the format                as defined in the Javadoc for the java.lang.Properties class) to                Properties objects. Registered by default                by BeanWrapperImpl.StringTrimmerEditorProperty editor that trims Strings. Optionally allows                transforming an empty string into a null                value. NOT registered by default; must be user registered as                needed.URLEditorCapable of resolving a String representation of a URL to an                actual URL object. Registered by default                by BeanWrapperImpl.      \n\r      \n\r\n\r Spring uses the        java.beans.PropertyEditorManager to set        the search path for property editors that might be needed. The search        path also includes sun.bean.editors, which includes        PropertyEditor implementations for types        such as Font, Color, and        most of the primitive types. Note also that the standard JavaBeans        infrastructure will automatically discover        PropertyEditor classes (without you        having to register them explicitly) if they are in the same package as        the class they handle, and have the same name as that class, with        \'Editor\' appended; for example, one could have the        following class and package structure, which would be sufficient for the        FooEditor class to be recognized and used as the        PropertyEditor for        Foo-typed properties.       com  chank    pop      Foo      FooEditor   // the PropertyEditor for the Foo class      \n\r\n\rNote that you can also use the standard        BeanInfo JavaBeans mechanism here as well        (described in not-amazing-detail here). Find below an example of using the        BeanInfo mechanism for explicitly        registering one or more PropertyEditor        instances with the properties of an associated class.      com  chank    pop      Foo      FooBeanInfo   // the BeanInfo for the Foo class      \n\r\n\r Here is the Java source code for the referenced        FooBeanInfo class. This would associate a        CustomNumberEditor with the        age property of the Foo class.       public class FooBeanInfo extends SimpleBeanInfo {    public PropertyDescriptor[] getPropertyDescriptors() {        try {            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);            PropertyDescriptor ageDescriptor = new PropertyDescriptor(\"age\", Foo.class) {                public PropertyEditor createPropertyEditor(Object bean) {                    return numberPE;                };            };            return new PropertyDescriptor[] { ageDescriptor };        }        catch (IntrospectionException ex) {            throw new Error(ex.toString());        }    }}      Registering additional custom          PropertyEditors                \n\r\n\rWhen setting bean properties as a string value, a Spring IoC          container ultimately uses standard JavaBeans          PropertyEditors to convert these Strings to the          complex type of the property. Spring pre-registers a number of custom          PropertyEditors (for example, to convert a          classname expressed as a string into a real          Class object). Additionally, Java\'s standard          JavaBeans PropertyEditor lookup          mechanism allows a PropertyEditor for a class          simply to be named appropriately and placed in the same package as the          class it provides support for, to be found automatically.        \n\r\n\rIf there is a need to register other custom          PropertyEditors, there are several mechanisms          available. The most manual approach, which is not normally convenient          or recommended, is to simply use the          registerCustomEditor() method of the          ConfigurableBeanFactory interface,          assuming you have a BeanFactory          reference. Another, slightly more convenient, mechanism is to use a          special bean factory post-processor called          CustomEditorConfigurer. Although bean factory          post-processors can be used with          BeanFactory implementations, the          CustomEditorConfigurer has a nested property          setup, so it is strongly recommended that it is used with the          ApplicationContext, where it may be          deployed in similar fashion to any other bean, and automatically          detected and applied.        \n\r\n\rNote that all bean factories and application contexts          automatically use a number of built-in property editors, through their          use of something called a BeanWrapper          to handle property conversions. The standard property editors that the          BeanWrapper registers are listed in          the previous section.          Additionally, ApplicationContexts also override or          add an additional number of editors to handle resource lookups in a          manner appropriate to the specific application context type.        \n\r\n\rStandard JavaBeans PropertyEditor          instances are used to convert property values expressed as strings to          the actual complex type of the property.          CustomEditorConfigurer, a bean factory          post-processor, may be used to conveniently add support for additional          PropertyEditor instances to an          ApplicationContext.        \n\r\n\rConsider a user class ExoticType, and          another class DependsOnExoticType which needs          ExoticType set as a property:        package example;public class ExoticType {    private String name;    public ExoticType(String name) {        this.name = name;    }}public class DependsOnExoticType {    private ExoticType type;    public void setType(ExoticType type) {        this.type = type;    }}        \n\r\n\rWhen things are properly set up, we want to be able to assign the          type property as a string, which a          PropertyEditor will behind the scenes          convert into an actual ExoticType          instance:        &lt;bean id=\"sample\" class=\"example.DependsOnExoticType\"&gt;    &lt;property name=\"type\" value=\"aNameForExoticType\"/&gt;&lt;/bean&gt;        \n\r\n\rThe PropertyEditor implementation          could look similar to this:        // converts string representation to ExoticType objectpackage example;public class ExoticTypeEditor extends PropertyEditorSupport {    public void setAsText(String text) {        setValue(new ExoticType(text.toUpperCase()));    }}        \n\r\n\rFinally, we use CustomEditorConfigurer to          register the new PropertyEditor with          the ApplicationContext, which will then          be able to use it as needed:        &lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt;  &lt;property name=\"customEditors\"&gt;    &lt;map&gt;      &lt;entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/&gt;    &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;        Using            PropertyEditorRegistrars                    \n\r\n\rAnother mechanism for registering property editors with the            Spring container is to create and use a            PropertyEditorRegistrar. This            interface is particularly useful when you need to use the same set            of property editors in several different situations: write a            corresponding registrar and reuse that in each case.            PropertyEditorRegistrars work in conjunction with            an interface called            PropertyEditorRegistry, an interface            that is implemented by the Spring            BeanWrapper (and            DataBinder).            PropertyEditorRegistrars are particularly            convenient when used in conjunction with the            CustomEditorConfigurer (introduced here), which exposes a property called            setPropertyEditorRegistrars(..):            PropertyEditorRegistrars added to a            CustomEditorConfigurer in this fashion can            easily be shared with DataBinder and            Spring MVC Controllers. Furthermore,            it avoids the need for synchronization on custom editors: a            PropertyEditorRegistrar is expected            to create fresh PropertyEditor            instances for each bean creation attempt.          \n\r\n\rUsing a PropertyEditorRegistrar            is perhaps best illustrated with an example. First off, you need to            create your own            PropertyEditorRegistrar            implementation:          package com.foo.editors.spring;public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {    public void registerCustomEditors(PropertyEditorRegistry registry) {        // it is expected that new PropertyEditor instances are created        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());        // you could register as many custom property editors as are required here...    }}          \n\r\n\rSee also the            org.springframework.beans.support.ResourceEditorRegistrar            for an example            PropertyEditorRegistrar            implementation. Notice how in its implementation of the            registerCustomEditors(..) method it creates            new instances of each property editor.          \n\r\n\rNext we configure a            CustomEditorConfigurer and inject an instance            of our CustomPropertyEditorRegistrar into            it:          &lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt;    &lt;property name=\"propertyEditorRegistrars\"&gt;        &lt;list&gt;            &lt;ref bean=\"customPropertyEditorRegistrar\"/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"customPropertyEditorRegistrar\"      class=\"com.foo.editors.spring.CustomPropertyEditorRegistrar\"/&gt;          \n\r\n\rFinally, and in a bit of a departure from the focus of this            chapter, for those of you using Spring\'s MVC web            framework, using            PropertyEditorRegistrars in            conjunction with data-binding            Controllers (such as            SimpleFormController) can be very convenient.            Find below an example of using a            PropertyEditorRegistrar in the            implementation of an initBinder(..)            method:          public final class RegisterUserController extends SimpleFormController {    private final PropertyEditorRegistrar customPropertyEditorRegistrar;    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {        this.customPropertyEditorRegistrar = propertyEditorRegistrar;    }    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder)                        throws Exception {        this.customPropertyEditorRegistrar.registerCustomEditors(binder);    }    // other methods to do with registering a User}          \n\r\n\rThis style of PropertyEditor            registration can lead to concise code (the implementation of            initBinder(..) is just one line long!), and            allows common PropertyEditor            registration code to be encapsulated in a class and then shared            amongst as many Controllers as            needed.                      7.5&nbsp;Spring 3 Type Conversion        \n\r\n\r Spring 3 introduces a core.convert package that      provides a general type conversion system. The system defines an SPI to      implement type conversion logic, as well as an API to execute type      conversions at runtime. Within a Spring container, this system can be used      as an alternative to PropertyEditors to convert externalized bean property      value strings to required property types. The public API may also be used      anywhere in your application where type conversion is needed.     7.5.1&nbsp;Converter SPI            \n\r\n\r The SPI to implement type conversion logic is simple and strongly        typed:       package org.springframework.core.convert.converter;public interface Converter&lt;S, T&gt; {    T convert(S source);}      \n\r\n\r To create your own Converter, simply implement the interface above.        Parameterize S as the type you are converting from, and T as the type        you are converting to. For each call to convert(S), the source argument        is guaranteed to be NOT null. Your Converter may throw any Exception if        conversion fails. An IllegalArgumentException should be thrown to report        an invalid source value. Take care to ensure your Converter        implementation is thread-safe.       \n\r\n\r Several converter implementations are provided in the        core.convert.support package as a convenience.        These include converters from Strings to Numbers and other common types.        Consider StringToInteger as an example Converter        implementation:       package org.springframework.core.convert.support;final class StringToInteger implements Converter&lt;String, Integer&gt; {    public Integer convert(String source) {        return Integer.valueOf(source);    }}        7.5.2&nbsp;ConverterFactory            \n\r\n\r When you need to centralize the conversion logic for an entire        class hierarchy, for example, when converting from String to        java.lang.Enum objects, implement        ConverterFactory:       package org.springframework.core.convert.converter;public interface ConverterFactory&lt;S, R&gt; {    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);}      \n\r\n\r Parameterize S to be the type you are converting from and R to be        the base type defining the range of classes you can        convert to. Then implement getConverter(Class&lt;T&gt;), where T is a        subclass of R.       \n\r\n\r Consider the StringToEnum ConverterFactory        as an example:       package org.springframework.core.convert.support;final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {        return new StringToEnumConverter(targetType);    }    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {        private Class&lt;T&gt; enumType;        public StringToEnumConverter(Class&lt;T&gt; enumType) {            this.enumType = enumType;        }        public T convert(String source) {            return (T) Enum.valueOf(this.enumType, source.trim());        }    }}        7.5.3&nbsp;GenericConverter            \n\r\n\r When you require a sophisticated Converter implementation, consider        the GenericConverter interface. With a more flexible but less strongly        typed signature, a GenericConverter supports converting between multiple        source and target types. In addition, a GenericConverter makes available        source and target field context you can use when implementing your        conversion logic. Such context allows a type conversion to be driven by        a field annotation, or generic information declared on a field        signature.       package org.springframework.core.convert.converter;public interface GenericConverter {    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);}      \n\r\n\r To implement a GenericConverter, have getConvertibleTypes() return        the supported source-&gt;target type pairs. Then implement        convert(Object, TypeDescriptor, TypeDescriptor) to implement your        conversion logic. The source TypeDescriptor provides access to the        source field holding the value being converted. The target        TypeDescriptor provides access to the target field where the converted        value will be set.       \n\r\n\r A good example of a GenericConverter is a converter that converts        between a Java Array and a Collection. Such an        ArrayToCollectionConverter introspects the field that declares the        target Collection type to resolve the Collection\'s element type. This        allows each element in the source array to be converted to the        Collection element type before the Collection is set on the target        field.       Note        \n\r\n\r Because GenericConverter is a more complex SPI interface, only          use it when you need it. Favor Converter or ConverterFactory for basic          type conversion needs.             ConditionalGenericConverter                \n\r\n\r Sometimes you only want a Converter to execute if a specific          condition holds true. For example, you might only want to execute a          Converter if a specific annotation is present on the target field. Or          you might only want to execute a Converter if a specific method, such          as static valueOf method, is defined on the target class.          ConditionalGenericConverter is an subinterface of GenericConverter          that allows you to define such custom matching criteria:         public interface ConditionalGenericConverter extends GenericConverter {    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);}        \n\r\n\r A good example of a ConditionalGenericConverter is an          EntityConverter that converts between an persistent entity identifier          and an entity reference. Such a EntityConverter might only match if          the target entity type declares a static finder method e.g.          findAccount(Long). You would perform such a finder method check in the          implementation of matches(TypeDescriptor, TypeDescriptor).               7.5.4&nbsp;ConversionService API            \n\r\n\r The ConversionService defines a unified API for executing type        conversion logic at runtime. Converters are often executed behind this        facade interface:       package org.springframework.core.convert;public interface ConversionService {    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);}      \n\r\n\r Most ConversionService implementations also implement        ConverterRegistry, which provides an SPI for        registering converters. Internally, a ConversionService implementation        delegates to its registered converters to carry out type conversion        logic.       \n\r\n\r A robust ConversionService implementation is provided in the        core.convert.support package.        GenericConversionService is the general-purpose        implementation suitable for use in most environments.        ConversionServiceFactory provides a convenient        factory for creating common ConversionService configurations.         7.5.5&nbsp;Configuring a ConversionService            \n\r\n\r A ConversionService is a stateless object designed to be        instantiated at application startup, then shared between multiple        threads. In a Spring application, you typically configure a        ConversionService instance per Spring container (or ApplicationContext).        That ConversionService will be picked up by Spring and then used        whenever a type conversion needs to be performed by the framework. You        may also inject this ConversionService into any of your beans and invoke        it directly.       Note        \n\r\n\r If no ConversionService is registered with Spring, the original          PropertyEditor-based system is used.             \n\r\n\r To register a default ConversionService with Spring, add the        following bean definition with id conversionService:       &lt;bean id=\"conversionService\"      class=\"org.springframework.context.support.ConversionServiceFactoryBean\"/&gt;      \n\r\n\r A default ConversionService can convert between strings, numbers,        enums, collections, maps, and other common types. To supplement or        override the default converters with your own custom converter(s), set        the converters property. Property values may implement        either of the Converter, ConverterFactory, or GenericConverter        interfaces.       &lt;bean id=\"conversionService\"      class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;    &lt;property name=\"converters\"&gt;        &lt;list&gt;            &lt;bean class=\"example.MyCustomConverter\"/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rIt is also common to use a ConversionService within a Spring MVC        application. See Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221;        for details on use with        &lt;mvc:annotation-driven/&gt;.      \n\r\n\rIn certain situations you may wish to apply formatting during        conversion. See Section&nbsp;7.6.3, &#8220;FormatterRegistry SPI&#8221; for        details on using        FormattingConversionServiceFactoryBean.        7.5.6&nbsp;Using a ConversionService programmatically            \n\r\n\r To work with a ConversionService instance programmatically, simply        inject a reference to it like you would for any other bean:       @Servicepublic class MyService {    @Autowired    public MyService(ConversionService conversionService) {        this.conversionService = conversionService;    }    public void doIt() {        this.conversionService.convert(...)    }}        7.6&nbsp;Spring 3 Field Formatting        \n\r\n\r As discussed in the previous section, core.convert is a general-purpose type      conversion system. It provides a unified ConversionService API as well as      a strongly-typed Converter SPI for implementing conversion logic from one      type to another. A Spring Container uses this system to bind bean property      values. In addition, both the Spring Expression Language (SpEL) and      DataBinder use this system to bind field values. For example, when SpEL      needs to coerce a Short to a      Long to complete an      expression.setValue(Object bean, Object value)      attempt, the core.convert system performs the coercion.     \n\r\n\r Now consider the type conversion requirements of a typical client      environment such as a web or desktop application. In such environments,      you typically convert from String to support the      client postback process, as well as back to String to      support the view rendering process. In addition, you often need to      localize String values. The more general core.convert      Converter SPI does not address such formatting      requirements directly. To directly address them, Spring 3 introduces a      convenient Formatter SPI that provides a simple and robust alternative to      PropertyEditors for client environments.     \n\r\n\r In general, use the Converter SPI when you need to implement      general-purpose type conversion logic; for example, for converting between      a java.util.Date and and java.lang.Long. Use the Formatter SPI when you\'re      working in a client environment, such as a web application, and need to      parse and print localized field values. The ConversionService provides a      unified type conversion API for both SPIs.     7.6.1&nbsp;Formatter SPI            \n\r\n\r The Formatter SPI to implement field formatting logic is simple and        strongly typed:       package org.springframework.format;public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}      \n\r\n\r Where Formatter extends from the Printer and Parser building-block        interfaces:       public interface Printer&lt;T&gt; {    String print(T fieldValue, Locale locale);}      import java.text.ParseException;public interface Parser&lt;T&gt; {    T parse(String clientValue, Locale locale) throws ParseException;}      \n\r\n\r To create your own Formatter, simply implement the Formatter        interface above. Parameterize T to be the type of object you wish to        format, for example, java.util.Date. Implement        the print() operation to print an instance of T        for display in the client locale. Implement the        parse() operation to parse an instance of T from        the formatted representation returned from the client locale. Your        Formatter should throw a ParseException or IllegalArgumentException if a        parse attempt fails. Take care to ensure your Formatter implementation        is thread-safe.       \n\r\n\r Several Formatter implementations are provided in        format subpackages as a convenience. The        number package provides a NumberFormatter,        CurrencyFormatter, and PercentFormatter to format java.lang.Number        objects using a java.text.NumberFormat. The        datetime package provides a DateFormatter to format        java.util.Date objects with a java.text.DateFormat. The        datetime.joda package provides comprehensive        datetime formatting support based on the Joda Time library.       \n\r\n\r Consider DateFormatter as an example        Formatter implementation:       package org.springframework.format.datetime;public final class DateFormatter implements Formatter&lt;Date&gt; {    private String pattern;    public DateFormatter(String pattern) {        this.pattern = pattern;    }    public String print(Date date, Locale locale) {        if (date == null) {            return \"\";        }        return getDateFormat(locale).format(date);    }    public Date parse(String formatted, Locale locale) throws ParseException {        if (formatted.length() == 0) {            return null;        }        return getDateFormat(locale).parse(formatted);    }    protected DateFormat getDateFormat(Locale locale) {        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);        dateFormat.setLenient(false);        return dateFormat;    }}      \n\r\n\r The Spring team welcomes community-driven Formatter contributions;        see http://jira.springframework.org to contribute.         7.6.2&nbsp;Annotation-driven Formatting            \n\r\n\r As you will see, field formatting can be configured by field type        or annotation. To bind an Annotation to a formatter, implement        AnnotationFormatterFactory:       package org.springframework.format;public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);}      \n\r\n\r Parameterize A to be the field annotationType you wish to associate        formatting logic with, for example        org.springframework.format.annotation.DateTimeFormat. Have        getFieldTypes() return the types of fields the        annotation may be used on. Have getPrinter()        return a Printer to print the value of an annotated field. Have        getParser() return a Parser to parse a        clientValue for an annotated field.       \n\r\n\r The example AnnotationFormatterFactory implementation below binds        the @NumberFormat Annotation to a formatter. This annotation allows        either a number style or pattern to be specified:       public final class NumberFormatAnnotationFormatterFactory        implements AnnotationFormatterFactory&lt;NumberFormat&gt; {    public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {        return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] {            Short.class, Integer.class, Long.class, Float.class,            Double.class, BigDecimal.class, BigInteger.class }));    }    public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {        return configureFormatterFrom(annotation, fieldType);    }    public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {        return configureFormatterFrom(annotation, fieldType);    }    private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation,                                                     Class&lt;?&gt; fieldType) {        if (!annotation.pattern().isEmpty()) {            return new NumberFormatter(annotation.pattern());        } else {            Style style = annotation.style();            if (style == Style.PERCENT) {                return new PercentFormatter();            } else if (style == Style.CURRENCY) {                return new CurrencyFormatter();            } else {                return new NumberFormatter();            }        }    }}      \n\r\n\r To trigger formatting, simply annotate fields with @NumberFormat:       public class MyModel {    @NumberFormat(style=Style.CURRENCY)    private BigDecimal decimal;}      Format Annotation API                \n\r\n\r A portable format annotation API exists in the          org.springframework.format.annotation package.          Use @NumberFormat to format java.lang.Number fields. Use          @DateTimeFormat to format java.util.Date, java.util.Calendar,          java.util.Long, or Joda Time fields.         \n\r\n\r The example below uses @DateTimeFormat to format a java.util.Date          as a ISO Date (yyyy-MM-dd):         public class MyModel {    @DateTimeFormat(iso=ISO.DATE)    private Date date;}              7.6.3&nbsp;FormatterRegistry SPI            \n\r\n\r The FormatterRegistry is an SPI for registering formatters and          converters. FormattingConversionService is          an implementation of FormatterRegistry suitable for most environments.          This implementation may be configured programmatically or declaratively          as a Spring bean using          FormattingConversionServiceFactoryBean.          Because this implementation also implements        ConversionService, it can be directly        configured for use with Spring\'s DataBinder and the Spring Expression        Language (SpEL).            \n\r\n\r Review the FormatterRegistry SPI below:       package org.springframework.format;public interface FormatterRegistry extends ConverterRegistry {    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);    void addFormatterForFieldType(Formatter&lt;?&gt; formatter);    void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);}      \n\r\n\r As shown above, Formatters can be registered by fieldType or        annotation.            \n\r\n\r The FormatterRegistry SPI allows you to configure Formatting rules        centrally, instead of duplicating such configuration across your        Controllers. For example, you might want to enforce that all Date fields        are formatted a certain way, or fields with a specific annotation are        formatted in a certain way. With a shared FormatterRegistry, you define        these rules once and they are applied whenever formatting is needed.              7.6.4&nbsp;FormatterRegistrar SPI            \n\r\n\r The FormatterRegistrar is an SPI for registering formatters and          converters through the FormatterRegistry:            package org.springframework.format;public interface FormatterRegistrar {    void registerFormatters(FormatterRegistry registry);}        \n\r\n\r A FormatterRegistrar is useful when registering multiple related            converters and formatters for a given formatting category, such as Date            formatting. It can also be useful where declarative registration is            insufficient. For example when a formatter needs to be indexed under a            specific field type different from its own &lt;T&gt; or when registering            a Printer/Parser pair. The next section provides more information on            converter and formatter registration.                7.6.5&nbsp;Configuring Formatting in Spring MVC            \n\r\n\r In a Spring MVC application, you may configure a custom        ConversionService instance explicitly as an attribute of the        annotation-driven element of the MVC namespace. This        ConversionService will then be used anytime a type conversion is        required during Controller model binding. If not configured explicitly,        Spring MVC will automatically register default formatters and converters        for common types such as numbers and dates.       \n\r\n\r To rely on default formatting rules, no custom configuration is        required in your Spring MVC config XML:       &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;      \n\r\n\r With this one-line of configuration, default formatters for Numbers        and Date types will be installed, including support for the        @NumberFormat and @DateTimeFormat annotations. Full support for the Joda        Time formatting library is also installed if Joda Time is present on the        classpath.      \n\r\n\r To inject a ConversionService instance with custom formatters and        converters registered, set the conversion-service attribute and then        specify custom converters, formatters, or FormatterRegistrars as properties        of the FormattingConversionServiceFactoryBean:       &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean id=\"conversionService\"          class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;set&gt;                &lt;bean class=\"org.example.MyConverter\"/&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"formatters\"&gt;            &lt;set&gt;                &lt;bean class=\"org.example.MyFormatter\"/&gt;                &lt;bean class=\"org.example.MyAnnotationFormatterFactory\"/&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"formatterRegistrars\"&gt;            &lt;set&gt;                &lt;bean class=\"org.example.MyFormatterRegistrar\"/&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;      Note          \n\r\n\r See Section&nbsp;7.6.4, &#8220;FormatterRegistrar SPI&#8221; and            the FormattingConversionServiceFactoryBean            for more information on when to use FormatterRegistrars.                        7.7&nbsp;Configuring a global date &amp; time format        \n\r\n\rBy default, date and time fields that are not annotated with    @DateTimeFormat are converted from strings    using the the DateFormat.SHORT style. If you prefer,    you can change this by defining your own global format.    \n\r\n\rYou will need to ensure that Spring does not register default    formatters, and instead you should register all formatters manually. Use the    org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar    or org.springframework.format.datetime.DateFormatterRegistrar    class depending on whether you use the Joda Time library.    \n\r\n\rFor example, the following Java configuration will register a global    \'yyyyMMdd\' format. This example does not depend on the    Joda Time library:    @Configurationpublic class AppConfig {  @Bean  public FormattingConversionService conversionService() {    // Use the DefaultFormattingConversionService but do not register defaults    DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);    // Ensure @NumberFormat is still supported    conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());    // Register date conversion with a specific global format    DateFormatterRegistrar registrar = new DateFormatterRegistrar();    registrar.setFormatter(new DateFormatter(\"yyyyMMdd\"));    registrar.registerFormatters(conversionService);    return conversionService;  }}    \n\r\n\rIf you prefer XML based configuration you can use a    FormattingConversionServiceFactoryBean. Here is the same    example, this time using Joda Time:    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt;        &lt;property name=\"registerDefaultFormatters\" value=\"false\" /&gt;        &lt;property name=\"formatters\"&gt;        &lt;set&gt;            &lt;bean class=\"org.springframework.format.number.NumberFormatAnnotationFormatterFactory\" /&gt;        &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"formatterRegistrars\"&gt;        &lt;set&gt;          &lt;bean class=\"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar\"&gt;              &lt;property name=\"dateFormatter\"&gt;                  &lt;bean class=\"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean\"&gt;                      &lt;property name=\"pattern\" value=\"yyyyMMdd\"/&gt;                  &lt;/bean&gt;              &lt;/property&gt;          &lt;/bean&gt;      &lt;/set&gt;      &lt;/property&gt;    &lt;/bean&gt;  &lt;/beans&gt;    Note      \n\r\n\rJoda Time provides separate distinct types to represent      date, time and      date-time values. The dateFormatter,      timeFormatter and dateTimeFormatter      properties of the JodaTimeFormatterRegistrar should      be used to configure the different formats for each type. The      DateTimeFormatterFactoryBean provides a      convenient way to create formatters.        \n\r\n\rIf you are using Spring MVC remember to explicitly configure the    conversion service that is used. For Java based    @Configuration this means extending the    WebMvcConfigurationSupport class and overriding    the mvcConversionService() method. For XML you should    use the \'conversion-service\' attribute of the    mvc:annotation-driven element. See    Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221; for details.    7.8&nbsp;Spring 3 Validation        \n\r\n\r Spring 3 introduces several enhancements to its validation support.      First, the JSR-303 Bean Validation API is now fully supported. Second,      when used programmatically, Spring\'s DataBinder can now validate objects as      well as bind to them. Third, Spring MVC now has support for declaratively      validating @Controller inputs.     7.8.1&nbsp;Overview of the JSR-303 Bean Validation API            \n\r\n\r JSR-303 standardizes validation constraint declaration and metadata        for the Java platform. Using this API, you annotate domain model        properties with declarative validation constraints and the runtime        enforces them. There are a number of built-in constraints you can take        advantage of. You may also define your own custom constraints.       \n\r\n\r To illustrate, consider a simple PersonForm model with two        properties:       public class PersonForm {    private String name;    private int age;}      \n\r\n\r JSR-303 allows you to define declarative validation constraints        against such properties:       public class PersonForm {    @NotNull    @Size(max=64)    private String name;    @Min(0)    private int age;}      \n\r\n\r When an instance of this class is validated by a JSR-303 Validator,        these constraints will be enforced.       \n\r\n\r For general information on JSR-303, see the Bean Validation        Specification. For information on the specific capabilities of        the default reference implementation, see the Hibernate Validator        documentation. To learn how to setup a JSR-303 implementation as a        Spring bean, keep reading.         7.8.2&nbsp;Configuring a Bean Validation Implementation            \n\r\n\r Spring provides full support for the JSR-303 Bean Validation API.        This includes convenient support for bootstrapping a JSR-303        implementation as a Spring bean. This allows for a        javax.validation.ValidatorFactory or        javax.validation.Validator to be injected wherever        validation is needed in your application.       \n\r\n\r Use the LocalValidatorFactoryBean to        configure a default JSR-303 Validator as a Spring bean:       &lt;bean id=\"validator\"      class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/&gt;      \n\r\n\r The basic configuration above will trigger JSR-303 to initialize        using its default bootstrap mechanism. A JSR-303 provider, such as        Hibernate Validator, is expected to be present in the classpath and will        be detected automatically.       Injecting a Validator                \n\r\n\r LocalValidatorFactoryBean implements both          javax.validation.ValidatorFactory and          javax.validation.Validator, as well as Spring\'s          org.springframework.validation.Validator. You may inject          a reference to either of these interfaces into beans that need to          invoke validation logic.         \n\r\n\r Inject a reference to javax.validation.Validator if          you prefer to work with the JSR-303 API directly:         import javax.validation.Validator;@Servicepublic class MyService {    @Autowired    private Validator validator;        \n\r\n\r Inject a reference to          org.springframework.validation.Validator if your bean          requires the Spring Validation API:         import org.springframework.validation.Validator;@Servicepublic class MyService {    @Autowired    private Validator validator;}            Configuring Custom Constraints                \n\r\n\r Each JSR-303 validation constraint consists of two parts. First,          a @Constraint annotation that declares the constraint and its          configurable properties. Second, an implementation of the          javax.validation.ConstraintValidator interface that          implements the constraint\'s behavior. To associate a declaration with          an implementation, each @Constraint annotation references a          corresponding ValidationConstraint implementation class. At runtime, a          ConstraintValidatorFactory instantiates the referenced          implementation when the constraint annotation is encountered in your          domain model.         \n\r\n\r By default, the LocalValidatorFactoryBean          configures a SpringConstraintValidatorFactory that uses          Spring to create ConstraintValidator instances. This allows your          custom ConstraintValidators to benefit from dependency injection like          any other Spring bean.         \n\r\n\r Shown below is an example of a custom @Constraint declaration,          followed by an associated ConstraintValidator          implementation that uses Spring for dependency injection:         @Target({ElementType.METHOD, ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy=MyConstraintValidator.class)public @interface MyConstraint {}        import javax.validation.ConstraintValidator;public class MyConstraintValidator implements ConstraintValidator {    @Autowired;    private Foo aDependency;    ...}        \n\r\n\r As you can see, a ConstraintValidator implementation may have its          dependencies @Autowired like any other Spring bean.             Additional Configuration Options                \n\r\n\r The default LocalValidatorFactoryBean          configuration should prove sufficient for most cases. There are a          number of other configuration options for various JSR-303 constructs,          from message interpolation to traversal resolution. See the JavaDocs          of LocalValidatorFactoryBean for more          information on these options.               7.8.3&nbsp;Configuring a DataBinder            \n\r\n\r Since Spring 3, a DataBinder instance can be configured with a        Validator. Once configured, the Validator may be invoked by calling        binder.validate(). Any validation Errors are automatically        added to the binder\'s BindingResult.       \n\r\n\r When working with the DataBinder programmatically, this can be used        to invoke validation logic after binding to a target object:       Foo target = new Foo();DataBinder binder = new DataBinder(target);binder.setValidator(new FooValidator());// bind to the target objectbinder.bind(propertyValues);// validate the target objectbinder.validate();// get BindingResult that includes any validation errorsBindingResult results = binder.getBindingResult();      \n\r\n\r A DataBinder can also be configured with multiple      Validator instances      via dataBinder.addValidators      and dataBinder.replaceValidators.      This is useful when combining globally configured JSR-303 Bean Validation      with a Spring Validator configured      locally on a DataBinder instance.      See the section called &#8220;Configuring a Validator for use by Spring MVC&#8221;.        7.8.4&nbsp;Spring MVC 3 Validation            \n\r\n\r Beginning with Spring 3, Spring MVC has the ability to        automatically validate @Controller inputs. In previous versions it was        up to the developer to manually invoke validation logic.       Triggering @Controller Input Validation                \n\r\n\r To trigger validation of a @Controller input, simply annotate the          input argument as @Valid:         @Controllerpublic class MyController {    @RequestMapping(\"/foo\", method=RequestMethod.POST)    public void processFoo(@Valid Foo foo) { /* ... */ }        \n\r\n\r Spring MVC will validate a @Valid object after binding so-long as          an appropriate Validator has been configured.         Note          \n\r\n\r The @Valid annotation is part of the standard JSR-303 Bean            Validation API, and is not a Spring-specific construct.                     Configuring a Validator for use by Spring MVC                \n\r\n\r The Validator instance invoked when a @Valid method argument is          encountered may be configured in two ways. First, you may call          binder.setValidator(Validator) within a @Controller\'s @InitBinder          callback. This allows you to configure a Validator instance per          @Controller class:         @Controllerpublic class MyController {    @InitBinder    protected void initBinder(WebDataBinder binder) {        binder.setValidator(new FooValidator());    }    @RequestMapping(\"/foo\", method=RequestMethod.POST)    public void processFoo(@Valid Foo foo) { ... }}        \n\r\n\r Second, you may call setValidator(Validator) on the global          WebBindingInitializer. This allows you to configure a Validator          instance across all @Controllers. This can be achieved easily by using          the Spring MVC namespace:         &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;    &lt;mvc:annotation-driven validator=\"globalValidator\"/&gt;&lt;/beans&gt;        \n\r\n\r To combine a global and a local validator, configure the        global validator as shown above and then add a local validator:        @Controllerpublic class MyController {    @InitBinder    protected void initBinder(WebDataBinder binder) {        binder.addValidators(new FooValidator());    }}            Configuring a JSR-303 Validator for use by Spring MVC                \n\r\n\r With JSR-303, a single javax.validation.Validator          instance typically validates all model objects          that declare validation constraints. To configure a JSR-303-backed          Validator with Spring MVC, simply add a JSR-303 Provider, such as          Hibernate Validator, to your classpath. Spring MVC will detect it and          automatically enable JSR-303 support across all Controllers.         \n\r\n\r The Spring MVC configuration required to enable JSR-303 support          is shown below:         &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;    &lt;!-- JSR-303 support will be detected on classpath and enabled automatically --&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;        \n\r\n\r With this minimal configuration, anytime a @Valid @Controller          input is encountered, it will be validated by the JSR-303 provider.          JSR-303, in turn, will enforce any constraints declared against the          input. Any ConstraintViolations will automatically be exposed as          errors in the BindingResult renderable by standard Spring MVC form          tags.             Prev&nbsp;Up&nbsp;Next6.&nbsp;Resources&nbsp;Home&nbsp;8.&nbsp;Spring Expression Language (SpEL)","7. Validation, Data Binding, and Type Conversion","scr\\validation.html","         18.&nbsp;View technologiesPrev&nbsp;Part&nbsp;V.&nbsp;The Web&nbsp;Next18.&nbsp;View technologies    18.1&nbsp;Introduction        \n\r\n\rOne of the areas in which Spring excels is in the separation of view    technologies from the rest of the MVC framework. For example, deciding to    use Velocity or XSLT in place of an existing JSP is primarily a matter of    configuration. This chapter covers the major view technologies that work    with Spring and touches briefly on how to add new ones. This chapter    assumes you are already familiar with Section&nbsp;17.5, &#8220;Resolving views&#8221;    which covers the basics of how views in general are coupled to the MVC    framework.    18.2&nbsp;JSP &amp; JSTL        \n\r\n\rSpring provides a couple of out-of-the-box solutions for JSP and    JSTL views. Using JSP or JSTL is done using a normal view resolver defined    in the WebApplicationContext. Furthermore,    of course you need to write some JSPs that will actually render the    view.    Note      \n\r\n\r        Setting up your application to use JSTL is a common source of error,        mainly caused by confusion over the different servlet spec., JSP and JSTL        version numbers, what they mean and how to declare the taglibs correctly.        The article                How to Reference and Use JSTL in your Web Application provides a        useful guide to the common pitfalls and how to avoid them. Note that as of        Spring 3.0, the minimum supported servlet version is 2.4 (JSP 2.0 and JSTL 1.1),        which reduces the scope for confusion somewhat.              18.2.1&nbsp;View resolvers            \n\r\n\rJust as with any other view technology you\'re integrating with      Spring, for JSPs you\'ll need a view resolver that will resolve your      views. The most commonly used view resolvers when developing with JSPs      are the InternalResourceViewResolver and the      ResourceBundleViewResolver. Both are declared in      the WebApplicationContext:      &lt;!-- the ResourceBundleViewResolver --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\"&gt;  &lt;property name=\"basename\" value=\"views\"/&gt;&lt;/bean&gt;# And a sample properties file is uses (views.properties in WEB-INF/classes):welcome.(class)=org.springframework.web.servlet.view.JstlViewwelcome.url=/WEB-INF/jsp/welcome.jspproductList.(class)=org.springframework.web.servlet.view.JstlViewproductList.url=/WEB-INF/jsp/productlist.jsp      \n\r\n\rAs you can see, the      ResourceBundleViewResolver needs a properties      file defining the view names mapped to 1) a class and 2) a URL. With a      ResourceBundleViewResolver you can mix different      types of views using only one resolver.      &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;  &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt;  &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt;  &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;      \n\r\n\rThe InternalResourceBundleViewResolver can      be configured for using JSPs as described above. As a best practice, we      strongly encourage placing your JSP files in a directory under the      \'WEB-INF\' directory, so there can      be no direct access by clients.        18.2.2&nbsp;\'Plain-old\' JSPs versus JSTL            \n\r\n\rWhen using the Java Standard Tag Library you must use a special      view class, the JstlView, as JSTL needs some      preparation before things such as the I18N features will work.        18.2.3&nbsp;Additional tags facilitating development            \n\r\n\rSpring provides data binding of request parameters to command      objects as described in earlier chapters. To facilitate the development      of JSP pages in combination with those data binding features, Spring      provides a few tags that make things even easier. All Spring tags have      HTML escaping features to enable or disable      escaping of characters.      \n\r\n\rThe tag library descriptor (TLD) is included in the spring-webmvc.jar.      Further information about the individual tags can be found in      the appendix entitled Appendix&nbsp;G, spring.tld.        18.2.4&nbsp;Using Spring\'s form tag library            \n\r\n\rAs of version 2.0, Spring provides a comprehensive set of data      binding-aware tags for handling form elements when using JSP and Spring      Web MVC. Each tag provides support for the set of attributes of its      corresponding HTML tag counterpart, making the tags familiar and      intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0      compliant.      \n\r\n\rUnlike other form/input tag libraries, Spring\'s form tag library      is integrated with Spring Web MVC, giving the tags access to the command      object and reference data your controller deals with. As you will see in      the following examples, the form tags make JSPs easier to develop, read      and maintain.      \n\r\n\rLet\'s go through the form tags and look at an example of how each      tag is used. We have included generated HTML snippets where certain tags      require further commentary.      Configuration                \n\r\n\rThe form tag library comes bundled in        spring-webmvc.jar.        The library descriptor is called        spring-form.tld.        \n\r\n\rTo use the tags from this library, add the following directive        to the top of your JSP page:        &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;        \n\r\n\r... where form is the tag name prefix you        want to use for the tags from this library.            The form tag                \n\r\n\rThis tag renders an HTML \'form\' tag and exposes a binding path        to inner tags for binding. It puts the command object in the        PageContext so that the command object can be        accessed by inner tags. All the other tags in this library        are nested tags of the form tag.        \n\r\n\rLet\'s assume we have a domain object called        User. It is a JavaBean with properties such as        firstName and lastName. We will        use it as the form backing object of our form controller which returns        form.jsp. Below is an example of what        form.jsp would look like:        &lt;form:form&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"firstName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"lastName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"2\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;        \n\r\n\rThe firstName and lastName        values are retrieved from the command object placed in the        PageContext by the page controller.        Keep reading to see more complex examples of how inner tags are used        with the form tag.        \n\r\n\rThe generated HTML looks like a standard form:        &lt;form method=\"POST\"&gt;      &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;First Name:&lt;/td&gt;            &lt;td&gt;&lt;input name=\"firstName\" type=\"text\" value=\"Harry\"/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;Last Name:&lt;/td&gt;            &lt;td&gt;&lt;input name=\"lastName\" type=\"text\" value=\"Potter\"/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=\"2\"&gt;              &lt;input type=\"submit\" value=\"Save Changes\" /&gt;            &lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;  &lt;/form&gt;        \n\r\n\rThe preceding JSP assumes that the variable name of the form        backing object is \'command\'. If you have put the        form backing object into the model under another name (definitely a        best practice), then you can bind the form to the named variable like        so:        &lt;form:form commandName=\"user\"&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"firstName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"lastName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"2\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;            The input tag                \n\r\n\rThis tag renders an HTML \'input\' tag using the bound value        and type=\'text\' by default. For an example of this tag, see the section called &#8220;The form tag&#8221;. Starting with Spring 3.1        you can use other types such HTML5-specific types like \'email\',        \'tel\', \'date\', and others.            The checkbox tag                \n\r\n\rThis tag renders an HTML \'input\' tag with type        \'checkbox\'.        \n\r\n\rLet\'s assume our User has preferences        such as newsletter subscription and a list of hobbies. Below is an        example of the Preferences class:      public class Preferences {      private boolean receiveNewsletter;      private String[] interests;      private String favouriteWord;      public boolean isReceiveNewsletter() {          return receiveNewsletter;      }      public void setReceiveNewsletter(boolean receiveNewsletter) {          this.receiveNewsletter = receiveNewsletter;      }      public String[] getInterests() {          return interests;      }      public void setInterests(String[] interests) {          this.interests = interests;      }      public String getFavouriteWord() {          return favouriteWord;      }      public void setFavouriteWord(String favouriteWord) {          this.favouriteWord = favouriteWord;      }  }      \n\r\n\rThe form.jsp would look like:      &lt;form:form&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;Subscribe to newsletter?:&lt;/td&gt;              &lt;%-- Approach 1: Property is of type java.lang.Boolean --%&gt;              &lt;td&gt;&lt;form:checkbox path=\"preferences.receiveNewsletter\"/&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Interests:&lt;/td&gt;              &lt;td&gt;                  &lt;%-- Approach 2: Property is of an array or of type java.util.Collection --%&gt;                  Quidditch: &lt;form:checkbox path=\"preferences.interests\" value=\"Quidditch\"/&gt;                  Herbology: &lt;form:checkbox path=\"preferences.interests\" value=\"Herbology\"/&gt;                  Defence Against the Dark Arts: &lt;form:checkbox path=\"preferences.interests\"                      value=\"Defence Against the Dark Arts\"/&gt;              &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Favourite Word:&lt;/td&gt;              &lt;td&gt;                  &lt;%-- Approach 3: Property is of type java.lang.Object --%&gt;                  Magic: &lt;form:checkbox path=\"preferences.favouriteWord\" value=\"Magic\"/&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;      \n\r\n\rThere are 3 approaches to the checkbox tag      which should meet all your checkbox needs.      \n\r            \n\r\n\rApproach One - When the bound value is of type            java.lang.Boolean, the            input(checkbox) is marked as \'checked\' if the            bound value is true. The            value attribute corresponds to the resolved            value of the setValue(Object) value            property.          \n\r            \n\r\n\rApproach Two - When the bound value is of type            array or            java.util.Collection, the            input(checkbox) is marked as \'checked\' if the            configured setValue(Object) value is present in            the bound Collection.          \n\r            \n\r\n\rApproach Three - For any other bound value type, the            input(checkbox) is marked as \'checked\' if the            configured setValue(Object) is equal to the            bound value.          \n\r      \n\r\n\rNote that regardless of the approach, the same HTML structure is      generated. Below is an HTML snippet of some checkboxes:      &lt;tr&gt;      &lt;td&gt;Interests:&lt;/td&gt;      &lt;td&gt;          Quidditch: &lt;input name=\"preferences.interests\" type=\"checkbox\" value=\"Quidditch\"/&gt;          &lt;input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/&gt;          Herbology: &lt;input name=\"preferences.interests\" type=\"checkbox\" value=\"Herbology\"/&gt;          &lt;input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/&gt;          Defence Against the Dark Arts: &lt;input name=\"preferences.interests\" type=\"checkbox\"              value=\"Defence Against the Dark Arts\"/&gt;          &lt;input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/&gt;      &lt;/td&gt;  &lt;/tr&gt;      \n\r\n\rWhat you might not expect to see is the additional hidden field      after each checkbox. When a checkbox in an HTML page is      not checked, its value will not be sent to the      server as part of the HTTP request parameters once the form is      submitted, so we need a workaround for this quirk in HTML in order for      Spring form data binding to work. The checkbox tag      follows the existing Spring convention of including a hidden parameter      prefixed by an underscore (\"_\") for each checkbox. By doing this, you      are effectively telling Spring that &#8220;          the checkbox was visible in the form and I want my object          to which the form data will be bound to reflect the state of the          checkbox no matter what        &#8221;.            The checkboxes tag                \n\r\n\rThis tag renders multiple HTML \'input\' tags with type        \'checkbox\'.        \n\r\n\rBuilding on the example from the previous        checkbox tag section. Sometimes you prefer not        to have to list all the possible hobbies in your JSP page. You would        rather provide a list at runtime of the available options and pass        that in to the tag. That is the purpose of the        checkboxes tag. You pass in an        Array, a List or a        Map containing the available options in the        \"items\" property. Typically the bound property is a collection so it        can hold multiple values selected by the user. Below is an example of        the JSP using this tag:      &lt;form:form&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;Interests:&lt;/td&gt;              &lt;td&gt;                  &lt;%-- Property is of an array or of type java.util.Collection --%&gt;                  &lt;form:checkboxes path=\"preferences.interests\" items=\"${interestList}\"/&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;      \n\r\n\rThis example assumes that the \"interestList\" is a      List available as a model attribute containing      strings of the values to be selected from. In the case where you use a      Map, the map entry key will be used as the value and the map entry\'s      value will be used as the label to be displayed. You can also use a      custom object where you can provide the property names for the value      using \"itemValue\" and the label using \"itemLabel\".            The radiobutton tag                \n\r\n\rThis tag renders an HTML \'input\' tag with type \'radio\'.        \n\r\n\rA typical usage pattern will involve multiple tag instances        bound to the same property but with different values.        &lt;tr&gt;      &lt;td&gt;Sex:&lt;/td&gt;      &lt;td&gt;Male: &lt;form:radiobutton path=\"sex\" value=\"M\"/&gt; &lt;br/&gt;          Female: &lt;form:radiobutton path=\"sex\" value=\"F\"/&gt; &lt;/td&gt;  &lt;/tr&gt;            The radiobuttons tag                \n\r\n\rThis tag renders multiple HTML \'input\' tags with type        \'radio\'.        \n\r\n\rJust like the checkboxes tag above, you        might want to pass in the available options as a runtime variable. For        this usage you would use the radiobuttons tag.        You pass in an Array, a        List or a Map containing        the available options in the \"items\" property. In the case where you        use a Map, the map entry key will be used as the value and the map        entry\'s value will be used as the label to be displayed. You can also        use a custom object where you can provide the property names for the        value using \"itemValue\" and the label using \"itemLabel\".        &lt;tr&gt;      &lt;td&gt;Sex:&lt;/td&gt;      &lt;td&gt;&lt;form:radiobuttons path=\"sex\" items=\"${sexOptions}\"/&gt;&lt;/td&gt;  &lt;/tr&gt;            The password tag                \n\r\n\rThis tag renders an HTML \'input\' tag with type \'password\' using        the bound value.        &lt;tr&gt;      &lt;td&gt;Password:&lt;/td&gt;      &lt;td&gt;          &lt;form:password path=\"password\" /&gt;      &lt;/td&gt;  &lt;/tr&gt;        \n\r\n\rPlease note that by default, the password value is        not shown. If you do want the password value to        be shown, then set the value of the \'showPassword\'        attribute to true, like so.        &lt;tr&gt;      &lt;td&gt;Password:&lt;/td&gt;      &lt;td&gt;          &lt;form:password path=\"password\" value=\"^76525bvHGq\" showPassword=\"true\" /&gt;      &lt;/td&gt;  &lt;/tr&gt;            The select tag                \n\r\n\rThis tag renders an HTML \'select\' element. It supports data        binding to the selected option as well as the use of nested        option and options tags.        \n\r\n\rLet\'s assume a User has a list of        skills.        &lt;tr&gt;      &lt;td&gt;Skills:&lt;/td&gt;      &lt;td&gt;&lt;form:select path=\"skills\" items=\"${skills}\"/&gt;&lt;/td&gt;  &lt;/tr&gt;        \n\r\n\rIf the User\'s skill were in Herbology, the        HTML source of the \'Skills\' row would look like:        &lt;tr&gt;      &lt;td&gt;Skills:&lt;/td&gt;      &lt;td&gt;&lt;select name=\"skills\" multiple=\"true\"&gt;          &lt;option value=\"Potions\"&gt;Potions&lt;/option&gt;          &lt;option value=\"Herbology\" selected=\"selected\"&gt;Herbology&lt;/option&gt;          &lt;option value=\"Quidditch\"&gt;Quidditch&lt;/option&gt;&lt;/select&gt;      &lt;/td&gt;  &lt;/tr&gt;            The option tag                \n\r\n\rThis tag renders an HTML \'option\'. It sets \'selected\' as        appropriate based on the bound value.        &lt;tr&gt;      &lt;td&gt;House:&lt;/td&gt;      &lt;td&gt;          &lt;form:select path=\"house\"&gt;              &lt;form:option value=\"Gryffindor\"/&gt;              &lt;form:option value=\"Hufflepuff\"/&gt;              &lt;form:option value=\"Ravenclaw\"/&gt;              &lt;form:option value=\"Slytherin\"/&gt;          &lt;/form:select&gt;      &lt;/td&gt;  &lt;/tr&gt;        \n\r\n\rIf the User\'s house was in Gryffindor, the        HTML source of the \'House\' row would look like:        &lt;tr&gt;      &lt;td&gt;House:&lt;/td&gt;      &lt;td&gt;          &lt;select name=\"house\"&gt;              &lt;option value=\"Gryffindor\" selected=\"selected\"&gt;Gryffindor&lt;/option&gt;              &lt;option value=\"Hufflepuff\"&gt;Hufflepuff&lt;/option&gt;              &lt;option value=\"Ravenclaw\"&gt;Ravenclaw&lt;/option&gt;              &lt;option value=\"Slytherin\"&gt;Slytherin&lt;/option&gt;          &lt;/select&gt;      &lt;/td&gt;   &lt;/tr&gt;            The options tag                \n\r\n\rThis tag renders a list of HTML \'option\' tags. It sets the        \'selected\' attribute as appropriate based on the bound value.        &lt;tr&gt;      &lt;td&gt;Country:&lt;/td&gt;      &lt;td&gt;          &lt;form:select path=\"country\"&gt;              &lt;form:option value=\"-\" label=\"--Please Select\"/&gt;              &lt;form:options items=\"${countryList}\" itemValue=\"code\" itemLabel=\"name\"/&gt;          &lt;/form:select&gt;      &lt;/td&gt;  &lt;/tr&gt;        \n\r\n\rIf the User lived in the UK, the HTML        source of the \'Country\' row would look like:        &lt;tr&gt;      &lt;td&gt;Country:&lt;/td&gt;      &lt;td&gt;          &lt;select name=\"country\"&gt;              &lt;option value=\"-\"&gt;--Please Select&lt;/option&gt;              &lt;option value=\"AT\"&gt;Austria&lt;/option&gt;              &lt;option value=\"UK\" selected=\"selected\"&gt;United Kingdom&lt;/option&gt;              &lt;option value=\"US\"&gt;United States&lt;/option&gt;          &lt;/select&gt;      &lt;/td&gt;  &lt;/tr&gt;        \n\r\n\rAs the example shows, the combined usage of an        option tag with the options tag        generates the same standard HTML, but allows you to explicitly specify        a value in the JSP that is for display only (where it belongs) such as        the default string in the example: \"-- Please Select\".        \n\r\n\rThe items attribute is typically populated        with a collection or array of item objects.        itemValue and itemLabel simply        refer to bean properties of those item objects, if specified;        otherwise, the item objects themselves will be stringified.        Alternatively, you may specify a Map of items, in        which case the map keys are interpreted as option values and the map        values correspond to option labels. If itemValue        and/or itemLabel happen to be specified as well,        the item value property will apply to the map key and the item label        property will apply to the map value.            The textarea tag                \n\r\n\rThis tag renders an HTML \'textarea\'.        &lt;tr&gt;      &lt;td&gt;Notes:&lt;/td&gt;      &lt;td&gt;&lt;form:textarea path=\"notes\" rows=\"3\" cols=\"20\" /&gt;&lt;/td&gt;      &lt;td&gt;&lt;form:errors path=\"notes\" /&gt;&lt;/td&gt;  &lt;/tr&gt;            The hidden tag                \n\r\n\rThis tag renders an HTML \'input\' tag with type \'hidden\' using        the bound value. To submit an unbound hidden value, use the HTML        input tag with type \'hidden\'.        &lt;form:hidden path=\"house\" /&gt;          \n\r\n\rIf we choose to submit the \'house\' value as a hidden one, the        HTML would look like:        &lt;input name=\"house\" type=\"hidden\" value=\"Gryffindor\"/&gt;              The errors tag                \n\r\n\rThis tag renders field errors in an HTML \'span\' tag. It provides        access to the errors created in your controller or those that were        created by any validators associated with your controller.        \n\r\n\rLet\'s assume we want to display all error messages for the        firstName and lastName fields        once we submit the form. We have a validator for instances of the        User class called        UserValidator.        public class UserValidator implements Validator {      public boolean supports(Class candidate) {          return User.class.isAssignableFrom(candidate);      }      public void validate(Object obj, Errors errors) {          ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"required\", \"Field is required.\");          ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"lastName\", \"required\", \"Field is required.\");      }  }        \n\r\n\rThe form.jsp would look like:        &lt;form:form&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"firstName\" /&gt;&lt;/td&gt;              &lt;%-- Show errors for firstName field --%&gt;              &lt;td&gt;&lt;form:errors path=\"firstName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"lastName\" /&gt;&lt;/td&gt;              &lt;%-- Show errors for lastName field --%&gt;              &lt;td&gt;&lt;form:errors path=\"lastName\"  /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"3\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;        \n\r\n\rIf we submit a form with empty values in the        firstName and lastName fields,        this is what the HTML would look like:        &lt;form method=\"POST\"&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;input name=\"firstName\" type=\"text\" value=\"\"/&gt;&lt;/td&gt;              &lt;%-- Associated errors to firstName field displayed --%&gt;              &lt;td&gt;&lt;span name=\"firstName.errors\"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;input name=\"lastName\" type=\"text\" value=\"\"/&gt;&lt;/td&gt;              &lt;%-- Associated errors to lastName field displayed --%&gt;              &lt;td&gt;&lt;span name=\"lastName.errors\"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"3\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form&gt;        \n\r\n\rWhat if we want to display the entire list of errors for a given        page? The example below shows that the errors tag        also supports some basic wildcarding functionality.        \n\r            \n\r\n\rpath=\"*\" - displays all errors          \n\r            \n\r\n\rpath=\"lastName\" - displays all errors            associated with the lastName field          \n\r            \n\r\n\rif path is omitted - object errors only are displayed          \n\r        \n\r\n\rThe example below will display a list of errors at the top of        the page, followed by field-specific errors next to the fields:        &lt;form:form&gt;      &lt;form:errors path=\"*\" cssClass=\"errorBox\" /&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"firstName\" /&gt;&lt;/td&gt;              &lt;td&gt;&lt;form:errors path=\"firstName\" /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;form:input path=\"lastName\" /&gt;&lt;/td&gt;              &lt;td&gt;&lt;form:errors path=\"lastName\"  /&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"3\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;      &lt;/table&gt;  &lt;/form:form&gt;        \n\r\n\rThe HTML would look like:        &lt;form method=\"POST\"&gt;      &lt;span name=\"*.errors\" class=\"errorBox\"&gt;Field is required.&lt;br/&gt;Field is required.&lt;/span&gt;      &lt;table&gt;          &lt;tr&gt;              &lt;td&gt;First Name:&lt;/td&gt;              &lt;td&gt;&lt;input name=\"firstName\" type=\"text\" value=\"\"/&gt;&lt;/td&gt;              &lt;td&gt;&lt;span name=\"firstName.errors\"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;Last Name:&lt;/td&gt;              &lt;td&gt;&lt;input name=\"lastName\" type=\"text\" value=\"\"/&gt;&lt;/td&gt;              &lt;td&gt;&lt;span name=\"lastName.errors\"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td colspan=\"3\"&gt;                  &lt;input type=\"submit\" value=\"Save Changes\" /&gt;              &lt;/td&gt;          &lt;/tr&gt;  &lt;/form&gt;            HTTP Method Conversion                \n\r\n\rA key principle of REST is the use of the Uniform Interface.        This means that all resources (URLs) can be manipulated using the same        four HTTP methods: GET, PUT, POST, and DELETE. For each method, the        HTTP specification defines the exact semantics. For instance, a GET        should always be a safe operation, meaning that is has no side        effects, and a PUT or DELETE should be idempotent, meaning that you        can repeat these operations over and over again, but the end result        should be the same. While HTTP defines these four methods, HTML only        supports two: GET and POST. Fortunately, there are two possible        workarounds: you can either use JavaScript to do your PUT or DELETE,        or simply do a POST with the \'real\' method as an additional parameter        (modeled as a hidden input field in an HTML form). This latter trick        is what Spring\'s HiddenHttpMethodFilter does.        This filter is a plain Servlet Filter and therefore it can be used in        combination with any web framework (not just Spring MVC). Simply add        this filter to your web.xml, and a POST with a hidden _method        parameter will be converted into the corresponding HTTP method        request.        \n\r\n\rTo support HTTP method conversion the Spring MVC form tag was        updated to support setting the HTTP method. For example, the following        snippet taken from the updated Petclinic sample        &lt;form:form method=\"delete\"&gt;      &lt;p class=\"submit\"&gt;&lt;input type=\"submit\" value=\"Delete Pet\"/&gt;&lt;/p&gt;&lt;/form:form&gt;        \n\r\n\rThis will actually perform an HTTP POST, with the \'real\' DELETE        method hidden behind a request parameter, to be picked up by the        HiddenHttpMethodFilter, as defined in web.xml:        &lt;filter&gt;    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;    &lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;&lt;/filter-mapping&gt;\n\r\n\rThe corresponding @Controller method        is shown below:        @RequestMapping(method = RequestMethod.DELETE)public String deletePet(@PathVariable int ownerId, @PathVariable int petId) {  this.clinic.deletePet(petId);  return \"redirect:/owners/\" + ownerId;}            HTML5 Tags                \n\r\n\rStarting with Spring 3, the Spring form tag library allows entering        dynamic attributes, which means you can enter any HTML5 specific attributes.                \n\r\n\rIn Spring 3.1, the form input tag supports entering a type attribute        other than \'text\'. This is intended to allow rendering new HTML5 specific        input types such as \'email\', \'date\', \'range\', and others. Note that        entering type=\'text\' is not required since \'text\' is the default type.                      18.3&nbsp;Tiles        \n\r\n\rIt is possible to integrate Tiles - just as any other view    technology - in web applications using Spring. The following describes in    a broad way how to do this.    \n\r\n\rNOTE: This section focuses on Spring\'s support    for Tiles 2 (the standalone version of Tiles, requiring Java 5+) in the    org.springframework.web.servlet.view.tiles2 package as    as well as Tiles 3 in the    org.springframework.web.servlet.view.tiles3 package.    Spring also continues to support Tiles 1.x (a.k.a. \"Struts Tiles\", as    shipped with Struts 1.1+; compatible with Java 1.4) in the original    org.springframework.web.servlet.view.tiles    package.    18.3.1&nbsp;Dependencies            \n\r\n\rTo be able to use Tiles you have to have a couple of additional      dependencies included in your project. The following is the list of      dependencies you need.      \n\r            \n\r\n\rTiles version 2.1.2 or higher          \n\r            \n\r\n\rCommons BeanUtils          \n\r            \n\r\n\rCommons Digester          \n\r            \n\r\n\rCommons Logging          \n\r        18.3.2&nbsp;How to integrate Tiles            \n\r\n\rTo be able to use Tiles, you have to configure it using files      containing definitions (for basic information on definitions and other      Tiles concepts, please have a look at http://tiles.apache.org). In Spring this is done using the      TilesConfigurer. Have a look at the following      piece of example ApplicationContext configuration:      &lt;bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles2.TilesConfigurer\"&gt;  &lt;property name=\"definitions\"&gt;    &lt;list&gt;      &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rAs you can see, there are five files containing definitions, which      are all located in the \'WEB-INF/defs\' directory. At initialization      of the WebApplicationContext, the files      will be loaded and the definitions factory will be initialized. After      that has been done, the Tiles includes in the definition files can be      used as views within your Spring web application. To be able to use the      views you have to have a ViewResolver      just as with any other view technology used with Spring. Below you can      find two possibilities, the UrlBasedViewResolver      and the ResourceBundleViewResolver.                UrlBasedViewResolver                        \n\r\n\rThe UrlBasedViewResolver instantiates the        given viewClass for each view it has to        resolve.        &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt;  &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.tiles2.TilesView\"/&gt;&lt;/bean&gt;                      ResourceBundleViewResolver                        \n\r\n\rThe ResourceBundleViewResolver has to be        provided with a property file containing viewnames and viewclasses the        resolver can use:        &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\"&gt;  &lt;property name=\"basename\" value=\"views\"/&gt;&lt;/bean&gt;        ...welcomeView.(class)=org.springframework.web.servlet.view.tiles2.TilesViewwelcomeView.url=welcome (this is the name of a Tiles definition)vetsView.(class)=org.springframework.web.servlet.view.tiles2.TilesViewvetsView.url=vetsView (again, this is the name of a Tiles definition)findOwnersForm.(class)=org.springframework.web.servlet.view.JstlViewfindOwnersForm.url=/WEB-INF/jsp/findOwners.jsp...        \n\r\n\rAs you can see, when using the        ResourceBundleViewResolver, you can easily mix        different view technologies.          \n\r\n\rNote that the TilesView class for Tiles 2          supports JSTL (the JSP Standard Tag Library) out of the box, whereas          there is a separate TilesJstlView subclass in the          Tiles 1.x support.            SimpleSpringPreparerFactory and        SpringBeanPreparerFactory                \n\r\n\rAs an advanced feature, Spring also supports two special Tiles 2        PreparerFactory implementations. Check        out the Tiles documentation for details on how to use        ViewPreparer references in your Tiles        definition files.        \n\r\n\rSpecify SimpleSpringPreparerFactory to        autowire ViewPreparer instances based on specified preparer classes,        applying Spring\'s container callbacks as well as applying configured        Spring BeanPostProcessors. If Spring\'s context-wide annotation-config        has been activated, annotations in ViewPreparer classes will be        automatically detected and applied. Note that this expects preparer        classes in the Tiles definition files, just like        the default PreparerFactory does.        \n\r\n\rSpecify SpringBeanPreparerFactory to        operate on specified preparer names instead of        classes, obtaining the corresponding Spring bean from the        DispatcherServlet\'s application context. The full bean creation        process will be in the control of the Spring application context in        this case, allowing for the use of explicit dependency injection        configuration, scoped beans etc. Note that you need to define one        Spring bean definition per preparer name (as used in your Tiles        definitions).        &lt;bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles2.TilesConfigurer\"&gt;  &lt;property name=\"definitions\"&gt;    &lt;list&gt;      &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;      &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;    &lt;/list&gt;  &lt;/property&gt;  &lt;!-- resolving preparer names as Spring bean definition names --&gt;  &lt;property name=\"preparerFactoryClass\"       value=\"org.springframework.web.servlet.view.tiles2.SpringBeanPreparerFactory\"/&gt;&lt;/bean&gt;              18.4&nbsp;Velocity &amp; FreeMarker        \n\r\n\rVelocity and FreeMarker are two templating    languages that can be used as view technologies within Spring MVC    applications. The languages are quite similar and serve similar needs and    so are considered together in this section. For semantic and syntactic    differences between the two languages, see the FreeMarker web site.    18.4.1&nbsp;Dependencies            \n\r\n\rYour web application will need to include velocity-1.x.x.jar or freemarker-2.x.jar in order to work with      Velocity or FreeMarker respectively and commons-collections.jar is required for      Velocity. Typically they are included in the      WEB-INF/lib folder where they are guaranteed to be      found by a Java EE server and added to the classpath for your application.      It is of course assumed that you already have the spring-webmvc.jar in your \'WEB-INF/lib\' directory too! If you make use of      Spring\'s \'dateToolAttribute\' or \'numberToolAttribute\' in your Velocity      views, you will also need to include the velocity-tools-generic-1.x.jar        18.4.2&nbsp;Context configuration            \n\r\n\rA suitable configuration is initialized by adding the relevant      configurer bean definition to your \'*-servlet.xml\'      as shown below:      &lt;!--  This bean sets up the Velocity environment for us based on a root path for templates.  Optionally, a properties file can be specified for more control over the Velocity  environment, but the defaults are pretty sane for file based template loading.--&gt;&lt;bean id=\"velocityConfig\" class=\"org.springframework.web.servlet.view.velocity.VelocityConfigurer\"&gt;  &lt;property name=\"resourceLoaderPath\" value=\"/WEB-INF/velocity/\"/&gt;&lt;/bean&gt;&lt;!--  View resolvers can also be configured with ResourceBundles or XML files. If you need  different view resolving based on Locale, you have to use the resource bundle resolver.--&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.velocity.VelocityViewResolver\"&gt;  &lt;property name=\"cache\" value=\"true\"/&gt;  &lt;property name=\"prefix\" value=\"\"/&gt;  &lt;property name=\"suffix\" value=\".vm\"/&gt;&lt;/bean&gt;      &lt;!-- freemarker config --&gt;&lt;bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"&gt;  &lt;property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/&gt;&lt;/bean&gt;&lt;!--  View resolvers can also be configured with ResourceBundles or XML files. If you need  different view resolving based on Locale, you have to use the resource bundle resolver.--&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"&gt;  &lt;property name=\"cache\" value=\"true\"/&gt;  &lt;property name=\"prefix\" value=\"\"/&gt;  &lt;property name=\"suffix\" value=\".ftl\"/&gt;&lt;/bean&gt;      Note        \n\r\n\rFor non web-apps add a        VelocityConfigurationFactoryBean or a        FreeMarkerConfigurationFactoryBean to your        application context definition file.              18.4.3&nbsp;Creating templates            \n\r\n\rYour templates need to be stored in the directory specified by the      *Configurer bean shown above. This document does not      cover details of creating templates for the two languages - please see      their relevant websites for information. If you use the view resolvers      highlighted, then the logical view names relate to the template file      names in similar fashion to      InternalResourceViewResolver for JSP\'s. So if      your controller returns a ModelAndView object containing a view name of      \"welcome\" then the resolvers will look for the      /WEB-INF/freemarker/welcome.ftl or      /WEB-INF/velocity/welcome.vm template as      appropriate.        18.4.4&nbsp;Advanced configuration            \n\r\n\rThe basic configurations highlighted above will be suitable for      most application requirements, however additional configuration options      are available for when unusual or advanced requirements dictate.      velocity.properties                \n\r\n\rThis file is completely optional, but if specified, contains the        values that are passed to the Velocity runtime in order to configure        velocity itself. Only required for advanced configurations, if you        need this file, specify its location on the        VelocityConfigurer bean definition above.        &lt;bean id=\"velocityConfig\" class=\"org.springframework.web.servlet.view.velocity.VelocityConfigurer\"&gt;  &lt;property name=\"configLocation\" value=\"/WEB-INF/velocity.properties\"/&gt;&lt;/bean&gt;        \n\r\n\rAlternatively, you can specify velocity properties directly in        the bean definition for the Velocity config bean by replacing the        \"configLocation\" property with the following inline properties.        &lt;bean id=\"velocityConfig\" class=\"org.springframework.web.servlet.view.velocity.VelocityConfigurer\"&gt;  &lt;property name=\"velocityProperties\"&gt;    &lt;props&gt;      &lt;prop key=\"resource.loader\"&gt;file&lt;/prop&gt;      &lt;prop key=\"file.resource.loader.class\"&gt;        org.apache.velocity.runtime.resource.loader.FileResourceLoader      &lt;/prop&gt;      &lt;prop key=\"file.resource.loader.path\"&gt;${webapp.root}/WEB-INF/velocity&lt;/prop&gt;      &lt;prop key=\"file.resource.loader.cache\"&gt;false&lt;/prop&gt;    &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;        \n\r\n\rRefer to the API        documentation for Spring configuration of Velocity, or the        Velocity documentation for examples and definitions of the        \'velocity.properties\' file itself.            FreeMarker                \n\r\n\rFreeMarker \'Settings\' and \'SharedVariables\' can be passed        directly to the FreeMarker Configuration object        managed by Spring by setting the appropriate bean properties on the        FreeMarkerConfigurer bean. The        freemarkerSettings property requires a        java.util.Properties object and the        freemarkerVariables property requires a        java.util.Map.        &lt;bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"&gt;  &lt;property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/&gt;  &lt;property name=\"freemarkerVariables\"&gt;    &lt;map&gt;      &lt;entry key=\"xml_escape\" value-ref=\"fmXmlEscape\"/&gt;    &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"fmXmlEscape\" class=\"freemarker.template.utility.XmlEscape\"/&gt;        \n\r\n\rSee the FreeMarker documentation for details of settings and        variables as they apply to the Configuration        object.              18.4.5&nbsp;Bind support and form handling            \n\r\n\rSpring provides a tag library for use in JSP\'s that contains      (amongst other things) a &lt;spring:bind/&gt; tag.      This tag primarily enables forms to display values from form backing      objects and to show the results of failed validations from a      Validator in the web or business tier. From version      1.1, Spring now has support for the same functionality in both Velocity      and FreeMarker, with additional convenience macros for generating form      input elements themselves.      The bind macros                \n\r\n\rA standard set of macros are maintained within the        spring-webmvc.jar file for both languages, so they are        always available to a suitably configured application.        \n\r\n\rSome of the macros defined in the Spring libraries are        considered internal (private) but no such scoping exists in the macro        definitions making all macros visible to calling code and user        templates. The following sections concentrate only on the macros you        need to be directly calling from within your templates. If you wish to        view the macro code directly, the files are called spring.vm /        spring.ftl and are in the packages        org.springframework.web.servlet.view.velocity or        org.springframework.web.servlet.view.freemarker        respectively.            Simple binding                \n\r\n\rIn your html forms (vm / ftl templates) that act as the        \'formView\' for a Spring form controller, you can use code similar to        the following to bind to field values and display error messages for        each input field in similar fashion to the JSP equivalent. Note that        the name of the command object is \"command\" by default, but can be        overridden in your MVC configuration by setting the \'commandName\' bean        property on your form controller. Example code is shown below for the        personFormV and personFormF        views configured earlier;        &lt;!-- velocity macros are automatically available --&gt;&lt;html&gt;...&lt;form action=\"\" method=\"POST\"&gt;  Name:  #springBind( \"command.name\" )  &lt;input type=\"text\"    name=\"${status.expression}\"    value=\"$!status.value\" /&gt;&lt;br&gt;  #foreach($error in $status.errorMessages) &lt;b&gt;$error&lt;/b&gt; &lt;br&gt; #end  &lt;br&gt;  ...  &lt;input type=\"submit\" value=\"submit\"/&gt;&lt;/form&gt;...&lt;/html&gt;        &lt;!-- freemarker macros have to be imported into a namespace.  We stronglyrecommend sticking to \'spring\' --&gt;&lt;#import \"/spring.ftl\" as spring /&gt;&lt;html&gt;...&lt;form action=\"\" method=\"POST\"&gt;  Name:  &lt;@spring.bind \"command.name\" /&gt;  &lt;input type=\"text\"    name=\"${spring.status.expression}\"    value=\"${spring.status.value?default(\"\")}\" /&gt;&lt;br&gt;  &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br&gt; &lt;/#list&gt;  &lt;br&gt;  ...  &lt;input type=\"submit\" value=\"submit\"/&gt;&lt;/form&gt;...&lt;/html&gt;        \n\r\n\r#springBind /        &lt;@spring.bind&gt; requires a \'path\' argument        which consists of the name of your command object (it will be        \'command\' unless you changed it in your FormController properties)        followed by a period and the name of the field on the command object        you wish to bind to. Nested fields can be used too such as        \"command.address.street\". The bind macro assumes        the default HTML escaping behavior specified by the ServletContext        parameter defaultHtmlEscape in web.xml        \n\r\n\rThe optional form of the macro called        #springBindEscaped /        &lt;@spring.bindEscaped&gt; takes a second argument        and explicitly specifies whether HTML escaping should be used in the        status error messages or values. Set to true or false as required.        Additional form handling macros simplify the use of HTML escaping and        these macros should be used wherever possible. They are explained in        the next section.            Form input generation macros                \n\r\n\rAdditional convenience macros for both languages simplify both        binding and form generation (including validation error display). It        is never necessary to use these macros to generate form input fields,        and they can be mixed and matched with simple HTML or calls direct to        the spring bind macros highlighted previously.        \n\r\n\rThe following table of available macros show the VTL and FTL        definitions and the parameter list that each takes.        \n\r\n\rTable&nbsp;18.1.&nbsp;Table of macro definitions                    macroVTL definitionFTL definitionmessage (output a                string from a resource bundle based on the code                parameter)#springMessage($code)&lt;@spring.message                code/&gt;messageText (output a                string from a resource bundle based on the code parameter,                falling back to the value of the default parameter)#springMessageText($code                $text)&lt;@spring.messageText code,                text/&gt;url (prefix a relative                URL with the application\'s context root)#springUrl($relativeUrl)&lt;@spring.url                relativeUrl/&gt;formInput (standard                input field for gathering user input)#springFormInput($path                $attributes)&lt;@spring.formInput path, attributes,                fieldType/&gt;formHiddenInput *                (hidden input field for submitting non-user input)#springFormHiddenInput($path                $attributes)&lt;@spring.formHiddenInput path,                attributes/&gt;formPasswordInput *                (standard input field for gathering passwords. Note that no                value will ever be populated in fields of this type)#springFormPasswordInput($path                $attributes)&lt;@spring.formPasswordInput path,                attributes/&gt;formTextarea (large                text field for gathering long, freeform text input)#springFormTextarea($path                $attributes)&lt;@spring.formTextarea path,                attributes/&gt;formSingleSelect (drop                down box of options allowing a single required value to be                selected)#springFormSingleSelect( $path $options                $attributes)&lt;@spring.formSingleSelect path, options,                attributes/&gt;formMultiSelect (a                list box of options allowing the user to select 0 or more                values)#springFormMultiSelect($path $options                $attributes)&lt;@spring.formMultiSelect path, options,                attributes/&gt;formRadioButtons (a                set of radio buttons allowing a single selection to be made                from the available choices)#springFormRadioButtons($path $options                $separator $attributes)&lt;@spring.formRadioButtons path, options                separator, attributes/&gt;formCheckboxes (a set                of checkboxes allowing 0 or more values to be                selected)#springFormCheckboxes($path $options                $separator $attributes)&lt;@spring.formCheckboxes path, options,                separator, attributes/&gt;formCheckbox (a single                checkbox)#springFormCheckbox($path                $attributes)&lt;@spring.formCheckbox path,                attributes/&gt;showErrors (simplify                display of validation errors for the bound field)#springShowErrors($separator                $classOrStyle)&lt;@spring.showErrors separator,                classOrStyle/&gt;        \n\r        \n\r\n\r* In FTL (FreeMarker), these two macros are not actually        required as you can use the normal formInput macro,        specifying \'hidden\' or        \'password\' as the value for the        fieldType parameter.        \n\r\n\rThe parameters to any of the above macros have consistent        meanings:        \n\r            \n\r\n\rpath: the name of the field to bind to (ie            \"command.name\")          \n\r            \n\r\n\roptions: a Map of all the available values that can be            selected from in the input field. The keys to the map represent            the values that will be POSTed back from the form and bound to the            command object. Map objects stored against the keys are the labels            displayed on the form to the user and may be different from the            corresponding values posted back by the form. Usually such a map            is supplied as reference data by the controller. Any Map            implementation can be used depending on required behavior. For            strictly sorted maps, a SortedMap such as a            TreeMap with a suitable Comparator may be used            and for arbitrary Maps that should return values in insertion            order, use a LinkedHashMap or a            LinkedMap from commons-collections.          \n\r            \n\r\n\rseparator: where multiple options are available as discreet            elements (radio buttons or checkboxes), the sequence of characters            used to separate each one in the list (ie \"&lt;br&gt;\").          \n\r            \n\r\n\rattributes: an additional string of arbitrary tags or text            to be included within the HTML tag itself. This string is echoed            literally by the macro. For example, in a textarea field you may            supply attributes as \'rows=\"5\" cols=\"60\"\' or you could pass style            information such as \'style=\"border:1px solid silver\"\'.          \n\r            \n\r\n\rclassOrStyle: for the showErrors macro, the name of the CSS            class that the span tag wrapping each error will use. If no            information is supplied (or the value is empty) then the errors            will be wrapped in &lt;b&gt;&lt;/b&gt; tags.          \n\r        \n\r\n\rExamples of the macros are outlined below some in FTL and some        in VTL. Where usage differences exist between the two languages, they        are explained in the notes.        Input Fields                    &lt;!-- the Name field example from above using form macros in VTL --&gt;...    Name:    #springFormInput(\"command.name\" \"\")&lt;br&gt;    #springShowErrors(\"&lt;br&gt;\" \"\")&lt;br&gt;          \n\r\n\rThe formInput macro takes the path parameter (command.name)          and an additional attributes parameter which is empty in the example          above. The macro, along with all other form generation macros,          performs an implicit spring bind on the path parameter. The binding          remains valid until a new bind occurs so the showErrors macro          doesn\'t need to pass the path parameter again - it simply operates          on whichever field a bind was last created for.          \n\r\n\rThe showErrors macro takes a separator parameter (the          characters that will be used to separate multiple errors on a given          field) and also accepts a second parameter, this time a class name          or style attribute. Note that FreeMarker is able to specify default          values for the attributes parameter, unlike Velocity, and the two          macro calls above could be expressed as follows in FTL:          &lt;@spring.formInput \"command.name\"/&gt;&lt;@spring.showErrors \"&lt;br&gt;\"/&gt;          \n\r\n\rOutput is shown below of the form fragment generating the name          field, and displaying a validation error after the form was          submitted with no value in the field. Validation occurs through          Spring\'s Validation framework.          \n\r\n\rThe generated HTML looks like this:          Name:  &lt;input type=\"text\" name=\"name\" value=\"\"&gt;&lt;br&gt;  &lt;b&gt;required&lt;/b&gt;&lt;br&gt;&lt;br&gt;          \n\r\n\rThe formTextarea macro works the same way as the formInput          macro and accepts the same parameter list. Commonly, the second          parameter (attributes) will be used to pass style information or          rows and cols attributes for the textarea.                Selection Fields                    \n\r\n\rFour selection field macros can be used to generate common UI          value selection inputs in your HTML forms.          \n\r              \n\r\n\rformSingleSelect            \n\r              \n\r\n\rformMultiSelect            \n\r              \n\r\n\rformRadioButtons            \n\r              \n\r\n\rformCheckboxes            \n\r          \n\r\n\rEach of the four macros accepts a Map of options containing          the value for the form field, and the label corresponding to that          value. The value and the label can be the same.          \n\r\n\rAn example of radio buttons in FTL is below. The form backing          object specifies a default value of \'London\' for this field and so          no validation is necessary. When the form is rendered, the entire          list of cities to choose from is supplied as reference data in the          model under the name \'cityMap\'.          ...  Town:  &lt;@spring.formRadioButtons \"command.address.town\", cityMap, \"\" /&gt;&lt;br&gt;&lt;br&gt;          \n\r\n\rThis renders a line of radio buttons, one for each value in          cityMap using the separator \"\". No additional          attributes are supplied (the last parameter to the macro is          missing). The cityMap uses the same String for each key-value pair          in the map. The map\'s keys are what the form actually submits as          POSTed request parameters, map values are the labels that the user          sees. In the example above, given a list of three well known cities          and a default value in the form backing object, the HTML would          be          Town:&lt;input type=\"radio\" name=\"address.town\" value=\"London\"&gt;London&lt;input type=\"radio\" name=\"address.town\" value=\"Paris\"  checked=\"checked\"&gt;Paris&lt;input type=\"radio\" name=\"address.town\" value=\"New York\"&gt;New York          \n\r\n\rIf your application expects to handle cities by internal codes          for example, the map of codes would be created with suitable keys          like the example below.          protected Map referenceData(HttpServletRequest request) throws Exception {  Map cityMap = new LinkedHashMap();  cityMap.put(\"LDN\", \"London\");  cityMap.put(\"PRS\", \"Paris\");  cityMap.put(\"NYC\", \"New York\");  Map m = new HashMap();  m.put(\"cityMap\", cityMap);  return m;}          \n\r\n\rThe code would now produce output where the radio values are          the relevant codes but the user still sees the more user friendly          city names.          Town:&lt;input type=\"radio\" name=\"address.town\" value=\"LDN\"&gt;London&lt;input type=\"radio\" name=\"address.town\" value=\"PRS\"  checked=\"checked\"&gt;Paris&lt;input type=\"radio\" name=\"address.town\" value=\"NYC\"&gt;New York                    HTML escaping and XHTML compliance                \n\r\n\rDefault usage of the form macros above will result in HTML tags        that are HTML 4.01 compliant and that use the default value for HTML        escaping defined in your web.xml as used by Spring\'s bind support. In        order to make the tags XHTML compliant or to override the default HTML        escaping value, you can specify two variables in your template (or in        your model where they will be visible to your templates). The        advantage of specifying them in the templates is that they can be        changed to different values later in the template processing to        provide different behavior for different fields in your form.        \n\r\n\rTo switch to XHTML compliance for your tags, specify a value of        \'true\' for a model/context variable named xhtmlCompliant:        ## for Velocity..#set($springXhtmlCompliant = true)&lt;#-- for FreeMarker --&gt;&lt;#assign xhtmlCompliant = true in spring&gt;        \n\r\n\rAny tags generated by the Spring macros will now be XHTML        compliant after processing this directive.        \n\r\n\rIn similar fashion, HTML escaping can be specified per        field:        &lt;#-- until this point, default HTML escaping is used --&gt;&lt;#assign htmlEscape = true in spring&gt;&lt;#-- next field will use HTML escaping --&gt;&lt;@spring.formInput \"command.name\" /&gt;&lt;#assign htmlEscape = false in spring&gt;&lt;#-- all future fields will be bound with HTML escaping off --&gt;              18.5&nbsp;XSLT        \n\r\n\rXSLT is a transformation language for XML and is popular as a view    technology within web applications. XSLT can be a good choice as a view    technology if your application naturally deals with XML, or if your model    can easily be converted to XML. The following section shows how to produce    an XML document as model data and have it transformed with XSLT in a    Spring Web MVC application.    18.5.1&nbsp;My First Words            \n\r\n\rThis example is a trivial Spring application that creates a list      of words in the Controller and adds them      to the model map. The map is returned along with the view name of our      XSLT view. See Section&nbsp;17.3, &#8220;Implementing Controllers&#8221; for details of Spring Web MVC\'s      Controller interface. The XSLT view will      turn the list of words into a simple XML document ready for      transformation.      Bean definitions                \n\r\n\rConfiguration is standard for a simple Spring application. The        dispatcher servlet config file contains a reference to a        ViewResolver, URL mappings and a single        controller bean...        &lt;bean id=\"homeController\"class=\"xslt.HomeController\"/&gt;        \n\r\n\r... that encapsulates our word generation logic.            Standard MVC controller code                \n\r\n\rThe controller logic is encapsulated in a subclass of        AbstractController, with the handler method        being defined like so...        protected ModelAndView handleRequestInternal(    HttpServletRequest request,    HttpServletResponse response) throws Exception {    Map map = new HashMap();    List wordList = new ArrayList();    wordList.add(\"hello\");    wordList.add(\"world\");    map.put(\"wordList\", wordList);    return new ModelAndView(\"home\", map);}        \n\r\n\rSo far we\'ve done nothing that\'s XSLT specific. The model data        has been created in the same way as you would for any other Spring MVC        application. Depending on the configuration of the application now,        that list of words could be rendered by JSP/JSTL by having them added        as request attributes, or they could be handled by Velocity by adding        the object to the VelocityContext. In order to        have XSLT render them, they of course have to be converted into an XML        document somehow. There are software packages available that will        automatically \'domify\' an object graph, but within Spring, you have        complete flexibility to create the DOM from your model in any way you        choose. This prevents the transformation of XML playing too great a        part in the structure of your model data which is a danger when using        tools to manage the domification process.            Convert the model data to XML                \n\r\n\rIn order to create a DOM document from our list of words or any        other model data, we must subclass the (provided)        org.springframework.web.servlet.view.xslt.AbstractXsltView        class. In doing so, we must also typically implement the abstract        method createXsltSource(..) method. The first        parameter passed to this method is our model map. Here\'s the complete        listing of the HomePage class in our trivial        word application:        package xslt;// imports omitted for brevitypublic class HomePage extends AbstractXsltView {    protected Source createXsltSource(Map model, String rootName, HttpServletRequest        request, HttpServletResponse response) throws Exception {        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();        Element root = document.createElement(rootName);        List words = (List) model.get(\"wordList\");        for (Iterator it = words.iterator(); it.hasNext();) {            String nextWord = (String) it.next();            Element wordNode = document.createElement(\"word\");            Text textNode = document.createTextNode(nextWord);            wordNode.appendChild(textNode);            root.appendChild(wordNode);        }        return new DOMSource(root);    }}        \n\r\n\rA series of parameter name/value pairs can optionally be defined        by your subclass which will be added to the transformation object. The        parameter names must match those defined in your XSLT template        declared with &lt;xsl:param        name=\"myParam\"&gt;defaultValue&lt;/xsl:param&gt;. To specify        the parameters, override the getParameters()        method of the AbstractXsltView class and return        a Map of the name/value pairs. If your        parameters need to derive information from the current request, you        can override the getParameters(HttpServletRequest        request) method instead.            Defining the view properties                \n\r\n\rThe views.properties file (or equivalent xml definition if        you\'re using an XML based view resolver as we did in the Velocity        examples above) looks like this for the one-view application that is        \'My First Words\':        home.(class)=xslt.HomePagehome.stylesheetLocation=/WEB-INF/xsl/home.xslthome.root=words        \n\r\n\rHere, you can see how the view is tied in with the        HomePage class just written which handles the        model domification in the first property \'.(class)\'.        The \'stylesheetLocation\' property points to the        XSLT file which will handle the XML transformation into HTML for us        and the final property \'.root\' is the name that        will be used as the root of the XML document. This gets passed to the        HomePage class above in the second parameter to        the createXsltSource(..) method(s).            Document transformation                \n\r\n\rFinally, we have the XSLT code used for transforming the above        document. As shown in the above        \'views.properties\' file, the stylesheet is called        \'home.xslt\' and it lives in the war file in the        \'WEB-INF/xsl\' directory.        &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;    &lt;xsl:output method=\"html\" omit-xml-declaration=\"yes\"/&gt;    &lt;xsl:template match=\"/\"&gt;        &lt;html&gt;            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;            &lt;body&gt;                &lt;h1&gt;My First Words&lt;/h1&gt;                &lt;xsl:apply-templates/&gt;            &lt;/body&gt;        &lt;/html&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match=\"word\"&gt;        &lt;xsl:value-of select=\".\"/&gt;&lt;br/&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;              18.5.2&nbsp;Summary            \n\r\n\rA summary of the files discussed and their location in the WAR      file is shown in the simplified WAR structure below.      ProjectRoot  |  +- WebContent      |      +- WEB-INF          |          +- classes          |    |          |    +- xslt          |    |   |          |    |   +- HomePageController.class          |    |   +- HomePage.class          |    |          |    +- views.properties          |          +- lib          |   |          |   +- spring-*.jar          |          +- xsl          |   |          |   +- home.xslt          |          +- frontcontroller-servlet.xml      \n\r\n\rYou will also need to ensure that an XML parser and an XSLT engine      are available on the classpath. JDK 1.4 provides them by default, and      most Java EE containers will also make them available by default, but it\'s      a possible source of errors to be aware of.        18.6&nbsp;Document views (PDF/Excel)        18.6.1&nbsp;Introduction            \n\r\n\rReturning an HTML page isn\'t always the best way for the user to      view the model output, and Spring makes it simple to generate a PDF      document or an Excel spreadsheet dynamically from the model data. The      document is the view and will be streamed from the server with the      correct content type to (hopefully) enable the client PC to run their      spreadsheet or PDF viewer application in response.      \n\r\n\rIn order to use Excel views, you need to add the \'poi\' library to      your classpath, and for PDF generation, the iText library.        18.6.2&nbsp;Configuration and setup            \n\r\n\rDocument based views are handled in an almost identical fashion to      XSLT views, and the following sections build upon the previous one by      demonstrating how the same controller used in the XSLT example is      invoked to render the same model as both a PDF document and an Excel      spreadsheet (which can also be viewed or manipulated in Open      Office).      Document view definitions                \n\r\n\rFirst, let\'s amend the views.properties file (or xml        equivalent) and add a simple view definition for both document types.        The entire file now looks like this with the XSLT view shown from        earlier:        home.(class)=xslt.HomePagehome.stylesheetLocation=/WEB-INF/xsl/home.xslthome.root=wordsxl.(class)=excel.HomePagepdf.(class)=pdf.HomePage        \n\r\n\rIf you want to start with a        template spreadsheet or a fillable PDF form to add your model data to, specify the location        as the \'url\' property in the view definition            Controller code                \n\r\n\rThe controller code we\'ll use remains exactly the same from the        XSLT example earlier other than to change the name of the view to use.        Of course, you could be clever and have this selected based on a URL        parameter or some other logic - proof that Spring really is very good        at decoupling the views from the controllers!            Subclassing for Excel views                \n\r\n\rExactly as we did for the XSLT example, we\'ll subclass suitable        abstract classes in order to implement custom behavior in generating        our output documents. For Excel, this involves writing a subclass of        org.springframework.web.servlet.view.document.AbstractExcelView        (for Excel files generated by POI) or        org.springframework.web.servlet.view.document.AbstractJExcelView        (for JExcelApi-generated Excel files) and implementing the        buildExcelDocument() method.        \n\r\n\rHere\'s the complete listing for our POI Excel view which        displays the word list from the model map in consecutive rows of the        first column of a new spreadsheet:        package excel;// imports omitted for brevitypublic class HomePage extends AbstractExcelView {    protected void buildExcelDocument(        Map model,        HSSFWorkbook wb,        HttpServletRequest req,        HttpServletResponse resp)        throws Exception {        HSSFSheet sheet;        HSSFRow sheetRow;        HSSFCell cell;        // Go to the first sheet        // getSheetAt: only if wb is created from an existing document        // sheet = wb.getSheetAt(0);        sheet = wb.createSheet(\"Spring\");        sheet.setDefaultColumnWidth((short) 12);        // write a text at A1        cell = getCell(sheet, 0, 0);        setText(cell, \"Spring-Excel test\");        List words = (List) model.get(\"wordList\");        for (int i=0; i &lt; words.size(); i++) {            cell = getCell(sheet, 2+i, 0);            setText(cell, (String) words.get(i));        }    }}        \n\r\n\rAnd the following is a view generating the same Excel file, now using        JExcelApi:        package excel;// imports omitted for brevitypublic class HomePage extends AbstractJExcelView {    protected void buildExcelDocument(Map model,        WritableWorkbook wb,        HttpServletRequest request,        HttpServletResponse response)    throws Exception {        WritableSheet sheet = wb.createSheet(\"Spring\", 0);        sheet.addCell(new Label(0, 0, \"Spring-Excel test\"));        List words = (List) model.get(\"wordList\");        for (int i = 0; i &lt; words.size(); i++) {            sheet.addCell(new Label(2+i, 0, (String) words.get(i)));        }    }}        \n\r\n\rNote the differences between the APIs. We\'ve found that the        JExcelApi is somewhat more intuitive, and furthermore, JExcelApi has        slightly better image-handling capabilities. There have been memory        problems with large Excel files when using JExcelApi however.        \n\r\n\rIf you now amend the controller such that it returns        xl as the name of the view (return new        ModelAndView(\"xl\", map);) and run your application again,        you should find that the Excel spreadsheet is created and downloaded        automatically when you request the same page as before.            Subclassing for PDF views                \n\r\n\rThe PDF version of the word list is even simpler. This time, the        class extends        org.springframework.web.servlet.view.document.AbstractPdfView        and implements the buildPdfDocument() method as        follows:        package pdf;// imports omitted for brevitypublic class PDFPage extends AbstractPdfView {    protected void buildPdfDocument(        Map model,        Document doc,        PdfWriter writer,        HttpServletRequest req,        HttpServletResponse resp)        throws Exception {        List words = (List) model.get(\"wordList\");        for (int i=0; i&lt;words.size(); i++)            doc.add( new Paragraph((String) words.get(i)));    }}        \n\r\n\rOnce again, amend the controller to return the        pdf view with return new        ModelAndView(\"pdf\", map);, and reload the URL in your        application. This time a PDF document should appear listing each of        the words in the model map.              18.7&nbsp;JasperReports        \n\r\n\rJasperReports (http://jasperreports.sourceforge.net) is a powerful    open-source reporting engine that supports the creation of report designs    using an easily understood XML file format. JasperReports is capable of    rendering reports in four different formats: CSV, Excel, HTML and    PDF.    18.7.1&nbsp;Dependencies            \n\r\n\rYour application will need to include the latest release of      JasperReports, which at the time of writing was 0.6.1. JasperReports      itself depends on the following projects:      \n\r          \n\r\n\rBeanShell        \n\r          \n\r\n\rCommons BeanUtils        \n\r          \n\r\n\rCommons Collections        \n\r          \n\r\n\rCommons Digester        \n\r          \n\r\n\rCommons Logging        \n\r          \n\r\n\riText        \n\r          \n\r\n\rPOI        \n\r      \n\r\n\rJasperReports also requires a JAXP compliant XML parser.        18.7.2&nbsp;Configuration            \n\r\n\rTo configure JasperReports views in your Spring container      configuration you need to define a      ViewResolver to map view names to the      appropriate view class depending on which format you want your report      rendered in.      Configuring the        ViewResolver                \n\r\n\rTypically, you will use the        ResourceBundleViewResolver to map view names to        view classes and files in a properties file.        &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\"&gt;    &lt;property name=\"basename\" value=\"views\"/&gt;&lt;/bean&gt;        \n\r\n\rHere we\'ve configured an instance of the        ResourceBundleViewResolver class that will look        for view mappings in the resource bundle with base name        views. (The content of this file is described in        the next section.)            Configuring the Views                \n\r\n\rThe Spring Framework contains five different        View implementations for JasperReports,        four of which correspond to one of the four output formats supported        by JasperReports, and one that allows for the format to be determined        at runtime:        \n\r\n\rTable&nbsp;18.2.&nbsp;JasperReports View          classes                    Class NameRender FormatJasperReportsCsvViewCSVJasperReportsHtmlViewHTMLJasperReportsPdfViewPDFJasperReportsXlsViewMicrosoft ExcelJasperReportsMultiFormatViewThe view is decided                upon at runtime        \n\r        \n\r\n\rMapping one of these classes to a view name and a report file is        a matter of adding the appropriate entries in the resource bundle        configured in the previous section as shown here:        simpleReport.(class)=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfViewsimpleReport.url=/WEB-INF/reports/DataSourceReport.jasper        \n\r\n\rHere you can see that the view with name        simpleReport is mapped to the        JasperReportsPdfView class, causing the output        of this report to be rendered in PDF format. The        url property of the view is set to the location of        the underlying report file.            About Report Files                \n\r\n\rJasperReports has two distinct types of report file: the design        file, which has a .jrxml extension, and the        compiled report file, which has a .jasper        extension. Typically, you use the JasperReports Ant task to compile        your .jrxml design file into a        .jasper file before deploying it into your        application. With the Spring Framework you can map either of these        files to your report file and the framework will take care of        compiling the .jrxml file on the fly for you. You        should note that after a .jrxml file is compiled by        the Spring Framework, the compiled report is cached for the lifetime        of the application. Thus, to make changes to the file you will need to        restart your application.            Using        JasperReportsMultiFormatView                \n\r\n\rThe JasperReportsMultiFormatView allows        for the report format to be specified at runtime. The actual rendering of        the report is delegated to one of the other JasperReports view classes        - the JasperReportsMultiFormatView class simply        adds a wrapper layer that allows for the exact implementation to be        specified at runtime.        \n\r\n\rThe JasperReportsMultiFormatView class        introduces two concepts: the format key and the discriminator key. The        JasperReportsMultiFormatView class uses the        mapping key to look up the actual view implementation class, and it uses        the format key to lookup up the mapping key. From a coding perspective        you add an entry to your model with the format key as the key and the        mapping key as the value, for example:        public ModelAndView handleSimpleReportMulti(HttpServletRequest request,HttpServletResponse response) throws Exception {  String uri = request.getRequestURI();  String format = uri.substring(uri.lastIndexOf(\".\") + 1);  Map model = getModel();  model.put(\"format\", format);  return new ModelAndView(\"simpleReportMulti\", model);}        \n\r\n\rIn this example, the mapping key is determined from the        extension of the request URI and is added to the model under the        default format key: format. If you wish to use a        different format key then you can configure this using the        formatKey property of the        JasperReportsMultiFormatView class.        \n\r\n\rBy default the following mapping key mappings are configured in        JasperReportsMultiFormatView:        \n\r\n\rTable&nbsp;18.3.&nbsp;JasperReportsMultiFormatView Default          Mapping Key Mappings                    Mapping KeyView ClasscsvJasperReportsCsvViewhtmlJasperReportsHtmlViewpdfJasperReportsPdfViewxlsJasperReportsXlsView        \n\r        \n\r\n\rSo in the example above a request to URI /foo/myReport.pdf would        be mapped to the JasperReportsPdfView class. You        can override the mapping key to view class mappings using the        formatMappings property of        JasperReportsMultiFormatView.              18.7.3&nbsp;Populating the ModelAndView            \n\r\n\rIn order to render your report correctly in the format you have      chosen, you must supply Spring with all of the data needed to populate      your report. For JasperReports this means you must pass in all report      parameters along with the report datasource. Report parameters are      simple name/value pairs and can be added to the      Map for your model as you would add any      name/value pair.      \n\r\n\rWhen adding the datasource to the model you have two approaches to      choose from. The first approach is to add an instance of      JRDataSource or a      Collection type to the model      Map under any arbitrary key. Spring will      then locate this object in the model and treat it as the report      datasource. For example, you may populate your model like so:      private Map getModel() {  Map model = new HashMap();  Collection beanData = getBeanData();  model.put(\"myBeanData\", beanData);  return model;}      \n\r\n\rThe second approach is to add the instance of      JRDataSource or Collection under a      specific key and then configure this key using the      reportDataKey property of the view class. In both      cases Spring will wrap instances of Collection in a      JRBeanCollectionDataSource instance. For      example:      private Map getModel() {  Map model = new HashMap();  Collection beanData = getBeanData();  Collection someData = getSomeData();  model.put(\"myBeanData\", beanData);  model.put(\"someData\", someData);  return model;}      \n\r\n\rHere you can see that two Collection instances      are being added to the model. To ensure that the correct one is used, we      simply modify our view configuration as appropriate:      simpleReport.(class)=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfViewsimpleReport.url=/WEB-INF/reports/DataSourceReport.jaspersimpleReport.reportDataKey=myBeanData      \n\r\n\rBe aware that when using the first approach, Spring will use the      first instance of JRDataSource or      Collection that it encounters. If you need to place      multiple instances of JRDataSource or      Collection into the model you need to use the      second approach.        18.7.4&nbsp;Working with Sub-Reports            \n\r\n\rJasperReports provides support for embedded sub-reports within      your master report files. There are a wide variety of mechanisms for      including sub-reports in your report files. The easiest way is to hard      code the report path and the SQL query for the sub report into your      design files. The drawback of this approach is obvious: the values are      hard-coded into your report files reducing reusability and making it      harder to modify and update report designs. To overcome this you can      configure sub-reports declaratively, and you can include additional data      for these sub-reports directly from your controllers.      Configuring Sub-Report Files                \n\r\n\rTo control which sub-report files are included in a master        report using Spring, your report file must be configured to accept        sub-reports from an external source. To do this you declare a        parameter in your report file like so:        &lt;parameter name=\"ProductsSubReport\" class=\"net.sf.jasperreports.engine.JasperReport\"/&gt;        \n\r\n\rThen, you define your sub-report to use this sub-report        parameter:        &lt;subreport&gt;    &lt;reportElement isPrintRepeatedValues=\"false\" x=\"5\" y=\"25\" width=\"325\"        height=\"20\" isRemoveLineWhenBlank=\"true\" backcolor=\"#ffcc99\"/&gt;    &lt;subreportParameter name=\"City\"&gt;        &lt;subreportParameterExpression&gt;&lt;![CDATA[$F{city}]]&gt;&lt;/subreportParameterExpression&gt;    &lt;/subreportParameter&gt;    &lt;dataSourceExpression&gt;&lt;![CDATA[$P{SubReportData}]]&gt;&lt;/dataSourceExpression&gt;    &lt;subreportExpression class=\"net.sf.jasperreports.engine.JasperReport\"&gt;                  &lt;![CDATA[$P{ProductsSubReport}]]&gt;&lt;/subreportExpression&gt;&lt;/subreport&gt;        \n\r\n\rThis defines a master report file that expects the sub-report to        be passed in as an instance of        net.sf.jasperreports.engine.JasperReports under the        parameter ProductsSubReport. When configuring your        Jasper view class, you can instruct Spring to load a report file and        pass it into the JasperReports engine as a sub-report using the        subReportUrls property:        &lt;property name=\"subReportUrls\"&gt;    &lt;map&gt;        &lt;entry key=\"ProductsSubReport\" value=\"/WEB-INF/reports/subReportChild.jrxml\"/&gt;    &lt;/map&gt;&lt;/property&gt;        \n\r\n\rHere, the key of the Map        corresponds to the name of the sub-report parameter in the report        design file, and the entry is the URL of the report file. Spring will        load this report file, compiling it if necessary, and pass it into        the JasperReports engine under the given key.            Configuring Sub-Report Data Sources                \n\r\n\rThis step is entirely optional when using Spring to configure your        sub-reports. If you wish, you can still configure the data source for        your sub-reports using static queries. However, if you want Spring to        convert data returned in your ModelAndView into        instances of JRDataSource then you need to specify        which of the parameters in your ModelAndView Spring        should convert. To do this, configure the list of parameter names using        the subReportDataKeys property of your chosen        view class:        &lt;property name=\"subReportDataKeys\" value=\"SubReportData\"/&gt;        \n\r\n\rHere, the key you supply must        correspond to both the key used in your ModelAndView        and the key used in your report design file.              18.7.5&nbsp;Configuring Exporter Parameters            \n\r\n\rIf you have special requirements for exporter configuration --      perhaps you want a specific page size for your PDF report -- you can      configure these exporter parameters declaratively in your Spring      configuration file using the exporterParameters      property of the view class. The exporterParameters      property is typed as a Map. In your      configuration the key of an entry should be the fully-qualified name of      a static field that contains the exporter parameter definition, and the      value of an entry should be the value you want to assign to the      parameter. An example of this is shown below:      &lt;bean id=\"htmlReport\" class=\"org.springframework.web.servlet.view.jasperreports.JasperReportsHtmlView\"&gt;  &lt;property name=\"url\" value=\"/WEB-INF/reports/simpleReport.jrxml\"/&gt;  &lt;property name=\"exporterParameters\"&gt;    &lt;map&gt;      &lt;entry key=\"net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER\"&gt;        &lt;value&gt;Footer by Spring!          &amp;lt;/td&amp;gt;&amp;lt;td width=\"50%\"&amp;gt;&amp;amp;nbsp; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;          &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;        &lt;/value&gt;      &lt;/entry&gt;    &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;      \n\r\n\rHere you can see that the      JasperReportsHtmlView is configured with an      exporter parameter for      net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER      which will output a footer in the resulting HTML.        18.8&nbsp;Feed Views        \n\r\n\rBoth AbstractAtomFeedView and    AbstractRssFeedView inherit from the base class    AbstractFeedView and are used to provide Atom and    RSS Feed views respectfully. They are based on java.net\'s ROME project and are located in    the package    org.springframework.web.servlet.view.feed.    \n\r\n\rAbstractAtomFeedView requires you to    implement the buildFeedEntries() method and    optionally override the buildFeedMetadata() method    (the default implementation is empty), as shown below.    public class SampleContentAtomView extends AbstractAtomFeedView {  @Override  protected void buildFeedMetadata(Map&lt;String, Object&gt; model, Feed feed,      HttpServletRequest request) {    // implementation omitted  }  @Override  protected List&lt;Entry&gt; buildFeedEntries(Map&lt;String, Object&gt; model,      HttpServletRequest request, HttpServletResponse response)      throws Exception {    // implementation omitted  }}    \n\r\n\rSimilar requirements apply for implementing    AbstractRssFeedView, as shown below.    public class SampleContentAtomView extends AbstractRssFeedView {  @Override  protected void buildFeedMetadata(Map&lt;String, Object&gt; model, Channel feed,                                   HttpServletRequest request) {    // implementation omitted  }  @Override  protected List&lt;Item&gt; buildFeedItems(Map&lt;String, Object&gt; model,      HttpServletRequest request, HttpServletResponse response)      throws Exception {    // implementation omitted  }}    \n\r\n\rThe buildFeedItems() and    buildFeedEntires() methods pass in the HTTP request in case    you need to access the Locale. The HTTP response is passed in only for the    setting of cookies or other HTTP headers. The feed will automatically be    written to the response object after the method returns.    \n\r\n\rFor an example of creating an Atom view please refer to Alef    Arendsen\'s SpringSource Team Blog entry.    18.9&nbsp;XML Marshalling View        \n\r\n\rThe MarhsallingView uses an XML    Marshaller defined in the    org.springframework.oxm package to render the    response content as XML. The object to be marshalled can be set explicitly    using MarhsallingView\'s    modelKey bean property. Alternatively, the view will    iterate over all model properties and marshal only those types that are    supported by the Marshaller. For more    information on the functionality in the    org.springframework.oxm package refer to the    chapter Marshalling XML using O/X    Mappers.    18.10&nbsp;JSON Mapping View              \n\r\n\rThe MappingJackson2JsonView        (or MappingJacksonJsonView depending on the        the Jackson version you have) uses the Jackson      library\'s ObjectMapper to render the response content      as JSON. By default, the entire contents of the model map (with the exception      of framework-specific classes) will be encoded as JSON. For cases where the      contents of the map need to be filtered, users may specify a specific set of      model attributes to encode via the RenderedAttributes      property. The extractValueFromSingleKeyModel property      may also be  used to have the value in single-key models extracted and      serialized directly rather than as a map of model attributes.    \n\r\n\rJSON mapping can be customized as needed through the use of Jackson\'s provided    annotations. When further control is needed, a custom    ObjectMapper can be injected through the    ObjectMapper property for cases where custom JSON    serializers/deserializers need to be provided for specific types.  Prev&nbsp;Up&nbsp;Next17.&nbsp;Web MVC framework&nbsp;Home&nbsp;19.&nbsp;Integrating with other web frameworks","18. View technologies","scr\\view.html","         19.&nbsp;Integrating with other web frameworksPrev&nbsp;Part&nbsp;V.&nbsp;The Web&nbsp;Next19.&nbsp;Integrating with other web frameworks    19.1&nbsp;Introduction        \n\r\n\rThis chapter details Spring\'s integration with third party web    frameworks such as JSF, Struts, WebWork, and Tapestry.        \n\r\n\rSpring Web Flow    \n\r\n\rSpring Web Flow (SWF) aims to be the best solution for the management  of web application page flow.  \n\r\n\rSWF integrates with existing frameworks like Spring MVC, Struts, and  JSF, in both servlet and portlet environments. If you have a business  process (or processes) that would benefit from a conversational model as  opposed to a purely request model, then SWF may be the solution.  \n\r\n\rSWF allows you to capture logical page flows as self-contained modules  that are reusable in different situations, and as such is ideal for building  web application modules that guide the user through controlled navigations  that drive business processes.  \n\r\n\rFor more information about SWF, consult the  Spring Web Flow website.      \n\r\n\rOne of the core value propositions of the Spring Framework is that    of enabling choice. In a general sense, Spring does    not force one to use or buy into any particular architecture, technology,    or methodology (although it certainly recommends some over others). This    freedom to pick and choose the architecture, technology, or methodology    that is most relevant to a developer and his or her development team is    arguably most evident in the web area, where Spring provides its own web    framework (Spring MVC), while at the same time    providing integration with a number of popular third party web frameworks.    This allows one to continue to leverage any and all of the skills one may    have acquired in a particular web framework such as Struts, while at the    same time being able to enjoy the benefits afforded by Spring in other    areas such as data access, declarative transaction management, and    flexible configuration and application assembly.    \n\r\n\rHaving dispensed with the woolly sales patter (c.f. the previous    paragraph), the remainder of this chapter will concentrate upon the meaty    details of integrating your favorite web framework with Spring. One thing    that is often commented upon by developers coming to Java from other    languages is the seeming super-abundance of web frameworks available in    Java. There are indeed a great number of web frameworks in the Java    space; in fact there are far too many to cover with any semblance of    detail in a single chapter. This chapter thus picks four of the more    popular web frameworks in Java, starting with the Spring configuration    that is common to all of the supported web frameworks, and then detailing    the specific integration options for each supported web framework.    Note        \n\r\n\rPlease note that this chapter does not attempt to explain        how to use any of the supported web frameworks. For example, if you want        to use Struts for the presentation layer of your web application, the        assumption is that you are already familiar with Struts. If you need        further details about any of the supported web frameworks themselves,        please do consult Section&nbsp;19.7, &#8220;Further Resources&#8221; at the end        of this chapter.                19.2&nbsp;Common configuration        \n\r\n\rBefore diving into the integration specifics of each supported web    framework, let us first take a look at the Spring configuration that is    not specific to any one web framework. (This section    is equally applicable to Spring\'s own web framework, Spring MVC.)    \n\r\n\rOne of the concepts (for want of a better word) espoused by    (Spring\'s) lightweight application model is that of a layered    architecture. Remember that in a \'classic\' layered architecture, the web    layer is but one of many layers; it serves as one of the entry points    into a server side application and it delegates to service objects    (facades) defined in a service layer to satisfy business specific (and    presentation-technology agnostic) use cases. In Spring, these service    objects, any other business-specific objects, data access objects, etc.    exist in a distinct \'business context\', which contains    no web or presentation layer objects (presentation    objects such as Spring MVC controllers are typically configured in a    distinct \'presentation context\'). This section details how one configures    a Spring container (a WebApplicationContext) that    contains all of the \'business beans\' in one\'s application.    \n\r\n\rOn to specifics: all that one need do is to declare a ContextLoaderListener    in the standard Java EE servlet web.xml file of one\'s web    application, and add a contextConfigLocation    &lt;context-param/&gt; section (in the same file) that defines which set    of Spring XML configuration files to load.    \n\r\n\rFind below the &lt;listener/&gt; configuration:    &lt;listener&gt;  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;    \n\r\n\rFind below the &lt;context-param/&gt; configuration:    &lt;context-param&gt;  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;&lt;/context-param&gt;    \n\r\n\rIf you don\'t specify the contextConfigLocation    context parameter, the ContextLoaderListener will    look for a file called /WEB-INF/applicationContext.xml    to load. Once the context files are loaded, Spring creates a WebApplicationContext    object based on the bean definitions and stores it in the    ServletContext of the web application.    \n\r\n\rAll Java web frameworks are built on top of the Servlet API, and so    one can use the following code snippet to get access to this \'business    context\' ApplicationContext created by the    ContextLoaderListener.    WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);    \n\r\n\rThe WebApplicationContextUtils    class is for convenience, so you don\'t have to remember the name of the    ServletContext attribute. Its    getWebApplicationContext() method will return    null if an object doesn\'t exist under the    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE    key. Rather than risk getting NullPointerExceptions    in your application, it\'s better to use the    getRequiredWebApplicationContext() method. This method    throws an exception when the ApplicationContext is    missing.    \n\r\n\rOnce you have a reference to the    WebApplicationContext, you can retrieve beans by    their name or type. Most developers retrieve beans by name and then cast them    to one of their implemented interfaces.    \n\r\n\rFortunately, most of the frameworks in this section have simpler    ways of looking up beans. Not only do they make it easy to get beans from    a Spring container, but they also allow you to use dependency injection on    their controllers. Each web framework section has more detail on its    specific integration strategies.    19.3&nbsp;JavaServer Faces 1.1 and 1.2        \n\r\n\rJavaServer Faces (JSF) is the JCP\'s standard component-based,    event-driven web user interface framework. As of Java EE 5, it is an    official part of the Java EE umbrella.    \n\r\n\rFor a popular JSF runtime as well as for popular JSF component    libraries, check out the Apache    MyFaces project. The MyFaces project also provides common JSF    extensions such as MyFaces Orchestra: a    Spring-based JSF extension that provides rich conversation scope    support.    Note      \n\r\n\rSpring Web Flow 2.0 provides rich JSF support through its newly      established Spring Faces module, both for JSF-centric usage (as      described in this section) and for Spring-centric usage (using JSF views      within a Spring MVC dispatcher). Check out the Spring Web Flow      website for details!        \n\r\n\rThe key element in Spring\'s JSF integration is the JSF 1.1    VariableResolver mechanism. On JSF 1.2, Spring    supports the ELResolver mechanism as a    next-generation version of JSF EL integration.    19.3.1&nbsp;DelegatingVariableResolver (JSF 1.1/1.2)            \n\r\n\rThe easiest way to integrate one\'s Spring middle-tier with one\'s      JSF web layer is to use the       DelegatingVariableResolver class. To      configure this variable resolver in one\'s application, one will need to      edit one\'s faces-context.xml file. After the      opening &lt;faces-config/&gt; element, add an      &lt;application/&gt; element and a      &lt;variable-resolver/&gt; element within it. The      value of the variable resolver should reference Spring\'s      DelegatingVariableResolver; for example:      &lt;faces-config&gt;  &lt;application&gt;    &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;    &lt;locale-config&gt;      &lt;default-locale&gt;en&lt;/default-locale&gt;      &lt;supported-locale&gt;en&lt;/supported-locale&gt;      &lt;supported-locale&gt;es&lt;/supported-locale&gt;    &lt;/locale-config&gt;    &lt;message-bundle&gt;messages&lt;/message-bundle&gt;  &lt;/application&gt;&lt;/faces-config&gt;      \n\r\n\rThe DelegatingVariableResolver will first      delegate value lookups to the default resolver of the underlying JSF      implementation and then to Spring\'s \'business context\'      WebApplicationContext. This allows one to easily      inject dependencies into one\'s JSF-managed beans.      \n\r\n\rManaged beans are defined in one\'s      faces-config.xml file. Find below an example where      #{userManager} is a bean that is retrieved from the      Spring \'business context\'.      &lt;managed-bean&gt;  &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;  &lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;  &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;  &lt;managed-property&gt;    &lt;property-name&gt;userManager&lt;/property-name&gt;    &lt;value&gt;#{userManager}&lt;/value&gt;  &lt;/managed-property&gt;&lt;/managed-bean&gt;        19.3.2&nbsp;SpringBeanVariableResolver (JSF 1.1/1.2)            \n\r\n\rSpringBeanVariableResolver is a variant of      DelegatingVariableResolver. It delegates to the      Spring\'s \'business context\' WebApplicationContext      first and then to the default resolver of the      underlying JSF implementation. This is useful in particular when using      request/session-scoped beans with special Spring resolution rules, e.g.      Spring FactoryBean      implementations.      \n\r\n\rConfiguration-wise, simply define      SpringBeanVariableResolver in your      faces-context.xml file:      &lt;faces-config&gt;  &lt;application&gt;    &lt;variable-resolver&gt;org.springframework.web.jsf.SpringBeanVariableResolver&lt;/variable-resolver&gt;    ...  &lt;/application&gt;&lt;/faces-config&gt;        19.3.3&nbsp;SpringBeanFacesELResolver (JSF 1.2+)            \n\r\n\rSpringBeanFacesELResolver is a JSF 1.2      compliant ELResolver implementation, integrating      with the standard Unified EL as used by JSF 1.2 and JSP 2.1. Like      SpringBeanVariableResolver, it delegates to the      Spring\'s \'business context\' WebApplicationContext      first, then to the default resolver of the      underlying JSF implementation.      \n\r\n\rConfiguration-wise, simply define      SpringBeanFacesELResolver in your JSF 1.2      faces-context.xml file:      &lt;faces-config&gt;  &lt;application&gt;    &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;/el-resolver&gt;    ...  &lt;/application&gt;&lt;/faces-config&gt;        19.3.4&nbsp;FacesContextUtils            \n\r\n\rA custom VariableResolver works      well when mapping one\'s properties to beans in      faces-config.xml, but at times one may need to grab      a bean explicitly. The       FacesContextUtils class makes this easy.      It is similar to WebApplicationContextUtils,      except that it takes a FacesContext parameter      rather than a ServletContext parameter.      ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());        19.4&nbsp;Apache Struts 1.x and 2.x        \n\r\n\rStruts used to be the    de facto web framework for Java applications, mainly    because it was one of the first to be released (June 2001). It has now been renamed to Struts 1    (as opposed to Struts 2). Many applications still use it.    Invented by Craig McClanahan, Struts is an open source project hosted by the Apache    Software Foundation. At the time, it greatly simplified the JSP/Servlet    programming paradigm and won over many developers who were using    proprietary frameworks. It simplified the programming model, it was open    source (and thus free as in beer), and it had a large community, which    allowed the project to grow and become popular among Java web    developers.    Note      \n\r\n\rThe following section discusses Struts 1 a.k.a. \"Struts      Classic\".      \n\r\n\rStruts 2 is effectively a different product - a successor of      WebWork 2.2 (as discussed in Section&nbsp;19.5, &#8220;WebWork 2.x&#8221;), carrying the      Struts brand now. Check out the Struts 2 Spring      Plugin for the built-in Spring integration shipped with Struts      2. In general, Struts 2 is closer to WebWork 2.2 than to Struts 1 in      terms of its Spring integration implications.        \n\r\n\rTo integrate your Struts 1.x application with Spring, you have two    options:    \n\r        \n\r\n\rConfigure Spring to manage your Actions as beans, using the        ContextLoaderPlugin, and set their dependencies        in a Spring context file.      \n\r        \n\r\n\rSubclass Spring\'s ActionSupport classes        and grab your Spring-managed beans explicitly using a        getWebApplicationContext() method.      \n\r    19.4.1&nbsp;ContextLoaderPlugin            \n\r\n\rThe ContextLoaderPlugin      is a Struts 1.1+ plug-in that loads a Spring context file for the Struts      ActionServlet. This context refers to the root      WebApplicationContext (loaded by the      ContextLoaderListener) as its parent. The default      name of the context file is the name of the mapped servlet, plus      -servlet.xml. If      ActionServlet is defined in web.xml as      &lt;servlet-name&gt;action&lt;/servlet-name&gt;, the      default is /WEB-INF/action-servlet.xml.      \n\r\n\rTo configure this plug-in, add the following XML to the plug-ins      section near the bottom of your struts-config.xml      file:      &lt;plug-in className=\"org.springframework.web.struts.ContextLoaderPlugIn\"/&gt;      \n\r\n\rThe location of the context configuration files can be customized      using the \'contextConfigLocation\' property.      &lt;plug-in className=\"org.springframework.web.struts.ContextLoaderPlugIn\"&gt;  &lt;set-property property=\"contextConfigLocation\"      value=\"/WEB-INF/action-servlet.xml,/WEB-INF/applicationContext.xml\"/&gt;&lt;/plug-in&gt;      \n\r\n\rIt is possible to use this plugin to load all your context files,      which can be useful when using testing tools like StrutsTestCase.      StrutsTestCase\'s MockStrutsTestCase won\'t      initialize Listeners on startup so putting all your context files in the      plugin is a workaround. (A       bug has been filed for this issue, but has been closed as \'Wont      Fix\').      \n\r\n\rAfter configuring this plug-in in      struts-config.xml, you can configure your      Action to be managed by Spring. Spring (1.1.3+)      provides two ways to do this:      \n\r          \n\r\n\rOverride Struts\' default          RequestProcessor with Spring\'s          DelegatingRequestProcessor.        \n\r          \n\r\n\rUse the DelegatingActionProxy class in          the type attribute of your          &lt;action-mapping&gt;.        \n\r      \n\r\n\rBoth of these methods allow you to manage your Actions and their      dependencies in the action-servlet.xml file. The      bridge between the Action in struts-config.xml and      action-servlet.xml is built with the      action-mapping\'s \"path\" and the bean\'s \"name\". If you have the following      in your struts-config.xml file:      &lt;action path=\"/users\" .../&gt;      \n\r\n\rYou must define that Action\'s bean with the \"/users\" name in      action-servlet.xml:      &lt;bean name=\"/users\" .../&gt;      DelegatingRequestProcessor                \n\r\n\rTo configure the         DelegatingRequestProcessor in your        struts-config.xml file, override the        \"processorClass\" property in the &lt;controller&gt; element. These        lines follow the &lt;action-mapping&gt; element.        &lt;controller&gt;  &lt;set-property property=\"processorClass\"      value=\"org.springframework.web.struts.DelegatingRequestProcessor\"/&gt;&lt;/controller&gt;        \n\r\n\rAfter adding this setting, your Action will automatically be        looked up in Spring\'s context file, no matter what the type. In fact,        you don\'t even need to specify a type. Both of the following snippets        will work:        &lt;action path=\"/user\" type=\"com.whatever.struts.UserAction\"/&gt;&lt;action path=\"/user\"/&gt;        \n\r\n\rIf you\'re using Struts\' modules feature,        your bean names must contain the module prefix. For example, an action        defined as &lt;action path=\"/user\"/&gt; with module        prefix \"admin\" requires a bean name with &lt;bean        name=\"/admin/user\"/&gt;.        Note          \n\r\n\rIf you are using Tiles in your Struts application, you must          configure your &lt;controller&gt; with the DelegatingTilesRequestProcessor          instead.                    DelegatingActionProxy                \n\r\n\rIf you have a custom RequestProcessor and        can\'t use the DelegatingRequestProcessor or        DelegatingTilesRequestProcessor approaches, you        can use the         DelegatingActionProxy as the type in        your action-mapping.        &lt;action path=\"/user\" type=\"org.springframework.web.struts.DelegatingActionProxy\"    name=\"userForm\" scope=\"request\" validate=\"false\" parameter=\"method\"&gt;  &lt;forward name=\"list\" path=\"/userList.jsp\"/&gt;  &lt;forward name=\"edit\" path=\"/userForm.jsp\"/&gt;&lt;/action&gt;        \n\r\n\rThe bean definition in action-servlet.xml        remains the same, whether you use a custom        RequestProcessor or the        DelegatingActionProxy.        \n\r\n\rIf you define your Action in a context        file, the full feature set of Spring\'s bean container will be        available for it: dependency injection as well as the option to        instantiate a new Action instance for each        request. To activate the latter, add        scope=\"prototype\" to your Action\'s bean        definition.        &lt;bean name=\"/user\" scope=\"prototype\" autowire=\"byName\"    class=\"org.example.web.UserAction\"/&gt;              19.4.2&nbsp;ActionSupport Classes            \n\r\n\rAs previously mentioned, you can retrieve the      WebApplicationContext from the      ServletContext using the      WebApplicationContextUtils class. An easier way      is to extend Spring\'s Action classes for Struts.      For example, instead of subclassing Struts\'      Action class, you can subclass Spring\'s       ActionSupport class.      \n\r\n\rThe ActionSupport class provides additional      convenience methods, like      getWebApplicationContext(). Below is an example of      how you might use this in an Action:      public class UserAction extends DispatchActionSupport {    public ActionForward execute(ActionMapping mapping,                                 ActionForm form,                                 HttpServletRequest request,                                 HttpServletResponse response) throws Exception {        if (log.isDebugEnabled()) {            log.debug(\"entering \'delete\' method...\");        }        WebApplicationContext ctx = getWebApplicationContext();        UserManager mgr = (UserManager) ctx.getBean(\"userManager\");        // talk to manager for business logic        return mapping.findForward(\"success\");    }}      \n\r\n\rSpring includes subclasses for all of the standard Struts Actions      - the Spring versions merely have Support appended      to the name: \n\r            \n\r\n\rActionSupport,          \n\r            \n\r\n\rDispatchActionSupport,          \n\r            \n\r\n\rLookupDispatchActionSupport            and          \n\r            \n\r\n\rMappingDispatchActionSupport.          \n\r      \n\r\n\rThe recommended strategy is to use the approach that best suits      your project. Subclassing makes your code more readable, and you know      exactly how your dependencies are resolved. In contrast, using the      ContextLoaderPlugin allows you to easily add new      dependencies in your context XML file. Either way, Spring provides some      nice options for integrating with Struts.        19.5&nbsp;WebWork 2.x        \n\r\n\rFrom the WebWork    homepage:    \n\r\n\r        &#8220;          WebWork is a Java web-application development framework. It is          built specifically with developer productivity and code simplicity in          mind, providing robust support for building reusable UI templates, such          as form controls, UI themes, internationalization, dynamic form          parameter mapping to JavaBeans, robust client and server side          validation, and much more.        &#8221;        \n\r\n\rWeb work\'s architecture and concepts are easy to    understand, and the framework also has an extensive tag library as well as    nicely decoupled validation.    \n\r\n\rOne of the key enablers in WebWork\'s technology stack is an    IoC container to manage Webwork Actions, handle the \"wiring\" of    business objects, etc. Prior to WebWork version 2.2, WebWork used its own    proprietary IoC container (and provided integration points so that one    could integrate an IoC container such as Spring\'s into the mix). However,    as of WebWork version 2.2, the default IoC container that is used within    WebWork is Spring. This is obviously great news if    one is a Spring developer, because it means that one is immediately    familiar with the basics of IoC configuration, idioms, and suchlike within    WebWork.    \n\r\n\rNow in the interests of adhering to the DRY (Don\'t Repeat Yourself)    principle, it would be foolish to document the Spring-WebWork integration    in light of the fact that the WebWork team have already written such a    writeup. Please consult the Spring-WebWork    integration page on the WebWork wiki    for the full lowdown.    \n\r\n\rNote that the Spring-WebWork integration code was developed (and    continues to be maintained and improved) by the WebWork developers    themselves. So please refer first to the WebWork site and forums if you are    having issues with the integration. But feel free to    post comments and queries regarding the Spring-WebWork integration on the    Spring    support forums, too.    19.6&nbsp;Tapestry 3.x and 4.x        \n\r\n\rFrom the Tapestry    homepage:    \n\r\n\r        &#8220;          Tapestry is an open-source framework for creating dynamic,          robust, highly scalable web applications in Java. Tapestry complements          and builds upon the standard Java Servlet API, and so it works in any          servlet container or application server.        &#8221;        \n\r\n\rWhile Spring has its own powerful web    layer, there are a number of unique advantages to building an    enterprise Java application using a combination of Tapestry for the web    user interface and the Spring container for the lower layers. This section    of the web integration chapter attempts to detail a few best practices for    combining these two frameworks.    \n\r\n\rA typical layered enterprise Java application    built with Tapestry and Spring will consist of a top user interface (UI)    layer built with Tapestry, and a number of lower layers, all wired together    by one or more Spring containers. Tapestry\'s own reference documentation    contains the following snippet of best practice advice. (Text that the    author of this Spring section has added is contained within    [] brackets.)    \n\r\n\r        &#8220;          A very successful design pattern in Tapestry is to keep pages          and components very simple, and delegate as much logic as possible out to          HiveMind [or Spring, or whatever] services. Listener methods should          ideally do little more than marshal together the correct information          and pass it over to a service.        &#8221;        \n\r\n\rThe key question then is: how does one supply Tapestry pages with    collaborating services? The answer, ideally, is that one would want to    dependency inject those services directly into one\'s Tapestry pages. In    Tapestry, one can effect this dependency injection by a variety of    means. This section is only going to enumerate the dependency injection    means afforded by Spring. The real beauty of the rest of this    Spring-Tapestry integration is that the elegant and flexible design of    Tapestry itself makes doing this dependency injection of Spring-managed    beans a cinch. (Another nice thing is that this Spring-Tapestry    integration code was written - and continues to be maintained - by the    Tapestry creator Howard M.    Lewis Ship, so hats off to him for what is really some silky    smooth integration).    19.6.1&nbsp;Injecting Spring-managed beans            \n\r\n\rAssume we have the following simple Spring container definition      (in the ubiquitous XML format):      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jee=\"http://www.springframework.org/schema/jee\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\"&gt;&lt;beans&gt;    &lt;!-- the DataSource --&gt;    &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:DefaultDS\"/&gt;    &lt;bean id=\"hibSessionFactory\"          class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\"          class=\"org.springframework.transaction.jta.JtaTransactionManager\"/&gt;    &lt;bean id=\"mapper\"          class=\"com.whatever.dataaccess.mapper.hibernate.MapperImpl\"&gt;        &lt;property name=\"sessionFactory\" ref=\"hibSessionFactory\"/&gt;    &lt;/bean&gt;    &lt;!-- (transactional) AuthenticationService --&gt;    &lt;bean id=\"authenticationService\"          class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt;        &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;        &lt;property name=\"target\"&gt;            &lt;bean class=\"com.whatever.services.service.user.AuthenticationServiceImpl\"&gt;                &lt;property name=\"mapper\" ref=\"mapper\"/&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;property name=\"proxyInterfacesOnly\" value=\"true\"/&gt;        &lt;property name=\"transactionAttributes\"&gt;            &lt;value&gt;                *=PROPAGATION_REQUIRED            &lt;/value&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- (transactional) UserService --&gt;    &lt;bean id=\"userService\"          class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt;        &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;        &lt;property name=\"target\"&gt;             &lt;bean class=\"com.whatever.services.service.user.UserServiceImpl\"&gt;                 &lt;property name=\"mapper\" ref=\"mapper\"/&gt;             &lt;/bean&gt;        &lt;/property&gt;        &lt;property name=\"proxyInterfacesOnly\" value=\"true\"/&gt;        &lt;property name=\"transactionAttributes\"&gt;            &lt;value&gt;                *=PROPAGATION_REQUIRED            &lt;/value&gt;        &lt;/property&gt;    &lt;/bean&gt; &lt;/beans&gt;      \n\r\n\rInside the Tapestry application, the above bean definitions need      to be loaded into a Spring      container, and any relevant Tapestry pages need to be supplied      (injected) with the authenticationService and      userService beans, which implement the      AuthenticationService and      UserService interfaces,      respectively.      \n\r\n\rAt this point, the application context is available to a web      application by calling Spring\'s static utility function      WebApplicationContextUtils.getApplicationContext(servletContext),      where servletContext is the standard      ServletContext from the Java EE Servlet      specification. As such, one simple mechanism for a page to get an      instance of the UserService, for example,      would be with code such as:      WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(    getRequestCycle().getRequestContext().getServlet().getServletContext());UserService userService = (UserService) appContext.getBean(\"userService\");// ... some code which uses UserService      \n\r\n\rThis mechanism does work. Having said that, it can be made a lot      less verbose by encapsulating most of the functionality in a method in      the base class for the page or component. However, in some respects it      goes against the IoC principle; ideally you would like the page to not      have to ask the context for a specific bean by name, and in fact, the      page would ideally not know about the context at all.      \n\r\n\rLuckily, there is a mechanism to allow this. We rely upon the fact      that Tapestry already has a mechanism to declaratively add properties to      a page, and it is in fact the preferred approach to manage all      properties on a page in this declarative fashion, so that Tapestry can      properly manage their lifecycle as part of the page and component      lifecycle.      Note        \n\r\n\rThis next section is applicable to Tapestry 3.x. If you are        using Tapestry version 4.x, please consult the section entitled the section called &#8220;Dependency Injecting Spring Beans into Tapestry pages -        Tapestry 4.x style&#8221;.            Dependency Injecting Spring Beans into Tapestry pages                \n\r\n\rFirst we need to make the        ApplicationContext available to the Tapestry        page or Component without having to have the        ServletContext; this is because at the stage in        the page\'s/component\'s lifecycle when we need to access the        ApplicationContext, the        ServletContext won\'t be easily available to the        page, so we can\'t use        WebApplicationContextUtils.getApplicationContext(servletContext)        directly. One way is by defining a custom version of the Tapestry        IEngine which exposes this for        us:        package com.whatever.web.xportal;// import ...public class MyEngine extends org.apache.tapestry.engine.BaseEngine {    public static final String APPLICATION_CONTEXT_KEY = \"appContext\";    /**     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)     */    protected void setupForRequest(RequestContext context) {        super.setupForRequest(context);        // insert ApplicationContext in global, if not there        Map global = (Map) getGlobal();        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);        if (ac == null) {            ac = WebApplicationContextUtils.getWebApplicationContext(                context.getServlet().getServletContext()            );            global.put(APPLICATION_CONTEXT_KEY, ac);        }    }}        \n\r\n\rThis engine class places the Spring Application Context as an        attribute called \"appContext\" in this Tapestry app\'s \'Global\' object.        Make sure to register the fact that this special IEngine instance        should be used for this Tapestry application, with an entry in the        Tapestry application definition file. For example:        file: xportal.application:&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE application PUBLIC    \"-//Apache Software Foundation//Tapestry Specification 3.0//EN\"    \"http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd\"&gt;&lt;application    name=\"Whatever xPortal\"    engine-class=\"com.whatever.web.xportal.MyEngine\"&gt;&lt;/application&gt;            Component definition files                \n\r\n\rNow in our page or component definition file (*.page or *.jwc),        we simply add property-specification elements to grab the beans we        need out of the ApplicationContext, and        create page or component properties for them. For example:            &lt;property-specification name=\"userService\"                            type=\"com.whatever.services.service.user.UserService\"&gt;        global.appContext.getBean(\"userService\")    &lt;/property-specification&gt;    &lt;property-specification name=\"authenticationService\"                            type=\"com.whatever.services.service.user.AuthenticationService\"&gt;        global.appContext.getBean(\"authenticationService\")    &lt;/property-specification&gt;        \n\r\n\rThe OGNL expression inside the property-specification specifies        the initial value for the property, as a bean obtained from the        context. The entire page definition might look like this:        &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE page-specification PUBLIC    \"-//Apache Software Foundation//Tapestry Specification 3.0//EN\"    \"http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd\"&gt;&lt;page-specification class=\"com.whatever.web.xportal.pages.Login\"&gt;    &lt;property-specification name=\"username\" type=\"java.lang.String\"/&gt;    &lt;property-specification name=\"password\" type=\"java.lang.String\"/&gt;    &lt;property-specification name=\"error\" type=\"java.lang.String\"/&gt;    &lt;property-specification name=\"callback\" type=\"org.apache.tapestry.callback.ICallback\" persistent=\"yes\"/&gt;    &lt;property-specification name=\"userService\"                            type=\"com.whatever.services.service.user.UserService\"&gt;        global.appContext.getBean(\"userService\")    &lt;/property-specification&gt;    &lt;property-specification name=\"authenticationService\"                            type=\"com.whatever.services.service.user.AuthenticationService\"&gt;        global.appContext.getBean(\"authenticationService\")    &lt;/property-specification&gt;    &lt;bean name=\"delegate\" class=\"com.whatever.web.xportal.PortalValidationDelegate\"/&gt;    &lt;bean name=\"validator\" class=\"org.apache.tapestry.valid.StringValidator\" lifecycle=\"page\"&gt;        &lt;set-property name=\"required\" expression=\"true\"/&gt;        &lt;set-property name=\"clientScriptingEnabled\" expression=\"true\"/&gt;    &lt;/bean&gt;    &lt;component id=\"inputUsername\" type=\"ValidField\"&gt;        &lt;static-binding name=\"displayName\" value=\"Username\"/&gt;        &lt;binding name=\"value\" expression=\"username\"/&gt;        &lt;binding name=\"validator\" expression=\"beans.validator\"/&gt;    &lt;/component&gt;    &lt;component id=\"inputPassword\" type=\"ValidField\"&gt;        &lt;binding name=\"value\" expression=\"password\"/&gt;       &lt;binding name=\"validator\" expression=\"beans.validator\"/&gt;       &lt;static-binding name=\"displayName\" value=\"Password\"/&gt;       &lt;binding name=\"hidden\" expression=\"true\"/&gt;    &lt;/component&gt;&lt;/page-specification&gt;            Adding abstract accessors                \n\r\n\rNow in the Java class definition for the page or component        itself, all we need to do is add an abstract getter method for the        properties we have defined (in order to be able to access the        properties).        // our UserService implementation; will come from page definitionpublic abstract UserService getUserService();// our AuthenticationService implementation; will come from page definitionpublic abstract AuthenticationService getAuthenticationService();        \n\r\n\rFor the sake of completeness, the entire Java class, for a login        page in this example, might look like this:        package com.whatever.web.xportal.pages;/** *  Allows the user to login, by providing username and password. *  After successfully logging in, a cookie is placed on the client browser *  that provides the default username for future logins (the cookie *  persists for a week). */public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {    /** the key under which the authenticated user object is stored in the visit as */    public static final String USER_KEY = \"user\";    /** The name of the cookie that identifies a user **/    private static final String COOKIE_NAME = Login.class.getName() + \".username\";    private final static int ONE_WEEK = 7 * 24 * 60 * 60;    public abstract String getUsername();    public abstract void setUsername(String username);    public abstract String getPassword();    public abstract void setPassword(String password);    public abstract ICallback getCallback();    public abstract void setCallback(ICallback value);    public abstract UserService getUserService();    public abstract AuthenticationService getAuthenticationService();    protected IValidationDelegate getValidationDelegate() {        return (IValidationDelegate) getBeans().getBean(\"delegate\");    }    protected void setErrorField(String componentId, String message) {        IFormComponent field = (IFormComponent) getComponent(componentId);        IValidationDelegate delegate = getValidationDelegate();        delegate.setFormComponent(field);        delegate.record(new ValidatorException(message));    }    /**     *  Attempts to login.     * &lt;p&gt;     *  If the user name is not known, or the password is invalid, then an error     *  message is displayed.     **/    public void attemptLogin(IRequestCycle cycle) {        String password = getPassword();        // Do a little extra work to clear out the password.        setPassword(null);        IValidationDelegate delegate = getValidationDelegate();        delegate.setFormComponent((IFormComponent) getComponent(\"inputPassword\"));        delegate.recordFieldInputValue(null);        // An error, from a validation field, may already have occurred.        if (delegate.getHasErrors()) {            return;        }        try {            User user = getAuthenticationService().login(getUsername(), getPassword());           loginUser(user, cycle);        }        catch (FailedLoginException ex) {            this.setError(\"Login failed: \" + ex.getMessage());            return;        }    }    /**     *  Sets up the {@link User} as the logged in user, creates     *  a cookie for their username (for subsequent logins),     *  and redirects to the appropriate page, or     *  a specified page).     **/    public void loginUser(User user, IRequestCycle cycle) {        String username = user.getUsername();        // Get the visit object; this will likely force the        // creation of the visit object and an HttpSession        Map visit = (Map) getVisit();        visit.put(USER_KEY, user);        // After logging in, go to the MyLibrary page, unless otherwise specified        ICallback callback = getCallback();        if (callback == null) {            cycle.activate(\"Home\");        }        else {            callback.performCallback(cycle);        }        IEngine engine = getEngine();        Cookie cookie = new Cookie(COOKIE_NAME, username);        cookie.setPath(engine.getServletPath());        cookie.setMaxAge(ONE_WEEK);        // Record the user\'s username in a cookie        cycle.getRequestContext().addCookie(cookie);        engine.forgetPage(getPageName());    }    public void pageBeginRender(PageEvent event) {        if (getUsername() == null) {            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));        }    }}            Dependency Injecting Spring Beans into Tapestry pages -        Tapestry 4.x style                \n\r\n\rEffecting the dependency injection of Spring-managed beans into        Tapestry pages in Tapestry version 4.x is so much        simpler. All that is needed is a single add-on        library, and some (small) amount of (essentially boilerplate)        configuration. Simply package and deploy this library with the (any of        the) other libraries required by your web application (typically in        WEB-INF/lib).        \n\r\n\rYou will then need to create and expose the Spring container        using the method detailed        previously. You can then inject Spring-managed beans into        Tapestry very easily; if we are using Java 5, consider the        Login page from above: we simply need to        annotate the appropriate getter methods in order to dependency inject        the Spring-managed userService and        authenticationService objects (lots of the class        definition has been elided for clarity).        package com.whatever.web.xportal.pages;public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {    @InjectObject(\"spring:userService\")    public abstract UserService getUserService();    @InjectObject(\"spring:authenticationService\")    public abstract AuthenticationService getAuthenticationService();}        \n\r\n\rWe are almost done. All that remains is the HiveMind        configuration that exposes the Spring container stored in the        ServletContext as a HiveMind service;        for example:        &lt;?xml version=\"1.0\"?&gt;&lt;module id=\"com.javaforge.tapestry.spring\" version=\"0.1.1\"&gt;    &lt;service-point id=\"SpringApplicationInitializer\"        interface=\"org.apache.tapestry.services.ApplicationInitializer\"        visibility=\"private\"&gt;        &lt;invoke-factory&gt;            &lt;construct class=\"com.javaforge.tapestry.spring.SpringApplicationInitializer\"&gt;                &lt;set-object property=\"beanFactoryHolder\"                    value=\"service:hivemind.lib.DefaultSpringBeanFactoryHolder\" /&gt;            &lt;/construct&gt;        &lt;/invoke-factory&gt;    &lt;/service-point&gt;    &lt;!-- Hook the Spring setup into the overall application initialization. --&gt;    &lt;contribution        configuration-id=\"tapestry.init.ApplicationInitializers\"&gt;        &lt;command id=\"spring-context\"            object=\"service:SpringApplicationInitializer\" /&gt;    &lt;/contribution&gt;&lt;/module&gt;        \n\r\n\rIf you are using Java 5 (and thus have access to annotations),        then that really is it.        \n\r\n\rIf you are not using Java 5, then one obviously doesn\'t annotate        one\'s Tapestry page classes with annotations; instead, one simply uses        good old fashioned XML to declare the dependency injection; for        example, inside the .page or        .jwc file for the Login page        (or component):        &lt;inject property=\"userService\" object=\"spring:userService\"/&gt;&lt;inject property=\"authenticationService\" object=\"spring:authenticationService\"/&gt;        \n\r\n\rIn this example, we\'ve managed to allow service beans defined in a        Spring container to be provided to the Tapestry page in a declarative        fashion. The page class does not know where the service implementations        are coming from, and in fact it is easy to slip in another implementation,        for example, during testing. This inversion of control is one of the prime        goals and benefits of the Spring Framework, and we have managed to extend        it throughout the stack in this Tapestry application.              19.7&nbsp;Further Resources        \n\r\n\rFind below links to further resources about the various web    frameworks described in this chapter.    \n\r        \n\r\n\rThe JSF        homepage      \n\r        \n\r\n\rThe Struts        homepage      \n\r        \n\r\n\rThe WebWork        homepage      \n\r        \n\r\n\rThe Tapestry        homepage      \n\r  Prev&nbsp;Up&nbsp;Next18.&nbsp;View technologies&nbsp;Home&nbsp;20.&nbsp;Portlet MVC Framework","19. Integrating with other web frameworks","scr\\web-integration.html","         Appendix&nbsp;E.&nbsp;XML Schema-based configurationPrev&nbsp;Part&nbsp;VII.&nbsp;Appendices&nbsp;NextAppendix&nbsp;E.&nbsp;XML Schema-based configuration        E.1&nbsp;Introduction                \n\r\n\rThis appendix details the XML Schema-based configuration introduced in Spring 2.0 and enhanced and extended in Spring 2.5 and 3.0.        \n\r\n\rDTD support?                        \n\r\n\rAuthoring Spring configuration files using the older DTD style            is still fully supported.            \n\r\n\rNothing will break if you forego the use of the new XML Schema-based            approach to authoring Spring XML configuration files. All that you lose            out on is the opportunity to have more succinct and clearer configuration.            Regardless of whether the XML configuration is DTD- or Schema-based, in the end            it all boils down to the same object model in the container (namely one or            more BeanDefinition instances).                \n\r\n\rThe central motivation for moving to XML Schema based configuration files was        to make Spring XML configuration easier. The \'classic\'        &lt;bean/&gt;-based approach is good, but its generic-nature comes        with a price in terms of configuration overhead.        \n\r\n\rFrom the Spring IoC containers point-of-view, everything        is a bean. That\'s great news for the Spring IoC container, because if everything is        a bean then everything can be treated in the exact same fashion. The same, however,        is not true from a developer\'s point-of-view. The objects defined in a Spring        XML configuration file are not all generic, vanilla beans. Usually, each bean requires        some degree of specific configuration.        \n\r\n\rSpring 2.0\'s new XML Schema-based configuration addresses this issue.        The &lt;bean/&gt; element is still present, and if you        wanted to, you could continue to write the exact same        style of Spring XML configuration using only &lt;bean/&gt;        elements. The new XML Schema-based configuration does, however, make        Spring XML configuration files substantially clearer to read. In addition, it allows        you to express the intent of a bean definition.        \n\r\n\rThe key thing to remember is that the new custom tags work best for infrastructure        or integration beans: for example, AOP, collections, transactions, integration with        3rd-party frameworks such as Mule, etc., while the existing bean tags are best suited to        application-specific beans, such as DAOs, service layer objects, validators, etc.        \n\r\n\rThe examples included below will hopefully convince you that the inclusion        of XML Schema support in Spring 2.0 was a good idea. The reception in the community        has been encouraging; also, please note the fact that this new configuration mechanism        is totally customisable and extensible. This means you can write your own domain-specific        configuration tags that would better represent your application\'s domain; the process        involved in doing so is covered in the appendix entitled Appendix&nbsp;F, Extensible XML authoring.        E.2&nbsp;XML Schema-based configuration                E.2.1&nbsp;Referencing the schemas                        \n\r\n\rTo switch over from the DTD-style to the new XML Schema-style, you need            to make the following change.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\"    \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;&lt;beans&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            \n\r\n\rThe equivalent file in the XML Schema-style would be...            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            Note                \n\r\n\rThe \'xsi:schemaLocation\' fragment is not actually required,                but can be included to reference a local copy of a schema (which can be useful                during development).                        \n\r\n\rThe above Spring XML configuration fragment is boilerplate that you can copy and paste            (!) and then plug &lt;bean/&gt; definitions into like you have always            done. However, the entire point of switching over is to            take advantage of the new Spring 2.0 XML tags since they make configuration easier. The            section entitled Section&nbsp;E.2.2, &#8220;The util schema&#8221; demonstrates how you can            start immediately by using some of the more common utility tags.            \n\r\n\rThe rest of this chapter is devoted to showing examples of the new Spring XML Schema            based configuration, with at least one example for every new tag. The format follows            a before and after style, with a before snippet of XML showing            the old (but still 100% legal and supported) style, followed immediately            by an after example showing the equivalent in the new XML Schema-based            style.                E.2.2&nbsp;The util schema                        \n\r\n\rFirst up is coverage of the util tags. As the name            implies, the util tags deal with common, utility            configuration issues, such as configuring collections, referencing constants,            and suchlike.            \n\r\n\rTo use the tags in the util schema, you need to have            the following preamble at the top of your Spring XML configuration file;            the text in the snippet below references the correct schema so that            the tags in the util namespace are available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:util=\"http://www.springframework.org/schema/util\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            &lt;util:constant/&gt;                                \n\r\n\rBefore...                &lt;bean id=\"...\" class=\"...\"&gt;  &lt;property name=\"isolation\"&gt;    &lt;bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"    class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" /&gt;  &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the FieldRetrievingFactoryBean, to                set the value of the \'isolation\' property on a bean                to the value of the \'java.sql.Connection.TRANSACTION_SERIALIZABLE\'                constant. This is all well and good, but it is a tad verbose and (unnecessarily)                exposes Spring\'s internal plumbing to the end user.                                \n\r\n\rThe following XML Schema-based version is more concise                and clearly expresses the developer\'s intent (\'inject this constant                value\'), and it just reads better.                                &lt;bean id=\"...\" class=\"...\"&gt;  &lt;property name=\"isolation\"&gt;    &lt;util:constant static-field=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/&gt;  &lt;/property&gt;&lt;/bean&gt;                Setting a bean property or constructor arg from a field value                                        \n\r\n\r                        FieldRetrievingFactoryBean                        is a FactoryBean which retrieves a                        static or non-static field value. It is typically                        used for retrieving public static                        final constants, which may then be used to set a                        property value or constructor arg for another bean.                                        \n\r\n\r                        Find below an example which shows how a static field is exposed, by                        using the staticField                        property:                                        &lt;bean id=\"myField\"        class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\"&gt;  &lt;property name=\"staticField\" value=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/&gt;&lt;/bean&gt;                    \n\r\n\rThere is also a convenience usage form where the static                    field is specified as the bean name:                    &lt;bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"    class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\"/&gt;                    \n\r\n\r                        This does mean that there is no longer any choice in what the bean id is (so                        any other bean that refers to it will also have to use this longer name),                        but this form is very concise to define, and very convenient to use as an                        inner bean since the id doesn\'t have to be specified for the bean                        reference:                                        &lt;bean id=\"...\" class=\"...\"&gt;  &lt;property name=\"isolation\"&gt;    &lt;bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"          class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" /&gt;  &lt;/property&gt;&lt;/bean&gt;                    \n\r\n\r                        It is also possible to access a non-static (instance) field of another bean,                        as described in the API documentation for the                        FieldRetrievingFactoryBean                        class.                                        \n\r\n\r                        Injecting enum values into beans as either property or constructor arguments is very                        easy to do in Spring, in that you don\'t actually have to do                        anything or know anything about the Spring internals (or even about classes such                        as the FieldRetrievingFactoryBean). Let\'s look at an example                        to see how easy injecting an enum value is; consider this JDK 5 enum:                                        package javax.persistence;public enum PersistenceContextType {    TRANSACTION,    EXTENDED}                    \n\r\n\rNow consider a setter of type PersistenceContextType:                    package example;public class Client {    private PersistenceContextType persistenceContextType;    public void setPersistenceContextType(PersistenceContextType type) {        this.persistenceContextType = type;    }}                    \n\r\n\r.. and the corresponding bean definition:                    &lt;bean class=\"example.Client\"&gt;    &lt;property name=\"persistenceContextType\" value=\"TRANSACTION\" /&gt;&lt;/bean&gt;                    \n\r\n\r                        This works for classic type-safe emulated enums (on JDK 1.4 and JDK 1.3) as well;                        Spring will automatically attempt to match the string property value to a constant                        on the enum class.                                                            &lt;util:property-path/&gt;                                \n\r\n\rBefore...                &lt;!-- target bean to be referenced by name --&gt;&lt;bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\"&gt;  &lt;property name=\"age\" value=\"10\"/&gt;  &lt;property name=\"spouse\"&gt;    &lt;bean class=\"org.springframework.beans.TestBean\"&gt;      &lt;property name=\"age\" value=\"11\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;!-- will result in 10, which is the value of property \'age\' of bean \'testBean\' --&gt;&lt;bean id=\"testBean.age\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the PropertyPathFactoryBean, to                create a bean (of type int) called                \'testBean.age\' that has a value equal to the \'age\'                property of the \'testBean\' bean.                                \n\r\n\rAfter...                &lt;!-- target bean to be referenced by name --&gt;&lt;bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\"&gt;  &lt;property name=\"age\" value=\"10\"/&gt;  &lt;property name=\"spouse\"&gt;    &lt;bean class=\"org.springframework.beans.TestBean\"&gt;      &lt;property name=\"age\" value=\"11\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;&lt;!-- will result in 10, which is the value of property \'age\' of bean \'testBean\' --&gt;&lt;util:property-path id=\"name\" path=\"testBean.age\"/&gt;                \n\r\n\rThe value of the \'path\' attribute of the                &lt;property-path/&gt; tag follows the form \'beanName.beanProperty\'.                Using &lt;util:property-path/&gt; to set a bean property or constructor-argument                                        \n\r\n\rPropertyPathFactoryBean is a                    FactoryBean that evaluates a property path on a given                    target object. The target object can be specified directly or via a bean                    name. This value may then be used in another bean definition as a property                    value or constructor argument.                    \n\r\n\rHere\'s an example where a path is used against another bean, by name:                    // target bean to be referenced by name&lt;bean id=\"person\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\"&gt;  &lt;property name=\"age\" value=\"10\"/&gt;  &lt;property name=\"spouse\"&gt;    &lt;bean class=\"org.springframework.beans.TestBean\"&gt;      &lt;property name=\"age\" value=\"11\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;// will result in 11, which is the value of property \'spouse.age\' of bean \'person\'&lt;bean id=\"theAge\"    class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"&gt;  &lt;property name=\"targetBeanName\" value=\"person\"/&gt;  &lt;property name=\"propertyPath\" value=\"spouse.age\"/&gt;&lt;/bean&gt;                    \n\r\n\rIn this example, a path is evaluated against an inner bean:                    &lt;!-- will result in 12, which is the value of property \'age\' of the inner bean --&gt;&lt;bean id=\"theAge\"    class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"&gt;  &lt;property name=\"targetObject\"&gt;    &lt;bean class=\"org.springframework.beans.TestBean\"&gt;      &lt;property name=\"age\" value=\"12\"/&gt;    &lt;/bean&gt;  &lt;/property&gt;  &lt;property name=\"propertyPath\" value=\"age\"/&gt;&lt;/bean&gt;                    \n\r\n\rThere is also a shortcut form, where the bean name is the property path.                    &lt;!-- will result in 10, which is the value of property \'age\' of bean \'person\' --&gt;&lt;bean id=\"person.age\"    class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/&gt;                \n\r\n\rThis form does mean that there is no choice in the name of the bean.                    Any reference to it will also have to use the same id, which is the path.                    Of course, if used as an inner bean, there is no need to refer to it at                    all:                    &lt;bean id=\"...\" class=\"...\"&gt;  &lt;property name=\"age\"&gt;    &lt;bean id=\"person.age\"        class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/&gt;  &lt;/property&gt;&lt;/bean&gt;                    \n\r\n\rThe result type may be specifically set in the actual definition.                    This is not necessary for most use cases, but can be of use for some.                    Please see the Javadocs for more info on this feature.                                        &lt;util:properties/&gt;                                \n\r\n\rBefore...                &lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;&lt;bean id=\"jdbcConfiguration\" class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\"&gt;  &lt;property name=\"location\" value=\"classpath:com/foo/jdbc-production.properties\"/&gt;&lt;/bean&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the PropertiesFactoryBean, to                instantiate a java.util.Properties instance with values loaded from                the supplied Resource location).                                \n\r\n\rAfter...                &lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;&lt;util:properties id=\"jdbcConfiguration\" location=\"classpath:com/foo/jdbc-production.properties\"/&gt;                        &lt;util:list/&gt;                                \n\r\n\rBefore...                &lt;!-- creates a java.util.List instance with values loaded from the supplied \'sourceList\' --&gt;&lt;bean id=\"emails\" class=\"org.springframework.beans.factory.config.ListFactoryBean\"&gt;  &lt;property name=\"sourceList\"&gt;      &lt;list&gt;        &lt;value&gt;pechorin@hero.org&lt;/value&gt;        &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;        &lt;value&gt;stavrogin@gov.org&lt;/value&gt;        &lt;value&gt;porfiry@gov.org&lt;/value&gt;      &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the ListFactoryBean, to                create a java.util.List instance initialized                with values taken from the supplied \'sourceList\'.                                \n\r\n\rAfter...                &lt;!-- creates a java.util.List instance with the supplied values --&gt;&lt;util:list id=\"emails\"&gt;    &lt;value&gt;pechorin@hero.org&lt;/value&gt;    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;    &lt;value&gt;porfiry@gov.org&lt;/value&gt;&lt;/util:list&gt;                \n\r\n\rYou can also explicitly control the exact type of List                that will be instantiated and populated via the use of the \'list-class\'                attribute on the &lt;util:list/&gt; element. For example, if we                really need a java.util.LinkedList to be instantiated, we could                use the following configuration:                &lt;util:list id=\"emails\" list-class=\"java.util.LinkedList\"&gt;    &lt;value&gt;jackshaftoe@vagabond.org&lt;/value&gt;    &lt;value&gt;eliza@thinkingmanscrumpet.org&lt;/value&gt;    &lt;value&gt;vanhoek@pirate.org&lt;/value&gt;    &lt;value&gt;d\'Arcachon@nemesis.org&lt;/value&gt;&lt;/util:list&gt;                \n\r\n\rIf no \'list-class\' attribute is supplied, a                List implementation will be chosen by the container.                                        &lt;util:map/&gt;                                \n\r\n\rBefore...                &lt;!-- creates a java.util.Map instance with values loaded from the supplied \'sourceMap\' --&gt;&lt;bean id=\"emails\" class=\"org.springframework.beans.factory.config.MapFactoryBean\"&gt;  &lt;property name=\"sourceMap\"&gt;      &lt;map&gt;        &lt;entry key=\"pechorin\" value=\"pechorin@hero.org\"/&gt;        &lt;entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/&gt;        &lt;entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/&gt;        &lt;entry key=\"porfiry\" value=\"porfiry@gov.org\"/&gt;      &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the MapFactoryBean, to                create a java.util.Map instance initialized                with key-value pairs taken from the supplied \'sourceMap\'.                                \n\r\n\rAfter...                &lt;!-- creates a java.util.Map instance with the supplied key-value pairs --&gt;&lt;util:map id=\"emails\"&gt;    &lt;entry key=\"pechorin\" value=\"pechorin@hero.org\"/&gt;    &lt;entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/&gt;    &lt;entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/&gt;    &lt;entry key=\"porfiry\" value=\"porfiry@gov.org\"/&gt;&lt;/util:map&gt;                \n\r\n\rYou can also explicitly control the exact type of Map                that will be instantiated and populated via the use of the \'map-class\'                attribute on the &lt;util:map/&gt; element. For example, if we                really need a java.util.TreeMap to be instantiated, we could                use the following configuration:                &lt;util:map id=\"emails\" map-class=\"java.util.TreeMap\"&gt;    &lt;entry key=\"pechorin\" value=\"pechorin@hero.org\"/&gt;    &lt;entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/&gt;    &lt;entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/&gt;    &lt;entry key=\"porfiry\" value=\"porfiry@gov.org\"/&gt;&lt;/util:map&gt;                \n\r\n\rIf no \'map-class\' attribute is supplied, a                Map implementation will be chosen by the container.                                        &lt;util:set/&gt;                                \n\r\n\rBefore...                &lt;!-- creates a java.util.Set instance with values loaded from the supplied \'sourceSet\' --&gt;&lt;bean id=\"emails\" class=\"org.springframework.beans.factory.config.SetFactoryBean\"&gt;  &lt;property name=\"sourceSet\"&gt;      &lt;set&gt;        &lt;value&gt;pechorin@hero.org&lt;/value&gt;        &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;        &lt;value&gt;stavrogin@gov.org&lt;/value&gt;        &lt;value&gt;porfiry@gov.org&lt;/value&gt;      &lt;/set&gt;  &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rThe above configuration uses a Spring FactoryBean                implementation, the SetFactoryBean, to                create a java.util.Set instance initialized                with values taken from the supplied \'sourceSet\'.                                \n\r\n\rAfter...                &lt;!-- creates a java.util.Set instance with the supplied values --&gt;&lt;util:set id=\"emails\"&gt;    &lt;value&gt;pechorin@hero.org&lt;/value&gt;    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;    &lt;value&gt;porfiry@gov.org&lt;/value&gt;&lt;/util:set&gt;                \n\r\n\rYou can also explicitly control the exact type of Set                that will be instantiated and populated via the use of the \'set-class\'                attribute on the &lt;util:set/&gt; element. For example, if we                really need a java.util.TreeSet to be instantiated, we could                use the following configuration:                &lt;util:set id=\"emails\" set-class=\"java.util.TreeSet\"&gt;    &lt;value&gt;pechorin@hero.org&lt;/value&gt;    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;    &lt;value&gt;porfiry@gov.org&lt;/value&gt;&lt;/util:set&gt;                \n\r\n\rIf no \'set-class\' attribute is supplied, a                Set implementation will be chosen by the container.                                            E.2.3&nbsp;The jee schema                        \n\r\n\rThe jee tags deal with Java EE (Java Enterprise Edition)-related            configuration issues, such as looking up a JNDI object and defining EJB references.            \n\r\n\rTo use the tags in the jee schema, you need to have            the following preamble at the top of your Spring XML configuration file;            the text in the following snippet references the correct schema so that            the tags in the jee namespace are available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jee=\"http://www.springframework.org/schema/jee\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            &lt;jee:jndi-lookup/&gt; (simple)                                \n\r\n\rBefore...                &lt;bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;    &lt;property name=\"jndiName\" value=\"jdbc/MyDataSource\"/&gt;&lt;/bean&gt;&lt;bean id=\"userDao\" class=\"com.foo.JdbcUserDao\"&gt;    &lt;!-- Spring will do the cast automatically (as usual) --&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/MyDataSource\"/&gt;&lt;bean id=\"userDao\" class=\"com.foo.JdbcUserDao\"&gt;    &lt;!-- Spring will do the cast automatically (as usual) --&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;                        &lt;jee:jndi-lookup/&gt; (with single JNDI environment setting)                                \n\r\n\rBefore...                &lt;bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;    &lt;property name=\"jndiName\" value=\"jdbc/MyDataSource\"/&gt;    &lt;property name=\"jndiEnvironment\"&gt;        &lt;props&gt;            &lt;prop key=\"foo\"&gt;bar&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\"&gt;    &lt;jee:environment&gt;foo=bar&lt;/jee:environment&gt;&lt;/jee:jndi-lookup&gt;                        &lt;jee:jndi-lookup/&gt; (with multiple JNDI environment settings)                                \n\r\n\rBefore...                &lt;bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;    &lt;property name=\"jndiName\" value=\"jdbc/MyDataSource\"/&gt;    &lt;property name=\"jndiEnvironment\"&gt;        &lt;props&gt;            &lt;prop key=\"foo\"&gt;bar&lt;/prop&gt;            &lt;prop key=\"ping\"&gt;pong&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\"&gt;    &lt;!-- newline-separated, key-value pairs for the environment (standard Properties format) --&gt;    &lt;jee:environment&gt;        foo=bar        ping=pong    &lt;/jee:environment&gt;&lt;/jee:jndi-lookup&gt;                        &lt;jee:jndi-lookup/&gt; (complex)                                \n\r\n\rBefore...                &lt;bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;    &lt;property name=\"jndiName\" value=\"jdbc/MyDataSource\"/&gt;    &lt;property name=\"cache\" value=\"true\"/&gt;    &lt;property name=\"resourceRef\" value=\"true\"/&gt;    &lt;property name=\"lookupOnStartup\" value=\"false\"/&gt;    &lt;property name=\"expectedType\" value=\"com.myapp.DefaultFoo\"/&gt;    &lt;property name=\"proxyInterface\" value=\"com.myapp.Foo\"/&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:jndi-lookup id=\"simple\"             jndi-name=\"jdbc/MyDataSource\"             cache=\"true\"             resource-ref=\"true\"             lookup-on-startup=\"false\"             expected-type=\"com.myapp.DefaultFoo\"             proxy-interface=\"com.myapp.Foo\"/&gt;                        &lt;jee:local-slsb/&gt; (simple)                                \n\r\n\rThe &lt;jee:local-slsb/&gt; tag configures a                reference to an EJB Stateless SessionBean.                \n\r\n\rBefore...                &lt;bean id=\"simple\"      class=\"org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/&gt;  &lt;property name=\"businessInterface\" value=\"com.foo.service.RentalService\"/&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:local-slsb id=\"simpleSlsb\" jndi-name=\"ejb/RentalServiceBean\"    business-interface=\"com.foo.service.RentalService\"/&gt;                        &lt;jee:local-slsb/&gt; (complex)                                &lt;bean id=\"complexLocalEjb\"      class=\"org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/&gt;  &lt;property name=\"businessInterface\" value=\"com.foo.service.RentalService\"/&gt;  &lt;property name=\"cacheHome\" value=\"true\"/&gt;  &lt;property name=\"lookupHomeOnStartup\" value=\"true\"/&gt;  &lt;property name=\"resourceRef\" value=\"true\"/&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:local-slsb id=\"complexLocalEjb\"    jndi-name=\"ejb/RentalServiceBean\"    business-interface=\"com.foo.service.RentalService\"    cache-home=\"true\"    lookup-home-on-startup=\"true\"    resource-ref=\"true\"&gt;                        &lt;jee:remote-slsb/&gt;                                \n\r\n\rThe &lt;jee:remote-slsb/&gt; tag configures a                reference to a remote EJB Stateless SessionBean.                \n\r\n\rBefore...                &lt;bean id=\"complexRemoteEjb\"      class=\"org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"ejb/MyRemoteBean\"/&gt;  &lt;property name=\"businessInterface\" value=\"com.foo.service.RentalService\"/&gt;  &lt;property name=\"cacheHome\" value=\"true\"/&gt;  &lt;property name=\"lookupHomeOnStartup\" value=\"true\"/&gt;  &lt;property name=\"resourceRef\" value=\"true\"/&gt;  &lt;property name=\"homeInterface\" value=\"com.foo.service.RentalService\"/&gt;  &lt;property name=\"refreshHomeOnConnectFailure\" value=\"true\"/&gt;&lt;/bean&gt;                \n\r\n\rAfter...                &lt;jee:remote-slsb id=\"complexRemoteEjb\"    jndi-name=\"ejb/MyRemoteBean\"    business-interface=\"com.foo.service.RentalService\"    cache-home=\"true\"    lookup-home-on-startup=\"true\"    resource-ref=\"true\"    home-interface=\"com.foo.service.RentalService\"    refresh-home-on-connect-failure=\"true\"&gt;                            E.2.4&nbsp;The lang schema                        \n\r\n\rThe lang tags deal with exposing objects that have been            written in a dynamic language such as JRuby or Groovy as beans in the Spring            container.            \n\r\n\rThese tags (and the dynamic language support) are comprehensively covered            in the chapter entitled Chapter&nbsp;28, Dynamic language support. Please do consult that            chapter for full details on this support and the lang tags            themselves.            \n\r\n\rIn the interest of completeness, to use the tags in the lang            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the lang namespace are            available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:lang=\"http://www.springframework.org/schema/lang\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;                E.2.5&nbsp;The jms schema                        \n\r\n\rThe jms tags deal with configuring JMS-related            beans such as Spring\'s MessageListenerContainers.            These tags are detailed in the section of the JMS chapter            entitled Section&nbsp;23.6, &#8220;JMS Namespace Support&#8221;. Please do consult that            chapter for full details on this support and the jms tags            themselves.            \n\r\n\rIn the interest of completeness, to use the tags in the jms            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the jms namespace are            available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jms=\"http://www.springframework.org/schema/jms\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;                E.2.6&nbsp;The tx (transaction) schema                        \n\r\n\rThe tx tags deal with configuring all of those            beans in Spring\'s comprehensive support for transactions. These tags are            covered in the chapter entitled Chapter&nbsp;12, Transaction Management.            Tip                \n\r\n\rYou are strongly encouraged to look at the                \'spring-tx.xsd\' file that ships with the Spring                distribution. This file is (of course), the XML Schema for Spring\'s                transaction configuration, and covers all of the various tags in the                tx namespace, including attribute defaults and                suchlike. This file is documented inline, and thus the information is                not repeated here in the interests of adhering to the DRY (Don\'t Repeat                Yourself) principle.                        \n\r\n\rIn the interest of completeness, to use the tags in the tx            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the tx namespace are            available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            Note                \n\r\n\rOften when using the tags in the tx namespace you will also be using                the tags from the aop namespace (since the declarative transaction support in Spring is implemented using                AOP). The above XML snippet contains the relevant lines needed to reference the aop schema                so that the tags in the aop namespace are available to you.                            E.2.7&nbsp;The aop schema                        \n\r\n\rThe aop tags deal with configuring all things            AOP in Spring: this includes Spring\'s own proxy-based AOP framework and Spring\'s            integration with the AspectJ AOP framework. These tags are            comprehensively covered in the chapter entitled Chapter&nbsp;9, Aspect Oriented Programming with Spring.            \n\r\n\rIn the interest of completeness, to use the tags in the aop            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the aop namespace are            available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;                E.2.8&nbsp;The context schema                        \n\r\n\rThe context tags deal with ApplicationContext            configuration that relates to plumbing - that is, not usually beans that are important to an end-user            but rather beans that do a lot of grunt work in Spring, such as BeanfactoryPostProcessors.            The following snippet references the correct schema so that the tags in the context            namespace are available to you.            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;            Note                \n\r\n\rThe context schema was only introduced in Spring 2.5.                        &lt;property-placeholder/&gt;                                \n\r\n\rThis element activates the replacement of ${...} placeholders, resolved                against the specified properties file (as a Spring resource location).                This element is a convenience mechanism that sets up a                PropertyPlaceholderConfigurer                for you; if you need more control over the PropertyPlaceholderConfigurer, just                define one yourself explicitly.                        &lt;annotation-config/&gt;                                \n\r\n\rActivates the Spring infrastructure for various annotations to be detected in bean classes:                Spring\'s @Required                and @Autowired, as well as                JSR 250\'s @PostConstruct, @PreDestroy and                @Resource (if available), and JPA\'s                @PersistenceContext and @PersistenceUnit                (if available). Alternatively, you can choose to activate the individual                BeanPostProcessors for those annotations explicitly.                Note                    \n\r\n\rThis element does not activate processing of Spring\'s                    @Transactional                    annotation. Use the                    &lt;tx:annotation-driven/&gt; element                    for that purpose.                                        &lt;component-scan/&gt;                                \n\r\n\rThis element is detailed in Section&nbsp;5.9, &#8220;Annotation-based container configuration&#8221;.                        &lt;load-time-weaver/&gt;                                \n\r\n\rThis element is detailed in Section&nbsp;9.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;.                        &lt;spring-configured/&gt;                                \n\r\n\rThis element is detailed in Section&nbsp;9.8.1, &#8220;Using AspectJ to dependency inject domain objects with      Spring&#8221;.                        &lt;mbean-export/&gt;                                \n\r\n\rThis element is detailed in Section&nbsp;24.4.3, &#8220;Configuring annotation based MBean export&#8221;.                            E.2.9&nbsp;The tool schema                        \n\r\n\rThe tool tags are for use when you want to add            tooling-specific metadata to your custom configuration elements. This metadata            can then be consumed by tools that are aware of this metadata, and the tools can            then do pretty much whatever they want with it (validation, etc.).            \n\r\n\rThe tool tags are not documented in this release of            Spring as they are currently undergoing review. If you are a third party tool            vendor and you would like to contribute to this review process, then do mail            the Spring mailing list. The currently supported tool            tags can be found in the file \'spring-tool.xsd\' in the            \'src/org/springframework/beans/factory/xml\' directory of the            Spring source distribution.                E.2.10&nbsp;The jdbc schema                        \n\r\n\rThe jdbc tags allow you to quickly configure an            embedded database or initialize an existing data source. These tags are            documented in Section&nbsp;14.8, &#8220;Embedded database support&#8221; and            Section&nbsp;14.9, &#8220;Initializing a DataSource&#8221; respectively.            \n\r\n\rTo use the tags in the jdbc            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the jdbc namespace are            available to you.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;                E.2.11&nbsp;The cache schema                        \n\r\n\rThe cache tags can be used to enable support for Spring\'s            @CacheEvict, @CachePut            and @Caching annotations. It it also supports declarative            XML-based caching. See  Section&nbsp;29.3.5, &#8220;Enable caching annotations&#8221; and            Section&nbsp;29.4, &#8220;Declarative XML-based caching&#8221; for details.            \n\r\n\rTo use the tags in the cache            schema, you need to have the following preamble at the top of your Spring XML            configuration file; the text in the following snippet references the            correct schema so that the tags in the cache namespace are            available to you.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:jdbc=\"http://www.springframework.org/schema/cache\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/cache http://www.springframework.org/schema/jdbc/spring-cache.xsd\"&gt;&lt;!-- bean definitions here --&gt;&lt;/beans&gt;                E.2.12&nbsp;The beans schema                        \n\r\n\rLast but not least we have the tags in the beans schema.            These are the same tags that have been in Spring since the very dawn of the framework.            Examples of the various tags in the beans schema are not shown here            because they are quite comprehensively covered in Section&nbsp;5.4.2, &#8220;Dependencies and configuration in detail&#8221;            (and indeed in that entire chapter).            \n\r\n\rOne thing that is new to the beans tags themselves in Spring 2.0 is the idea            of arbitrary bean metadata. In Spring 2.0 it is now possible to add zero or more            key / value pairs to &lt;bean/&gt; XML definitions. What, if            anything, is done with this extra metadata is totally up to your own custom logic (and            so is typically only of use if you are writing your own custom tags as described in            the appendix entitled Appendix&nbsp;F, Extensible XML authoring).            \n\r\n\rFind below an example of the &lt;meta/&gt; tag in the context            of a surrounding &lt;bean/&gt; (please note that without any logic            to interpret it the metadata is effectively useless as-is).            &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt;        &lt;meta key=\"cacheName\" value=\"foo\"/&gt;        &lt;property name=\"name\" value=\"Rick\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;            \n\r\n\rIn the case of the above example, you would assume that there is some            logic that will consume the bean definition and set up some caching infrastructure            using the supplied metadata.                Prev&nbsp;Up&nbsp;NextAppendix&nbsp;D.&nbsp;Migrating to Spring Framework 3.2&nbsp;Home&nbsp;Appendix&nbsp;F.&nbsp;Extensible XML authoring","E. XML Schema-based configuration","scr\\xsd-config.html");