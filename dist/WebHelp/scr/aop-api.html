<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0014)about:internet -->
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>10. Spring AOP APIs</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="prev" href="aop.html" title="9.&nbsp;Aspect Oriented Programming with Spring"><link rel="next" href="testing.html" title="11.&nbsp;Testing"></head><body bgcolor="white" text="black" link="#0000ff" vlink="#840084" alink="#0000ff"><script language="JavaScript" type="text/JavaScript">
function syn(){
if(parent.nav.tree){
 if(parent.nav.tree.loaded){
  parent.nav.tree.selectNode(349);
 }else{
  setTimeout("syn()",500);
}
  }else{
  setTimeout("syn()",500);
  }}
if(parent!=self){
  setTimeout("syn()",100);
}else{
  parent.location.href = "../index.htm#page=aop-api.html";
}
originalOnload = window.onload;
if(originalOnload==null){
window.onload = function(){parent.contentLoaded = true;};
}else{
window.onload = function(){originalOnload();parent.contentLoaded = true;};
}
</script> 
<div class="navheader"><table summary="Navigation header" width="100%"><tr><th colspan="3" align="center">10.&nbsp;Spring AOP APIs</th></tr><tr><td width="20%" align="left"><A accessKey=p href="aop.html">Prev</A>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Core Technologies</th><td width="20%" align="right">&nbsp;<A accessKey=n href="testing.html">Next</A></td></tr></table><hr></div><div class="chapter" title="10.&nbsp;Spring AOP APIs"><div class="titlepage"><div><div><h2 class="title"><a name="aop-api"></a>10.&nbsp;Spring AOP APIs</h2></div></div></div>
  

  <div class="section" title="10.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="aop-api-introduction"></a>10.1&nbsp;Introduction</h2></div></div></div>
    

    <p>The previous chapter described the Spring 2.0 and later version's
    support for AOP using @AspectJ and schema-based aspect definitions. In
    this chapter we discuss the lower-level Spring AOP APIs and the AOP
    support used in Spring 1.2 applications. For new applications, we
    recommend the use of the Spring 2.0 and later AOP support described in the
    previous chapter, but when working with existing applications, or when
    reading books and articles, you may come across Spring 1.2 style examples.
    Spring 3.0 is backwards compatible with Spring 1.2 and everything
    described in this chapter is fully supported in Spring 3.0.</p>
  </div>

  <div class="section" title="10.2&nbsp;Pointcut API in Spring"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="aop-api-pointcuts"></a>10.2&nbsp;Pointcut API in Spring</h2></div></div></div>
    

    <p>Let's look at how Spring handles the crucial pointcut
    concept.</p>

    <div class="section" title="10.2.1&nbsp;Concepts"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-concepts"></a>10.2.1&nbsp;Concepts</h3></div></div></div>
      

      <p>Spring's pointcut model enables pointcut reuse independent of
      advice types. It's possible to target different advice using the same
      pointcut.</p>

      <p>The <code class="literal">org.springframework.aop.Pointcut</code> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</pre>

      <p>Splitting the <code class="interfacename">Pointcut</code> interface
      into two parts allows reuse of class and method matching parts, and
      fine-grained composition operations (such as performing a "union" with
      another method matcher).</p>

      <p>The <code class="interfacename">ClassFilter</code> interface is used
      to restrict the pointcut to a given set of target classes. If the
      <code class="literal">matches()</code> method always returns true, all target
      classes will be matched:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ClassFilter {

    <span class="hl-keyword">boolean</span> matches(Class clazz);
}</pre>

      <p>The <code class="interfacename">MethodMatcher</code> interface is
      normally more important. The complete interface is shown below:</p>

      <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MethodMatcher {

    <span class="hl-keyword">boolean</span> matches(Method m, Class targetClass);

    <span class="hl-keyword">boolean</span> isRuntime();

    <span class="hl-keyword">boolean</span> matches(Method m, Class targetClass, Object[] args);
}</pre>

      <p>The <code class="literal">matches(Method, Class) </code>method is used to
      test whether this pointcut will ever match a given method on a target
      class. This evaluation can be performed when an AOP proxy is created, to
      avoid the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <code class="literal">isRuntime()</code> method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</p>

      <p>Most MethodMatchers are static, meaning that their
      <code class="literal">isRuntime()</code> method returns false. In this case, the
      3-argument matches method will never be invoked.</p>

      <div class="tip" title="Tip" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Tip><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Tip] src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        <p>If possible, try to make pointcuts static, allowing the AOP
        framework to cache the results of pointcut evaluation when an AOP
        proxy is created.</p>
      </td></tr></table></div>
    </div>

    <div class="section" title="10.2.2&nbsp;Operations on pointcuts"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcut-ops"></a>10.2.2&nbsp;Operations on pointcuts</h3></div></div></div>
      

      <p>Spring supports operations on pointcuts: notably,
      <span class="emphasis"><em>union</em></span> and <span class="emphasis"><em>intersection</em></span>.</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Union means the methods that either pointcut matches.</p><li class="listitem">
          <p>Intersection means the methods that both pointcuts
          match.</p><li class="listitem">
          <p>Union is usually more useful.</p><li class="listitem">
          <p>Pointcuts can be composed using the static methods in the
          <span class="emphasis"><em>org.springframework.aop.support.Pointcuts</em></span>
          class, or using the <span class="emphasis"><em>ComposablePointcut</em></span> class in
          the same package. However, using AspectJ pointcut expressions is
          usually a simpler approach.</p>
        </li></ul></div>
    </div>

    <div class="section" title="10.2.3&nbsp;AspectJ expression pointcuts"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-aspectj"></a>10.2.3&nbsp;AspectJ expression pointcuts</h3></div></div></div>
      

      <p>Since 2.0, the most important type of pointcut used by Spring is
      <code class="literal">org.springframework.aop.aspectj.AspectJExpressionPointcut</code>.
      This is a pointcut that uses an AspectJ supplied library to parse an
      AspectJ pointcut expression string.</p>

      <p>See the previous chapter for a discussion of supported AspectJ
      pointcut primitives.</p>
    </div>

    <div class="section" title="10.2.4&nbsp;Convenience pointcut implementations"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-impls"></a>10.2.4&nbsp;Convenience pointcut implementations</h3></div></div></div>
      

      <p>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</p>

      <div class="section" title="Static pointcuts"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-pointcuts-static"></a>Static pointcuts</h4></div></div></div>
        

        <p>Static pointcuts are based on method and target class, and
        cannot take into account the method's arguments. Static pointcuts are
        sufficient - <span class="emphasis"><em>and best</em></span> - for most usages. It's
        possible for Spring to evaluate a static pointcut only once, when a
        method is first invoked: after that, there is no need to evaluate the
        pointcut again with each method invocation.</p>

        <p>Let's consider some static pointcut implementations included
        with Spring.</p>

        <div class="section" title="Regular expression pointcuts"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-regex"></a>Regular expression pointcuts</h5></div></div></div>
          

          <p>One obvious way to specify static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible.
          <code class="literal">org.springframework.aop.support.JdkRegexpMethodPointcut</code>
          is a generic regular expression pointcut, using the regular
          expression support in JDK 1.4+.</p>

          <p>Using the <code class="literal">JdkRegexpMethodPointcut</code> class,
          you can provide a list of pattern Strings. If any of these is a
          match, the pointcut will evaluate to true. (So the result is
          effectively the union of these pointcuts.)</p>

          <p>The usage is shown below:</p>

          <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"settersAndAbsquatulatePointcut"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"patterns"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>.*set.*<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>.*absquatulate<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

          <p>Spring provides a convenience class,
          <code class="literal">RegexpMethodPointcutAdvisor</code>, that allows us to
          also reference an Advice (remember that an Advice can be an
          interceptor, before advice, throws advice etc.). Behind the scenes,
          Spring will use a <code class="literal">JdkRegexpMethodPointcut</code>. Using
          <code class="literal">RegexpMethodPointcutAdvisor</code> simplifies wiring, as
          the one bean encapsulates both pointcut and advice, as shown
          below:</p>

          <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"settersAndAbsquatulateAdvisor"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"advice"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">local</span>=<span class="hl-value">"beanNameOfAopAllianceInterceptor"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"patterns"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>.*set.*<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>.*absquatulate<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

          <p><span class="emphasis"><em>RegexpMethodPointcutAdvisor</em></span> can be used
          with any Advice type.</p>
        </div>

        <div class="section" title="Attribute-driven pointcuts"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-attribute-driven"></a>Attribute-driven pointcuts</h5></div></div></div>
          

          <p>An important type of static pointcut is a
          <span class="emphasis"><em>metadata-driven</em></span> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</p>
        </div>
      </div>

      <div class="section" title="Dynamic pointcuts"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-pointcuts-dynamic"></a>Dynamic pointcuts</h4></div></div></div>
        

        <p>Dynamic pointcuts are costlier to evaluate than static
        pointcuts. They take into account method
        <span class="emphasis"><em>arguments</em></span>, as well as static information. This
        means that they must be evaluated with every method invocation; the
        result cannot be cached, as arguments will vary.</p>

        <p>The main example is the <code class="literal">control flow</code>
        pointcut.</p>

        <div class="section" title="Control flow pointcuts"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-cflow"></a>Control flow pointcuts</h5></div></div></div>
          

          <p>Spring control flow pointcuts are conceptually similar to
          AspectJ <span class="emphasis"><em>cflow</em></span> pointcuts, although less
          powerful. (There is currently no way to specify that a pointcut
          executes below a join point matched by another pointcut.) A control
          flow pointcut matches the current call stack. For example, it might
          fire if the join point was invoked by a method in the
          <code class="literal">com.mycompany.web</code> package, or by the
          <code class="literal">SomeCaller</code> class. Control flow pointcuts are
          specified using the
          <code class="literal">org.springframework.aop.support.ControlFlowPointcut
          </code>class.</p><div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
              <p>Control flow pointcuts are significantly more expensive to
              evaluate at runtime than even other dynamic pointcuts. In Java
              1.4, the cost is about 5 times that of other dynamic
              pointcuts.</p>
            </td></tr></table></div>
        </div>
      </div>
    </div>

    <div class="section" title="10.2.5&nbsp;Pointcut superclasses"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-superclasses"></a>10.2.5&nbsp;Pointcut superclasses</h3></div></div></div>
      

      <p>Spring provides useful pointcut superclasses to help you to
      implement your own pointcuts.</p>

      <p>Because static pointcuts are most useful, you'll probably subclass
      StaticMethodMatcherPointcut, as shown below. This requires implementing
      just one abstract method (although it's possible to override other
      methods to customize behavior):</p>

      <pre class="programlisting"><span class="hl-keyword">class</span> TestStaticPointcut <span class="hl-keyword">extends</span> StaticMethodMatcherPointcut {

    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> matches(Method m, Class targetClass) {
        <span class="hl-comment">// return true if custom criteria match</span>
    }
}</pre><p>There are also superclasses for dynamic pointcuts.</p>

      <p>You can use custom pointcuts with any advice type in Spring 1.0
      RC2 and above.</p>
    </div>

    <div class="section" title="10.2.6&nbsp;Custom pointcuts"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-custom"></a>10.2.6&nbsp;Custom pointcuts</h3></div></div></div>
      

      <p>Because pointcuts in Spring AOP are Java classes, rather than
      language features (as in AspectJ) it's possible to declare custom
      pointcuts, whether static or dynamic. Custom pointcuts in Spring can be
      arbitrarily complex. However, using the AspectJ pointcut expression
      language is recommended if possible.</p>

      <div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>Later versions of Spring may offer support for "semantic
        pointcuts" as offered by JAC: for example, "all methods that change
        instance variables in the target object."</p>
      </td></tr></table></div>
    </div>
  </div>

  <div class="section" title="10.3&nbsp;Advice API in Spring"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="aop-api-advice"></a>10.3&nbsp;Advice API in Spring</h2></div></div></div>
    

    <p>Let's now look at how Spring AOP handles advice.</p>

    <div class="section" title="10.3.1&nbsp;Advice lifecycles"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-advice-lifecycle"></a>10.3.1&nbsp;Advice lifecycles</h3></div></div></div>
      

      <p>Each advice is a Spring bean. An advice instance can be shared
      across all advised objects, or unique to each advised object. This
      corresponds to <span class="emphasis"><em>per-class</em></span> or
      <span class="emphasis"><em>per-instance</em></span> advice.</p>

      <p>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; they merely act on the method and
      arguments.</p>

      <p>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied
      object.</p>

      <p>It's possible to use a mix of shared and per-instance advice in
      the same AOP proxy.</p>
    </div>

    <div class="section" title="10.3.2&nbsp;Advice types in Spring"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-advice-types"></a>10.3.2&nbsp;Advice types in Spring</h3></div></div></div>
      

      <p>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let us look at the basic
      concepts and standard advice types.</p>

      <div class="section" title="Interception around advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-around"></a>Interception around advice</h4></div></div></div>
        

        <p>The most fundamental advice type in Spring is
        <span class="emphasis"><em>interception around advice</em></span>.</p>

        <p>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MethodInterceptor <span class="hl-keyword">extends</span> Interceptor {

    Object invoke(MethodInvocation invocation) <span class="hl-keyword">throws</span> Throwable;
}</pre>

        <p>The <code class="classname">MethodInvocation</code> argument to the
        <code class="methodname">invoke()</code> method exposes the method being
        invoked; the target join point; the AOP proxy; and the arguments to
        the method. The <code class="methodname">invoke()</code> method should return
        the invocation's result: the return value of the join point.</p>

        <p>A simple <code class="classname">MethodInterceptor</code> implementation
        looks as follows:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DebugInterceptor <span class="hl-keyword">implements</span> MethodInterceptor {

    <span class="hl-keyword">public</span> Object invoke(MethodInvocation invocation) <span class="hl-keyword">throws</span> Throwable {
        System.out.println(<span class="hl-string">"Before: invocation=["</span> + invocation + <span class="hl-string">"]"</span>);
        Object rval = invocation.proceed();
        System.out.println(<span class="hl-string">"Invocation returned"</span>);
        <span class="hl-keyword">return</span> rval;
    }
}</pre>

        <p>Note the call to the MethodInvocation's
        <code class="methodname">proceed()</code> method. This proceeds down the
        interceptor chain towards the join point. Most interceptors will
        invoke this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don't want to do this without good reason!</p>

        <div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>MethodInterceptors offer interoperability with other AOP
          Alliance-compliant AOP implementations. The other advice types
          discussed in the remainder of this section implement common AOP
          concepts, but in a Spring-specific way. While there is an advantage
          in using the most specific advice type, stick with MethodInterceptor
          around advice if you are likely to want to run the aspect in another
          AOP framework. Note that pointcuts are not currently interoperable
          between frameworks, and the AOP Alliance does not currently define
          pointcut interfaces.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Before advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-before"></a>Before advice</h4></div></div></div>
        

        <p>A simpler advice type is a <span class="bold"><strong>before
        advice</strong></span>. This does not need a
        <code class="literal">MethodInvocation</code> object, since it will only be
        called before entering the method.</p>

        <p>The main advantage of a before advice is that there is no need
        to invoke the <code class="literal">proceed() </code>method, and therefore no
        possibility of inadvertently failing to proceed down the interceptor
        chain.</p>

        <p>The <code class="literal">MethodBeforeAdvice</code> interface is shown
        below. (Spring's API design would allow for field before advice,
        although the usual objects apply to field interception and it's
        unlikely that Spring will ever implement it).</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MethodBeforeAdvice <span class="hl-keyword">extends</span> BeforeAdvice {

    <span class="hl-keyword">void</span> before(Method m, Object[] args, Object target) <span class="hl-keyword">throws</span> Throwable;
}</pre>

        <p>Note the return type is <code class="literal">void</code>. Before advice
        can insert custom behavior before the join point executes, but cannot
        change the return value. If a before advice throws an exception, this
        will abort further execution of the interceptor chain. The exception
        will propagate back up the interceptor chain. If it is unchecked, or
        on the signature of the invoked method, it will be passed directly to
        the client; otherwise it will be wrapped in an unchecked exception by
        the AOP proxy.</p>

        <p>An example of a before advice in Spring, which counts all method
        invocations:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CountingBeforeAdvice <span class="hl-keyword">implements</span> MethodBeforeAdvice {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> count;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> before(Method m, Object[] args, Object target) <span class="hl-keyword">throws</span> Throwable {
        ++count;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getCount() {
        <span class="hl-keyword">return</span> count;
    }
}</pre>

        <div class="tip" title="Tip" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Tip><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Tip] src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
          <p>Before advice can be used with any pointcut.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="Throws advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-throws"></a>Throws advice</h4></div></div></div>
        

        <p><span class="bold"><strong>Throws advice</strong></span> is invoked after
        the return of the join point if the join point threw an exception.
        Spring offers typed throws advice. Note that this means that the
        <code class="literal">org.springframework.aop.ThrowsAdvice</code> interface does
        not contain any methods: It is a tag interface identifying that the
        given object implements one or more typed throws advice methods. These
        should be in the form of:</p>

        <pre class="programlisting">afterThrowing([Method, args, target], subclassOfThrowable) </pre>

        <p>Only the last argument is required. The method signatures may
        have either one or four arguments, depending on whether the advice
        method is interested in the method and arguments. The following
        classes are examples of throws advice.</p>

        <p>The advice below is invoked if a
        <code class="exceptionname">RemoteException</code> is thrown (including
        subclasses):</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RemoteThrowsAdvice <span class="hl-keyword">implements</span> ThrowsAdvice {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterThrowing(RemoteException ex) <span class="hl-keyword">throws</span> Throwable {
        <em class="lineannotation"><span class="lineannotation">// Do something with remote exception</span></em>
    }
}</pre>

        <p>The following advice is invoked if a
        <code class="exceptionname">ServletException</code> is thrown. Unlike the
        above advice, it declares 4 arguments, so that it has access to the
        invoked method, method arguments and target object:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ServletThrowsAdviceWithArguments <span class="hl-keyword">implements</span> ThrowsAdvice {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        <em class="lineannotation"><span class="lineannotation">// Do something with all arguments</span></em>
    }
}</pre>

        <p>The final example illustrates how these two methods could be
        used in a single class, which handles both
        <code class="literal">RemoteException</code> and
        <code class="literal">ServletException</code>. Any number of throws advice
        methods can be combined in a single class.</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> CombinedThrowsAdvice <span class="hl-keyword">implements</span> ThrowsAdvice {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterThrowing(RemoteException ex) <span class="hl-keyword">throws</span> Throwable {
        <span class="hl-comment">// Do something with remote exception</span>
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        <span class="hl-comment">// Do something with all arguments</span>
    }
}</pre>

        <p><span class="emphasis"><em>Note:</em></span> If a throws-advice method throws an
        exception itself, it will override the original exception (i.e. change
        the exception thrown to the user). The overriding exception will
        typically be a RuntimeException; this is compatible with any method
        signature. However, if a throws-advice method throws a checked
        exception, it will have to match the declared exceptions of the target
        method and is hence to some degree coupled to specific target method
        signatures. <span class="emphasis"><em>Do not throw an undeclared checked exception
        that is incompatible with the target method's
        signature!</em></span></p>

        <div class="tip" title="Tip" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Tip><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Tip] src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
          <p>Throws advice can be used with any pointcut.</p>
        </td></tr></table></div>
      </div>

      <div class="section" title="After Returning advice"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-after-returning"></a>After Returning advice</h4></div></div></div>
        

        <p>An after returning advice in Spring must implement the
        <span class="emphasis"><em>org.springframework.aop.AfterReturningAdvice</em></span>
        interface, shown below:</p>

        <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AfterReturningAdvice <span class="hl-keyword">extends</span> Advice {

    <span class="hl-keyword">void</span> afterReturning(Object returnValue, Method m, Object[] args, Object target)
            <span class="hl-keyword">throws</span> Throwable;
}</pre>

        <p>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and
        target.</p>

        <p>The following after returning advice counts all successful
        method invocations that have not thrown exceptions:</p><pre class=programlisting><span class=hl-keyword>public</span> <span class=hl-keyword>class</span> CountingAfterReturningAdvice <span class=hl-keyword>implements</span> AfterReturningAdvice {

    <span class=hl-keyword>private</span> <span class=hl-keyword>int</span> count;

    <span class=hl-keyword>public</span> <span class=hl-keyword>void</span> afterReturning(Object returnValue, Method m, Object[] args, Object target)
            <span class=hl-keyword>throws</span> Throwable {
        ++count;
    }

    <span class=hl-keyword>public</span> <span class=hl-keyword>int</span> getCount() {
        <span class=hl-keyword>return</span> count;
    }
}</pre>
<p>This advice doesn't change the execution path. If it 
throws an exception, this will be thrown up the interceptor chain instead of the 
return value.</p>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>After returning advice can be used with any 
      pointcut.</P></TD></TR></TABLE></DIV>
      </div>
<div class=section title="Introduction advice">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=aop-api-advice-introduction></A>Introduction advice</H4></DIV></DIV></DIV>
<p>Spring treats introduction advice as a special kind of 
interception advice.</P>
<p>Introduction requires an <code class=literal>IntroductionAdvisor</CODE>, and an <code class=literal>IntroductionInterceptor</CODE>, implementing the following 
interface:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> IntroductionInterceptor <span class=hl-keyword>extends</SPAN> MethodInterceptor {

    <span class=hl-keyword>boolean</SPAN> implementsInterface(Class intf);
}</PRE>
<p>The <code class=literal>invoke() 
</CODE>method inherited from the AOP Alliance <code class=literal>MethodInterceptor</CODE> interface must implement the 
introduction: that is, if the invoked method is on an introduced interface, the 
introduction interceptor is responsible for handling the method call - it cannot 
invoke <code class=literal>proceed()</CODE>.</P>
<p>Introduction advice cannot be used with any pointcut, as 
it applies only at class, rather than method, level. You can only use 
introduction advice with the <code class=literal>IntroductionAdvisor</CODE>, which has the following 
methods:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> IntroductionAdvisor <span class=hl-keyword>extends</SPAN> Advisor, IntroductionInfo {

    ClassFilter getClassFilter();

    <span class=hl-keyword>void</SPAN> validateInterfaces() <span class=hl-keyword>throws</SPAN> IllegalArgumentException;
}

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> IntroductionInfo {

    Class[] getInterfaces();
}</PRE>
<p>There is no <code class=interfacename>MethodMatcher</CODE>, and hence no <code 
class=interfacename>Pointcut</CODE>, associated with 
introduction advice. Only class filtering is logical.</P>
<p>The <code class=literal>getInterfaces()</CODE> method returns the interfaces 
introduced by this advisor.</P>
<p>The <code class=literal>validateInterfaces()</CODE> method is used internally to 
see whether or not the introduced interfaces can be implemented by the 
configured <code class=literal>IntroductionInterceptor</CODE>.</P>
<p>Let's look at a simple example from the Spring test 
suite. Let's suppose we want to introduce the following interface to one or more 
objects:</P>
<p></P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> Lockable {
    <span class=hl-keyword>void</SPAN> lock();
    <span class=hl-keyword>void</SPAN> unlock();
    <span class=hl-keyword>boolean</SPAN> locked();
}</PRE>
<p></P>
<p>This illustrates a <span class=bold><strong>mixin</STRONG></SPAN>. We want 
to be able to cast advised objects to Lockable, whatever their type, and call 
lock and unlock methods. If we call the lock() method, we want all setter 
methods to throw a <code class=literal>LockedException</CODE>. Thus we can add an aspect that 
provides the ability to make objects immutable, without them having any 
knowledge of it: a good example of AOP.</P>
<p>Firstly, we'll need an <code class=literal>IntroductionInterceptor</CODE> that does the heavy lifting. 
In this case, we extend the <code class=literal>org.springframework.aop.support.DelegatingIntroductionInterceptor</CODE> 
convenience class. We could implement IntroductionInterceptor directly, but 
using <code class=literal>DelegatingIntroductionInterceptor</CODE> is best for most 
cases.</P>
<p>The <code class=literal>DelegatingIntroductionInterceptor</CODE> is designed to 
delegate an introduction to an actual implementation of the introduced 
interface(s), concealing the use of interception to do so. The delegate can be 
set to any object using a constructor argument; the default delegate (when the 
no-arg constructor is used) is this. Thus in the example below, the delegate is 
the <code class=literal>LockMixin</CODE> subclass of <code 
class=literal>DelegatingIntroductionInterceptor</CODE>. 
Given a delegate (by default itself), a <code class=literal>DelegatingIntroductionInterceptor</CODE> instance looks for 
all interfaces implemented by the delegate (other than IntroductionInterceptor), 
and will support introductions against any of them. It's possible for subclasses 
such as <code class=literal>LockMixin</CODE> to call the 
<code class=literal>suppressInterface(Class intf) 
</CODE>method to suppress interfaces that should not be exposed. However, no 
matter how many interfaces an <code class=literal>IntroductionInterceptor</CODE> is prepared to support, the 
<code class=literal>IntroductionAdvisor</CODE> used will 
control which interfaces are actually exposed. An introduced interface will 
conceal any implementation of the same interface by the target.</P>
<p>Thus LockMixin subclasses <code class=literal>DelegatingIntroductionInterceptor</CODE> and implements 
Lockable itself. The superclass automatically picks up that Lockable can be 
supported for introduction, so we don't need to specify that. We could introduce 
any number of interfaces in this way.</P>
<p>Note the use of the <code class=literal>locked</CODE> instance variable. This effectively adds 
additional state to that held in the target object.</P>
<p></P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> LockMixin <span class=hl-keyword>extends</SPAN> DelegatingIntroductionInterceptor
    <span class=hl-keyword>implements</SPAN> Lockable {

    <span class=hl-keyword>private</SPAN> <span class=hl-keyword>boolean</SPAN> locked;

    <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> lock() {
        <span class=hl-keyword>this</SPAN>.locked = true;
    }

    <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> unlock() {
        <span class=hl-keyword>this</SPAN>.locked = false;
    }

    <span class=hl-keyword>public</SPAN> <span class=hl-keyword>boolean</SPAN> locked() {
        <span class=hl-keyword>return</SPAN> <span class=hl-keyword>this</SPAN>.locked;
    }

    <span class=hl-keyword>public</SPAN> Object invoke(MethodInvocation invocation) <span class=hl-keyword>throws</SPAN> Throwable {
        <span class=hl-keyword>if</SPAN> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class=hl-string>"set"</SPAN>) == <span class=hl-number>0</SPAN>)
            <span class=hl-keyword>throw</SPAN> <span class=hl-keyword>new</SPAN> LockedException();
        <span class=hl-keyword>return</SPAN> <span class=hl-keyword>super</SPAN>.invoke(invocation);
    }

}</PRE>
<p></P>
<p>Often it isn't necessary to override the <code 
class=literal>invoke() </CODE>method: the <code 
class=literal>DelegatingIntroductionInterceptor</CODE> 
implementation - which calls the delegate method if the method is introduced, 
otherwise proceeds towards the join point - is usually sufficient. In the 
present case, we need to add a check: no setter method can be invoked if in 
locked mode.</P>
<p>The introduction advisor required is simple. All it 
needs to do is hold a distinct <code class=literal>LockMixin</CODE> instance, and specify the introduced 
interfaces - in this case, just <code class=literal>Lockable</CODE>. A more complex example might take a 
reference to the introduction interceptor (which would be defined as a 
prototype): in this case, there's no configuration relevant for a <code 
class=literal>LockMixin</CODE>, so we simply create it 
using <code class=literal>new</CODE>.</P>
<p></P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> LockMixinAdvisor <span class=hl-keyword>extends</SPAN> DefaultIntroductionAdvisor {

    <span class=hl-keyword>public</SPAN> LockMixinAdvisor() {
        <span class=hl-keyword>super</SPAN>(<span class=hl-keyword>new</SPAN> LockMixin(), Lockable.<span class=hl-keyword>class</SPAN>);
    }
}</PRE>
<p></P>
<p>We can apply this advisor very simply: it requires no 
configuration. (However, it <span class=emphasis><em>is</EM></SPAN> necessary: It's impossible to use an <code 
class=literal>IntroductionInterceptor</CODE> without an 
<span class=emphasis><em>IntroductionAdvisor</EM></SPAN>.) As usual with 
introductions, the advisor must be per-instance, as it is stateful. We need a 
different instance of <code class=literal>LockMixinAdvisor</CODE>, and hence <code class=literal>LockMixin</CODE>, for each advised object. The advisor 
comprises part of the advised object's state.</P>
<p>We can apply this advisor programmatically, using the 
<code class=literal>Advised.addAdvisor() </CODE>method, or 
(the recommended way) in XML configuration, like any other advisor. All proxy 
creation choices discussed below, including "auto proxy creators," correctly 
handle introductions and stateful mixins.</P></DIV>
    </div>
  </div>
<div class=section title="10.4&nbsp;Advisor API in Spring">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=aop-api-advisor></A>10.4&nbsp;Advisor API in Spring</H2></DIV></DIV></DIV>
<p>In Spring, an Advisor is an aspect that contains just a 
single advice object associated with a pointcut expression.</P>
<p>Apart from the special case of introductions, any 
advisor can be used with any advice. <code class=literal>org.springframework.aop.support.DefaultPointcutAdvisor</CODE> 
is the most commonly used advisor class. For example, it can be used with a 
<code class=literal>MethodInterceptor</CODE>, <code 
class=literal>BeforeAdvice</CODE> or <code class=literal>ThrowsAdvice</CODE>.</P>
<p>It is possible to mix advisor and advice types in Spring 
in the same AOP proxy. For example, you could use a interception around advice, 
throws advice and before advice in one proxy configuration: Spring will 
automatically create the necessary interceptor chain.</P></DIV>
<div class=section 
title="10.5&nbsp;Using the ProxyFactoryBean to create AOP proxies">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=aop-pfb></A>10.5&nbsp;Using the ProxyFactoryBean to create AOP 
proxies</H2></DIV></DIV></DIV>
<p>If you're using the Spring IoC container (an 
ApplicationContext or BeanFactory) for your business objects - and you should 
be! - you will want to use one of Spring's AOP FactoryBeans. (Remember that a 
factory bean introduces a layer of indirection, enabling it to create objects of 
a different type.)</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The Spring 2.0 AOP support also uses factory beans 
      under the covers.</P></TD></TR></TABLE></DIV>
<p>The basic way to create an AOP proxy in Spring is to use 
the <span class=emphasis><em>org.springframework.aop.framework.ProxyFactoryBean</EM></SPAN>. 
This gives complete control over the pointcuts and advice that will apply, and 
their ordering. However, there are simpler options that are preferable if you 
don't need such control.</P>
<div class=section title=10.5.1&nbsp;Basics>
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-pfb-1></A>10.5.1&nbsp;Basics</H3></DIV></DIV></DIV>
<p>The <code class=literal>ProxyFactoryBean</CODE>, like other Spring <code 
class=literal>FactoryBean</CODE> implementations, 
introduces a level of indirection. If you define a <code class=literal>ProxyFactoryBean</CODE> with name <code class=literal>foo</CODE>, what objects referencing <code class=literal>foo</CODE> see is not the <code class=literal>ProxyFactoryBean</CODE> instance itself, but an object 
created by the <code class=literal>ProxyFactoryBean</CODE>'s implementation of the <code 
class=literal>getObject() </CODE>method. This method will 
create an AOP proxy wrapping a target object.</P>
<p>One of the most important benefits of using a <code 
class=literal>ProxyFactoryBean</CODE> or another IoC-aware 
class to create AOP proxies, is that it means that advices and pointcuts can 
also be managed by IoC. This is a powerful feature, enabling certain approaches 
that are hard to achieve with other AOP frameworks. For example, an advice may 
itself reference application objects (besides the target, which should be 
available in any AOP framework), benefiting from all the pluggability provided 
by Dependency Injection.</P></DIV>
<div class=section title="10.5.2&nbsp;JavaBean properties">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-pfb-2></A>10.5.2&nbsp;JavaBean properties</H3></DIV></DIV></DIV>
<p>In common with most <code class=interfacename>FactoryBean</CODE> implementations provided with Spring, 
the <code class=classname>ProxyFactoryBean</CODE> class is 
itself a JavaBean. Its properties are used to:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Specify the target you want to proxy.</P>
  <li class=listitem>
  <p>Specify whether to use CGLIB (see below and also <A class=xref title="10.5.3&nbsp;JDK- and CGLIB-based proxies" href="aop-api.html#aop-pfb-proxy-types" >Section&nbsp;10.5.3, “JDK- 
  and CGLIB-based proxies”</A>).</P></LI></UL></DIV>
<p>Some key properties are inherited from <code 
class=classname>org.springframework.aop.framework.ProxyConfig</CODE> (the 
superclass for all AOP proxy factories in Spring). These key properties 
include:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><code class=literal 
  >proxyTargetClass</CODE>: <code class=literal 
  >true</CODE> if the target class is to be proxied, rather 
  than the target class' interfaces. If this property value is set to <code 
  class=literal>true</CODE>, then CGLIB proxies will be 
  created (but see also <A class=xref title="10.5.3&nbsp;JDK- and CGLIB-based proxies" href="aop-api.html#aop-pfb-proxy-types" >Section&nbsp;10.5.3, “JDK- 
  and CGLIB-based proxies”</A>).</P>
  <li class=listitem>
  <p><code class=literal 
  >optimize</CODE>: controls whether or not aggressive 
  optimizations are applied to proxies <span class=emphasis 
  ><em>created via CGLIB</EM></SPAN>. 
  One should not blithely use this setting unless one fully understands how the 
  relevant AOP proxy handles optimization. This is currently used only for CGLIB 
  proxies; it has no effect with JDK dynamic proxies.</P>
  <li class=listitem>
  <p><code class=literal 
  >frozen</CODE>: if a proxy configuration is <code 
  class=literal>frozen</CODE>, then changes to the 
  configuration are no longer allowed. This is useful both as a slight 
  optimization and for those cases when you don't want callers to be able to 
  manipulate the proxy (via the <code class=interfacename 
  >Advised</CODE> interface) after the proxy has been 
  created. The default value of this property is <code class=literal 
  >false</CODE>, so changes such as adding additional advice 
  are allowed.</P>
  <li class=listitem>
  <p><code class=literal 
  >exposeProxy</CODE>: determines whether or not the current 
  proxy should be exposed in a <code class=classname 
  >ThreadLocal</CODE> so that it can be accessed by the 
  target. If a target needs to obtain the proxy and the <code class=literal 
  >exposeProxy</CODE> property is set to <code class=literal 
  >true</CODE>, the target can use the <code 
  class=methodname>AopContext.currentProxy()</CODE> 
  method.</P></LI></UL></DIV>
<p>Other properties specific to <code class=classname>ProxyFactoryBean</CODE> include:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><code class=literal 
  >proxyInterfaces</CODE>: array of String interface names. 
  If this isn't supplied, a CGLIB proxy for the target class will be used (but 
  see also <A class=xref title="10.5.3&nbsp;JDK- and CGLIB-based proxies" href="aop-api.html#aop-pfb-proxy-types" >Section&nbsp;10.5.3, “JDK- 
  and CGLIB-based proxies”</A>).</P>
  <li class=listitem>
  <p><code class=literal 
  >interceptorNames</CODE>: String array of <code 
  class=interfacename>Advisor</CODE>, interceptor or other 
  advice names to apply. Ordering is significant, on a first come-first served 
  basis. That is to say that the first interceptor in the list will be the first 
  to be able to intercept the invocation.</P>
  <p>The names are bean names in the current factory, 
  including bean names from ancestor factories. You can't mention bean 
  references here since doing so would result in the <code class=classname 
  >ProxyFactoryBean</CODE> ignoring the singleton setting of 
  the advice.</P>
  <p>You can append an interceptor name with an asterisk 
  (<code class=literal>*</CODE>). This will result in the 
  application of all advisor beans with names starting with the part before the 
  asterisk to be applied. An example of using this feature can be found in <A class=xref title="10.5.6&nbsp;Using 'global' advisors" href="aop-api.html#aop-global-advisors" >Section&nbsp;10.5.6, “Using 
  'global' advisors”</A>.</P>
  <li class=listitem>
  <p>singleton: whether or not the factory should return a 
  single object, no matter how often the <code class=literal 
  >getObject()</CODE> method is called. Several <code 
  class=interfacename>FactoryBean</CODE> implementations 
  offer such a method. The default value is <code class=literal 
  >true</CODE>. If you want to use stateful advice - for 
  example, for stateful mixins - use prototype advices along with a singleton 
  value of <code class=literal>false</CODE>.</P></LI></UL></DIV></DIV>
<div class=section title="10.5.3&nbsp;JDK- and CGLIB-based proxies">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-pfb-proxy-types></A>10.5.3&nbsp;JDK- and CGLIB-based 
proxies</H3></DIV></DIV></DIV>
<p>This section serves as the definitive documentation on 
how the <code class=classname>ProxyFactoryBean</CODE> 
chooses to create one of either a JDK- and CGLIB-based proxy for a particular 
target object (that is to be proxied).</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The behavior of the <code class=classname 
      >ProxyFactoryBean</CODE> with regard to creating JDK- 
      or CGLIB-based proxies changed between versions 1.2.x and 2.0 of Spring. 
      The <code class=classname>ProxyFactoryBean</CODE> now 
      exhibits similar semantics with regard to auto-detecting interfaces as 
      those of the <code class=classname 
      >TransactionProxyFactoryBean</CODE> 
  class.</P></TD></TR></TABLE></DIV>
<p>If the class of a target object that is to be proxied 
(hereafter simply referred to as the target class) doesn't implement any 
interfaces, then a CGLIB-based proxy will be created. This is the easiest 
scenario, because JDK proxies are interface based, and no interfaces means JDK 
proxying isn't even possible. One simply plugs in the target bean, and specifies 
the list of interceptors via the <code class=literal>interceptorNames</CODE> property. Note that a CGLIB-based 
proxy will be created even if the <code class=literal>proxyTargetClass</CODE> property of the <code 
class=classname>ProxyFactoryBean</CODE> has been set to 
<code class=literal>false</CODE>. (Obviously this makes no 
sense, and is best removed from the bean definition because it is at best 
redundant, and at worst confusing.)</P>
<p>If the target class implements one (or more) interfaces, 
then the type of proxy that is created depends on the configuration of the <code 
class=classname>ProxyFactoryBean</CODE>.</P>
<p>If the <code class=literal>proxyTargetClass</CODE> property of the <code 
class=classname>ProxyFactoryBean</CODE> has been set to 
<code class=literal>true</CODE>, then a CGLIB-based proxy 
will be created. This makes sense, and is in keeping with the principle of least 
surprise. Even if the <code class=literal>proxyInterfaces</CODE> property of the <code 
class=classname>ProxyFactoryBean</CODE> has been set to one 
or more fully qualified interface names, the fact that the <code class=literal>proxyTargetClass</CODE> property is set to <code 
class=literal>true</CODE> <span class=emphasis><em>will</EM></SPAN> cause CGLIB-based 
proxying to be in effect.</P>
<p>If the <code class=literal>proxyInterfaces</CODE> property of the <code 
class=classname>ProxyFactoryBean</CODE> has been set to one 
or more fully qualified interface names, then a JDK-based proxy will be created. 
The created proxy will implement all of the interfaces that were specified in 
the <code class=literal>proxyInterfaces</CODE> property; if 
the target class happens to implement a whole lot more interfaces than those 
specified in the <code class=literal>proxyInterfaces</CODE> 
property, that is all well and good but those additional interfaces will not be 
implemented by the returned proxy.</P>
<p>If the <code class=literal>proxyInterfaces</CODE> property of the <code 
class=classname>ProxyFactoryBean</CODE> has <span 
class=emphasis><em>not</EM></SPAN> 
been set, but the target class <span class=emphasis><em>does implement one (or more)</EM></SPAN> interfaces, then 
the <code class=classname>ProxyFactoryBean</CODE> will 
auto-detect the fact that the target class does actually implement at least one 
interface, and a JDK-based proxy will be created. The interfaces that are 
actually proxied will be <span class=emphasis><em>all</EM></SPAN> of the interfaces that the target class 
implements; in effect, this is the same as simply supplying a list of each and 
every interface that the target class implements to the <code class=literal>proxyInterfaces</CODE> property. However, it is 
significantly less work, and less prone to typos.</P></DIV>
<div class=section title="10.5.4&nbsp;Proxying interfaces">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-api-proxying-intf></A>10.5.4&nbsp;Proxying interfaces</H3></DIV></DIV></DIV>
<p>Let's look at a simple example of <code class=classname>ProxyFactoryBean</CODE> in action. This example 
involves:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>A <span class=emphasis><em 
  >target bean</EM></SPAN> that will be proxied. This is the 
  "personTarget" bean definition in the example below.</P>
  <li class=listitem>
  <p>An Advisor and an Interceptor used to provide 
  advice.</P>
  <li class=listitem>
  <p>An AOP proxy bean definition specifying the target 
  object (the personTarget bean) and the interfaces to proxy, along with the 
  advices to apply.</P></LI></UL></DIV><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"personTarget"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.PersonImpl"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Tony"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"age"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"51"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myAdvisor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.MyAdvisor"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"someProperty"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Custom string property value"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"debugInterceptor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.interceptor.DebugInterceptor"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"person"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.ProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"proxyInterfaces"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"com.mycompany.Person"</SPAN><span class=hl-tag>/&gt;</SPAN>

    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"personTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"interceptorNames"</SPAN><span class=hl-tag>&gt;</SPAN>
        <span class=hl-tag>&lt;list&gt;</SPAN>
            <span class=hl-tag>&lt;value&gt;</SPAN>myAdvisor<span class=hl-tag>&lt;/value&gt;</SPAN>
            <span class=hl-tag>&lt;value&gt;</SPAN>debugInterceptor<span class=hl-tag>&lt;/value&gt;</SPAN>
        <span class=hl-tag>&lt;/list&gt;</SPAN>
    <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>Note that the <code class=literal>interceptorNames</CODE> property takes a list of String: 
the bean names of the interceptor or advisors in the current factory. Advisors, 
interceptors, before, after returning and throws advice objects can be used. The 
ordering of advisors is significant.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>You might be wondering why the list doesn't hold 
      bean references. The reason for this is that if the ProxyFactoryBean's 
      singleton property is set to false, it must be able to return independent 
      proxy instances. If any of the advisors is itself a prototype, an 
      independent instance would need to be returned, so it's necessary to be 
      able to obtain an instance of the prototype from the factory; holding a 
      reference isn't sufficient.</P></TD></TR></TABLE></DIV>
<p>The "person" bean definition above can be used in place 
of a Person implementation, as follows:</P><pre class=programlisting>Person person = (Person) factory.getBean(<span class=hl-string>"person"</SPAN>);</PRE>
<p>Other beans in the same IoC context can express a 
strongly typed dependency on it, as with an ordinary Java object:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"personUser"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.PersonUser"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"person"</SPAN><span class=hl-tag>&gt;</SPAN><span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>local</SPAN>=<span class=hl-value>"person"</SPAN><span class=hl-tag>/&gt;</SPAN><span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The <code class=literal>PersonUser</CODE> class in this example would expose a 
property of type Person. As far as it's concerned, the AOP proxy can be used 
transparently in place of a "real" person implementation. However, its class 
would be a dynamic proxy class. It would be possible to cast it to the <code 
class=literal>Advised</CODE> interface (discussed 
below).</P>
<p>It's possible to conceal the distinction between target 
and proxy using an anonymous <span class=emphasis><em>inner bean</EM></SPAN>, as follows. Only the <code 
class=literal>ProxyFactoryBean</CODE> definition is 
different; the advice is included only for completeness:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myAdvisor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.MyAdvisor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"someProperty"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Custom string property value"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"debugInterceptor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.interceptor.DebugInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"person"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.ProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"proxyInterfaces"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"com.mycompany.Person"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-comment>&lt;!-- Use inner bean, not local reference to target --&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.PersonImpl"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Tony"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"age"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"51"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;/bean&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"interceptorNames"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;list&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>myAdvisor<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>debugInterceptor<span class=hl-tag>&lt;/value&gt;</SPAN>
    <span class=hl-tag>&lt;/list&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>This has the advantage that there's only one object of 
type <code class=literal>Person</CODE>: useful if we want 
to prevent users of the application context from obtaining a reference to the 
un-advised object, or need to avoid any ambiguity with Spring IoC <span 
class=emphasis><em>autowiring</EM></SPAN>. There's also arguably an advantage 
in that the ProxyFactoryBean definition is self-contained. However, there are 
times when being able to obtain the un-advised target from the factory might 
actually be an <span class=emphasis><em>advantage</EM></SPAN>: for example, in certain test 
scenarios.</P></DIV>
<div class=section title="10.5.5&nbsp;Proxying classes">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-api-proxying-class></A>10.5.5&nbsp;Proxying classes</H3></DIV></DIV></DIV>
<p>What if you need to proxy a class, rather than one or 
more interfaces?</P>
<p>Imagine that in our example above, there was no <code 
class=literal>Person</CODE> interface: we needed to advise 
a class called <code class=literal>Person</CODE> that 
didn't implement any business interface. In this case, you can configure Spring 
to use CGLIB proxying, rather than dynamic proxies. Simply set the <code 
class=literal>proxyTargetClass</CODE> property on the 
ProxyFactoryBean above to true. While it's best to program to interfaces, rather 
than classes, the ability to advise classes that don't implement interfaces can 
be useful when working with legacy code. (In general, Spring isn't prescriptive. 
While it makes it easy to apply good practices, it avoids forcing a particular 
approach.)</P>
<p>If you want to, you can force the use of CGLIB in any 
case, even if you do have interfaces.</P>
<p>CGLIB proxying works by generating a subclass of the 
target class at runtime. Spring configures this generated subclass to delegate 
method calls to the original target: the subclass is used to implement the <span 
class=emphasis><em>Decorator</EM></SPAN> pattern, weaving in the advice.</P>
<p>CGLIB proxying should generally be transparent to users. 
However, there are some issues to consider:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><code class=literal>Final</CODE> 
  methods can't be advised, as they can't be overridden.</P>
  <li class=listitem>
  <p>There is no need to add CGLIB to your classpath. As of 
  Spring 3.2, CGLIB is repackaged and included in the spring-core JAR. In other 
  words, CGLIB-based AOP will work "out of the box" just as do JDK dynamic 
  proxies.</P></LI></UL></DIV>
<p>There's little performance difference between CGLIB 
proxying and dynamic proxies. As of Spring 1.0, dynamic proxies are slightly 
faster. However, this may change in the future. Performance should not be a 
decisive consideration in this case.</P></DIV>
<div class=section title="10.5.6&nbsp;Using 'global' advisors">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-global-advisors></A>10.5.6&nbsp;Using 'global' 
advisors</H3></DIV></DIV></DIV>
<p>By appending an asterisk to an interceptor name, all 
advisors with bean names matching the part before the asterisk, will be added to 
the advisor chain. This can come in handy if you need to add a standard set of 
'global' advisors: </P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"proxy"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.ProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"service"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"interceptorNames"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;list&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>global*<span class=hl-tag>&lt;/value&gt;</SPAN>
    <span class=hl-tag>&lt;/list&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"global_debug"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.interceptor.DebugInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"global_performance"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.interceptor.PerformanceMonitorInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
</PRE></DIV></DIV>
<div class=section title="10.6&nbsp;Concise proxy definitions">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=aop-concise-proxy></A>10.6&nbsp;Concise proxy 
definitions</H2></DIV></DIV></DIV>
<p>Especially when defining transactional proxies, you may 
end up with many similar proxy definitions. The use of parent and child bean 
definitions, along with inner bean definitions, can result in much cleaner and 
more concise proxy definitions.</P>
<p>First a parent, <span class=emphasis><em>template</EM></SPAN>, bean 
definition is created for the proxy:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"txProxyTemplate"</SPAN> <span class=hl-attribute>abstract</SPAN>=<span class=hl-value>"true"</SPAN>
        <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionManager"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionManager"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionAttributes"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;props&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"*"</SPAN><span class=hl-tag>&gt;</SPAN>PROPAGATION_REQUIRED<span class=hl-tag>&lt;/prop&gt;</SPAN>
    <span class=hl-tag>&lt;/props&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>This will never be instantiated itself, so may actually 
be incomplete. Then each proxy which needs to be created is just a child bean 
definition, which wraps the target of the proxy as an inner bean definition, 
since the target will never be used on its own anyway.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myService"</SPAN> <span class=hl-attribute>parent</SPAN>=<span class=hl-value>"txProxyTemplate"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.samples.MyServiceImpl"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;/bean&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>It is of course possible to override properties from the 
parent template, such as in this case, the transaction propagation settings:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"mySpecialService"</SPAN> <span class=hl-attribute>parent</SPAN>=<span class=hl-value>"txProxyTemplate"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.samples.MySpecialServiceImpl"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;/bean&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionAttributes"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;props&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"get*"</SPAN><span class=hl-tag>&gt;</SPAN>PROPAGATION_REQUIRED,readOnly<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"find*"</SPAN><span class=hl-tag>&gt;</SPAN>PROPAGATION_REQUIRED,readOnly<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"load*"</SPAN><span class=hl-tag>&gt;</SPAN>PROPAGATION_REQUIRED,readOnly<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"store*"</SPAN><span class=hl-tag>&gt;</SPAN>PROPAGATION_REQUIRED<span class=hl-tag>&lt;/prop&gt;</SPAN>
    <span class=hl-tag>&lt;/props&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>Note that in the example above, we have explicitly 
marked the parent bean definition as <span class=emphasis><em>abstract</EM></SPAN> by using the 
<span class=emphasis><em>abstract</EM></SPAN> attribute, as described <A class=link title="5.7&nbsp;Bean definition inheritance" href="beans.html#beans-child-bean-definitions" >previously</A>, so that 
it may not actually ever be instantiated. Application contexts (but not simple 
bean factories) will by default pre-instantiate all singletons. It is therefore 
important (at least for singleton beans) that if you have a (parent) bean 
definition which you intend to use only as a template, and this definition 
specifies a class, you must make sure to set the <span class=emphasis><em>abstract</EM></SPAN> attribute to 
<span class=emphasis><em>true</EM></SPAN>, otherwise the application context will 
actually try to pre-instantiate it.</P></DIV>
<div class=section 
title="10.7&nbsp;Creating AOP proxies programmatically with the ProxyFactory">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=aop-prog></A>10.7&nbsp;Creating AOP proxies programmatically with 
the ProxyFactory</H2></DIV></DIV></DIV>
<p>It's easy to create AOP proxies programmatically using 
Spring. This enables you to use Spring AOP without dependency on Spring IoC.</P>
<p>The following listing shows creation of a proxy for a 
target object, with one interceptor and one advisor. The interfaces implemented 
by the target object will automatically be proxied:</P><pre class=programlisting>ProxyFactory factory = <span class=hl-keyword>new</SPAN> ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</PRE>
<p>The first step is to construct an object of type <code 
class=literal>org.springframework.aop.framework.ProxyFactory</CODE>. You 
can create this with a target object, as in the above example, or specify the 
interfaces to be proxied in an alternate constructor.</P>
<p>You can add advices (with interceptors as a specialized 
kind of advice) and/or advisors, and manipulate them for the life of the 
ProxyFactory. If you add an IntroductionInterceptionAroundAdvisor, you can cause 
the proxy to implement additional interfaces.</P>
<p>There are also convenience methods on ProxyFactory 
(inherited from <code class=classname>AdvisedSupport</CODE>) which allow you to add other advice 
types such as before and throws advice. AdvisedSupport is the superclass of both 
ProxyFactory and ProxyFactoryBean.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Integrating AOP proxy creation with the IoC 
      framework is best practice in most applications. We recommend that you 
      externalize configuration from Java code with AOP, as in 
  general.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="10.8&nbsp;Manipulating advised objects">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=aop-api-advised></A>10.8&nbsp;Manipulating advised 
objects</H2></DIV></DIV></DIV>
<p>However you create AOP proxies, you can manipulate them 
using the <code class=literal>org.springframework.aop.framework.Advised</CODE> interface. 
Any AOP proxy can be cast to this interface, whichever other interfaces it 
implements. This interface includes the following methods:</P><pre class=programlisting>Advisor[] getAdvisors();

<span class=hl-keyword>void</SPAN> addAdvice(Advice advice) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>void</SPAN> addAdvice(<span class=hl-keyword>int</SPAN> pos, Advice advice)
        <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>void</SPAN> addAdvisor(Advisor advisor) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>void</SPAN> addAdvisor(<span class=hl-keyword>int</SPAN> pos, Advisor advisor) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>int</SPAN> indexOf(Advisor advisor);

<span class=hl-keyword>boolean</SPAN> removeAdvisor(Advisor advisor) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>void</SPAN> removeAdvisor(<span class=hl-keyword>int</SPAN> index) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>boolean</SPAN> replaceAdvisor(Advisor a, Advisor b) <span class=hl-keyword>throws</SPAN> AopConfigException;

<span class=hl-keyword>boolean</SPAN> isFrozen();</PRE>
<p>The <code class=literal>getAdvisors()</CODE> method will return an Advisor for 
every advisor, interceptor or other advice type that has been added to the 
factory. If you added an Advisor, the returned advisor at this index will be the 
object that you added. If you added an interceptor or other advice type, Spring 
will have wrapped this in an advisor with a pointcut that always returns true. 
Thus if you added a <code class=literal>MethodInterceptor</CODE>, the advisor returned for this 
index will be an <code class=literal>DefaultPointcutAdvisor</CODE> returning your <code 
class=literal>MethodInterceptor</CODE> and a pointcut that 
matches all classes and methods.</P>
<p>The <code class=literal>addAdvisor()</CODE> methods can be used to add any Advisor. 
Usually the advisor holding pointcut and advice will be the generic <code 
class=literal>DefaultPointcutAdvisor</CODE>, which can be 
used with any advice or pointcut (but not for introductions).</P>
<p>By default, it's possible to add or remove advisors or 
interceptors even once a proxy has been created. The only restriction is that 
it's impossible to add or remove an introduction advisor, as existing proxies 
from the factory will not show the interface change. (You can obtain a new proxy 
from the factory to avoid this problem.)</P>
<p>A simple example of casting an AOP proxy to the <code 
class=literal>Advised</CODE> interface and examining and 
manipulating its advice:</P><pre class=programlisting>Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
<span class=hl-keyword>int</SPAN> oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + <span class=hl-string>" advisors"</SPAN>);

<span class=hl-comment>// Add an advice like an interceptor without a pointcut</SPAN>
<span class=hl-comment>// Will match all proxied methods</SPAN>
<span class=hl-comment>// Can use for interceptors, before, after returning or throws advice</SPAN>
advised.addAdvice(<span class=hl-keyword>new</SPAN> DebugInterceptor());

<span class=hl-comment>// Add selective advice using a pointcut</SPAN>
advised.addAdvisor(<span class=hl-keyword>new</SPAN> DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals(<span class=hl-string>"Added two advisors"</SPAN>,
     oldAdvisorCount + <span class=hl-number>2</SPAN>, advised.getAdvisors().length);</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>It's questionable whether it's advisable (no pun 
      intended) to modify advice on a business object in production, although 
      there are no doubt legitimate usage cases. However, it can be very useful 
      in development: for example, in tests. I have sometimes found it very 
      useful to be able to add test code in the form of an interceptor or other 
      advice, getting inside a method invocation I want to test. (For example, 
      the advice can get inside a transaction created for that method: for 
      example, to run SQL to check that a database was correctly updated, before 
      marking the transaction for roll back.)</P></TD></TR></TABLE></DIV>
<p>Depending on how you created the proxy, you can usually 
set a <code class=literal>frozen</CODE> flag, in which case 
the <code class=literal>Advised</CODE> <code class=literal>isFrozen()</CODE> method will return true, and any attempts 
to modify advice through addition or removal will result in an <code 
class=literal>AopConfigException</CODE>. The ability to 
freeze the state of an advised object is useful in some cases, for example, to 
prevent calling code removing a security interceptor. It may also be used in 
Spring 1.1 to allow aggressive optimization if runtime advice modification is 
known not to be required.</P></DIV>
<div class=section title='10.9&nbsp;Using the "autoproxy" facility'>
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=aop-autoproxy></A>10.9&nbsp;Using the "autoproxy" 
facility</H2></DIV></DIV></DIV>
<p>So far we've considered explicit creation of AOP proxies 
using a <code class=literal>ProxyFactoryBean</CODE> or 
similar factory bean.</P>
<p>Spring also allows us to use "autoproxy" bean 
definitions, which can automatically proxy selected bean definitions. This is 
built on Spring "bean post processor" infrastructure, which enables modification 
of any bean definition as the container loads.</P>
<p>In this model, you set up some special bean definitions 
in your XML bean definition file to configure the auto proxy infrastructure. 
This allows you just to declare the targets eligible for autoproxying: you don't 
need to use <code class=literal>ProxyFactoryBean</CODE>.</P>
<p>There are two ways to do this:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Using an autoproxy creator that refers to specific 
  beans in the current context.</P>
  <li class=listitem>
  <p>A special case of autoproxy creation that deserves to 
  be considered separately; autoproxy creation driven by source-level metadata 
  attributes.</P></LI></UL></DIV>
<div class=section title="10.9.1&nbsp;Autoproxy bean definitions">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-autoproxy-choices></A>10.9.1&nbsp;Autoproxy bean 
definitions</H3></DIV></DIV></DIV>
<p>The <code class=literal>org.springframework.aop.framework.autoproxy</CODE> package 
provides the following standard autoproxy creators.</P>
<div class=section title=BeanNameAutoProxyCreator>
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=aop-api-autoproxy></A>BeanNameAutoProxyCreator</H4></DIV></DIV></DIV>
<p>The <code class=literal>BeanNameAutoProxyCreator</CODE> class is a <code 
class=literal>BeanPostProcessor</CODE> that automatically 
creates AOP proxies for beans with names matching literal values or 
wildcards.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"beanNames"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"jdk*,onlyJdk"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"interceptorNames"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;list&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>myInterceptor<span class=hl-tag>&lt;/value&gt;</SPAN>
    <span class=hl-tag>&lt;/list&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>As with <code class=literal>ProxyFactoryBean</CODE>, there is an <code class=literal>interceptorNames</CODE> property rather than a list of 
interceptors, to allow correct behavior for prototype advisors. Named 
"interceptors" can be advisors or any advice type.</P>
<p>As with auto proxying in general, the main point of 
using <code class=literal>BeanNameAutoProxyCreator</CODE> 
is to apply the same configuration consistently to multiple objects, with 
minimal volume of configuration. It is a popular choice for applying declarative 
transactions to multiple objects.</P>
<p>Bean definitions whose names match, such as "jdkMyBean" 
and "onlyJdk" in the above example, are plain old bean definitions with the 
target class. An AOP proxy will be created automatically by the <code 
class=literal>BeanNameAutoProxyCreator</CODE>. The same 
advice will be applied to all matching beans. Note that if advisors are used 
(rather than the interceptor in the above example), the pointcuts may apply 
differently to different beans.</P></DIV>
<div class=section title=DefaultAdvisorAutoProxyCreator>
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=aop-api-autoproxy-default></A>DefaultAdvisorAutoProxyCreator</H4></DIV></DIV></DIV>
<p>A more general and extremely powerful auto proxy creator 
is <code class=literal>DefaultAdvisorAutoProxyCreator</CODE>. This will 
automagically apply eligible advisors in the current context, without the need 
to include specific bean names in the autoproxy advisor's bean definition. It 
offers the same merit of consistent configuration and avoidance of duplication 
as <code class=literal>BeanNameAutoProxyCreator</CODE>.</P>
<p>Using this mechanism involves:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Specifying a <code class=literal 
  >DefaultAdvisorAutoProxyCreator</CODE> bean 
definition.</P>
  <li class=listitem>
  <p>Specifying any number of Advisors in the same or 
  related contexts. Note that these <span class=emphasis 
  ><em>must</EM></SPAN> be Advisors, 
  not just interceptors or other advices. This is necessary because there must 
  be a pointcut to evaluate, to check the eligibility of each advice to 
  candidate bean definitions.</P></LI></UL></DIV>
<p>The <code class=literal>DefaultAdvisorAutoProxyCreator</CODE> will automatically 
evaluate the pointcut contained in each advisor, to see what (if any) advice it 
should apply to each business object (such as "businessObject1" and 
"businessObject2" in the example).</P>
<p>This means that any number of advisors can be applied 
automatically to each business object. If no pointcut in any of the advisors 
matches any method in a business object, the object will not be proxied. As bean 
definitions are added for new business objects, they will automatically be 
proxied if necessary.</P>
<p>Autoproxying in general has the advantage of making it 
impossible for callers or dependencies to obtain an un-advised object. Calling 
getBean("businessObject1") on this ApplicationContext will return an AOP proxy, 
not the target business object. (The "inner bean" idiom shown earlier also 
offers this benefit.)</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"customAdvisor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.MyAdvisor"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"businessObject1"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.BusinessObject1"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-comment>&lt;!-- Properties omitted --&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"businessObject2"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.BusinessObject2"</SPAN><span class=hl-tag>/&gt;</SPAN>
</PRE>
<p>The <code class=literal>DefaultAdvisorAutoProxyCreator</CODE> is very useful if you 
want to apply the same advice consistently to many business objects. Once the 
infrastructure definitions are in place, you can simply add new business objects 
without including specific proxy configuration. You can also drop in additional 
aspects very easily - for example, tracing or performance monitoring aspects - 
with minimal change to configuration.</P>
<p>The DefaultAdvisorAutoProxyCreator offers support for 
filtering (using a naming convention so that only certain advisors are 
evaluated, allowing use of multiple, differently configured, 
AdvisorAutoProxyCreators in the same factory) and ordering. Advisors can 
implement the <code class=literal>org.springframework.core.Ordered</CODE> interface to ensure 
correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used 
in the above example has a configurable order value; the default setting is 
unordered.</P></DIV>
<div class=section title=AbstractAdvisorAutoProxyCreator>
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=aop-api-autoproxy-abstract></A>AbstractAdvisorAutoProxyCreator</H4></DIV></DIV></DIV>
<p>This is the superclass of 
DefaultAdvisorAutoProxyCreator. You can create your own autoproxy creators by 
subclassing this class, in the unlikely event that advisor definitions offer 
insufficient customization to the behavior of the framework <code class=literal>DefaultAdvisorAutoProxyCreator</CODE>.</P></DIV></DIV>
<div class=section title="10.9.2&nbsp;Using metadata-driven auto-proxying">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-autoproxy-metadata></A>10.9.2&nbsp;Using metadata-driven 
auto-proxying</H3></DIV></DIV></DIV>
<p>A particularly important type of autoproxying is driven 
by metadata. This produces a similar programming model to .NET <code 
class=literal>ServicedComponents</CODE>. Instead of using 
XML deployment descriptors as in EJB, configuration for transaction management 
and other enterprise services is held in source-level attributes.</P>
<p>In this case, you use the <code class=literal>DefaultAdvisorAutoProxyCreator</CODE>, in combination with 
Advisors that understand metadata attributes. The metadata specifics are held in 
the pointcut part of the candidate advisors, rather than in the autoproxy 
creation class itself.</P>
<p>This is really a special case of the <code class=literal>DefaultAdvisorAutoProxyCreator</CODE>, but deserves 
consideration on its own. (The metadata-aware code is in the pointcuts contained 
in the advisors, not the AOP framework itself.)</P>
<p>The <code class=literal>/attributes</CODE> directory of the JPetStore sample 
application shows the use of attribute-driven autoproxying. In this case, 
there's no need to use the <code class=literal>TransactionProxyFactoryBean</CODE>. Simply defining 
transactional attributes on business objects is sufficient, because of the use 
of metadata-aware pointcuts. The bean definitions include the following code, in 
<code class=literal>/WEB-INF/declarativeServices.xml</CODE>. Note that this is 
generic, and can be used outside the JPetStore:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionInterceptor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionManager"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionManager"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionAttributeSource"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"attributes"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"attributes"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;/bean&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"attributes"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.metadata.commons.CommonsAttributes"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>The <code class=literal>DefaultAdvisorAutoProxyCreator</CODE> bean definition (the 
name is not significant, hence it can even be omitted) will pick up all eligible 
pointcuts in the current application context. In this case, the 
"transactionAdvisor" bean definition, of type <code class=literal>TransactionAttributeSourceAdvisor</CODE>, will apply to 
classes or methods carrying a transaction attribute. The 
TransactionAttributeSourceAdvisor depends on a TransactionInterceptor, via 
constructor dependency. The example resolves this via autowiring. The <code 
class=literal>AttributesTransactionAttributeSource</CODE> 
depends on an implementation of the <code class=literal>org.springframework.metadata.Attributes</CODE> interface. 
In this fragment, the "attributes" bean satisfies this, using the Jakarta 
Commons Attributes API to obtain attribute information. (The application code 
must have been compiled using the Commons Attributes compilation task.)</P>
<p>The <code class=literal>/annotation</CODE> directory of the JPetStore sample 
application contains an analogous example for auto-proxying driven by JDK 1.5+ 
annotations. The following configuration enables automatic detection of Spring's 
<code class=literal>Transactional</CODE> annotation, 
leading to implicit proxies for beans containing that annotation:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"transactionInterceptor"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.interceptor.TransactionInterceptor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionManager"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"transactionManager"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"transactionAttributeSource"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The <code class=literal>TransactionInterceptor</CODE> defined here depends on a 
<code class=literal>PlatformTransactionManager</CODE> 
definition, which is not included in this generic file (although it could be) 
because it will be specific to the application's transaction requirements 
(typically JTA, as in this example, or Hibernate, JDO or JDBC):</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"transactionManager"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.transaction.jta.JtaTransactionManager"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If you require only declarative transaction 
      management, using these generic XML definitions will result in Spring 
      automatically proxying all classes or methods with transaction attributes. 
      You won't need to work directly with AOP, and the programming model is 
      similar to that of .NET ServicedComponents.</P></TD></TR></TABLE></DIV>
<p>This mechanism is extensible. It's possible to do 
autoproxying based on custom attributes. You need to:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Define your custom attribute.</P>
  <li class=listitem>
  <p>Specify an Advisor with the necessary advice, 
  including a pointcut that is triggered by the presence of the custom attribute 
  on a class or method. You may be able to use an existing advice, merely 
  implementing a static pointcut that picks up the custom 
attribute.</P></LI></UL></DIV>
<p>It's possible for such advisors to be unique to each 
advised class (for example, mixins): they simply need to be defined as 
prototype, rather than singleton, bean definitions. For example, the <code 
class=literal>LockMixin</CODE> introduction interceptor 
from the Spring test suite, shown above, could be used in conjunction with an 
attribute-driven pointcut to target a mixin, as shown here. We use the generic 
<code class=literal>DefaultPointcutAdvisor</CODE>, 
configured using JavaBean properties:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"lockMixin"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.LockMixin"</SPAN>
    <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"prototype"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"lockableAdvisor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.support.DefaultPointcutAdvisor"</SPAN>
    <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"prototype"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"pointcut"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"myAttributeAwarePointcut"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"advice"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"lockMixin"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"anyBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"anyclass"</SPAN> <span class=hl-attribute>...</SPAN></PRE>
<p>If the attribute aware pointcut matches any methods in 
the <code class=literal>anyBean</CODE> or other bean 
definitions, the mixin will be applied. Note that both <code class=literal>lockMixin</CODE> and <code class=literal>lockableAdvisor</CODE> definitions are prototypes. The 
<code class=literal>myAttributeAwarePointcut</CODE> 
pointcut can be a singleton definition, as it doesn't hold state for individual 
advised objects.</P></DIV></DIV>
<div class=section title="10.10&nbsp;Using TargetSources">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=aop-targetsource></A>10.10&nbsp;Using 
TargetSources</H2></DIV></DIV></DIV>
<p>Spring offers the concept of a <span class=emphasis><em>TargetSource</EM></SPAN>, 
expressed in the <code class=literal>org.springframework.aop.TargetSource</CODE> interface. This 
interface is responsible for returning the "target object" implementing the join 
point. The <code class=literal>TargetSource</CODE> 
implementation is asked for a target instance each time the AOP proxy handles a 
method invocation.</P>
<p>Developers using Spring AOP don't normally need to work 
directly with TargetSources, but this provides a powerful means of supporting 
pooling, hot swappable and other sophisticated targets. For example, a pooling 
TargetSource can return a different target instance for each invocation, using a 
pool to manage instances.</P>
<p>If you do not specify a TargetSource, a default 
implementation is used that wraps a local object. The same target is returned 
for each invocation (as you would expect).</P>
<p>Let's look at the standard target sources provided with 
Spring, and how you can use them.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>When using a custom target source, your target 
      will usually need to be a prototype rather than a singleton bean 
      definition. This allows Spring to create a new target instance when 
      required.</P></TD></TR></TABLE></DIV>
<div class=section title="10.10.1&nbsp;Hot swappable target sources">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-ts-swap></A>10.10.1&nbsp;Hot swappable target 
sources</H3></DIV></DIV></DIV>
<p>The <code class=literal>org.springframework.aop.target.HotSwappableTargetSource</CODE> 
exists to allow the target of an AOP proxy to be switched while allowing callers 
to keep their references to it.</P>
<p>Changing the target source's target takes effect 
immediately. The <code class=literal>HotSwappableTargetSource</CODE> is threadsafe.</P>
<p>You can change the target via the <code class=literal>swap()</CODE> method on HotSwappableTargetSource as 
follows:</P><pre class=programlisting>HotSwappableTargetSource swapper =
    (HotSwappableTargetSource) beanFactory.getBean(<span class=hl-string>"swapper"</SPAN>);
Object oldTarget = swapper.swap(newTarget);</PRE>
<p>The XML definitions required look as follows:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"initialTarget"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"mycompany.OldTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"swapper"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.target.HotSwappableTargetSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"initialTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"swappable"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.ProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetSource"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"swapper"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The above <code class=literal>swap()</CODE> call changes the target of the swappable 
bean. Clients who hold a reference to that bean will be unaware of the change, 
but will immediately start hitting the new target.</P>
<p>Although this example doesn't add any advice - and it's 
not necessary to add advice to use a <code class=literal>TargetSource</CODE> - of course any <code class=literal>TargetSource</CODE> can be used in conjunction with 
arbitrary advice.</P></DIV>
<div class=section title="10.10.2&nbsp;Pooling target sources">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-ts-pool></A>10.10.2&nbsp;Pooling target 
sources</H3></DIV></DIV></DIV>
<p>Using a pooling target source provides a similar 
programming model to stateless session EJBs, in which a pool of identical 
instances is maintained, with method invocations going to free objects in the 
pool.</P>
<p>A crucial difference between Spring pooling and SLSB 
pooling is that Spring pooling can be applied to any POJO. As with Spring in 
general, this service can be applied in a non-invasive way.</P>
<p>Spring provides out-of-the-box support for Jakarta 
Commons Pool 1.3, which provides a fairly efficient pooling implementation. 
You'll need the commons-pool Jar on your application's classpath to use this 
feature. It's also possible to subclass <code class=literal>org.springframework.aop.target.AbstractPoolingTargetSource</CODE> 
to support any other pooling API.</P>
<p>Sample configuration is shown below:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"businessObjectTarget"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.mycompany.MyBusinessObject"</SPAN>
    <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"prototype"</SPAN><span class=hl-tag>&gt;</SPAN>
  ... properties omitted
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"poolTargetSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.target.CommonsPoolTargetSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetBeanName"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"businessObjectTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"maxSize"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"25"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"businessObject"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.framework.ProxyFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetSource"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"poolTargetSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"interceptorNames"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"myInterceptor"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>Note that the target object - "businessObjectTarget" in 
the example - <span class=emphasis><em>must</EM></SPAN> be a prototype. This allows the <code 
class=literal>PoolingTargetSource</CODE> implementation to 
create new instances of the target to grow the pool as necessary. See the 
javadoc for <code class=literal>AbstractPoolingTargetSource</CODE> and the concrete 
subclass you wish to use for information about its properties: "maxSize" is the 
most basic, and always guaranteed to be present.</P>
<p>In this case, "myInterceptor" is the name of an 
interceptor that would need to be defined in the same IoC context. However, it 
isn't necessary to specify interceptors to use pooling. If you want only 
pooling, and no other advice, don't set the interceptorNames property at 
all.</P>
<p>It's possible to configure Spring so as to be able to 
cast any pooled object to the <code class=literal>org.springframework.aop.target.PoolingConfig</CODE> 
interface, which exposes information about the configuration and current size of 
the pool through an introduction. You'll need to define an advisor like 
this:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"poolConfigAdvisor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetObject"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"poolTargetSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetMethod"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"getPoolingConfigMixin"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>This advisor is obtained by calling a convenience method 
on the <code class=literal>AbstractPoolingTargetSource</CODE> class, hence the use of 
MethodInvokingFactoryBean. This advisor's name ("poolConfigAdvisor" here) must 
be in the list of interceptors names in the ProxyFactoryBean exposing the pooled 
object.</P>
<p>The cast will look as follows:</P><pre class=programlisting>PoolingConfig conf = (PoolingConfig) beanFactory.getBean(<span class=hl-string>"businessObject"</SPAN>);
System.out.println(<span class=hl-string>"Max pool size is "</SPAN> + conf.getMaxSize());</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Pooling stateless service objects is not usually 
      necessary. We don't believe it should be the default choice, as most 
      stateless objects are naturally thread safe, and instance pooling is 
      problematic if resources are cached.</P></TD></TR></TABLE></DIV>
<p>Simpler pooling is available using autoproxying. It's 
possible to set the TargetSources used by any autoproxy creator.</P></DIV>
<div class=section title="10.10.3&nbsp;Prototype target sources">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-ts-prototype></A>10.10.3&nbsp;Prototype target 
sources</H3></DIV></DIV></DIV>
<p>Setting up a "prototype" target source is similar to a 
pooling TargetSource. In this case, a new instance of the target will be created 
on every method invocation. Although the cost of creating a new object isn't 
high in a modern JVM, the cost of wiring up the new object (satisfying its IoC 
dependencies) may be more expensive. Thus you shouldn't use this approach 
without very good reason.</P>
<p>To do this, you could modify the <code class=literal>poolTargetSource</CODE> definition shown above as follows. 
(I've also changed the name, for clarity.)</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"prototypeTargetSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.target.PrototypeTargetSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetBeanName"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"businessObjectTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>There's only one property: the name of the target bean. 
Inheritance is used in the TargetSource implementations to ensure consistent 
naming. As with the pooling target source, the target bean must be a prototype 
bean definition.</P></DIV>
<div class=section title="10.10.4&nbsp;ThreadLocal target sources">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aop-ts-threadlocal></A>10.10.4&nbsp;<code class=classname>ThreadLocal</CODE> target sources</H3></DIV></DIV></DIV>
<p><code class=classname>ThreadLocal</CODE> target sources are useful if you need an 
object to be created for each incoming request (per thread that is). The concept 
of a <code class=classname>ThreadLocal</CODE> provide a 
JDK-wide facility to transparently store resource alongside a thread. Setting up 
a <code class=classname>ThreadLocalTargetSource</CODE> is 
pretty much the same as was explained for the other types of target source:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"threadlocalTargetSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.aop.target.ThreadLocalTargetSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetBeanName"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"businessObjectTarget"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>ThreadLocals come with serious issues (potentially 
      resulting in memory leaks) when incorrectly using them in a multi-threaded 
      and multi-classloader environments. One should always consider wrapping a 
      threadlocal in some other class and never directly use the <code 
      class=classname>ThreadLocal</CODE> itself (except of 
      course in the wrapper class). Also, one should always remember to 
      correctly set and unset (where the latter simply involved a call to <code 
      class=literal>ThreadLocal.set(null)</CODE>) the 
      resource local to the thread. Unsetting should be done in any case since 
      not unsetting it might result in problematic behavior. Spring's 
      ThreadLocal support does this for you and should always be considered in 
      favor of using ThreadLocals without other proper handling 
  code.</P></TD></TR></TABLE></DIV></DIV></DIV>
<div class=section title="10.11&nbsp;Defining new Advice types">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=aop-extensibility></A>10.11&nbsp;Defining new <code 
class=interfacename>Advice</CODE> 
types</H2></DIV></DIV></DIV>
<p>Spring AOP is designed to be extensible. While the 
interception implementation strategy is presently used internally, it is 
possible to support arbitrary advice types in addition to the out-of-the-box 
interception around advice, before, throws advice and after returning 
advice.</P>
<p>The <code class=literal>org.springframework.aop.framework.adapter</CODE> package is 
an SPI package allowing support for new custom advice types to be added without 
changing the core framework. The only constraint on a custom <code 
class=interfacename>Advice</CODE> type is that it must 
implement the <code class=interfacename>org.aopalliance.aop.Advice</CODE> tag interface.</P>
<p>Please refer to the <code class=literal>org.springframework.aop.framework.adapter</CODE> package's 
Javadocs for further information.</P></DIV>
<div class=section title="10.12&nbsp;Further resources">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=aop-api-resources></A>10.12&nbsp;Further 
resources</H2></DIV></DIV></DIV>
<p>Please refer to the Spring sample applications for 
further examples of Spring AOP:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>The JPetStore's default configuration illustrates the 
  use of the <code class=classname 
  >TransactionProxyFactoryBean</CODE> for declarative 
  transaction management.</P>
  <li class=listitem>
  <p>The <code class=literal 
  >/attributes</CODE> directory of the JPetStore illustrates 
  the use of attribute-driven declarative transaction 
management.</P></LI></UL></DIV></DIV>
</div>
<div class=navfooter>
<hr>

<table summary="Navigation footer" width="100%">
  
  <tr>
    <td width="40%" align=left><A accessKey=p href="aop.html" >Prev</A>&nbsp;</TD>
    <td width="20%" align=center><A accessKey=u href="spring-core.html" >Up</A></TD>
    <td width="40%" align=right>&nbsp;<A accessKey=n href="testing.html" >Next</A></TD></TR>
  <tr>
    <td vAlign=top width="40%" align=left>9.&nbsp;Aspect 
      Oriented Programming with Spring&nbsp;</TD>
    <td width="20%" align=center><A accessKey=h href="index.html" >Home</A></TD>
    <td vAlign=top width="40%" align=right 
      >&nbsp;11.&nbsp;Testing</TD></TR></TABLE></DIV></body>