<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0014)about:internet -->
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>5. The IoC container</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="prev" href="spring-core.html" title="Part&nbsp;III.&nbsp;Core Technologies"><link rel="next" href="resources.html" title="6.&nbsp;Resources"></head><body bgcolor="white" text="black" link="#0000ff" vlink="#840084" alink="#0000ff"><script language="JavaScript" type="text/JavaScript">
function syn(){
if(parent.nav.tree){
 if(parent.nav.tree.loaded){
  parent.nav.tree.selectNode(81);
 }else{
  setTimeout("syn()",500);
}
  }else{
  setTimeout("syn()",500);
  }}
if(parent!=self){
  setTimeout("syn()",100);
}else{
  parent.location.href = "../index.htm#page=beans.html";
}
originalOnload = window.onload;
if(originalOnload==null){
window.onload = function(){parent.contentLoaded = true;};
}else{
window.onload = function(){originalOnload();parent.contentLoaded = true;};
}
</script> 
<div class="navheader"><table summary="Navigation header" width="100%"><tr><th colspan="3" align="center">5.&nbsp;The IoC container</th></tr><tr><td width="20%" align="left"><A accessKey=p href="spring-core.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Core Technologies</th><td width="20%" align="right">&nbsp;<A accessKey=n href="resources.html">Next</a></td></tr></table><hr></div><div class="chapter" title="5.&nbsp;The IoC container"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>5.&nbsp;The IoC container</h2></div></div></div>
  

  <div class="section" title="5.1&nbsp;Introduction to the Spring IoC container and beans"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="beans-introduction"></a>5.1&nbsp;Introduction to the Spring IoC container and beans</h2></div></div></div>
    

    <p>This chapter covers the Spring Framework implementation of the
      Inversion of Control (IoC) <sup>[<A class=footnote href="#ftn.d4e1140" name=d4e1140>1</a>]</sup>principle. IoC is also known as <span class="emphasis"><em>dependency
      injection</em></span> (DI). It is a process whereby objects define their
      dependencies, that is, the other objects they work with, only through
      constructor arguments, arguments to a factory method, or properties that
      are set on the object instance after it is constructed or returned from a
      factory method. The container then <span class="emphasis"><em>injects</em></span> those
      dependencies when it creates the bean. This process is fundamentally the
      inverse, hence the name <span class="emphasis"><em>Inversion of Control</em></span> (IoC),
      of the bean itself controlling the instantiation or location of its
      dependencies by using direct construction of classes, or a mechanism such
      as the <span class="emphasis"><em>Service Locator</em></span> pattern.</p>

    

    <p>The <code class="literal">org.springframework.beans</code> and
      <code class="literal">org.springframework.context</code> packages are the basis for
      Spring Framework's IoC container. The <code class="interfacename"><a class="ulink" href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></code> interface provides an advanced
      configuration mechanism capable of managing any type of object.
      <code class="literal"><a class="ulink" href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></code> is a sub-interface of
      <code class="interfacename">BeanFactory.</code> It adds easier integration
      with Spring's AOP features; message resource handling (for use in
      internationalization), event publication; and application-layer specific
      contexts such as the <code class="interfacename">WebApplicationContext</code>
      for use in web applications.</p>

    <p>In short, the <code class="interfacename">BeanFactory</code> provides the
      configuration framework and basic functionality, and the
      <code class="interfacename">ApplicationContext</code> adds more
      enterprise-specific functionality. The
      <code class="interfacename">ApplicationContext</code> is a complete superset
      of the <code class="interfacename">BeanFactory</code>, and is used exclusively
      in this chapter in descriptions of Spring's IoC container.
      For
      more information on using the <code class="classname">BeanFactory</code> instead
      of the <code class="classname">ApplicationContext,</code> refer to <A class=xref title="5.15&nbsp;The BeanFactory" href="beans.html#beans-beanfactory" >Section&nbsp;5.15, “The BeanFactory”</a>.</p>

    <p>In Spring, the objects that form the backbone of your application and
      that are managed by the Spring IoC <em class="firstterm">container</em> are
      called <em class="firstterm">beans</em>. A bean is an object that is
      instantiated, assembled, and otherwise managed by a Spring IoC container.
      Otherwise, a bean is simply one of many objects in your application.
      Beans, and the <em class="firstterm">dependencies</em> among them, are
      reflected in the <em class="firstterm">configuration metadata</em> used by a
      container.</p>
  </div>

  <div class="section" title="5.2&nbsp;Container overview"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="beans-basics"></a>5.2&nbsp;Container overview</h2></div></div></div>
    

    <p>The interface
      <code class="classname">org.springframework.context.ApplicationContext</code>
      represents the Spring IoC container and is responsible for instantiating,
      configuring, and assembling the aforementioned beans. The container gets
      its instructions on what objects to instantiate, configure, and assemble
      by reading configuration metadata. The configuration metadata is
      represented in XML, Java annotations, or Java code. It allows you to
      express the objects that compose your application and the rich
      interdependencies between such objects.</p>

    <p>Several implementations of the
      <code class="classname">ApplicationContext</code> interface are supplied
      out-of-the-box with Spring. In standalone applications it is common to
      create an instance of <a class="ulink" href="http://static.springsource.org/spring/docs/current/api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_top"><code class="classname">ClassPathXmlApplicationContext</code></a> or <a class="ulink" href="http://static.springsource.org/spring/docs/current/api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_top"><code class="classname">FileSystemXmlApplicationContext</code></a>.
       While XML has been the traditional format
      for defining configuration metadata you can instruct the container to use
      Java annotations or code as the metadata format by providing a small amount
      of XML configuration to declaratively enable support for these additional
      metadata formats.</p>

    <p>In most application scenarios, explicit user code is not required to
      instantiate one or more instances of a Spring IoC container. For example,
      in a web application scenario, a simple eight (or so) lines of boilerplate
      J2EE web descriptor XML in the <code class="literal">web.xml</code> file of the
      application will typically suffice (see <A class=xref title="5.14.4&nbsp;Convenient ApplicationContext instantiation for web applications" href="beans.html#context-create" >Section&nbsp;5.14.4, “Convenient <code class="interfacename">ApplicationContext</code>
      instantiation for web applications”</a>).
      If you are using the <a class="ulink" href="http://www.springsource.com/produts/sts" target="_top">SpringSource Tool Suite</a> Eclipse-powered development environment
      or <a class="ulink" href="http://www.springsource.org/roo" target="_top">Spring Roo</a> this
      boilerplate configuration can be easily created with few mouse clicks or
      keystrokes.</p>

    <p>The following diagram is a high-level view of how Spring works. Your
      application classes are combined with configuration metadata so that after
      the <code class="classname">ApplicationContext</code> is created and initialized,
      you have a fully configured and executable system or application.</p>

    <div class="mediaobject" align="center"><IMG align=middle src="images/container-magic.png"><div class="caption"><p>The Spring IoC container</p></div></div>

    <div class="section" title="5.2.1&nbsp;Configuration metadata"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-metadata"></a>5.2.1&nbsp;Configuration metadata</h3></div></div></div>
      

      <p>As the preceding diagram shows, the Spring IoC container consumes a
        form of <span class="emphasis"><em>configuration metadata</em></span>; this configuration
        metadata represents how you as an application developer tell the Spring
        container to instantiate, configure, and assemble the objects in your
        application.</p>

      <p>Configuration metadata is traditionally supplied in a simple and
        intuitive XML format, which is what most of this chapter uses to convey
        key concepts and features of the Spring IoC container.</p>

      <div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>XML-based metadata is <span class="emphasis"><em>not</em></span> the only allowed
          form of configuration metadata. The Spring IoC container itself is
          <span class="emphasis"><em>totally</em></span> decoupled from the format in which this
          configuration metadata is actually written.</p>
      </td></tr></table></div>

      <p>For information about using other forms of metadata with the Spring
        container, see:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><A class=link title="5.9&nbsp;Annotation-based container configuration" href="beans.html#beans-annotation-config" >Annotation-based
            configuration</a>: Spring 2.5 introduced support for
            annotation-based configuration metadata.</p><li class="listitem">
          <p><A class=link title="5.12&nbsp;Java-based container configuration" href="beans.html#beans-java" >Java-based configuration</a>:
            Starting with Spring 3.0, many features provided by the <a class="ulink" href="http://www.springsource.org/javaconfig" target="_top">Spring JavaConfig
            project</a> became part of the core Spring Framework. Thus you
            can define beans external to your application classes by using Java
            rather than XML files. To use these new features, see the
            <code class="interfacename">@Configuration</code>, <code class="interfacename">@Bean,
            @Import</code> and
            <code class="interfacename">@DependsOn</code> annotations.</p>
        </li></ul></div>

      <p>Spring configuration consists of at least one and typically more
        than one bean definition that the container must manage. XML-based
        configuration metadata shows these beans configured as
        <code class="literal">&lt;bean/&gt;</code> elements inside a top-level
        <code class="literal">&lt;beans/&gt;</code> element.</p>

      <p>These bean definitions correspond to the actual objects that make up
        your application. Typically you define service layer objects, data
        access objects (DAOs), presentation objects such as Struts
        <code class="interfacename">Action</code> instances, infrastructure objects
        such as Hibernate <code class="interfacename">SessionFactories</code>, JMS
        <code class="interfacename">Queues</code>, and so forth. Typically one does
        not configure fine-grained domain objects in the container, because it
        is usually the responsibility of DAOs and business logic to create and
        load domain objects. However, you can use Spring's integration with
        AspectJ to configure objects that have been created outside the control
        of an IoC container. See <A class=link title="9.8.1&nbsp;Using AspectJ to dependency inject domain objects with Spring" href="aop.html#aop-atconfigurable" >Using
        AspectJ to dependency-inject domain objects with Spring</a>.</p>

      <p>The following example shows the basic structure of XML-based
        configuration metadata:</p>

      <pre class="programlisting"><span class="hl-directive" style="COLOR: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

  <span class="hl-comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <p>The <code class="literal">id</code> attribute is a string that you use to
        identify the individual bean definition. The <code class="literal">class</code>
        attribute defines the type of the bean and uses the fully qualified
        classname. The value of the id attribute refers to collaborating
        objects. The XML for referring to collaborating objects is not shown in
        this example; see <A class=link title=5.4&nbsp;Dependencies href="beans.html#beans-dependencies">Dependencies</a>
        for more information.</p>
    </div>

    <div class="section" title="5.2.2&nbsp;Instantiating a container"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-instantiation"></a>5.2.2&nbsp;Instantiating a container</h3></div></div></div>
      

      <p>Instantiating a Spring IoC container is straightforward. The
        location path or paths supplied to an
        <code class="interfacename">ApplicationContext</code> constructor are
        actually resource strings that allow the container to load configuration
        metadata from a variety of external resources such as the local file
        system, from the Java <code class="literal">CLASSPATH</code>, and so on.</p>

      <pre class="programlisting">ApplicationContext context =
    <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-keyword">new</span> String[] {<span class="hl-string">"services.xml"</span>, <span class="hl-string">"daos.xml"</span>});</pre>

      <div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>After you learn about Spring's IoC container, you may want to know
          more about Spring's <code class="interfacename">Resource</code>
          abstraction, as described in <A class=xref title=6.&nbsp;Resources href="resources.html">Chapter&nbsp;6, <i>Resources</i></a>, which
          provides a convenient mechanism for reading an InputStream from
          locations defined in a URI syntax. In particular,
          <code class="classname">Resource</code> paths are used to construct
          applications contexts as described in <A class=xref title="6.7&nbsp;Application contexts and Resource paths" href="resources.html#resources-app-ctx" >Section&nbsp;6.7, “Application contexts and <code class="interfacename">Resource</code> paths”</a>.</p>
      </td></tr></table></div>

      <p>The following example shows the service layer objects
        <code class="literal">(services.xml)</code> configuration file:</p>

      <pre class="programlisting"><span class="hl-directive" style="COLOR: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

  <span class="hl-comment">&lt;!-- services --&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"petStore"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accountDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accountDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"itemDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"itemDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

  <span class="hl-comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span>
</pre>

      <p>The following example shows the data access objects
        <code class="literal">daos.xml</code> file:</p>

      <pre class="programlisting"><span class="hl-directive" style="COLOR: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountDao"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.samples.jpetstore.dao.ibatis.SqlMapAccountDao"</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"itemDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.samples.jpetstore.dao.ibatis.SqlMapItemDao"</span><span class="hl-tag">&gt;</span>
    <span class="hl-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>

  <span class="hl-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <p>In the preceding example, the service layer consists of the class
        <code class="classname">PetStoreServiceImpl</code>, and two data access objects
        of the type <code class="classname">SqlMapAccountDao</code> and SqlMapItemDao
        are based on the <a class="ulink" href="http://ibatis.apache.org/" target="_top">iBatis</a>
        Object/Relational mapping framework. The <code class="literal">property
        name</code> element refers to the name of the JavaBean property, and
        the <code class="literal">ref</code> element refers to the name of another bean
        definition. This linkage between id and ref elements expresses the
        dependency between collaborating objects. For details of configuring an
        object's dependencies, see <A class=link title=5.4&nbsp;Dependencies href="beans.html#beans-dependencies">Dependencies</a>.</p>

      <div class="section" title="Composing XML-based configuration metadata"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-xml-import"></a>Composing XML-based configuration metadata</h4></div></div></div>
        

        <p>It can be useful to have bean definitions span multiple XML files.
          Often each individual XML configuration file represents a logical
          layer or module in your architecture.</p>

        <p>You can use the application context constructor to load bean
          definitions from all these XML fragments. This constructor takes
          multiple <code class="interfacename">Resource</code> locations, as was
          shown in the previous section. Alternatively, use one or more
          occurrences of the <code class="literal">&lt;import/&gt;</code> element to load
          bean definitions from another file or files. For example:</p>

        <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;import</span> <span class="hl-attribute">resource</span>=<span class="hl-value">"services.xml"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;import</span> <span class="hl-attribute">resource</span>=<span class="hl-value">"resources/messageSource.xml"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;import</span> <span class="hl-attribute">resource</span>=<span class="hl-value">"/resources/themeSource.xml"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"bean1"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"bean2"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"..."</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

        <p>In the preceding example, external bean definitions are loaded
          from three files, <code class="literal">services.xml</code>,
          <code class="literal">messageSource.xml</code>, and
          <code class="literal">themeSource.xml</code>. All location paths are relative to
          the definition file doing the importing, so
          <code class="literal">services.xml</code> must be in the same directory or
          classpath location as the file doing the importing, while
          <code class="literal">messageSource.xml</code> and
          <code class="literal">themeSource.xml</code> must be in a
          <code class="literal">resources</code> location below the location of the
          importing file. As you can see, a leading slash is ignored, but given
          that these paths are relative, it is better form not to use the slash
          at all. The contents of the files being imported, including the top
          level <code class="literal">&lt;beans/&gt;</code> element, must be valid XML
          bean definitions according to the Spring Schema or DTD.</p>

        <div class="note" title="Note" style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in"><table border="0" summary=Note><tr><td rowspan="2" align="center" valign="top" width="25"><IMG alt=[Note] src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          <p>It is possible, but not recommended, to reference files in
            parent directories using a relative "../" path. Doing so creates a
            dependency on a file that is outside the current application. In
            particular, this reference is not recommended for "classpath:" URLs
            (for example, "classpath:../services.xml"), where the runtime
            resolution process chooses the "nearest" classpath root and then
            looks into its parent directory. Classpath configuration changes may
            lead to the choice of a different, incorrect directory.</p>

          <p>You can always use fully qualified resource locations instead of
            relative paths: for example, "file:C:/config/services.xml" or
            "classpath:/config/services.xml". However, be aware that you are
            coupling your application's configuration to specific absolute
            locations. It is generally preferable to keep an indirection for
            such absolute locations, for example, through "${...}" placeholders
            that are resolved against JVM system properties at runtime.</p>
        </td></tr></table></div>
      </div>
    </div>

    <div class="section" title="5.2.3&nbsp;Using the container"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-client"></a>5.2.3&nbsp;Using the container</h3></div></div></div>
      

      <p>The <code class="interfacename">ApplicationContext</code> is the
        interface for an advanced factory capable of maintaining a registry of
        different beans and their dependencies. Using the method <code class="methodname">T
        getBean(String name, Class&lt;T&gt; requiredType)</code> you can
        retrieve instances of your beans.</p>

      <p>The <code class="interfacename">ApplicationContext</code> enables you to
        read bean definitions and access them as follows:</p>

      <pre class="programlisting"><span class="hl-comment">// create and configure beans</span>
ApplicationContext context =
    <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-keyword">new</span> String[] {<span class="hl-string">"services.xml"</span>, <span class="hl-string">"daos.xml"</span>});

<span class="hl-comment">// retrieve configured instance</span>
PetStoreServiceImpl service = context.getBean(<span class="hl-string">"petStore"</span>, PetStoreServiceImpl.<span class="hl-keyword">class</span>);

<span class="hl-comment">// use configured instance</span>
List userList = service.getUsernameList();
</pre>

      <p>You use <code class="methodname">getBean()</code> to retrieve instances of
        your beans. The <code class="interfacename">ApplicationContext</code>
        interface has a few other methods for retrieving beans, but ideally your
        application code should never use them. Indeed, your application code
        should have no calls to the <code class="methodname">getBean()</code> method at
        all, and thus no dependency on Spring APIs at all. For example, Spring's
        integration with web frameworks provides for dependency injection for
        various web framework classes such as controllers and JSF-managed
        beans.</p>
    </div>
  </div>

  <div class="section" title="5.3&nbsp;Bean overview"><div class="titlepage"><div><div><h2 class="title" style="CLEAR: both"><a name="beans-definition"></a>5.3&nbsp;Bean overview</h2></div></div></div>
    

    <p>A Spring IoC container manages one or more <span class="emphasis"><em>beans</em></span>.
      These beans are created with the configuration metadata that you supply to
      the container, for example, in the form of XML
      <code class="literal">&lt;bean/&gt;</code> definitions.</p>

    <p>Within the container itself, these bean definitions are represented as
      <code class="interfacename">BeanDefinition</code> objects, which contain
      (among other information) the following metadata:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><span class="emphasis"><em>A package-qualified class name:</em></span> typically the
          actual implementation class of the bean being defined.</p><li class="listitem">
        <p>Bean behavioral configuration elements, which state how the bean
          should behave in the container (scope, lifecycle callbacks, and so
          forth).</p><li class="listitem">
        <p>References to other beans that are needed for the bean to do its
          work; these references are also called
          <span class="emphasis"><em>collaborators</em></span> or
          <span class="emphasis"><em>dependencies</em></span>.</p><li class="listitem">
        <p>Other configuration settings to set in the newly created object,
          for example, the number of connections to use in a bean that manages a
          connection pool, or the size limit of the pool.</p>
      </li></ul></div>

    <p>This metadata translates to a set of properties that make up each bean
      definition.</p>

    <div class="table"><a name="beans-factory-bean-definition-tbl"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;The bean definition</b></p><div class="table-contents">
      

      <table style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" summary      ="The bean definition"><colgroup><col><col></colgroup><thead><tr><th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >Property</th><th style="BORDER-BOTTOM: 0.5pt solid"  >Explained in...</th></tr></thead><tbody><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >class</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.3.2&nbsp;Instantiating beans" href="beans.html#beans-factory-class" >Section&nbsp;5.3.2, “Instantiating beans”</a> </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >name</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.3.1&nbsp;Naming beans" href="beans.html#beans-beanname" >Section&nbsp;5.3.1, “Naming beans”</a> </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >scope</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.5&nbsp;Bean scopes" href="beans.html#beans-factory-scopes" >Section&nbsp;5.5, “Bean scopes”</a> </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >constructor arguments</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.4.1&nbsp;Dependency injection" href="beans.html#beans-factory-collaborators" >Section&nbsp;5.4.1, “Dependency injection”</a>
              </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >properties</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.4.1&nbsp;Dependency injection" href="beans.html#beans-factory-collaborators" >Section&nbsp;5.4.1, “Dependency injection”</a>
              </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >autowiring mode</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.4.5&nbsp;Autowiring collaborators" href="beans.html#beans-factory-autowire" >Section&nbsp;5.4.5, “Autowiring collaborators”</a>
              </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >lazy-initialization mode</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="5.4.4&nbsp;Lazy-initialized beans" href="beans.html#beans-factory-lazy-init" >Section&nbsp;5.4.4, “Lazy-initialized
      beans”</a>
              </p></td></tr><tr><td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
     >initialization method</td><td style="BORDER-BOTTOM: 0.5pt solid"  ><p> <A class=xref title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" >the section called “Initialization callbacks”</a>
              </p></td></tr><tr><td style="BORDER-RIGHT: 0.5pt solid"  >destruction method</td><td><p> <A class=xref title="Destruction callbacks" href="beans.html#beans-factory-lifecycle-disposablebean" >the section called “Destruction callbacks”</a> </p></td></tr></tbody></table>
    </div></div><br class="table-break">

    <p>In addition to bean definitions that contain information on how to
      create a specific bean, the
      <code class="interfacename">ApplicationContext</code> implementations also
      permit the registration of existing objects that are created outside the
      container, by users. This is done by accessing the ApplicationContext's
      BeanFactory via the method <code class="methodname">getBeanFactory()</code> which
      returns the BeanFactory implementation
      <code class="classname">DefaultListableBeanFactory</code>.
      <code class="classname">DefaultListableBeanFactory</code> supports this
      registration through the methods
      <code class="methodname">registerSingleton(..)</code> and
      <code class="methodname">registerBeanDefinition(..)</code>. However, typical
      applications work solely with beans defined through metadata bean
      definitions.</p>

    <div class="section" title="5.3.1&nbsp;Naming beans"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beanname"></a>5.3.1&nbsp;Naming beans</h3></div></div></div>
      

      <p>Every bean has one or more identifiers. These identifiers must be
        unique within the container that hosts the bean. A bean usually has only
        one identifier, but if it requires more than one, the extra ones can be
        considered aliases.</p>

      <p>In XML-based configuration metadata, you use the
        <code class="literal">id</code> and/or <code class="literal">name</code> attributes to
        specify the bean identifier(s). The <code class="literal">id</code> attribute
        allows you to specify exactly one id.  Conventionally these names are
        alphanumeric ('myBean', 'fooService', etc), but may special characters
        as well.  If you want to introduce other aliases to the bean, you can
        also specify them in the <code class="literal">name</code> attribute, separated by
        a comma (<code class="literal">,</code>), semicolon (<code class="literal">;</code>), or
        white space.  As a historical note, in versions prior to Spring 3.1, the
        <code class="literal">id</code> attribute was typed as an
        <code class="literal">xsd:ID</code>, which constrained possible characters.  As of
        3.1, it is now <code class="literal">xsd:string</code>.  Note that bean id
        uniqueness is still enforced by the container, though no longer by XML
        parsers.</p>

      <p>You are not required to supply a name or id for a bean. If no name
        or id is supplied explicitly, the container generates a unique name for
        that bean. However, if you want to refer to that bean by name, through
        the use of the <code class="literal">ref</code> element or <A class=link title="5.15.2&nbsp;Glue code and the evil singleton" href="beans.html#beans-servicelocator" >Service Locator</a> style lookup,
        you must provide a name. Motivations for not supplying a name are
        related to using <A class=link title="Inner beans" href="beans.html#beans-inner-beans" >inner beans</a>
        and <A class=link title="5.4.5&nbsp;Autowiring collaborators" href="beans.html#beans-factory-autowire" >autowiring
        collaborators</a>.</p>

      <div class="sidebar" title="Bean naming conventions"><p class="title"><b>Bean naming conventions</b></p>
        

        <p>The convention is to use the standard Java convention for instance
          field names when naming beans. That is, bean names start with a
          lowercase letter, and are camel-cased from then on. Examples of such
          names would be (without quotes) <code class="literal">'accountManager'</code>,
          <code class="literal">'accountService'</code>, <code class="literal">'userDao'</code>,
          <code class="literal">'loginController'</code>, and so forth.</p>

        <p>Naming beans consistently makes your configuration easier to read
          and understand, and if you are using Spring AOP it helps a lot when
          applying advice to a set of beans related by name.</p>
      </div>

      <div class="section" title="Aliasing a bean outside the bean definition"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beanname-alias"></a>Aliasing a bean outside the bean definition</h4></div></div></div>
        

        <p>In a bean definition itself, you can supply more than one name for
          the bean, by using a combination of up to one name specified by the
          <code class="literal">id</code> attribute, and any number of other names in the
          <code class="literal">name</code> attribute. These names can be equivalent
          aliases to the same bean, and are useful for some situations, such as
          allowing each component in an application to refer to a common
          dependency by using a bean name that is specific to that component
          itself.</p>

        <p>Specifying all aliases where the bean is actually defined is not
          always adequate, however. It is sometimes desirable to introduce an
          alias for a bean that is defined elsewhere. This is commonly the case
          in large systems where configuration is split amongst each subsystem,
          each subsystem having its own set of object definitions. In XML-based
          configuration metadata, you can use the
          <code class="literal">&lt;alias/&gt;</code> element to accomplish this.</p>

        <pre class="programlisting"><span class="hl-tag">&lt;alias</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fromName"</span> <span class=hl-attribute>alias</SPAN>=<span class=hl-value>"toName"</SPAN><span class=hl-tag>/&gt;</SPAN></pre>
<p>In this case, a bean in the same container which is 
named <code class=literal>fromName</CODE>, may also after 
the use of this alias definition, be referred to as <code class=literal>toName</CODE>.</P>
<p>For example, the configuration metadata for subsystem A 
may refer to a DataSource via the name 'subsystemA-dataSource. The configuration 
metadata for subsystem B may refer to a DataSource via the name 
'subsystemB-dataSource'. When composing the main application that uses both 
these subsystems the main application refers to the DataSource via the name 
'myApp-dataSource'. To have all three names refer to the same object you add to 
the MyApp configuration metadata the following aliases definitions:</P><pre class=programlisting><span class=hl-tag>&lt;alias</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"subsystemA-dataSource"</SPAN> <span class=hl-attribute>alias</SPAN>=<span class=hl-value>"subsystemB-dataSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;alias</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"subsystemA-dataSource"</SPAN> <span class=hl-attribute>alias</SPAN>=<span class=hl-value>"myApp-dataSource"</SPAN><span class=hl-tag> /&gt;</SPAN></PRE>
<p>Now each component and the main application can refer to 
the dataSource through a name that is unique and guaranteed not to clash with 
any other definition (effectively creating a namespace), yet they refer to the 
same bean.</P>
      </div>
    </div>
<div class=section title="5.3.2&nbsp;Instantiating beans">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-class></A>5.3.2&nbsp;Instantiating beans</H3></DIV></DIV></DIV>
<p>A bean definition essentially is a recipe for creating 
one or more objects. The container looks at the recipe for a named bean when 
asked, and uses the configuration metadata encapsulated by that bean definition 
to create (or acquire) an actual object.</P>
<p>If you use XML-based configuration metadata, you specify 
the type (or class) of object that is to be instantiated in the <code 
class=literal>class</CODE> attribute of the <code 
class=literal>&lt;bean/&gt;</CODE> element. This <code 
class=literal>class</CODE> attribute, which internally is a 
<code class=classname>Class</CODE> property on a <code 
class=interfacename>BeanDefinition</CODE> instance, is 
usually mandatory. (For exceptions, see <A class=xref title="Instantiation using an instance factory method" href="beans.html#beans-factory-class-instance-factory-method" >the 
section called “Instantiation using an instance factory method”</A> and <A class=xref title="5.7&nbsp;Bean definition inheritance" href="beans.html#beans-child-bean-definitions" >Section&nbsp;5.7, “Bean 
definition inheritance”</A>.) You use the <code class=classname>Class</CODE> property in one of two ways: </P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Typically, to specify the bean class to be constructed 
  in the case where the container itself directly creates the bean by calling 
  its constructor reflectively, somewhat equivalent to Java code using the <code 
  class=code>new</CODE> operator.</P></LI></UL></DIV>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>To specify the actual class containing the <code 
  class=literal>static</CODE> factory method that will be 
  invoked to create the object, in the less common case where the container 
  invokes a <code class=literal>static</CODE>, <span 
  class=emphasis><em 
  >factory</EM></SPAN> method on a class to create the bean. 
  The object type returned from the invocation of the <code class=literal 
  >static</CODE> factory method may be the same class or 
  another class entirely.</P></LI></UL></DIV>
<div class=sidebar title="Inner class names">
<p class=title><b>Inner class 
names</B></P>
<p>If you want to configure a bean definition for a <code 
class=literal>static</CODE> nested class, you have to use 
the <span class=emphasis><em>binary</EM></SPAN> name of the inner class.</P>
<p>For example, if you have a class called <code 
class=classname>Foo</CODE> in the <code class=literal>com.example</CODE> package, and this <code class=classname>Foo</CODE> class has a <code class=literal>static</CODE> inner class called <code class=classname>Bar</CODE>, the value of the <code class=literal>'class'</CODE> attribute on a bean definition would 
be...</P>
<p><code class=classname>com.example.Foo$Bar</CODE></P>
<p>Notice the use of the <code class=literal>$</CODE> character in the name to separate the inner class 
name from the outer class name.</P></DIV>
<div class=section title="Instantiation with a constructor">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-class-ctor></A>Instantiation with a constructor</H4></DIV></DIV></DIV>
<p>When you create a bean by the constructor approach, all 
normal classes are usable by and compatible with Spring. That is, the class 
being developed does not need to implement any specific interfaces or to be 
coded in a specific fashion. Simply specifying the bean class should suffice. 
However, depending on what type of IoC you use for that specific bean, you may 
need a default (empty) constructor.</P>
<p>The Spring IoC container can manage virtually <span 
class=emphasis><em>any</EM></SPAN> 
class you want it to manage; it is not limited to managing true JavaBeans. Most 
Spring users prefer actual JavaBeans with only a default (no-argument) 
constructor and appropriate setters and getters modeled after the properties in 
the container. You can also have more exotic non-bean-style classes in your 
container. If, for example, you need to use a legacy connection pool that 
absolutely does not adhere to the JavaBean specification, Spring can manage it 
as well.</P>
<p>With XML-based configuration metadata you can specify 
your bean class as follows:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"anotherExample"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBeanTwo"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>For details about the mechanism for supplying arguments 
to the constructor (if required) and setting object instance properties after 
the object is constructed, see <A class=link title="5.4.1&nbsp;Dependency injection" href="beans.html#beans-factory-collaborators" >Injecting 
Dependencies</A>.</P></DIV>
<div class=section title="Instantiation with a static factory method">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-class-static-factory-method></A>Instantiation with a static factory 
method</H4></DIV></DIV></DIV>
<p>When defining a bean that you create with a static 
factory method, you use the <code class=literal>class</CODE> attribute to specify the class containing the 
<code class=literal>static</CODE> factory method and an 
attribute named <code class=literal>factory-method</CODE> 
to specify the name of the factory method itself. You should be able to call 
this method (with optional arguments as described later) and return a live 
object, which subsequently is treated as if it had been created through a 
constructor. One use for such a bean definition is to call <code class=literal>static</CODE> factories in legacy code.</P>
<p>The following bean definition specifies that the bean 
will be created by calling a factory-method. The definition does not specify the 
type (class) of the returned object, only the class containing the factory 
method. In this example, the <code class=methodname>createInstance()</CODE> method must be a <span 
class=emphasis><em>static</EM></SPAN> 
method.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"clientService"</SPAN>
      <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ClientService"</SPAN>
      <span class=hl-attribute>factory-method</SPAN>=<span class=hl-value>"createInstance"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ClientService {
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>static</SPAN> ClientService clientService = <span class=hl-keyword>new</SPAN> ClientService();
  <span class=hl-keyword>private</SPAN> ClientService() {}

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> ClientService createInstance() {
    <span class=hl-keyword>return</SPAN> clientService;
  }
}</PRE>
<p>For details about the mechanism for supplying (optional) 
arguments to the factory method and setting object instance properties after the 
object is returned from the factory, see <A class=link title="5.4.2&nbsp;Dependencies and configuration in detail" href="beans.html#beans-factory-properties-detailed" >Dependencies and 
configuration in detail</A>.</P></DIV>
<div class=section title="Instantiation using an instance factory method">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-class-instance-factory-method></A>Instantiation using an instance factory 
method</H4></DIV></DIV></DIV>
<p>Similar to instantiation through a <A class=link title="Instantiation with a static factory method" href="beans.html#beans-factory-class-static-factory-method" >static 
factory method</A>, instantiation with an instance factory method invokes a 
non-static method of an existing bean from the container to create a new bean. 
To use this mechanism, leave the <code class=literal>class 
</CODE>attribute empty, and in the <code class=literal>factory-bean</CODE> attribute, specify the name of a bean 
in the current (or parent/ancestor) container that contains the instance method 
that is to be invoked to create the object. Set the name of the factory method 
itself with the <code class=literal>factory-method</CODE> 
attribute.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"serviceLocator"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.DefaultServiceLocator"</SPAN><span class=hl-tag>&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this locator bean --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- the bean to be created via the factory bean --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"clientService"</SPAN>
      <span class=hl-attribute>factory-bean</SPAN>=<span class=hl-value>"serviceLocator"</SPAN>
      <span class=hl-attribute>factory-method</SPAN>=<span class=hl-value>"createClientServiceInstance"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> DefaultServiceLocator {
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>static</SPAN> ClientService clientService = <span class=hl-keyword>new</SPAN> ClientServiceImpl();
  <span class=hl-keyword>private</SPAN> DefaultServiceLocator() {}

  <span class=hl-keyword>public</SPAN> ClientService createClientServiceInstance() {
    <span class=hl-keyword>return</SPAN> clientService;
  }
}</PRE>
<p>One factory class can also hold more than one factory 
method as shown here:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"serviceLocator"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.DefaultServiceLocator"</SPAN><span class=hl-tag>&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this locator bean --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"clientService"</SPAN>
      <span class=hl-attribute>factory-bean</SPAN>=<span class=hl-value>"serviceLocator"</SPAN>
      <span class=hl-attribute>factory-method</SPAN>=<span class=hl-value>"createClientServiceInstance"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN>
      <span class=hl-attribute>factory-bean</SPAN>=<span class=hl-value>"serviceLocator"</SPAN>
      <span class=hl-attribute>factory-method</SPAN>=<span class=hl-value>"createAccountServiceInstance"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> DefaultServiceLocator {
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>static</SPAN> ClientService clientService = <span class=hl-keyword>new</SPAN> ClientServiceImpl();
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>static</SPAN> AccountService accountService = <span class=hl-keyword>new</SPAN> AccountServiceImpl();

  <span class=hl-keyword>private</SPAN> DefaultServiceLocator() {}

  <span class=hl-keyword>public</SPAN> ClientService createClientServiceInstance() {
    <span class=hl-keyword>return</SPAN> clientService;
  }

  <span class=hl-keyword>public</SPAN> AccountService createAccountServiceInstance() {
    <span class=hl-keyword>return</SPAN> accountService;
  }
}</PRE>
<p>This approach shows that the factory bean itself can be 
managed and configured through dependency injection (DI). See <A class=link title="5.4.2&nbsp;Dependencies and configuration in detail" href="beans.html#beans-factory-properties-detailed" ><A class=link title="5.4.2&nbsp;Dependencies and configuration in detail" href="beans.html#beans-factory-properties-detailed" >Dependencies and 
configuration in detail</A>.</A></P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>In Spring documentation,<span class=emphasis 
      ><em> factory bean</EM></SPAN> 
      refers to a bean that is configured in the Spring container that will 
      create objects through an <A class=link title="Instantiation using an instance factory method" href="beans.html#beans-factory-class-instance-factory-method" >instance</A> 
      or <A class=link title="Instantiation with a static factory method" href="beans.html#beans-factory-class-static-factory-method" >static</A> 
      factory method. By contrast, <code class=interfacename 
      >FactoryBean</CODE> (notice the capitalization) refers 
      to a Spring-specific <A class=link title="5.8.3&nbsp;Customizing instantiation logic with a FactoryBean" href="beans.html#beans-factory-extension-factorybean" ><code 
      class=interfacename>FactoryBean</CODE> 
  </A>.</P></TD></TR></TABLE></DIV></DIV></DIV>
  </div>
<div class=section title=5.4&nbsp;Dependencies>
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-dependencies></A>5.4&nbsp;Dependencies</H2></DIV></DIV></DIV>
<p>A typical enterprise application does not consist of a 
single object (or bean in the Spring parlance). Even the simplest application 
has a few objects that work together to present what the end-user sees as a 
coherent application. This next section explains how you go from defining a 
number of bean definitions that stand alone to a fully realized application 
where objects collaborate to achieve a goal.</P>
<div class=section title="5.4.1&nbsp;Dependency injection">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-collaborators></A>5.4.1&nbsp;Dependency injection</H3></DIV></DIV></DIV>
<p><span class=emphasis><em>Dependency injection</EM></SPAN> (DI) is a process whereby 
objects define their dependencies, that is, the other objects they work with, 
only through constructor arguments, arguments to a factory method, or properties 
that are set on the object instance after it is constructed or returned from a 
factory method. The container then <span class=emphasis><em>injects</EM></SPAN> those dependencies when it creates the 
bean. This process is fundamentally the inverse, hence the name <span 
class=emphasis><em>Inversion of 
Control</EM></SPAN> (IoC), of the bean itself controlling the instantiation or 
location of its dependencies on its own by using direct construction of classes, 
or the <span class=emphasis><em>Service Locator</EM></SPAN> pattern.</P>
<p>Code is cleaner with the DI principle and decoupling is 
more effective when objects are provided with their dependencies. The object 
does not look up its dependencies, and does not know the location or class of 
the dependencies. As such, your classes become easier to test, in particular 
when the dependencies are on interfaces or abstract base classes, which allow 
for stub or mock implementations to be used in unit tests.</P>
<p>DI exists in two major variants, <A class=link title="Constructor-based dependency injection" href="beans.html#beans-constructor-injection" >Constructor-based 
dependency injection</A> and <A class=link title="Setter-based dependency injection" href="beans.html#beans-setter-injection" >Setter-based dependency 
injection</A>.</P>
<div class=section title="Constructor-based dependency injection">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-constructor-injection></A>Constructor-based dependency 
injection</H4></DIV></DIV></DIV>
<p><span class=emphasis><em>Constructor-based</EM></SPAN> DI is accomplished by the 
container invoking a constructor with a number of arguments, each representing a 
dependency. Calling a <code class=literal>static</CODE> 
factory method with specific arguments to construct the bean is nearly 
equivalent, and this discussion treats arguments to a constructor and to a <code 
class=literal>static</CODE> factory method similarly. The 
following example shows a class that can only be dependency-injected with 
constructor injection. Notice that there is nothing <span class=emphasis><em>special</EM></SPAN> about this 
class, it is a POJO that has no dependencies on container specific interfaces, 
base classes or annotations.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <em class=lineannotation><span class=lineannotation>// the SimpleMovieLister has a dependency on a MovieFinder</SPAN></EM>
  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <em class=lineannotation><span class=lineannotation>// a constructor so that the Spring container can 'inject' a MovieFinder</SPAN></EM>
  <span class=hl-keyword>public</SPAN> SimpleMovieLister(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }

  <em class=lineannotation><span class=lineannotation>// business logic that actually 'uses' the injected MovieFinder is omitted...</SPAN></EM>
}</PRE>
<div class=section title="Constructor argument resolution">
<div class=titlepage>
<div>
<div>
<h5 class=title><a 
name=beans-factory-ctor-arguments-resolution></A>Constructor argument resolution</H5></DIV></DIV></DIV>
<p>Constructor argument resolution matching occurs using 
the argument's type. If no potential ambiguity exists in the constructor 
arguments of a bean definition, then the order in which the constructor 
arguments are defined in a bean definition is the order in which those arguments 
are supplied to the appropriate constructor when the bean is being instantiated. 
Consider the following class:</P><pre class=programlisting><span class=hl-keyword>package</SPAN> x.y;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> Foo {

  <span class=hl-keyword>public</SPAN> Foo(Bar bar, Baz baz) {
      <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
  }
}</PRE>
<p>No potential ambiguity exists, assuming that <code 
class=classname>Bar</CODE> and <code class=classname>Baz</CODE> classes are not related by inheritance. Thus the 
following configuration works fine, and you do not need to specify the 
constructor argument indexes and/or types explicitly in the <code class=literal>&lt;constructor-arg/&gt;</CODE> element.</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"foo"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Foo"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"bar"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"baz"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"bar"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Bar"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"baz"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Baz"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>When another bean is referenced, the type is known, and 
matching can occur (as was the case with the preceding example). When a simple 
type is used, such as <code class=literal>&lt;value&gt;true&lt;value&gt;</CODE>, Spring cannot 
determine the type of the value, and so cannot match by type without help. 
Consider the following class:</P><pre class=programlisting><span class=hl-keyword>package</SPAN> examples;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <em class=lineannotation><span class=lineannotation>// No. of years to the calculate the Ultimate Answer</SPAN></EM>
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>int</SPAN> years;

  <em class=lineannotation><span class=lineannotation>// The Answer to Life, the Universe, and Everything</SPAN></EM>
  <span class=hl-keyword>private</SPAN> String ultimateAnswer;

  <span class=hl-keyword>public</SPAN> ExampleBean(<span class=hl-keyword>int</SPAN> years, String ultimateAnswer) {
      <span class=hl-keyword>this</SPAN>.years = years;
      <span class=hl-keyword>this</SPAN>.ultimateAnswer = ultimateAnswer;
  }
}</PRE>
<div class=section title="Constructor argument type matching">
<div class=titlepage>
<div>
<div>
<h6 class=title><a name=beans-factory-ctor-arguments-type></A>Constructor argument type 
matching</H6></DIV></DIV></DIV>
<p>In the preceding scenario, the container <span 
class=emphasis><em>can</EM></SPAN> use 
type matching with simple types if you explicitly specify the type of the 
constructor argument using the <code class=literal>type</CODE> attribute. For example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"int"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"7500000"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"java.lang.String"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"42"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE></DIV>
<div class=section title="Constructor argument index">
<div class=titlepage>
<div>
<div>
<h6 class=title><a name=beans-factory-ctor-arguments-index></A>Constructor argument index</H6></DIV></DIV></DIV>
<p>Use the <code class=literal>index</CODE> attribute to specify explicitly the index of 
constructor arguments. For example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>index</SPAN>=<span class=hl-value>"0"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"7500000"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>index</SPAN>=<span class=hl-value>"1"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"42"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>In addition to resolving the ambiguity of multiple 
simple values, specifying an index resolves ambiguity where a constructor has 
two arguments of the same type. Note that the <span class=emphasis><em>index is 0 
based</EM></SPAN>.</P></DIV>
<div class=section title="Constructor argument name">
<div class=titlepage>
<div>
<div>
<h6 class=title><a name=beans-factory-ctor-arguments-name></A>Constructor argument name</H6></DIV></DIV></DIV>
<p>As of Spring 3.0 you can also use the constructor 
parameter name for value disambiguation:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"years"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"7500000"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"ultimateanswer"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"42"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>Keep in mind that to make this work out of the box your 
code must be compiled with the debug flag enabled so that Spring can look up the 
parameter name from the constructor. If you can't compile your code with debug 
flag (or don't want to) you can use <code class=interfacename><a class=ulink 
href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" 
target=_top>@ConstructorProperties</A></CODE> JDK 
annotation to explicitly name your constructor arguments. The sample class would 
then have to look as follows:</P><pre class=programlisting><span class=hl-keyword>package</SPAN> examples;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <em class=lineannotation><span class=lineannotation>// </SPAN></EM>Fields omitted

  <i><span style="COLOR: gray" class=hl-annotation>@ConstructorProperties({"years", "ultimateAnswer"})</SPAN></I>
  <span class=hl-keyword>public</SPAN> ExampleBean(<span class=hl-keyword>int</SPAN> years, String ultimateAnswer) {
      <span class=hl-keyword>this</SPAN>.years = years;
      <span class=hl-keyword>this</SPAN>.ultimateAnswer = ultimateAnswer;
  }
}</PRE></DIV></DIV></DIV>
<div class=section title="Setter-based dependency injection">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-setter-injection></A>Setter-based dependency 
injection</H4></DIV></DIV></DIV>
<p><span class=emphasis><em>Setter-based</EM></SPAN> DI is accomplished by the 
container calling setter methods on your beans after invoking a no-argument 
constructor or no-argument <code class=literal>static</CODE> factory method to instantiate your bean.</P>
<p>The following example shows a class that can only be 
dependency-injected using pure setter injection. This class is conventional 
Java. It is a POJO that has no dependencies on container specific interfaces, 
base classes or annotations.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <em class=lineannotation><span class=lineannotation>// the SimpleMovieLister has a dependency on the MovieFinder</SPAN></EM>
  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <em class=lineannotation><span class=lineannotation>// a setter method so that the Spring container can 'inject' a MovieFinder</SPAN></EM>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }

  <em class=lineannotation><span class=lineannotation>// business logic that actually 'uses' the injected MovieFinder is omitted...</SPAN></EM>
}</PRE>
<p>The <code class=interfacename>ApplicationContext</CODE> supports constructor- and 
setter-based DI for the beans it manages. It also supports setter-based DI after 
some dependencies are already injected through the constructor approach. You 
configure the dependencies in the form of a <code class=interfacename>BeanDefinition</CODE>, which you use with <code 
class=interfacename>PropertyEditor</CODE> instances to 
convert properties from one format to another. However, most Spring users do not 
work with these classes directly (programmatically), but rather with an XML 
definition file that is then converted internally into instances of these 
classes, and used to load an entire Spring IoC container instance.</P>
<div class=sidebar title="Constructor-based or setter-based DI?">
<p class=title><b>Constructor-based or 
setter-based DI?</B></P>
<p>Since you can mix both, Constructor- and Setter-based 
DI, it is a good rule of thumb to use constructor arguments for mandatory 
dependencies and setters for optional dependencies. Note that the use of a <A class=link title=5.9.1&nbsp;@Required href="beans.html#beans-required-annotation" >@Required</A> annotation on 
a setter can be used to make setters required dependencies.</P>
<p>The Spring team generally advocates setter injection, 
because large numbers of constructor arguments can get unwieldy, especially when 
properties are optional. Setter methods also make objects of that class amenable 
to reconfiguration or re-injection later. Management through <A class=link title=24.&nbsp;JMX href="jmx.html" >JMX MBeans</A> is a compelling use case.</P>
<p>Some purists favor constructor-based injection. 
Supplying all object dependencies means that the object is always returned to 
client (calling) code in a totally initialized state. The disadvantage is that 
the object becomes less amenable to reconfiguration and re-injection.</P>
<p>Use the DI that makes the most sense for a particular 
class. Sometimes, when dealing with third-party classes to which you do not have 
the source, the choice is made for you. A legacy class may not expose any setter 
methods, and so constructor injection is the only available DI.</P></DIV></DIV>
<div class=section title="Dependency resolution process">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-dependency-resolution></A>Dependency resolution process</H4></DIV></DIV></DIV>
<p>The container performs bean dependency resolution as 
follows:</P>
<div class=orderedlist>
<ol class=orderedlist type=1>
  <li class=listitem>
  <p>The <code class=interfacename 
  >ApplicationContext</CODE> is created and initialized with 
  configuration metadata that describes all the beans. Configuration metadata 
  can be specified via XML, Java code or annotations.</P>
  <li class=listitem>
  <p>For each bean, its dependencies are expressed in the 
  form of properties, constructor arguments, or arguments to the static-factory 
  method if you are using that instead of a normal constructor. These 
  dependencies are provided to the bean, <span class=emphasis 
  ><em>when the bean is actually 
  created</EM></SPAN>.</P>
  <li class=listitem>
  <p>Each property or constructor argument is an actual 
  definition of the value to set, or a reference to another bean in the 
  container.</P>
  <li class=listitem>
  <p>Each property or constructor argument which is a value 
  is converted from its specified format to the actual type of that property or 
  constructor argument. By default Spring can convert a value supplied in string 
  format to all built-in types, such as <code class=literal 
  >int</CODE>, <code class=literal 
  >long</CODE>, <code class=literal 
  >String</CODE>, <code class=literal 
  >boolean</CODE>, etc.</P></LI></OL></DIV>
<p>The Spring container validates the configuration of each 
bean as the container is created, including the validation of whether bean 
reference properties refer to valid beans. However, the bean properties 
themselves are not set until the bean <span class=emphasis><em>is actually created</EM></SPAN>. 
Beans that are singleton-scoped and set to be pre-instantiated (the default) are 
created when the container is created. Scopes are defined in <A class=xref title="5.5&nbsp;Bean scopes" href="beans.html#beans-factory-scopes" >Section&nbsp;5.5, “Bean 
scopes”</A> Otherwise, the bean is created only when it is requested. Creation 
of a bean potentially causes a graph of beans to be created, as the bean's 
dependencies and its dependencies' dependencies (and so on) are created and 
assigned.</P>
<div class=sidebar title="Circular dependencies">
<p class=title><b>Circular 
dependencies</B></P>
<p>If you use predominantly constructor injection, it is 
possible to create an unresolvable circular dependency scenario.</P>
<p>For example: Class A requires an instance of class B 
through constructor injection, and class B requires an instance of class A 
through constructor injection. If you configure beans for classes A and B to be 
injected into each other, the Spring IoC container detects this circular 
reference at runtime, and throws a <code class=classname>BeanCurrentlyInCreationException</CODE>.</P>
<p>One possible solution is to edit the source code of some 
classes to be configured by setters rather than constructors. Alternatively, 
avoid constructor injection and use setter injection only. In other words, 
although it is not recommended, you can configure circular dependencies with 
setter injection.</P>
<p>Unlike the <span class=emphasis><em>typical</EM></SPAN> case (with no circular dependencies), a 
circular dependency between bean A and bean B forces one of the beans to be 
injected into the other prior to being fully initialized itself (a classic 
chicken/egg scenario).</P></DIV>
<p>You can generally trust Spring to do the right thing. It 
detects configuration problems, such as references to non-existent beans and 
circular dependencies, at container load-time. Spring sets properties and 
resolves dependencies as late as possible, when the bean is actually created. 
This means that a Spring container which has loaded correctly can later generate 
an exception when you request an object if there is a problem creating that 
object or one of its dependencies. For example, the bean throws an exception as 
a result of a missing or invalid property. This potentially delayed visibility 
of some configuration issues is why <code class=interfacename>ApplicationContext</CODE> implementations by default 
pre-instantiate singleton beans. At the cost of some upfront time and memory to 
create these beans before they are actually needed, you discover configuration 
issues when the <code class=interfacename>ApplicationContext</CODE> is created, not later. You can 
still override this default behavior so that singleton beans will 
lazy-initialize, rather than be pre-instantiated.</P>
<p>If no circular dependencies exist, when one or more 
collaborating beans are being injected into a dependent bean, each collaborating 
bean is <span class=emphasis><em>totally</EM></SPAN> configured prior to being injected into 
the dependent bean. This means that if bean A has a dependency on bean B, the 
Spring IoC container completely configures bean B prior to invoking the setter 
method on bean A. In other words, the bean is instantiated (if not a 
pre-instantiated singleton), its dependencies are set, and the relevant 
lifecycle methods (such as a <A class=link title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" >configured 
init method</A> or the <A class=link title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" >InitializingBean 
callback method</A>) are invoked.</P></DIV>
<div class=section title="Examples of dependency injection">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-some-examples></A>Examples of dependency injection</H4></DIV></DIV></DIV>
<p>The following example uses XML-based configuration 
metadata for setter-based DI. A small part of a Spring XML configuration file 
specifies some bean definitions:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- setter injection using the nested &lt;ref/&gt; element --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"beanOne"</SPAN><span class=hl-tag>&gt;</SPAN><span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN><span class=hl-tag>&lt;/property&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- setter injection using the neater 'ref' attribute --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"beanTwo"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"integerProperty"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"1"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.AnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.YetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <span class=hl-keyword>private</SPAN> AnotherBean beanOne;
  <span class=hl-keyword>private</SPAN> YetAnotherBean beanTwo;
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>int</SPAN> i;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setBeanOne(AnotherBean beanOne) {
      <span class=hl-keyword>this</SPAN>.beanOne = beanOne;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setBeanTwo(YetAnotherBean beanTwo) {
      <span class=hl-keyword>this</SPAN>.beanTwo = beanTwo;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setIntegerProperty(<span class=hl-keyword>int</SPAN> i) {
      <span class=hl-keyword>this</SPAN>.i = i;
  }
}</PRE>
<p>In the preceding example, setters are declared to match 
against the properties specified in the XML file. The following example uses 
constructor-based DI:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- constructor injection using the nested &lt;ref/&gt; element --&gt;</SPAN></EM>
<span class=hl-tag>&lt;constructor-arg&gt;</SPAN>
  <span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/constructor-arg&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</SPAN></EM>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"int"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"1"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.AnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.YetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <span class=hl-keyword>private</SPAN> AnotherBean beanOne;
  <span class=hl-keyword>private</SPAN> YetAnotherBean beanTwo;
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>int</SPAN> i;

  <span class=hl-keyword>public</SPAN> ExampleBean(
      AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=hl-keyword>int</SPAN> i) {
      <span class=hl-keyword>this</SPAN>.beanOne = anotherBean;
      <span class=hl-keyword>this</SPAN>.beanTwo = yetAnotherBean;
      <span class=hl-keyword>this</SPAN>.i = i;
  }
}</PRE>
<p>The constructor arguments specified in the bean 
definition will be used as arguments to the constructor of the <code 
class=classname>ExampleBean</CODE>.</P>
<p>Now consider a variant of this example, where instead of 
using a constructor, Spring is told to call a <code class=literal>static</CODE> factory method to return an instance of the 
object:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN>
    <span class=hl-attribute>factory-method</SPAN>=<span class=hl-value>"createInstance"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;constructor-arg</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"1"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"anotherExampleBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.AnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"yetAnotherBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.YetAnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <em class=lineannotation><span class=lineannotation>// a private constructor</SPAN></EM>
  <span class=hl-keyword>private</SPAN> ExampleBean(...) {
    ...
  }
  <em class=lineannotation><span class=lineannotation>
  // a static factory method; the arguments to this method can be
  // considered the dependencies of the bean that is returned,
  // regardless of how those arguments are actually used.</SPAN></EM>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> ExampleBean createInstance (
          AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=hl-keyword>int</SPAN> i) {

      ExampleBean eb = <span class=hl-keyword>new</SPAN> ExampleBean (...);
      <em class=lineannotation><span class=lineannotation>// some other operations...</SPAN></EM>
      <span class=hl-keyword>return</SPAN> eb;
  }
}</PRE>
<p>Arguments to the <code class=literal>static</CODE> factory method are supplied via <code 
class=literal>&lt;constructor-arg/&gt;</CODE> elements, 
exactly the same as if a constructor had actually been used. The type of the 
class being returned by the factory method does not have to be of the same type 
as the class that contains the <code class=literal>static</CODE> factory method, although in this example it 
is. An instance (non-static) factory method would be used in an essentially 
identical fashion (aside from the use of the <code class=literal>factory-bean</CODE> attribute instead of the <code 
class=literal>class</CODE> attribute), so details will not 
be discussed here.</P></DIV></DIV>
<div class=section title="5.4.2&nbsp;Dependencies and configuration in detail">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-properties-detailed></A>5.4.2&nbsp;Dependencies and configuration in 
detail</H3></DIV></DIV></DIV>
<p>As mentioned in the previous section, you can define 
bean properties and constructor arguments as references to other managed beans 
(collaborators), or as values defined inline. Spring's XML-based configuration 
metadata supports sub-element types within its <code class=literal>&lt;property/&gt;</CODE> and <code class=literal>&lt;constructor-arg/&gt;</CODE> elements for this 
purpose.</P>
<div class=section title="Straight values (primitives, Strings, and so on)">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-value-element></A>Straight values (primitives, <code class=literal>Strings</CODE>, and so on)</H4></DIV></DIV></DIV>
<p>The <code class=literal>value</CODE> attribute of the <code class=literal>&lt;property/&gt;</CODE> element specifies a property or 
constructor argument as a human-readable string representation. <A class=link title="7.4.2&nbsp;Built-in PropertyEditor implementations" href="validation.html#beans-beans-conversion" >As mentioned 
previously</A>, JavaBeans <code class=literal>PropertyEditors</CODE> are used to convert these string 
values from a <code class=classname>String</CODE> to the 
actual type of the property or argument.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myDataSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.apache.commons.dbcp.BasicDataSource"</SPAN> <span class=hl-attribute>destroy-method</SPAN>=<span class=hl-value>"close"</SPAN><span class=hl-tag>&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- results in a setDriverClassName(String) call --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"driverClassName"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"com.mysql.jdbc.Driver"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"url"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"jdbc:mysql://localhost:3306/mydb"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"username"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"root"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"password"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"masterkaoli"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The following example uses the <A class=link title="XML shortcut with the p-namespace" href="beans.html#beans-p-namespace" >p-namespace</A> for even more 
succinct XML configuration.</P><pre class=programlisting><span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <span class=hl-attribute>xmlns:p</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/p"</SPAN>
     <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myDataSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.apache.commons.dbcp.BasicDataSource"</SPAN>
      <span class=hl-attribute>destroy-method</SPAN>=<span class=hl-value>"close"</SPAN>
      <span class=hl-attribute>p:driverClassName</SPAN>=<span class=hl-value>"com.mysql.jdbc.Driver"</SPAN>
      <span class=hl-attribute>p:url</SPAN>=<span class=hl-value>"jdbc:mysql://localhost:3306/mydb"</SPAN>
      <span class=hl-attribute>p:username</SPAN>=<span class=hl-value>"root"</SPAN>
      <span class=hl-attribute>p:password</SPAN>=<span class=hl-value>"masterkaoli"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN>

</PRE>
<p>The preceding XML is more succinct; however, typos are 
discovered at runtime rather than design time, unless you use an IDE such as <a 
class=ulink href="http://www.jetbrains.com/idea/" target=_top>IntelliJ IDEA</A> or the <a class=ulink 
href="http://www.springsource.com/products/sts" target=_top>SpringSource Tool Suite</A> (STS) that support automatic 
property completion when you create bean definitions. Such IDE assistance is 
highly recommended.</P>
<p>You can also configure a <code class=classname>java.util.Properties</CODE> instance as:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"mappings"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</SPAN><span class=hl-tag>&gt;</SPAN>

 <em class=lineannotation><span class=lineannotation>&lt;!-- typed as a java.util.Properties --&gt;</SPAN></EM>
 <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"properties"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;value&gt;</SPAN>
       jdbc.driver.className=com.mysql.jdbc.Driver
       jdbc.url=jdbc:mysql://localhost:3306/mydb
    <span class=hl-tag>&lt;/value&gt;</SPAN>
 <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The Spring container converts the text inside the <code 
class=literal>&lt;value/&gt;</CODE> element into a <code 
class=classname>java.util.Properties</CODE> instance by 
using the JavaBeans <code class=interfacename>PropertyEditor</CODE> mechanism. This is a nice shortcut, 
and is one of a few places where the Spring team do favor the use of the nested 
<code class=literal>&lt;value/&gt;</CODE> element over the 
<code class=literal>value</CODE> attribute style.</P>
<div class=section title="The idref element">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-idref-element></A>The <code class=literal>idref</CODE> element</H5></DIV></DIV></DIV>
<p>The <code class=literal>idref</CODE> element is simply an error-proof way to pass 
the <span class=emphasis><em>id</EM></SPAN> (string value - not a reference) of another 
bean in the container to a <code class=literal>&lt;constructor-arg/&gt;</CODE> or <code class=literal>&lt;property/&gt;</CODE> element.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"theTargetBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"theClientBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetName"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;idref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"theTargetBean"</SPAN><span class=hl-tag> /&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The above bean definition snippet is <span 
class=emphasis><em>exactly</EM></SPAN> 
equivalent (at runtime) to the following snippet:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"theTargetBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN><span class=hl-tag> /&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"client"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetName"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"theTargetBean"</SPAN><span class=hl-tag> /&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The first form is preferable to the second, because 
using the <code class=literal>idref</CODE> tag allows the 
container to validate <span class=emphasis><em>at deployment time</EM></SPAN> that the referenced, named 
bean actually exists. In the second variation, no validation is performed on the 
value that is passed to the <code class=literal>targetName</CODE> property of the <code class=literal>client</CODE> bean. Typos are only discovered (with most 
likely fatal results) when the <code class=literal>client</CODE> bean is actually instantiated. If the <code 
class=literal>client</CODE> bean is a <A class=link title="5.5&nbsp;Bean scopes" href="beans.html#beans-factory-scopes" >prototype</A> bean, this typo 
and the resulting exception may only be discovered long after the container is 
deployed.</P>
<p>Additionally, if the referenced bean is in the same XML 
unit, and the bean name is the bean <span class=emphasis><em>id</EM></SPAN>, you can use the 
<code class=literal>local</CODE> attribute, which allows 
the XML parser itself to validate the bean id earlier, at XML document parse 
time.</P><pre class=programlisting><span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"targetName"</SPAN><span class=hl-tag>&gt;</SPAN>
 <em class=lineannotation><span class=lineannotation>&lt;!-- a bean with id 'theTargetBean' must exist; otherwise an exception will be thrown --&gt;</SPAN></EM>
 <span class=hl-tag>&lt;idref</SPAN> <span class=hl-attribute>local</SPAN>=<span class=hl-value>"theTargetBean"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN></PRE>
<p>A common place (at least in versions earlier than Spring 
2.0) where the &lt;idref/&gt; element brings value is in the configuration of <A class=link title=10.5.1&nbsp;Basics href="aop-api.html#aop-pfb-1" >AOP interceptors</A> 
in a <code class=classname>ProxyFactoryBean</CODE> bean 
definition. Using &lt;idref/&gt; elements when you specify the interceptor names 
prevents you from misspelling an interceptor id.</P></DIV></DIV>
<div class=section title="References to other beans (collaborators)">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-ref-element></A>References to other beans 
(collaborators)</H4></DIV></DIV></DIV>
<p>The <code class=literal>ref</CODE> 
element is the final element inside a <code class=literal>&lt;constructor-arg/&gt;</CODE> or <code class=literal>&lt;property/&gt;</CODE> definition element. Here you set 
the value of the specified property of a bean to be a reference to another bean 
(a collaborator) managed by the container. The referenced bean is a dependency 
of the bean whose property will be set, and it is initialized on demand as 
needed before the property is set. (If the collaborator is a singleton bean, it 
may be initialized already by the container.) All references are ultimately a 
reference to another object. Scoping and validation depend on whether you 
specify the id/name of the other object through the <code class=literal>bean</CODE>,<code class=literal>local,</CODE> or <code class=literal>parent</CODE> attributes.</P>
<p>Specifying the target bean through the <code 
class=literal>bean</CODE> attribute of the <code 
class=literal>&lt;ref/&gt;</CODE> tag is the most general 
form, and allows creation of a reference to any bean in the same container or 
parent container, regardless of whether it is in the same XML file. The value of 
the <code class=literal>bean</CODE> attribute may be the 
same as the <code class=literal>id</CODE> attribute of the 
target bean, or as one of the values in the <code class=literal>name</CODE> attribute of the target bean.</P><pre class=programlisting><span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"someBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>Specifying the target bean through the <code 
class=literal>local</CODE> attribute leverages the ability 
of the XML parser to validate XML id references within the same file. The value 
of the <code class=literal>local</CODE> attribute must be 
the same as the <code class=literal>id</CODE> attribute of 
the target bean. The XML parser issues an error if no matching element is found 
in the same file. As such, using the local variant is the best choice (in order 
to know about errors as early as possible) if the target bean is in the same XML 
file.</P><pre class=programlisting><span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>local</SPAN>=<span class=hl-value>"someBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>Specifying the target bean through the <code 
class=literal>parent</CODE> attribute creates a reference 
to a bean that is in a parent container of the current container. The value of 
the <code class=literal>parent</CODE> attribute may be the 
same as either the <code class=literal>id</CODE> attribute 
of the target bean, or one of the values in the <code class=literal>name</CODE> attribute of the target bean, and the target 
bean must be in a parent container of the current one. You use this bean 
reference variant mainly when you have a hierarchy of containers and you want to 
wrap an existing bean in a parent container with a proxy that will have the same 
name as the parent bean.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- in the parent context --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.SimpleAccountService"</SPAN><span class=hl-tag>&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- insert dependencies as required as here --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- in the child (descendant) context --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN>  <em class=lineannotation><span class=lineannotation>&lt;-- bean name is the same as the parent bean --&gt;</SPAN></EM>
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN><span class=hl-tag>&gt;</SPAN>
        <span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>parent</SPAN>=<span class=hl-value>"accountService"</SPAN><span class=hl-tag>/&gt;</SPAN>  <em class=lineannotation><span class=lineannotation>&lt;!-- notice how we refer to the parent bean --&gt;</SPAN></EM>
    <span class=hl-tag>&lt;/property&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- insert other configuration and dependencies as required here --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE></DIV>
<div class=section title="Inner beans">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-inner-beans></A>Inner beans</H4></DIV></DIV></DIV>
<p>A <code class=literal>&lt;bean/&gt;</CODE> element inside the <code class=literal>&lt;property/&gt;</CODE> or <code class=literal>&lt;constructor-arg/&gt;</CODE> elements defines a 
so-called <em class=firstterm>inner bean</EM>.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"outer"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN><span class=hl-tag>&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"target"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.Person"</SPAN><span class=hl-tag>&gt;</SPAN> <em class=lineannotation><span class=lineannotation>&lt;!-- this is the inner bean --&gt;</SPAN></EM>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Fiona Apple"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"age"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"25"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>An inner bean definition does not require a defined id 
or name; the container ignores these values. It also ignores the <code 
class=literal>scope</CODE> flag. Inner beans are <span 
class=emphasis><em>always</EM></SPAN> 
anonymous and they are <span class=emphasis><em>always</EM></SPAN> scoped as <A class=link title="5.5.2&nbsp;The prototype scope" href="beans.html#beans-factory-scopes-prototype" >prototypes</A>. It is 
<span class=emphasis><em>not</EM></SPAN> possible to inject inner beans into 
collaborating beans other than into the enclosing bean.</P></DIV>
<div class=section title=Collections>
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-collection-elements></A>Collections</H4></DIV></DIV></DIV>
<p>In the <code class=literal>&lt;list/&gt;</CODE>, <code class=literal>&lt;set/&gt;</CODE>, <code class=literal>&lt;map/&gt;</CODE>, and <code class=literal>&lt;props/&gt;</CODE> elements, you set the properties and 
arguments of the Java <code class=interfacename>Collection</CODE> types <code class=interfacename>List</CODE>, <code class=interfacename>Set</CODE>, <code class=interfacename>Map</CODE>, and <code class=interfacename>Properties</CODE>, respectively.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"moreComplexObject"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.ComplexObject"</SPAN><span class=hl-tag>&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"adminEmails"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;props&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"administrator"</SPAN><span class=hl-tag>&gt;</SPAN>administrator@example.org<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"support"</SPAN><span class=hl-tag>&gt;</SPAN>support@example.org<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"development"</SPAN><span class=hl-tag>&gt;</SPAN>development@example.org<span class=hl-tag>&lt;/prop&gt;</SPAN>
  <span class=hl-tag>&lt;/props&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- results in a setSomeList(java.util.List) call --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"someList"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;list&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>a list element followed by a reference<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"myDataSource"</SPAN><span class=hl-tag> /&gt;</SPAN>
  <span class=hl-tag>&lt;/list&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"someMap"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;map&gt;</SPAN>
      <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"an entry"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"just some string"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN> =<span class=hl-value>"a ref"</SPAN> <span class=hl-attribute>value-ref</SPAN>=<span class=hl-value>"myDataSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/map&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</SPAN></EM>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"someSet"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;set&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>just some string<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;ref</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"myDataSource"</SPAN><span class=hl-tag> /&gt;</SPAN>
  <span class=hl-tag>&lt;/set&gt;</SPAN>
<span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p><span class=emphasis><em>The value of a map key or value, or a set value, can also 
again be any of the following elements:</EM></SPAN></P><pre class=programlisting>bean | ref | idref | list | set | map | props | value | null</PRE>
<div class=section title="Collection merging">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-collection-elements-merging></A>Collection merging</H5></DIV></DIV></DIV>
<p>As of Spring 2.0, the container supports the <span 
class=emphasis><em>merging</EM></SPAN> 
of collections. An application developer can define a parent-style <code 
class=literal>&lt;list/&gt;</CODE>, <code class=literal>&lt;map/&gt;</CODE>, <code class=literal>&lt;set/&gt;</CODE> or <code class=literal>&lt;props/&gt;</CODE> element, and have child-style <code 
class=literal>&lt;list/&gt;</CODE>, <code class=literal>&lt;map/&gt;</CODE>, <code class=literal>&lt;set/&gt;</CODE> or <code class=literal>&lt;props/&gt;</CODE> elements inherit and override values 
from the parent collection. That is, the child collection's values are the 
result of merging the elements of the parent and child collections, with the 
child's collection elements overriding values specified in the parent 
collection.</P>
<p><span class=emphasis><em>This section on merging discusses the parent-child bean 
mechanism. Readers unfamiliar with parent and child bean definitions may wish to 
read the <A class=link title="5.7&nbsp;Bean definition inheritance" href="beans.html#beans-child-bean-definitions" >relevant section</A> 
before continuing.</EM></SPAN></P>
<p>The following example demonstrates collection 
merging:</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"parent"</SPAN> <span class=hl-attribute>abstract</SPAN>=<span class=hl-value>"true"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.ComplexObject"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"adminEmails"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;props&gt;</SPAN>
          <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"administrator"</SPAN><span class=hl-tag>&gt;</SPAN>administrator@example.com<span class=hl-tag>&lt;/prop&gt;</SPAN>
          <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"support"</SPAN><span class=hl-tag>&gt;</SPAN>support@example.com<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;/props&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"child"</SPAN> <span class=hl-attribute>parent</SPAN>=<span class=hl-value>"parent"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"adminEmails"</SPAN><span class=hl-tag>&gt;</SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- the merge is specified on the *child* collection definition --&gt;</SPAN></EM>
      <span class=hl-tag>&lt;props</SPAN> <span class=hl-attribute>merge</SPAN>=<span class=hl-value>"true"</SPAN><span class=hl-tag>&gt;</SPAN>
          <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"sales"</SPAN><span class=hl-tag>&gt;</SPAN>sales@example.com<span class=hl-tag>&lt;/prop&gt;</SPAN>
          <span class=hl-tag>&lt;prop</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"support"</SPAN><span class=hl-tag>&gt;</SPAN>support@example.co.uk<span class=hl-tag>&lt;/prop&gt;</SPAN>
      <span class=hl-tag>&lt;/props&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;beans&gt;</SPAN></PRE>
<p>Notice the use of the <code class=literal>merge=true</CODE> attribute on the <code class=literal>&lt;props/&gt;</CODE> element of the <code class=literal>adminEmails</CODE> property of the <code class=literal>child</CODE> bean definition. When the <code class=literal>child</CODE> bean is resolved and instantiated by the 
container, the resulting instance has an <code class=literal>adminEmails</CODE> <code class=classname>Properties</CODE> collection that contains the result of 
the merging of the child's <code class=literal>adminEmails</CODE> collection with the parent's <code 
class=literal>adminEmails</CODE> collection.</P><pre class=programlisting>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</PRE>
<p>The child <code class=classname>Properties</CODE> collection's value set inherits all 
property elements from the parent <code class=literal>&lt;props/&gt;</CODE>, and the child's value for the <code 
class=literal>support</CODE> value overrides the value in 
the parent collection.</P>
<p>This merging behavior applies similarly to the <code 
class=literal>&lt;list/&gt;</CODE>, <code class=literal>&lt;map/&gt;</CODE>, and <code class=literal>&lt;set/&gt;</CODE> collection types. In the specific case 
of the <code class=literal>&lt;list/&gt;</CODE> element, 
the semantics associated with the <code class=classname>List</CODE> collection type, that is, the notion of an 
<code class=literal>ordered</CODE> collection of values, is 
maintained; the parent's values precede all of the child list's values. In the 
case of the <code class=interfacename>Map</CODE>, <code 
class=interfacename>Set</CODE>, and <code 
class=interfacename>Properties</CODE> collection types, no 
ordering exists. Hence no ordering semantics are in effect for the collection 
types that underlie the associated <code class=interfacename>Map</CODE>, <code class=interfacename>Set</CODE>, and <code class=interfacename>Properties</CODE> implementation types that the container 
uses internally.</P></DIV>
<div class=section title="Limitations of collection merging">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-collection-merge-limitations></A>Limitations of collection 
merging</H5></DIV></DIV></DIV>
<p>You cannot merge different collection types (such as a 
<code class=interfacename>Map</CODE> and a <code 
class=interfacename>List</CODE>), and if you do attempt to 
do so an appropriate <code class=classname>Exception</CODE> 
is thrown. The <code class=literal>merge</CODE> attribute 
must be specified on the lower, inherited, child definition; specifying the 
<code class=literal>merge</CODE> attribute on a parent 
collection definition is redundant and will not result in the desired merging. 
The merging feature is available only in Spring 2.0 and later.</P></DIV>
<div class=section title="Strongly-typed collection (Java 5+ only)">
<div class=titlepage>
<div>
<div>
<h5 class=title><a 
name=beans-collection-elements-strongly-typed></A>Strongly-typed collection (Java 5+ 
only)</H5></DIV></DIV></DIV>
<p>In Java 5 and later, you can use strongly typed 
collections (using generic types). That is, it is possible to declare a <code 
class=interfacename>Collection</CODE> type such that it can 
only contain <code class=classname>String</CODE> elements 
(for example). If you are using Spring to dependency-inject a strongly-typed 
<code class=interfacename>Collection</CODE> into a bean, 
you can take advantage of Spring's type-conversion support such that the 
elements of your strongly-typed <code class=interfacename>Collection</CODE> instances are converted to the 
appropriate type prior to being added to the <code class=interfacename>Collection</CODE>.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> Foo {

  <span class=hl-keyword>private</SPAN> Map&lt;String, Float&gt; accounts;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setAccounts(Map&lt;String, Float&gt; accounts) {
      <span class=hl-keyword>this</SPAN>.accounts = accounts;
  }
}</PRE><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"foo"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Foo"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"accounts"</SPAN><span class=hl-tag>&gt;</SPAN>
          <span class=hl-tag>&lt;map&gt;</SPAN>
              <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"one"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"9.99"</SPAN><span class=hl-tag>/&gt;</SPAN>
              <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"two"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"2.75"</SPAN><span class=hl-tag>/&gt;</SPAN>
              <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"six"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"3.99"</SPAN><span class=hl-tag>/&gt;</SPAN>
          <span class=hl-tag>&lt;/map&gt;</SPAN>
      <span class=hl-tag>&lt;/property&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>When the <code class=literal>accounts</CODE> property of the <code class=literal>foo</CODE> bean is prepared for injection, the generics 
information about the element type of the strongly-typed <code class=classname>Map&lt;String, Float&gt;</CODE> is available by reflection. 
Thus Spring's type conversion infrastructure recognizes the various value 
elements as being of type <code class=classname>Float</CODE>, and the string values <code class=literal>9.99, 2.75</CODE>, and <code class=literal>3.99</CODE> are converted into an actual <code 
class=classname>Float</CODE> type.</P></DIV></DIV>
<div class=section title="Null and empty string values">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-null-element></A>Null and empty string values</H4></DIV></DIV></DIV>
<p>Spring treats empty arguments for properties and the 
like as empty <code class=literal>Strings</CODE>. The 
following XML-based configuration metadata snippet sets the email property to 
the empty <code class=classname>String</CODE> value 
("")</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"email"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>""</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The preceding example is equivalent to the following 
Java code: <code class=methodname>exampleBean.setEmail("")</CODE>. The <code class=literal>&lt;null/&gt;</CODE> element handles <code class=literal>null</CODE> values. For example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"email"</SPAN><span class=hl-tag>&gt;</SPAN><span class=hl-tag>&lt;null/&gt;</SPAN><span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The above configuration is equivalent to the following 
Java code: <code class=methodname>exampleBean.setEmail(null)</CODE>.</P></DIV>
<div class=section title="XML shortcut with the p-namespace">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-p-namespace></A>XML shortcut with the 
p-namespace</H4></DIV></DIV></DIV>
<p>The p-namespace enables you to use the <code 
class=literal>bean</CODE> element's attributes, instead of 
nested <code class=literal>&lt;property/&gt;</CODE> 
elements, to describe your property values and/or collaborating beans.</P>
<p>Spring 2.0 and later supports extensible configuration 
formats <A class=link title="Appendix&nbsp;D.&nbsp;XML Schema-based configuration" href="xsd-config.html" >with 
namespaces</A>, which are based on an XML Schema definition. The <code 
class=literal>beans</CODE> configuration format discussed 
in this chapter is defined in an XML Schema document. However, the p-namespace 
is not defined in an XSD file and exists only in the core of Spring.</P>
<p>The following example shows two XML snippets that 
resolve to the same result: The first uses standard XML format and the second 
uses the p-namespace.</P><pre class=programlisting><span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
  <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  <span class=hl-attribute>xmlns:p</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/p"</SPAN>
  <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"classic"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.ExampleBean"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"email"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"foo@bar.com"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"p-namespace"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.ExampleBean"</SPAN>
        <span class=hl-attribute>p:email</SPAN>=<span class=hl-value>"foo@bar.com"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>The example shows an attribute in the p-namespace called 
email in the bean definition. This tells Spring to include a property 
declaration. As previously mentioned, the p-namespace does not have a schema 
definition, so you can set the name of the attribute to the property name.</P>
<p>This next example includes two more bean definitions 
that both have a reference to another bean:</P><pre class=programlisting><span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
  <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  <span class=hl-attribute>xmlns:p</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/p"</SPAN>
  <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"john-classic"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.Person"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"John Doe"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"spouse"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"jane"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"john-modern"</SPAN>
      <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.Person"</SPAN>
      <span class=hl-attribute>p:name</SPAN>=<span class=hl-value>"John Doe"</SPAN>
      <span class=hl-attribute>p:spouse-ref</SPAN>=<span class=hl-value>"jane"</SPAN><span class=hl-tag>/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"jane"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.example.Person"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Jane Doe"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>As you can see, this example includes not only a 
property value using the p-namespace, but also uses a special format to declare 
property references. Whereas the first bean definition uses <code class=literal>&lt;property name="spouse" ref="jane"/&gt;</CODE> to create 
a reference from bean <code class=literal>john</CODE> to 
bean <code class=literal>jane</CODE>, the second bean 
definition uses <code class=literal>p:spouse-ref="jane"</CODE> as an attribute to do the exact 
same thing. In this case <code class=literal>spouse</CODE> 
is the property name, whereas the <code class=literal>-ref</CODE> part indicates that this is not a straight 
value but rather a reference to another bean.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The p-namespace is not as flexible as the standard 
      XML format. For example, the format for declaring property references 
      clashes with properties that end in <code class=literal 
      >Ref</CODE>, whereas the standard XML format does not. 
      We recommend that you choose your approach carefully and communicate this 
      to your team members, to avoid producing XML documents that use all three 
      approaches at the same time.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="XML shortcut with the c-namespace">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-c-namespace></A>XML shortcut with the 
c-namespace</H4></DIV></DIV></DIV>
<p>Similar to the <A class=xref title="XML shortcut with the p-namespace" href="beans.html#beans-p-namespace" >the section 
called “XML shortcut with the p-namespace”</A>, the <span class=emphasis><em>c-namespace</EM></SPAN>, newly 
introduced in Spring 3.1, allows usage of inlined attributes for configuring the 
constructor arguments rather then nested <code class=literal>constructor-arg</CODE> elements.</P>
<p>Let's review the examples from <A class=xref title="Constructor-based dependency injection" href="beans.html#beans-constructor-injection" >the section called 
“Constructor-based dependency injection”</A> with the <code class=literal>c</CODE> namespace:</P><pre class=programlisting>&lt;beans xmlns=<span class=hl-string>"http://www.springframework.org/schema/beans"</SPAN>
  xmlns:xsi=<span class=hl-string>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  xmlns:c=<span class=hl-string>"http://www.springframework.org/schema/c"</SPAN>
  xsi:schemaLocation=<span class=hl-string>"http://www.springframework.org/schema/beans
</SPAN>      http:<span class=hl-comment>//www.springframework.org/schema/beans/spring-beans.xsd"&gt;</SPAN>

  &lt;bean id=<span class=hl-string>"bar"</SPAN> <span class=hl-keyword>class</SPAN>=<span class=hl-string>"x.y.Bar"</SPAN>/&gt;
  &lt;bean id=<span class=hl-string>"baz"</SPAN> <span class=hl-keyword>class</SPAN>=<span class=hl-string>"x.y.Baz"</SPAN>/&gt;

  &lt;-- <span class=hl-string>'traditional'</SPAN> declaration --&gt;
  &lt;bean id=<span class=hl-string>"foo"</SPAN> <span class=hl-keyword>class</SPAN>=<span class=hl-string>"x.y.Foo"</SPAN>&gt;
      &lt;constructor-arg ref=<span class=hl-string>"bar"</SPAN>/&gt;
      &lt;constructor-arg ref=<span class=hl-string>"baz"</SPAN>/&gt;
      &lt;constructor-arg value=<span class=hl-string>"foo@bar.com"</SPAN>/&gt;
  &lt;/bean&gt;

  &lt;-- <span class=hl-string>'c-namespace'</SPAN> declaration --&gt;
  &lt;bean id=<span class=hl-string>"foo"</SPAN> <span class=hl-keyword>class</SPAN>=<span class=hl-string>"x.y.Foo"</SPAN> c:bar-ref=<span class=hl-string>"bar"</SPAN> c:baz-ref=<span class=hl-string>"baz"</SPAN> c:email=<span class=hl-string>"foo@bar.com"</SPAN>&gt;

&lt;/beans&gt;</PRE>
<p>The <code class=literal>c:</CODE> 
namespace uses the same conventions as the <code class=literal>p:</CODE> one (trailing <code class=literal>-ref</CODE> for bean references) for setting the 
constructor arguments by their names. And just as well, it needs to be declared 
even though it is not defined in an XSD schema (but it exists inside the Spring 
core).</P>
<p>For the rare cases where the constructor argument names 
are not available (usually if the bytecode was compiled without debugging 
information), one can use fallback to the argument indexes:</P><pre class=programlisting>&lt;-- <span class=hl-string>'c-namespace'</SPAN> index declaration --&gt;
&lt;bean id=<span class=hl-string>"foo"</SPAN> <span class=hl-keyword>class</SPAN>=<span class=hl-string>"x.y.Foo"</SPAN> c:_<span class=hl-number>0</SPAN>-ref=<span class=hl-string>"bar"</SPAN> c:_<span class=hl-number>1</SPAN>-ref=<span class=hl-string>"baz"</SPAN>&gt;</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Due to the XML grammar, the index notation 
      requires the presence of the leading <span class=emphasis 
      ><em>_</EM></SPAN> as XML 
      attribute names cannot start with a number (even though some IDE allow 
      it).</P></TD></TR></TABLE></DIV>
<p>In practice, the constructor resolution <A class=link title="Constructor argument resolution" href="beans.html#beans-factory-ctor-arguments-resolution" >mechanism</A> 
is quite efficient in matching arguments so unless one really needs to, we 
recommend using the name notation through-out your configuration.</P></DIV>
<div class=section title="Compound property names">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-compound-property-names></A>Compound property names</H4></DIV></DIV></DIV>
<p>You can use compound or nested property names when you 
set bean properties, as long as all components of the path except the final 
property name are not <code class=literal>null</CODE>. 
Consider the following bean definition.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"foo"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"foo.Bar"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"fred.bob.sammy"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"123"</SPAN><span class=hl-tag> /&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The <code class=literal>foo</CODE> 
bean has a <code class=literal>fred</CODE> property, which 
has a <code class=literal>bob</CODE> property, which has a 
<code class=literal>sammy</CODE> property, and that final 
<code class=literal>sammy</CODE> property is being set to 
the value <code class=literal>123</CODE>. In order for this 
to work, the <code class=literal>fred</CODE> property of 
<code class=literal>foo</CODE>, and the <code class=literal>bob</CODE> property of <code class=literal>fred</CODE> must not be <code class=literal>null</CODE> after the bean is constructed, or a <code 
class=exceptionname>NullPointerException</CODE> is 
thrown.</P></DIV></DIV>
<div class=section title="5.4.3&nbsp;Using depends-on">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-dependson></A>5.4.3&nbsp;Using <code class=literal>depends-on</CODE></H3></DIV></DIV></DIV>
<p>If a bean is a dependency of another that usually means 
that one bean is set as a property of another. Typically you accomplish this 
with the <A class=link title="References to other beans (collaborators)" href="beans.html#beans-ref-element" ><code class=literal>&lt;ref/&gt;</CODE> element</A> in XML-based configuration 
metadata. However, sometimes dependencies between beans are less direct; for 
example, a static initializer in a class needs to be triggered, such as database 
driver registration. The <code class=literal>depends-on</CODE> attribute can explicitly force one or 
more beans to be initialized before the bean using this element is initialized. 
The following example uses the <code class=literal>depends-on</CODE> attribute to express a dependency on a 
single bean:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"beanOne"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"ExampleBean"</SPAN> <span class=hl-attribute>depends-on</SPAN>=<span class=hl-value>"</SPAN><span class=bold><strong>manager</STRONG></SPAN>"/&gt;

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"</SPAN><span class=bold><strong>manager</STRONG></SPAN>" class="ManagerBean" /&gt;</PRE>
<p>To express a dependency on multiple beans, supply a list 
of bean names as the value of the <code class=literal>depends-on</CODE> attribute, with commas, whitespace and 
semicolons, used as valid delimiters:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"beanOne"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"ExampleBean"</SPAN> <span class=hl-attribute>depends-on</SPAN>=<span class=hl-value>"manager,accountDao"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"manager"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"manager"</SPAN><span class=hl-tag> /&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"manager"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"ManagerBean"</SPAN><span class=hl-tag> /&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountDao"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.jdbc.JdbcAccountDao"</SPAN><span class=hl-tag> /&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The <code class=literal 
      >depends-on</CODE> attribute in the bean definition 
      can specify both an initialization time dependency and, in the case of <A class=link title="5.5.1&nbsp;The singleton scope" href="beans.html#beans-factory-scopes-singleton" >singleton</A> 
      beans only, a corresponding destroy time dependency. Dependent beans that 
      define a <code class=literal>depends-on</CODE> 
      relationship with a given bean are destroyed first, prior to the given 
      bean itself being destroyed. Thus <code class=literal 
      >depends-on</CODE> can also control shutdown 
    order.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.4.4&nbsp;Lazy-initialized beans">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-lazy-init></A>5.4.4&nbsp;Lazy-initialized 
beans</H3></DIV></DIV></DIV>
<p>By default,<code class=interfacename> ApplicationContext</CODE> implementations eagerly create 
and configure all <A class=link title="5.5.1&nbsp;The singleton scope" href="beans.html#beans-factory-scopes-singleton" >singleton</A> beans as 
part of the initialization process. Generally, this pre-instantiation is 
desirable, because errors in the configuration or surrounding environment are 
discovered immediately, as opposed to hours or even days later. When this 
behavior is <span class=emphasis><em>not</EM></SPAN> desirable, you can prevent 
pre-instantiation of a singleton bean by marking the bean definition as 
lazy-initialized. A lazy-initialized bean tells the IoC container to create a 
bean instance when it is first requested, rather than at startup.</P>
<p>In XML, this behavior is controlled by the <code 
class=literal>lazy-init</CODE> attribute on the <code 
class=literal>&lt;bean/&gt;</CODE> element; for 
example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"lazy"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.ExpensiveToCreateBean"</SPAN> <span class=bold><strong>lazy-init="true"</STRONG></SPAN>/&gt;

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"not.lazy"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.AnotherBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>When the preceding configuration is consumed by an <code 
class=interfacename>ApplicationContext</CODE>, the bean 
named <code class=literal>lazy</CODE> is not eagerly 
pre-instantiated when the <code class=interfacename>ApplicationContext</CODE> is starting up, whereas the <code 
class=literal>not.lazy</CODE> bean is eagerly 
pre-instantiated.</P>
<p>However, when a lazy-initialized bean is a dependency of 
a singleton bean that is <span class=emphasis><em>not</EM></SPAN> lazy-initialized, the <code 
class=interfacename>ApplicationContext</CODE> creates the 
lazy-initialized bean at startup, because it must satisfy the singleton's 
dependencies. The lazy-initialized bean is injected into a singleton bean 
elsewhere that is not lazy-initialized.</P>
<p>You can also control lazy-initialization at the 
container level by using the <code class=literal>default-lazy-init</CODE> attribute on the <code 
class=literal>&lt;beans/&gt;</CODE> element; for 
example:</P><pre class=programlisting><span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>default-lazy-init</SPAN>=<span class=hl-value>"true"</SPAN><span class=hl-tag>&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- no beans will be pre-instantiated... --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE></DIV>
<div class=section title="5.4.5&nbsp;Autowiring collaborators">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-autowire></A>5.4.5&nbsp;Autowiring 
collaborators</H3></DIV></DIV></DIV>
<p>The Spring container can <span class=emphasis><em>autowire</EM></SPAN> relationships 
between collaborating beans. You can allow Spring to resolve collaborators 
(other beans) automatically for your bean by inspecting the contents of the 
<code class=interfacename>ApplicationContext</CODE>. 
Autowiring has the following advantages:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Autowiring can significantly reduce the need to 
  specify properties or constructor arguments. (Other mechanisms such as a bean 
  template <A class=link title="5.7&nbsp;Bean definition inheritance" href="beans.html#beans-child-bean-definitions" >discussed elsewhere in 
  this chapter</A> are also valuable in this regard.)</P>
  <li class=listitem>
  <p>Autowiring can update a configuration as your objects 
  evolve. For example, if you need to add a dependency to a class, that 
  dependency can be satisfied automatically without you needing to modify the 
  configuration. Thus autowiring can be especially useful during development, 
  without negating the option of switching to explicit wiring when the code base 
  becomes more stable.</P></LI></UL></DIV>
<p>When using XML-based configuration metadata<sup>[<A class=footnote href="#ftn.d4e1974" name=d4e1974 >2</A>]</SUP>, you specify 
autowire mode for a bean definition with the <code class=literal>autowire</CODE> attribute of the <code class=literal>&lt;bean/&gt;</CODE> element. The autowiring functionality 
has five modes. You specify autowiring <span class=emphasis><em>per</EM></SPAN> bean and thus can 
choose which ones to autowire.</P>
<div class=table><a name=beans-factory-autowiring-modes-tbl></A>
<p class=title><b>Table&nbsp;5.2.&nbsp;Autowiring modes</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Autowiring modes">
  <colgroup>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Mode</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid" 
  >Explanation</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >no</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>(Default) No autowiring. Bean references must be 
      defined via a <code class=literal>ref</CODE> element. 
      Changing the default setting is not recommended for larger deployments, 
      because specifying collaborators explicitly gives greater control and 
      clarity. To some extent, it documents the structure of a system.</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >byName</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>Autowiring by property name. Spring looks for a 
      bean with the same name as the property that needs to be autowired. For 
      example, if a bean definition is set to autowire by name, and it contains 
      a <span class=emphasis><em 
      >master</EM></SPAN> property (that is, it has a <span 
      class=emphasis><em 
      >setMaster(..)</EM></SPAN> method), Spring looks for a 
      bean definition named <code class=literal 
      >master</CODE>, and uses it to set the 
  property.</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >byType</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>Allows a property to be autowired if exactly one 
      bean of the property type exists in the container. If more than one 
      exists, a fatal exception is thrown, which indicates that you may not use 
      <span class=emphasis><em 
      >byType</EM></SPAN> autowiring for that bean. If there 
      are no matching beans, nothing happens; the property is not set.</P></TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid">constructor</TD>
    <td>
      <p>Analogous to <span class=emphasis 
      ><em>byType</EM></SPAN>, but 
      applies to constructor arguments. If there is not exactly one bean of the 
      constructor argument type in the container, a fatal error is 
  raised.</P></TD></TR></TBODY></TABLE></DIV></DIV><br class=table-break>
<p>With <span class=emphasis><em>byType</EM></SPAN> or <span class=emphasis><em>constructor</EM></SPAN> autowiring 
mode, you can wire arrays and typed-collections. In such cases <span 
class=emphasis><em>all</EM></SPAN> 
autowire candidates within the container that match the expected type are 
provided to satisfy the dependency. You can autowire strongly-typed Maps if the 
expected key type is <code class=classname>String</CODE>. 
An autowired Maps values will consist of all bean instances that match the 
expected type, and the Maps keys will contain the corresponding bean names.</P>
<p>You can combine autowire behavior with dependency 
checking, which is performed after autowiring completes.</P>
<div class=section title="Limitations and disadvantages of autowiring">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-autowired-exceptions></A>Limitations and disadvantages of 
autowiring</H4></DIV></DIV></DIV>
<p>Autowiring works best when it is used consistently 
across a project. If autowiring is not used in general, it might be confusing to 
developers to use it to wire only one or two bean definitions.</P>
<p>Consider the limitations and disadvantages of 
autowiring:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Explicit dependencies in <code class=literal 
  >property</CODE> and <code class=literal 
  >constructor-arg</CODE> settings always override 
  autowiring. You cannot autowire so-called <span class=emphasis 
  ><em>simple</EM></SPAN> properties 
  such as primitives, <code class=classname>Strings</CODE>, 
  and <code class=classname>Classes</CODE> (and arrays of 
  such simple properties). This limitation is by-design.</P></LI></UL></DIV>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Autowiring is less exact than explicit wiring. 
  Although, as noted in the above table, Spring is careful to avoid guessing in 
  case of ambiguity that might have unexpected results, the relationships 
  between your Spring-managed objects are no longer documented explicitly.</P>
  <li class=listitem>
  <p>Wiring information may not be available to tools that 
  may generate documentation from a Spring container.</P></LI></UL></DIV>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Multiple bean definitions within the container may 
  match the type specified by the setter method or constructor argument to be 
  autowired. For arrays, collections, or Maps, this is not necessarily a 
  problem. However for dependencies that expect a single value, this ambiguity 
  is not arbitrarily resolved. If no unique bean definition is available, an 
  exception is thrown.</P></LI></UL></DIV>
<p>In the latter scenario, you have several options:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Abandon autowiring in favor of explicit wiring.</P>
  <li class=listitem>
  <p>Avoid autowiring for a bean definition by setting its 
  <code class=literal>autowire-candidate</CODE> attributes 
  to <code class=literal>false</CODE> as described in the 
  next section.</P>
  <li class=listitem>
  <p>Designate a single bean definition as the <span 
  class=emphasis><em 
  >primary</EM></SPAN> candidate by setting the <code 
  class=literal>primary</CODE> attribute of its <code 
  class=literal>&lt;bean/&gt;</CODE> element to <code 
  class=literal>true</CODE>.</P>
  <li class=listitem>
  <p>If you are using Java 5 or later, implement the more 
  fine-grained control available with annotation-based configuration, as 
  described in <A class=xref title="5.9&nbsp;Annotation-based container configuration" href="beans.html#beans-annotation-config" >Section&nbsp;5.9, 
  “Annotation-based container configuration”</A>.</P></LI></UL></DIV></DIV>
<div class=section title="Excluding a bean from autowiring">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-autowire-candidate></A>Excluding a bean from autowiring</H4></DIV></DIV></DIV>
<p>On a per-bean basis, you can exclude a bean from 
autowiring. In Spring's XML format, set the <code class=literal>autowire-candidate</CODE> attribute of the <code 
class=literal>&lt;bean/&gt;</CODE> element to <code 
class=literal>false</CODE>; the container makes that 
specific bean definition unavailable to the autowiring infrastructure (including 
annotation style configurations such as <A class=link title=5.9.2&nbsp;@Autowired href="beans.html#beans-autowired-annotation" ><code 
class=interfacename>@Autowired</CODE></A>).</P>
<p>You can also limit autowire candidates based on 
pattern-matching against bean names. The top-level <code class=literal>&lt;beans/&gt;</CODE> element accepts one or more patterns 
within its <code class=literal>default-autowire-candidates</CODE> attribute. For example, 
to limit autowire candidate status to any bean whose name ends with <span 
class=emphasis><em>Repository,</EM></SPAN> provide a value of *Repository. To 
provide multiple patterns, define them in a comma-separated list. An explicit 
value of <code class=literal>true</CODE> or <code 
class=literal>false</CODE> for a bean definitions <code 
class=literal>autowire-candidate</CODE> attribute always 
takes precedence, and for such beans, the pattern matching rules do not 
apply.</P>
<p>These techniques are useful for beans that you never 
want to be injected into other beans by autowiring. It does not mean that an 
excluded bean cannot itself be configured using autowiring. Rather, the bean 
itself is not a candidate for autowiring other beans.</P></DIV></DIV>
<div class=section title="5.4.6&nbsp;Method injection">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-method-injection></A>5.4.6&nbsp;Method injection</H3></DIV></DIV></DIV>
<p>In most application scenarios, most beans in the 
container are <A class=link title="5.5.1&nbsp;The singleton scope" href="beans.html#beans-factory-scopes-singleton" >singletons</A>. When a 
singleton bean needs to collaborate with another singleton bean, or a 
non-singleton bean needs to collaborate with another non-singleton bean, you 
typically handle the dependency by defining one bean as a property of the other. 
A problem arises when the bean lifecycles are different. Suppose singleton bean 
A needs to use non-singleton (prototype) bean B, perhaps on each method 
invocation on A. The container only creates the singleton bean A once, and thus 
only gets one opportunity to set the properties. The container cannot provide 
bean A with a new instance of bean B every time one is needed.</P>
<p>A solution is to forego some inversion of control. You 
can <A class=link title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >make bean A aware of the 
container</A> by implementing the <code class=interfacename>ApplicationContextAware</CODE> interface, and by <A class=link title="5.2.3&nbsp;Using the container" href="beans.html#beans-factory-client" >making a getBean("B") call to 
the container</A> ask for (a typically new) bean B instance every time bean A 
needs it. The following is an example of this approach:</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>// a class that uses a stateful Command-style class to perform some processing</SPAN></EM>
<span class=hl-keyword>package</SPAN> fiona.apple;

<em class=lineannotation><span class=lineannotation>// Spring-API imports</SPAN></EM>
<span class=hl-keyword>import</SPAN> org.springframework.beans.BeansException;
<span class=hl-keyword>import</SPAN> org.springframework.context.ApplicationContext;
<span class=hl-keyword>import</SPAN> org.springframework.context.ApplicationContextAware;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> CommandManager <span class=hl-keyword>implements</SPAN> ApplicationContextAware {

 <span class=hl-keyword>private</SPAN> ApplicationContext applicationContext;

 <span class=hl-keyword>public</SPAN> Object process(Map commandState) {
    <em class=lineannotation><span class=lineannotation>// grab a new instance of the appropriate Command</SPAN></EM>
    Command command = createCommand();
    <em class=lineannotation><span class=lineannotation>// set the state on the (hopefully brand new) Command instance</SPAN></EM>
    command.setState(commandState);
    <span class=hl-keyword>return</SPAN> command.execute();
 }

 <span class=hl-keyword>protected</SPAN> Command createCommand() {
    <em class=lineannotation><span class=lineannotation>// notice the Spring API dependency!</SPAN></EM>
    <span class=hl-keyword>return</SPAN> <span class=hl-keyword>this</SPAN>.applicationContext.getBean(<span class=hl-string>"command"</SPAN>, Command.<span class=hl-keyword>class</SPAN>);
 }

 <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setApplicationContext(ApplicationContext applicationContext)
                                                                  <span class=hl-keyword>throws</SPAN> BeansException {
    <span class=hl-keyword>this</SPAN>.applicationContext = applicationContext;
 }
}</PRE>
<p>The preceding is not desirable, because the business 
code is aware of and coupled to the Spring Framework. Method Injection, a 
somewhat advanced feature of the Spring IoC container, allows this use case to 
be handled in a clean fashion.</P>
<div class=sidebar>
<p class=title><b></B></P>
<p>You can read more about the motivation for Method 
Injection in <a class=ulink 
href="http://blog.springsource.com/2004/08/06/method-injection/" target=_top>this blog entry</A>.</P></DIV>
<div class=section title="Lookup method injection">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-lookup-method-injection></A>Lookup 
method injection</H4></DIV></DIV></DIV>
<p>Lookup method injection is the ability of the container 
to override methods on <span class=emphasis><em>container managed beans</EM></SPAN>, to return the lookup 
result for another named bean in the container. The lookup typically involves a 
prototype bean as in the scenario described in the preceding section. The Spring 
Framework implements this method injection by using bytecode generation from the 
CGLIB library to generate dynamically a subclass that overrides the method.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>For this dynamic subclassing to work, the class 
      that the Spring container will subclass cannot be <code class=literal 
      >final</CODE>, and the method to be overridden cannot 
      be <code class=literal>final</CODE> either. Also, 
      testing a class that has an <code class=literal 
      >abstract</CODE> method requires you to subclass the 
      class yourself and to supply a stub implementation of the <code 
      class=literal>abstract</CODE> method. Finally, 
      objects that have been the target of method injection cannot be 
      serialized. As of Spring 3.2 it is no longer necessary to add CGLIB to 
      your classpath, because CGLIB classes are repackaged under 
      org.springframework and distributed within the spring-core JAR. This is 
      done both for convenience as well as to avoid potential conflicts with 
      other projects that use differing versions of 
CGLIB.</P></TD></TR></TABLE></DIV>
<p>Looking at the <code class=classname>CommandManager</CODE> class in the previous code snippet, 
you see that the Spring container will dynamically override the implementation 
of the <code class=methodname>createCommand()</CODE> 
method. Your <code class=classname>CommandManager</CODE> 
class will not have any Spring dependencies, as can be seen in the reworked 
example:</P><pre class=programlisting><span class=hl-keyword>package</SPAN> fiona.apple;

<em class=lineannotation><span class=lineannotation>// no more Spring imports! </SPAN></EM>

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>abstract</SPAN> <span class=hl-keyword>class</SPAN> CommandManager {

 <span class=hl-keyword>public</SPAN> Object process(Object commandState) {
    <em class=lineannotation><span class=lineannotation>// grab a new instance of the appropriate Command interface</SPAN></EM>
    Command command = createCommand();
    <em class=lineannotation><span class=lineannotation>// set the state on the (hopefully brand new) Command instance</SPAN></EM>
    command.setState(commandState);
    <span class=hl-keyword>return</SPAN> command.execute();
 }

  <em class=lineannotation><span class=lineannotation>// okay... but where is the implementation of this method?</SPAN></EM>
 <span class=hl-keyword>protected</SPAN> <span class=hl-keyword>abstract</SPAN> Command createCommand();
}</PRE>
<p>In the client class containing the method to be injected 
(the <code class=classname>CommandManager</CODE> in this 
case), the method to be injected requires a signature of the following form:</P><pre class=programlisting><span class=hl-tag>&lt;public|protected&gt;</SPAN> [abstract] <span class=hl-tag>&lt;return-type&gt;</SPAN> theMethodName(<em class=lineannotation><span class=lineannotation>no-arguments</SPAN></EM>);</PRE>
<p>If the method is <code class=literal>abstract</CODE>, the dynamically-generated subclass 
implements the method. Otherwise, the dynamically-generated subclass overrides 
the concrete method defined in the original class. For example:</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"command"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"fiona.apple.AsyncCommand"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"prototype"</SPAN><span class=hl-tag>&gt;</SPAN>
<em class=lineannotation><span class=lineannotation>&lt;!-- inject dependencies here as required --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"commandManager"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"fiona.apple.CommandManager"</SPAN><span class=hl-tag>&gt;</SPAN>
<span class=hl-tag>&lt;lookup-method</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"createCommand"</SPAN> <span class=hl-attribute>bean</SPAN>=<span class=hl-value>"command"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The bean identified as <span class=emphasis><em>commandManager</EM></SPAN> calls 
its own method <code class=methodname>createCommand()</CODE> whenever it needs a new instance of 
the <span class=emphasis><em>command</EM></SPAN> bean. You must be careful to deploy the 
<code class=literal>command</CODE> bean as a prototype, if 
that is actually what is needed. If it is deployed as a <A class=link title="5.5.1&nbsp;The singleton scope" href="beans.html#beans-factory-scopes-singleton" >singleton</A>, the 
same instance of the <code class=literal>command</CODE> 
bean is returned each time.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The interested reader may also find the <code 
      class=classname>ServiceLocatorFactoryBean</CODE> (in 
      the <code class=literal 
      >org.springframework.beans.factory.config</CODE> 
      package) to be of use. The approach used in ServiceLocatorFactoryBean is 
      similar to that of another utility class, <code class=classname 
      >ObjectFactoryCreatingFactoryBean</CODE>, but it 
      allows you to specify your own lookup interface as opposed to a 
      Spring-specific lookup interface. Consult the JavaDocs for these classes 
      as well as this <a class=ulink 
      href="http://blog.arendsen.net/index.php/2006/10/05/on-the-servicelocatorfactorybean-dlas-and-the-sustainability-of-code-and-design/" 
      target=_top>blog entry</A> for additional information 
      ServiceLocatorFactoryBean.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="Arbitrary method replacement">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-arbitrary-method-replacement></A>Arbitrary method replacement</H4></DIV></DIV></DIV>
<p>A less useful form of method injection than lookup 
method Injection is the ability to replace arbitrary methods in a managed bean 
with another method implementation. Users may safely skip the rest of this 
section until the functionality is actually needed.</P>
<p>With XML-based configuration metadata, you can use the 
<code class=literal>replaced-method</CODE> element to 
replace an existing method implementation with another, for a deployed bean. 
Consider the following class, with a method computeValue, which we want to 
override:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MyValueCalculator {

<span class=hl-keyword>public</SPAN> String computeValue(String input) {
  <em class=lineannotation><span class=lineannotation>// some real code...</SPAN></EM>
}

<em class=lineannotation><span class=lineannotation>// some other methods...</SPAN></EM>

}</PRE>
<p>A class implementing the <code class=interfacename>org.springframework.beans.factory.support.MethodReplacer</CODE> 
interface provides the new method definition.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>/** meant to be used to override the existing computeValue(String)
  implementation in MyValueCalculator
*/</SPAN></EM>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ReplacementComputeValue <span class=hl-keyword>implements</SPAN> MethodReplacer {

  <span class=hl-keyword>public</SPAN> Object reimplement(Object o, Method m, Object[] args) <span class=hl-keyword>throws</SPAN> Throwable {
      <em class=lineannotation><span class=lineannotation>// get the input value, work with it, and return a computed result</SPAN></EM>
      String input = (String) args[<span class=hl-number>0</SPAN>];
      ...
      <span class=hl-keyword>return</SPAN> ...;
  }
}</PRE>
<p>The bean definition to deploy the original class and 
specify the method override would look like this:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myValueCalculator"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.z.MyValueCalculator"</SPAN><span class=hl-tag>&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- arbitrary method replacement --&gt;</SPAN></EM>
<span class=hl-tag>&lt;replaced-method</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"computeValue"</SPAN> <span class=hl-attribute>replacer</SPAN>=<span class=hl-value>"replacementComputeValue"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;arg-type&gt;</SPAN>String<span class=hl-tag>&lt;/arg-type&gt;</SPAN>
<span class=hl-tag>&lt;/replaced-method&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"replacementComputeValue"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"a.b.c.ReplacementComputeValue"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>You can use one or more contained <code class=literal>&lt;arg-type/&gt;</CODE> elements within the <code 
class=literal>&lt;replaced-method/&gt;</CODE> element to 
indicate the method signature of the method being overridden. The signature for 
the arguments is necessary only if the method is overloaded and multiple 
variants exist within the class. For convenience, the type string for an 
argument may be a substring of the fully qualified type name. For example, the 
following all match <code class=classname>java.lang.String</CODE>:</P><pre class=programlisting>    java.lang.String
  String
  Str</PRE>
<p>Because the number of arguments is often enough to 
distinguish between each possible choice, this shortcut can save a lot of 
typing, by allowing you to type only the shortest string that will match an 
argument type.</P></DIV></DIV></DIV>
<div class=section title="5.5&nbsp;Bean scopes">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-factory-scopes></A>5.5&nbsp;Bean 
scopes</H2></DIV></DIV></DIV>
<p>When you create a bean definition, you create a <span 
class=emphasis><em>recipe</EM></SPAN> 
for creating actual instances of the class defined by that bean definition. The 
idea that a bean definition is a recipe is important, because it means that, as 
with a class, you can create many object instances from a single recipe.</P>
<p>You can control not only the various dependencies and 
configuration values that are to be plugged into an object that is created from 
a particular bean definition, but also the <em class=firstterm>scope</EM> of the objects created from a particular bean 
definition. This approach is powerful and flexible in that you can <span 
class=emphasis><em>choose</EM></SPAN> 
the scope of the objects you create through configuration instead of having to 
bake in the scope of an object at the Java class level. Beans can be defined to 
be deployed in one of a number of scopes: out of the box, the Spring Framework 
supports five scopes, three of which are available only if you use a web-aware 
<code class=interfacename>ApplicationContext</CODE>.</P>
<p>The following scopes are supported out of the box. You 
can also create <A class=link title="5.5.5&nbsp;Custom scopes" href="beans.html#beans-factory-scopes-custom" >a custom scope.</A></P>
<div class=table><a name=beans-factory-scopes-tbl></A>
<p class=title><b>Table&nbsp;5.3.&nbsp;Bean scopes</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Bean scopes">
  <colgroup>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>Scope</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid" align=center 
      >Description</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p><A class=link title="5.5.1&nbsp;The singleton scope" href="beans.html#beans-factory-scopes-singleton" >singleton</A> 
      </P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>(Default) Scopes a single bean definition to a 
      single object instance per Spring IoC container.</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p><A class=link title="5.5.2&nbsp;The prototype scope" href="beans.html#beans-factory-scopes-prototype" >prototype</A> 
      </P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>Scopes a single bean definition to any number of 
      object instances.</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p><A class=link title="Request scope" href="beans.html#beans-factory-scopes-request" >request</A> 
</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>Scopes a single bean definition to the lifecycle 
      of a single HTTP request; that is, each HTTP request has its own instance 
      of a bean created off the back of a single bean definition. Only valid in 
      the context of a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE>.</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p><A class=link title="Session scope" href="beans.html#beans-factory-scopes-session" >session</A> 
</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>Scopes a single bean definition to the lifecycle 
      of an HTTP <code class=interfacename>Session</CODE>. 
      Only valid in the context of a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE>.</P></TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid">
      <p><A class=link title="Global session scope" href="beans.html#beans-factory-scopes-global-session" >global 
      session</A> </P></TD>
    <td>
      <p>Scopes a single bean definition to the lifecycle 
      of a global HTTP <code class=interfacename 
      >Session</CODE>. Typically only valid when used in a 
      portlet context. Only valid in the context of a web-aware Spring <code 
      class=interfacename 
  >ApplicationContext</CODE>.</P></TD></TR></TBODY></TABLE></DIV></DIV><br 
class=table-break>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note 
title="Thread-scoped beans">
<table border=0 summary="Note: Thread-scoped beans">
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Thread-scoped beans</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>As of Spring 3.0, a <span class=emphasis 
      ><em>thread scope</EM></SPAN> is 
      available, but is not registered by default. For more information, see the 
      documentation for <a class=ulink 
      href="http://static.springsource.org/spring/docs/current/api/org/springframework/context/support/SimpleThreadScope.html" 
      target=_top>SimpleThreadScope</A>. For instructions 
      on how to register this or any other custom scope, see <A class=xref title="Using a custom scope" href="beans.html#beans-factory-scopes-custom-using" >the section 
      called “Using a custom scope”</A>.</P></TD></TR></TABLE></DIV>
<div class=section title="5.5.1&nbsp;The singleton scope">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-scopes-singleton></A>5.5.1&nbsp;The singleton scope</H3></DIV></DIV></DIV>
<p>Only one <span class=emphasis><em>shared</EM></SPAN> instance of a singleton bean is managed, 
and all requests for beans with an id or ids matching that bean definition 
result in that one specific bean instance being returned by the Spring 
container.</P>
<p>To put it another way, when you define a bean definition 
and it is scoped as a singleton, the Spring IoC container creates <span 
class=emphasis><em>exactly 
one</EM></SPAN> instance of the object defined by that bean definition. This 
single instance is stored in a cache of such singleton beans, and <span 
class=emphasis><em>all subsequent 
requests and references</EM></SPAN> for that named bean return the cached 
object.</P>
<div class=mediaobject align=center><IMG align=middle src="images/singleton.png" ></DIV>
<p>Spring's concept of a singleton bean differs from the 
Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF 
Singleton hard-codes the scope of an object such that one <span class=emphasis><em>and only one</EM></SPAN> instance 
of a particular class is created<span class=emphasis><em> per <code class=classname>ClassLoader</CODE></EM></SPAN>. The scope of the Spring 
singleton is best described as <span class=emphasis><em>per container and per bean</EM></SPAN>. This means that if 
you define one bean for a particular class in a single Spring container, then 
the Spring container creates one <span class=emphasis><em>and only one</EM></SPAN> instance of the class defined by 
that bean definition. <span class=emphasis><em>The singleton scope is the default scope in 
Spring</EM></SPAN>. To define a bean as a singleton in XML, you would write, for 
example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.DefaultAccountService"</SPAN><span class=hl-tag>/&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.DefaultAccountService"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"singleton"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE></DIV>
<div class=section title="5.5.2&nbsp;The prototype scope">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-scopes-prototype></A>5.5.2&nbsp;The prototype scope</H3></DIV></DIV></DIV>
<p>The non-singleton, prototype scope of bean deployment 
results in the <span class=emphasis><em>creation of a new bean instance</EM></SPAN> every time a 
request for that specific bean is made. That is, the bean is injected into 
another bean or you request it through a <code class=literal>getBean()</CODE> method call on the container. As a rule, 
use the prototype scope for all stateful beans and the singleton scope for 
stateless beans.</P>
<p>The following diagram illustrates the Spring prototype 
scope. <span class=emphasis><em>A data 
access object (DAO) is not typically configured as a prototype, because a 
typical DAO does not hold any conversational state; it was just easier for this 
author to reuse the core of the singleton diagram.</EM></SPAN></P>
<div class=mediaobject align=center><IMG align=middle src="images/prototype.png" ></DIV>
<p>The following example defines a bean as a prototype in 
XML:</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- using spring-beans-2.0.dtd --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"accountService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.DefaultAccountService"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"prototype"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>In contrast to the other scopes, Spring does not manage 
the complete lifecycle of a prototype bean: the container instantiates, 
configures, and otherwise assembles a prototype object, and hands it to the 
client, with no further record of that prototype instance. Thus, although <span 
class=emphasis><em>initialization</EM></SPAN> lifecycle callback methods are 
called on all objects regardless of scope, in the case of prototypes, configured 
<span class=emphasis><em>destruction</EM></SPAN> lifecycle callbacks are <span 
class=emphasis><em>not</EM></SPAN> 
called. The client code must clean up prototype-scoped objects and release 
expensive resources that the prototype bean(s) are holding. To get the Spring 
container to release resources held by prototype-scoped beans, try using a 
custom <A class=link title="5.8.1&nbsp;Customizing beans using a BeanPostProcessor" href="beans.html#beans-factory-extension-bpp" >bean post-processor</A>, 
which holds a reference to beans that need to be cleaned up.</P>
<p>In some respects, the Spring container's role in regard 
to a prototype-scoped bean is a replacement for the Java <code class=literal>new</CODE> operator. All lifecycle management past that 
point must be handled by the client. (For details on the lifecycle of a bean in 
the Spring container, see <A class=xref title="5.6.1&nbsp;Lifecycle callbacks" href="beans.html#beans-factory-lifecycle" >Section&nbsp;5.6.1, 
“Lifecycle callbacks”</A>.)</P></DIV>
<div class=section 
title="5.5.3&nbsp;Singleton beans with prototype-bean dependencies">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-factory-scopes-sing-prot-interaction></A>5.5.3&nbsp;Singleton beans with prototype-bean 
dependencies</H3></DIV></DIV></DIV>
<p>When you use singleton-scoped beans with dependencies on 
prototype beans, be aware that <span class=emphasis><em>dependencies are resolved at instantiation 
time</EM></SPAN>. Thus if you dependency-inject a prototype-scoped bean into a 
singleton-scoped bean, a new prototype bean is instantiated and then 
dependency-injected into the singleton bean. The prototype instance is the sole 
instance that is ever supplied to the singleton-scoped bean.</P>
<p>However, suppose you want the singleton-scoped bean to 
acquire a new instance of the prototype-scoped bean repeatedly at runtime. You 
cannot dependency-inject a prototype-scoped bean into your singleton bean, 
because that injection occurs only <span class=emphasis><em>once</EM></SPAN>, when the Spring container is 
instantiating the singleton bean and resolving and injecting its dependencies. 
If you need a new instance of a prototype bean at runtime more than once, see <A class=xref title="5.4.6&nbsp;Method injection" href="beans.html#beans-factory-method-injection" >Section&nbsp;5.4.6, 
“Method injection”</A></P></DIV>
<div class=section 
title="5.5.4&nbsp;Request, session, and global session scopes">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-scopes-other></A>5.5.4&nbsp;Request, session, and global session 
scopes</H3></DIV></DIV></DIV>
<p>The <code class=literal>request</CODE>, <code class=literal>session</CODE>, and <code class=literal>global session</CODE> scopes are <span class=emphasis><em>only</EM></SPAN> available if you 
use a web-aware Spring <code class=interfacename>ApplicationContext</CODE> implementation (such as <code 
class=classname>XmlWebApplicationContext</CODE>). If you 
use these scopes with regular Spring IoC containers such as the <code 
class=classname>ClassPathXmlApplicationContext</CODE>, you 
get an <code class=classname>IllegalStateException</CODE> 
complaining about an unknown bean scope.</P>
<div class=section title="Initial web configuration">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-scopes-other-web-configuration></A>Initial web configuration</H4></DIV></DIV></DIV>
<p>To support the scoping of beans at the <code 
class=literal>request</CODE>, <code class=literal>session</CODE>, and <code class=literal>global session</CODE> levels (web-scoped beans), some minor 
initial configuration is required before you define your beans. (This initial 
setup is <span class=emphasis><em>not</EM></SPAN> required for the standard scopes, singleton 
and prototype.)</P>
<p>How you accomplish this initial setup depends on your 
particular Servlet environment..</P>
<p>If you access scoped beans within Spring Web MVC, in 
effect, within a request that is processed by the Spring <code class=classname>DispatcherServlet</CODE>, or <code class=classname>DispatcherPortlet</CODE>, then no special setup is 
necessary: <code class=classname>DispatcherServlet</CODE> 
and <code class=classname>DispatcherPortlet</CODE> already 
expose all relevant state.</P>
<p>If you use a Servlet 2.4+ web container, with requests 
processed outside of Spring's DispatcherServlet (for example, when using JSF or 
Struts), you need to add the following <code class=interfacename>javax.servlet.ServletRequestListener</CODE> to the 
declarations in your web applications <code class=literal>web.xml</CODE> file:</P><pre class=programlisting><span class=hl-tag>&lt;web-app&gt;</SPAN>
...
<span class=hl-tag>&lt;listener&gt;</SPAN>
  <span class=hl-tag>&lt;listener-class&gt;</SPAN>
      org.springframework.web.context.request.RequestContextListener
  <span class=hl-tag>&lt;/listener-class&gt;</SPAN>
<span class=hl-tag>&lt;/listener&gt;</SPAN>
...
<span class=hl-tag>&lt;/web-app&gt;</SPAN></PRE>
<p>If you use an older web container (Servlet 2.3), use the 
provided <code class=interfacename>javax.servlet.Filter</CODE> implementation. The following 
snippet of XML configuration must be included in the <code class=literal>web.xml</CODE> file of your web application if you want to 
access web-scoped beans in requests outside of Spring's DispatcherServlet on a 
Servlet 2.3 container. (The filter mapping depends on the surrounding web 
application configuration, so you must change it as appropriate.)</P><pre class=programlisting><span class=hl-tag>&lt;web-app&gt;</SPAN>
..
<span class=hl-tag>&lt;filter&gt;</SPAN>
  <span class=hl-tag>&lt;filter-name&gt;</SPAN>requestContextFilter<span class=hl-tag>&lt;/filter-name&gt;</SPAN>
  <span class=hl-tag>&lt;filter-class&gt;</SPAN>org.springframework.web.filter.RequestContextFilter<span class=hl-tag>&lt;/filter-class&gt;</SPAN>
<span class=hl-tag>&lt;/filter&gt;</SPAN>
<span class=hl-tag>&lt;filter-mapping&gt;</SPAN>
  <span class=hl-tag>&lt;filter-name&gt;</SPAN>requestContextFilter<span class=hl-tag>&lt;/filter-name&gt;</SPAN>
  <span class=hl-tag>&lt;url-pattern&gt;</SPAN>/*<span class=hl-tag>&lt;/url-pattern&gt;</SPAN>
<span class=hl-tag>&lt;/filter-mapping&gt;</SPAN>
...
<span class=hl-tag>&lt;/web-app&gt;</SPAN></PRE>
<p><code class=classname>DispatcherServlet</CODE>, <code class=classname>RequestContextListener</CODE> and <code class=classname>RequestContextFilter</CODE> all do exactly the same thing, 
namely bind the HTTP request object to the <code class=classname>Thread</CODE> that is servicing that request. This makes 
beans that are request- and session-scoped available further down the call 
chain.</P></DIV>
<div class=section title="Request scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-scopes-request></A>Request scope</H4></DIV></DIV></DIV>
<p>Consider the following bean definition:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"loginAction"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.LoginAction"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"request"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>The Spring container creates a new instance of the <code 
class=classname>LoginAction</CODE> bean by using the <code 
class=literal>loginAction</CODE> bean definition for each 
and every HTTP request. That is, the <code class=literal>loginAction</CODE> bean is scoped at the HTTP request 
level. You can change the internal state of the instance that is created as much 
as you want, because other instances created from the same <code class=literal>loginAction</CODE> bean definition will not see these 
changes in state; they are particular to an individual request. When the request 
completes processing, the bean that is scoped to the request is 
discarded.</P></DIV>
<div class=section title="Session scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-scopes-session></A>Session scope</H4></DIV></DIV></DIV>
<p>Consider the following bean definition:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"session"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>The Spring container creates a new instance of the <code 
class=classname>UserPreferences</CODE> bean by using the 
<code class=literal>userPreferences</CODE> bean definition 
for the lifetime of a single HTTP <code class=interfacename>Session</CODE>. In other words, the <code class=literal>userPreferences</CODE> bean is effectively scoped at the 
HTTP <code class=interfacename>Session</CODE> level. As 
with <code class=literal>request-scoped</CODE> beans, you 
can change the internal state of the instance that is created as much as you 
want, knowing that other HTTP <code class=interfacename>Session</CODE> instances that are also using instances 
created from the same <code class=literal>userPreferences</CODE> bean definition do not see these 
changes in state, because they are particular to an individual HTTP <code 
class=interfacename>Session</CODE>. When the HTTP <code 
class=interfacename>Session</CODE> is eventually discarded, 
the bean that is scoped to that particular HTTP <code class=interfacename>Session</CODE> is also discarded.</P></DIV>
<div class=section title="Global session scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-scopes-global-session></A>Global session scope</H4></DIV></DIV></DIV>
<p>Consider the following bean definition:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"globalSession"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>The <code class=literal>global 
session</CODE> scope is similar to the standard HTTP <code class=interfacename>Session</CODE> scope (<A class=link title="Session scope" href="beans.html#beans-factory-scopes-session" >described above</A>), 
and applies only in the context of portlet-based web applications. The portlet 
specification defines the notion of a global <code class=interfacename>Session</CODE> that is shared among all portlets that make 
up a single portlet web application. Beans defined at the <code class=literal>global session</CODE> scope are scoped (or bound) to the 
lifetime of the global portlet <code class=interfacename>Session</CODE>.</P>
<p>If you write a standard Servlet-based web application 
and you define one or more beans as having <code class=literal>global session</CODE> scope, the standard HTTP <code 
class=interfacename>Session</CODE> scope is used, and no 
error is raised.</P></DIV>
<div class=section title="Scoped beans as dependencies">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-scopes-other-injection></A>Scoped beans 
as dependencies</H4></DIV></DIV></DIV>
<p>The Spring IoC container manages not only the 
instantiation of your objects (beans), but also the wiring up of collaborators 
(or dependencies). If you want to inject (for example) an HTTP request scoped 
bean into another bean, you must inject an AOP proxy in place of the scoped 
bean. That is, you need to inject a proxy object that exposes the same public 
interface as the scoped object but that can also retrieve the real, target 
object from the relevant scope (for example, an HTTP request) and delegate 
method calls onto the real object.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>You <span class=emphasis><em 
      >do not</EM></SPAN> need to use the <code 
      class=literal>&lt;aop:scoped-proxy/&gt;</CODE> in 
      conjunction with beans that are scoped as <code class=literal 
      >singletons</CODE> or <code class=literal 
      >prototypes</CODE>.</P></TD></TR></TABLE></DIV>
<p>The configuration in the following example is only one 
line, but it is important to understand the <span class=quote>“<span class=quote>why</SPAN>”</SPAN> 
as well as the <span class=quote>“<span class=quote>how</SPAN>”</SPAN> behind it.</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <span class=hl-attribute>xmlns:aop</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/aop"</SPAN>
     <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/aop
         http://www.springframework.org/schema/aop/spring-aop.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <em class=lineannotation><span class=lineannotation>&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"session"</SPAN><span class=hl-tag>&gt;</SPAN>

        <em class=lineannotation><span class=lineannotation>&lt;!-- instructs the container to proxy the surrounding bean --&gt;</SPAN></EM>
        <span class=hl-tag>&lt;aop:scoped-proxy/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <em class=lineannotation><span class=lineannotation>&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.SimpleUserService"</SPAN><span class=hl-tag>&gt;</SPAN>

      <em class=lineannotation><span class=lineannotation>&lt;!-- a reference to the proxied userPreferences bean --&gt;</SPAN></EM>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"userPreferences"</SPAN><span class=hl-tag>/&gt;</SPAN>

  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN>
</PRE>
<p>To create such a proxy, you insert a child <code 
class=literal>&lt;aop:scoped-proxy/&gt;</CODE> element into 
a scoped bean definition. See <A class=xref title="Choosing the type of proxy to create" href="beans.html#beans-factory-scopes-other-injection-proxies" >the 
section called “Choosing the type of proxy to create”</A> and <A class=xref title="Appendix&nbsp;D.&nbsp;XML Schema-based configuration" href="xsd-config.html" >Appendix&nbsp;D, <i>XML 
Schema-based configuration</I></A>.) Why do definitions of beans scoped at the 
<code class=literal>request</CODE>, <code class=literal>session</CODE>, <code class=literal>globalSession</CODE> and custom-scope levels require the 
<code class=literal>&lt;aop:scoped-proxy/&gt;</CODE> 
element ? Let's examine the following singleton bean definition and contrast it 
with what you need to define for the aforementioned scopes. (The following <code 
class=literal>userPreferences</CODE> bean definition as it 
stands is <span class=emphasis><em>incomplete.)</EM></SPAN></P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"session"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userManager"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserManager"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"userPreferences"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>In the preceding example, the singleton bean <code 
class=literal>userManager</CODE> is injected with a 
reference to the HTTP <code class=interfacename>Session</CODE>-scoped bean <code class=literal>userPreferences</CODE>. The salient point here is that the 
<code class=literal>userManager</CODE> bean is a singleton: 
it will be instantiated <span class=emphasis><em>exactly once</EM></SPAN> per container, and its 
dependencies (in this case only one, the <code class=literal>userPreferences</CODE> bean) are also injected only once. 
This means that the <code class=literal>userManager</CODE> 
bean will only operate on the exact same <code class=literal>userPreferences</CODE> object, that is, the one that it was 
originally injected with.</P>
<p>This is <span class=emphasis><em>not</EM></SPAN> the behavior you want when injecting a 
shorter-lived scoped bean into a longer-lived scoped bean, for example injecting 
an HTTP <code class=interfacename>Session</CODE>-scoped 
collaborating bean as a dependency into singleton bean. Rather, you need a 
single <code class=literal>userManager</CODE> object, and 
for the lifetime of an HTTP <code class=interfacename>Session</CODE>, you need a <code class=literal>userPreferences</CODE> object that is specific to said HTTP 
<code class=interfacename>Session</CODE>. Thus the 
container creates an object that exposes the exact same public interface as the 
<code class=classname>UserPreferences</CODE> class (ideally 
an object that <span class=emphasis><em>is a</EM></SPAN> <code class=classname>UserPreferences</CODE> instance) which can fetch the real 
<code class=classname>UserPreferences</CODE> object from 
the scoping mechanism (HTTP request, <code class=interfacename>Session</CODE>, etc.). The container injects this proxy 
object into the <code class=literal>userManager</CODE> 
bean, which is unaware that this <code class=classname>UserPreferences</CODE> reference is a proxy. In this 
example, when a <code class=interfacename>UserManager</CODE> instance invokes a method on the 
dependency-injected <code class=classname>UserPreferences</CODE> object, it actually is invoking a 
method on the proxy. The proxy then fetches the real <code class=classname>UserPreferences</CODE> object from (in this case) the HTTP 
<code class=interfacename>Session</CODE>, and delegates the 
method invocation onto the retrieved real <code class=classname>UserPreferences</CODE> object.</P>
<p>Thus you need the following, correct and complete, 
configuration when injecting <code class=literal>request-</CODE>, <code class=literal>session-</CODE>, and <code class=literal>globalSession-scoped</CODE> beans into collaborating 
objects:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"session"</SPAN><span class=hl-tag>&gt;</SPAN>
  <code class=literal>&lt;aop:scoped-proxy/&gt;</CODE>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userManager"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserManager"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"userPreferences"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<div class=section title="Choosing the type of proxy to create">
<div class=titlepage>
<div>
<div>
<h5 class=title><a 
name=beans-factory-scopes-other-injection-proxies></A>Choosing the type of proxy to 
create</H5></DIV></DIV></DIV>
<p>By default, when the Spring container creates a proxy 
for a bean that is marked up with the <code class=literal>&lt;aop:scoped-proxy/&gt;</CODE> element, <span 
class=emphasis><em>a CGLIB-based class 
proxy is created</EM></SPAN>.</P>
<p><span class=emphasis><em>Note: CGLIB proxies only intercept public method 
calls!</EM></SPAN> Do not call non-public methods on such a proxy; they will not 
be delegated to the scoped target object.</P>
<p>Alternatively, you can configure the Spring container to 
create standard JDK interface-based proxies for such scoped beans, by specifying 
<code class=literal>false</CODE> for the value of the <code 
class=literal>proxy-target-class</CODE> attribute of the 
<code class=literal>&lt;aop:scoped-proxy/&gt;</CODE> 
element. Using JDK interface-based proxies means that you do not need additional 
libraries in your application classpath to effect such proxying. However, it 
also means that the class of the scoped bean must implement at least one 
interface, and <span class=emphasis><em>that all</EM></SPAN> collaborators into which the scoped 
bean is injected must reference the bean through one of its interfaces.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</SPAN></EM>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.DefaultUserPreferences"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"session"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;aop:scoped-proxy</SPAN> <span class=hl-attribute>proxy-target-class</SPAN>=<span class=hl-value>"false"</SPAN><code class=literal></CODE>/&gt;
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"userManager"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.UserManager"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"userPreferences"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"userPreferences"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>For more detailed information about choosing class-based 
or interface-based proxying, see <A class=xref title="9.6&nbsp;Proxying mechanisms" href="aop.html#aop-proxying" >Section&nbsp;9.6, 
“Proxying mechanisms”</A>.</P></DIV></DIV></DIV>
<div class=section title="5.5.5&nbsp;Custom scopes">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-scopes-custom></A>5.5.5&nbsp;Custom scopes</H3></DIV></DIV></DIV>
<p>As of Spring 2.0, the bean scoping mechanism is 
extensible. You can define your own scopes, or even redefine existing scopes, 
although the latter is considered bad practice and you <span class=emphasis><em>cannot</EM></SPAN> override the 
built-in <code class=literal>singleton</CODE> and <code 
class=literal>prototype</CODE> scopes.</P>
<div class=section title="Creating a custom scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-scopes-custom-creating></A>Creating a 
custom scope</H4></DIV></DIV></DIV>
<p>To integrate your custom scope(s) into the Spring 
container, you need to implement the <code class=interfacename>org.springframework.beans.factory.config.Scope</CODE> 
interface, which is described in this section. For an idea of how to implement 
your own scopes, see the <code class=interfacename>Scope</CODE> implementations that are supplied with the 
Spring Framework itself and the <a class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/Scope.html" 
target=_top>Scope Javadoc</A>, which explains the methods 
you need to implement in more detail.</P>
<p>The <code class=literal>Scope</CODE> interface has four methods to get objects from 
the scope, remove them from the scope, and allow them to be destroyed.</P>
<p>The following method returns the object from the 
underlying scope. The session scope implementation, for example, returns the 
session-scoped bean (and if it does not exist, the method returns a new instance 
of the bean, after having bound it to the session for future reference).</P><pre class=programlisting>Object get(String name, ObjectFactory objectFactory)</PRE>
<p>The following method removes the object from the 
underlying scope. The session scope implementation for example, removes the 
session-scoped bean from the underlying session. The object should be returned, 
but you can return null if the object with the specified name is not found.</P><pre class=programlisting>Object remove(String name)</PRE>
<p>The following method registers the callbacks the scope 
should execute when it is destroyed or when the specified object in the scope is 
destroyed. Refer to the Javadoc or a Spring scope implementation for more 
information on destruction callbacks.</P><pre class=programlisting><span class=hl-keyword>void</SPAN> registerDestructionCallback(String name, Runnable destructionCallback)</PRE>
<p>The following method obtains the conversation identifier 
for the underlying scope. This identifier is different for each scope. For a 
session scoped implementation, this identifier can be the session 
identifier.</P><pre class=programlisting>String getConversationId()</PRE></DIV>
<div class=section title="Using a custom scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-scopes-custom-using></A>Using a custom scope</H4></DIV></DIV></DIV>
<p>After you write and test one or more custom <code 
class=interfacename>Scope</CODE> implementations, you need 
to make the Spring container aware of your new scope(s). The following method is 
the central method to register a new <code class=interfacename>Scope</CODE> with the Spring container:</P><pre class=programlisting><span class=hl-keyword>void</SPAN> registerScope(String scopeName, Scope scope);</PRE>
<p>This method is declared on the <code class=interfacename>ConfigurableBeanFactory</CODE> interface, which is 
available on most of the concrete <code class=interfacename>ApplicationContext</CODE> implementations that ship with 
Spring via the BeanFactory property.</P>
<p>The first argument to the <code class=methodname>registerScope(..)</CODE> method is the unique name 
associated with a scope; examples of such names in the Spring container itself 
are <code class=literal>singleton</CODE> and <code 
class=literal>prototype</CODE>. The second argument to the 
<code class=methodname>registerScope(..)</CODE> method is 
an actual instance of the custom <code class=interfacename>Scope</CODE> implementation that you wish to register and 
use.</P>
<p>Suppose that you write your custom <code 
class=interfacename>Scope</CODE> implementation, and then 
register it as below.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The example below uses <code class=literal 
      >SimpleThreadScope</CODE> which is included with 
      Spring, but not registered by default. The instructions would be the same 
      for your own custom <code class=literal>Scope</CODE> 
      implementations.</P></TD></TR></TABLE></DIV><pre class=programlisting>Scope threadScope = <span class=hl-keyword>new</SPAN> SimpleThreadScope();
beanFactory.registerScope(<span class=hl-string>"thread"</SPAN>, threadScope);</PRE>
<p>You then create bean definitions that adhere to the 
scoping rules of your custom <code class=interfacename>Scope</CODE>:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"..."</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"..."</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"thread"</SPAN><span class=hl-tag>&gt;</SPAN></PRE>
<p>With a custom <code class=interfacename>Scope</CODE> implementation, you are not limited to 
programmatic registration of the scope. You can also do the <code 
class=interfacename>Scope</CODE> registration 
declaratively, using the <code class=classname>CustomScopeConfigurer</CODE> class:</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <span class=hl-attribute>xmlns:aop</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/aop"</SPAN>
     <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/aop
         http://www.springframework.org/schema/aop/spring-aop.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.config.CustomScopeConfigurer"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"scopes"</SPAN><span class=hl-tag>&gt;</SPAN>
          <span class=hl-tag>&lt;map&gt;</SPAN>
              <span class=hl-tag>&lt;entry</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"thread"</SPAN><span class=hl-tag>&gt;</SPAN>
                  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.context.support.SimpleThreadScope"</SPAN><span class=hl-tag>/&gt;</SPAN>
              <span class=hl-tag>&lt;/entry&gt;</SPAN>
          <span class=hl-tag>&lt;/map&gt;</SPAN>
      <span class=hl-tag>&lt;/property&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"bar"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Bar"</SPAN> <span class=hl-attribute>scope</SPAN>=<span class=hl-value>"thread"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Rick"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;aop:scoped-proxy/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"foo"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"x.y.Foo"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"bar"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"bar"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>When you place &lt;aop:scoped-proxy/&gt; in a 
      <code class=interfacename>FactoryBean</CODE> 
      implementation, it is the factory bean itself that is scoped, not the 
      object returned from <code class=methodname 
      >getObject()</CODE>.</P></TD></TR></TABLE></DIV></DIV></DIV></DIV>
<div class=section title="5.6&nbsp;Customizing the nature of a bean">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-factory-nature></A>5.6&nbsp;Customizing the 
nature of a bean</H2></DIV></DIV></DIV>
<div class=section title="5.6.1&nbsp;Lifecycle callbacks">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-lifecycle></A>5.6.1&nbsp;Lifecycle callbacks</H3></DIV></DIV></DIV>
<p>To interact with the container's management of the bean 
lifecycle, you can implement the Spring <code class=interfacename>InitializingBean</CODE> and <code class=interfacename>DisposableBean</CODE> interfaces. The container calls <code 
class=methodname>afterPropertiesSet()</CODE> for the former 
and <code class=methodname>destroy()</CODE> for the latter 
to allow the bean to perform certain actions upon initialization and destruction 
of your beans. You can also achieve the same integration with the container 
without coupling your classes to Spring interfaces through the use of 
init-method and destroy method object definition metadata.</P>
<p>Internally, the Spring Framework uses <code 
class=interfacename>BeanPostProcessor</CODE> 
implementations to process any callback interfaces it can find and call the 
appropriate methods. If you need custom features or other lifecycle behavior 
Spring does not offer out-of-the-box, you can implement a <code 
class=interfacename>BeanPostProcessor</CODE> yourself. For 
more information, see <A class=xref title="5.8&nbsp;Container Extension Points" href="beans.html#beans-factory-extension" >Section&nbsp;5.8, “Container 
Extension Points”</A>.</P>
<p>In addition to the initialization and destruction 
callbacks, Spring-managed objects may also implement the <code 
class=interfacename>Lifecycle</CODE> interface so that 
those objects can participate in the startup and shutdown process as driven by 
the container's own lifecycle.</P>
<p>The lifecycle callback interfaces are described in this 
section.</P>
<div class=section title="Initialization callbacks">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-lifecycle-initializingbean></A>Initialization callbacks</H4></DIV></DIV></DIV>
<p>The <code class=interfacename>org.springframework.beans.factory.InitializingBean</CODE> 
interface allows a bean to perform initialization work after all necessary 
properties on the bean have been set by the container. The <code 
class=interfacename>InitializingBean</CODE> interface 
specifies a single method:</P><pre class=programlisting><span class=hl-keyword>void</SPAN> afterPropertiesSet() <span class=hl-keyword>throws</SPAN> Exception;</PRE>
<p>It is recommended that you do not use the <code 
class=interfacename>InitializingBean</CODE> interface 
because it unnecessarily couples the code to Spring. Alternatively, specify a 
POJO initialization method. In the case of XML-based configuration metadata, you 
use the <code class=literal>init-method</CODE> attribute to 
specify the name of the method that has a void no-argument signature. For 
example, the following definition:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleInitBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN> <span class=hl-attribute>init-method</SPAN>=<span class=hl-value>"init"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> init() {
      <em class=lineannotation><span class=lineannotation>// do some initialization work</SPAN></EM>
  }
}</PRE>
<p>...is exactly the same as...</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleInitBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.AnotherExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AnotherExampleBean <span class=hl-keyword>implements</SPAN> InitializingBean {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> afterPropertiesSet() {
      <em class=lineannotation><span class=lineannotation>// do some initialization work</SPAN></EM>
  }
}</PRE>
<p>... but does not couple the code to Spring.</P></DIV>
<div class=section title="Destruction callbacks">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-lifecycle-disposablebean></A>Destruction 
callbacks</H4></DIV></DIV></DIV>
<p>Implementing the <code class=interfacename>org.springframework.beans.factory.DisposableBean</CODE> 
interface allows a bean to get a callback when the container containing it is 
destroyed. The <code class=interfacename>DisposableBean</CODE> interface specifies a single 
method:</P><pre class=programlisting><span class=hl-keyword>void</SPAN> destroy() <span class=hl-keyword>throws</SPAN> Exception;</PRE>
<p>It is recommended that you do not use the <code 
class=interfacename>DisposableBean</CODE> callback 
interface because it unnecessarily couples the code to Spring. Alternatively, 
specify a generic method that is supported by bean definitions. With XML-based 
configuration metadata, you use the <code class=literal>destroy-method</CODE> attribute on the <code class=literal>&lt;bean/&gt;</CODE>. For example, the following 
definition:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleInitBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.ExampleBean"</SPAN> <span class=hl-attribute>destroy-method</SPAN>=<span class=hl-value>"cleanup"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ExampleBean {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> cleanup() {
      <em class=lineannotation><span class=lineannotation>// do some destruction work (like releasing pooled connections)</SPAN></EM>
  }
}</PRE>
<p>...is exactly the same as...</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"exampleInitBean"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"examples.AnotherExampleBean"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AnotherExampleBean <span class=hl-keyword>implements</SPAN> DisposableBean {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> destroy() {
      <em class=lineannotation><span class=lineannotation>// do some destruction work (like releasing pooled connections)</SPAN></EM>
  }
}</PRE>
<p>... but does not couple the code to Spring.</P></DIV>
<div class=section title="Default initialization and destroy methods">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-lifecycle-default-init-destroy-methods></A>Default initialization and destroy 
methods</H4></DIV></DIV></DIV>
<p>When you write initialization and destroy method 
callbacks that do not use the Spring-specific <code class=interfacename>InitializingBean</CODE> and <code class=interfacename>DisposableBean</CODE> callback interfaces, you typically 
write methods with names such as <code class=literal>init()</CODE>, <code class=literal>initialize()</CODE>, <code class=literal>dispose()</CODE>, and so on. Ideally, the names of such 
lifecycle callback methods are standardized across a project so that all 
developers use the same method names and ensure consistency.</P>
<p>You can configure the Spring container to <code 
class=literal>look</CODE> for named initialization and 
destroy callback method names on <span class=emphasis><em>every</EM></SPAN> bean. This means that you, as an 
application developer, can write your application classes and use an 
initialization callback called <code class=literal>init()</CODE>, without having to configure an <code 
class=literal>init-method="init"</CODE> attribute with each 
bean definition. The Spring IoC container calls that method when the bean is 
created (and in accordance with the standard lifecycle callback contract 
described previously). This feature also enforces a consistent naming convention 
for initialization and destroy method callbacks.</P>
<p>Suppose that your initialization callback methods are 
named <code class=literal>init()</CODE> and destroy 
callback methods are named <code class=literal>destroy()</CODE>. Your class will resemble the class in the 
following example.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> DefaultBlogService <span class=hl-keyword>implements</SPAN> BlogService {

  <span class=hl-keyword>private</SPAN> BlogDao blogDao;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setBlogDao(BlogDao blogDao) {
      <span class=hl-keyword>this</SPAN>.blogDao = blogDao;
  }

  <em class=lineannotation><span class=lineannotation>// this is (unsurprisingly) the initialization callback method</SPAN></EM>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> init() {
      <span class=hl-keyword>if</SPAN> (<span class=hl-keyword>this</SPAN>.blogDao == null) {
          <span class=hl-keyword>throw</SPAN> <span class=hl-keyword>new</SPAN> IllegalStateException(<span class=hl-string>"The [blogDao] property must be set."</SPAN>);
      }
  }
}</PRE><pre class=programlisting><span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>default-init-method</SPAN>=<span class=hl-value>"init"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"blogService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.DefaultBlogService"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"blogDao"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"blogDao"</SPAN><span class=hl-tag> /&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>The presence of the <code class=literal>default-init-method</CODE> attribute on the top-level <code 
class=literal>&lt;beans/&gt;</CODE> element attribute 
causes the Spring IoC container to recognize a method called <code class=literal>init</CODE> on beans as the initialization method callback. 
When a bean is created and assembled, if the bean class has such a method, it is 
invoked at the appropriate time.</P>
<p>You configure destroy method callbacks similarly (in 
XML, that is) by using the <code class=literal>default-destroy-method</CODE> attribute on the top-level 
<code class=literal>&lt;beans/&gt;</CODE> element.</P>
<p>Where existing bean classes already have callback 
methods that are named at variance with the convention, you can override the 
default by specifying (in XML, that is) the method name using the <code 
class=literal>init-method</CODE> and <code class=literal>destroy-method</CODE> attributes of the &lt;bean/&gt; 
itself.</P>
<p>The Spring container guarantees that a configured 
initialization callback is called immediately after a bean is supplied with all 
dependencies. Thus the initialization callback is called on the raw bean 
reference, which means that AOP interceptors and so forth are not yet applied to 
the bean. A target bean is fully created <span class=emphasis><em>first</EM></SPAN>, <span 
class=emphasis><em>then</EM></SPAN> an 
AOP proxy (for example) with its interceptor chain is applied. If the target 
bean and the proxy are defined separately, your code can even interact with the 
raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply 
the interceptors to the init method, because doing so would couple the lifecycle 
of the target bean with its proxy/interceptors and leave strange semantics when 
your code interacts directly to the raw target bean.</P></DIV>
<div class=section title="Combining lifecycle mechanisms">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-lifecycle-combined-effects></A>Combining 
lifecycle mechanisms</H4></DIV></DIV></DIV>
<p>As of Spring 2.5, you have three options for controlling 
bean lifecycle behavior: the <A class=link title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" ><code 
class=interfacename>InitializingBean</CODE></A> and <A class=link title="Destruction callbacks" href="beans.html#beans-factory-lifecycle-disposablebean" ><code 
class=interfacename>DisposableBean</CODE></A> callback 
interfaces; custom <code class=literal>init()</CODE> and 
<code class=literal>destroy()</CODE> methods; and the <A class=link title="5.9.6&nbsp;@PostConstruct and @PreDestroy" href="beans.html#beans-postconstruct-and-predestroy-annotations" ><code 
class=interfacename>@PostConstruct</CODE> and <code 
class=interfacename>@PreDestroy</CODE> annotations</A>. You 
can combine these mechanisms to control a given bean.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If multiple lifecycle mechanisms are configured 
      for a bean, and each mechanism is configured with a different method name, 
      then each configured method is executed in the order listed below. 
      However, if the same method name is configured - for example, <code 
      class=literal>init()</CODE> for an initialization 
      method - for more than one of these lifecycle mechanisms, that method is 
      executed once, as explained in the preceding 
section.</P></TD></TR></TABLE></DIV>
<p>Multiple lifecycle mechanisms configured for the same 
bean, with different initialization methods, are called as follows:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Methods annotated with <code class=interfacename 
  >@PostConstruct</CODE></P>
  <li class=listitem>
  <p><code class=literal 
  >afterPropertiesSet()</CODE> as defined by the <code 
  class=interfacename>InitializingBean</CODE> callback 
  interface</P>
  <li class=listitem>
  <p>A custom configured <code class=literal 
  >init()</CODE> method</P></LI></UL></DIV>
<p>Destroy methods are called in the same order:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p>Methods annotated with <code class=interfacename 
  >@PreDestroy</CODE></P>
  <li class=listitem>
  <p><code class=literal 
  >destroy()</CODE> as defined by the <code 
  class=interfacename>DisposableBean</CODE> callback 
  interface</P>
  <li class=listitem>
  <p>A custom configured <code class=literal 
  >destroy()</CODE> method</P></LI></UL></DIV></DIV>
<div class=section title="Startup and shutdown callbacks">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-lifecycle-processor></A>Startup and shutdown callbacks</H4></DIV></DIV></DIV>
<p>The <code class=interfacename>Lifecycle</CODE> interface defines the essential methods 
for any object that has its own lifecycle requirements (e.g. starts and stops 
some background process):</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> Lifecycle {

  <span class=hl-keyword>void</SPAN> start();

  <span class=hl-keyword>void</SPAN> stop();

  <span class=hl-keyword>boolean</SPAN> isRunning();

}</PRE>
<p>Any Spring-managed object may implement that interface. 
Then, when the ApplicationContext itself starts and stops, it will cascade those 
calls to all Lifecycle implementations defined within that context. It does this 
by delegating to a <code class=interfacename>LifecycleProcessor</CODE>:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> LifecycleProcessor <span class=hl-keyword>extends</SPAN> Lifecycle {

  <span class=hl-keyword>void</SPAN> onRefresh();

  <span class=hl-keyword>void</SPAN> onClose();

}</PRE>
<p>Notice that the <code class=interfacename>LifecycleProcessor</CODE> is itself an extension of the 
<code class=interfacename>Lifecycle</CODE> interface. It 
also adds two other methods for reacting to the context being refreshed and 
closed.</P>
<p>The order of startup and shutdown invocations can be 
important. If a "depends-on" relationship exists between any two objects, the 
dependent side will start <span class=emphasis><em>after</EM></SPAN> its dependency, and it will stop <span 
class=emphasis><em>before</EM></SPAN> 
its dependency. However, at times the direct dependencies are unknown. You may 
only know that objects of a certain type should start prior to objects of 
another type. In those cases, the <code class=interfacename>SmartLifecycle</CODE> interface defines another option, 
namely the <code class=methodname>getPhase()</CODE> method 
as defined on its super-interface, <code class=interfacename>Phased</CODE>.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> Phased {

  <span class=hl-keyword>int</SPAN> getPhase();

}


<span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> SmartLifecycle <span class=hl-keyword>extends</SPAN> Lifecycle, Phased {

  <span class=hl-keyword>boolean</SPAN> isAutoStartup();

  <span class=hl-keyword>void</SPAN> stop(Runnable callback);

}</PRE>
<p>When starting, the objects with the lowest phase start 
first, and when stopping, the reverse order is followed. Therefore, an object 
that implements <code class=interfacename>SmartLifecycle</CODE> and whose getPhase() method returns 
<code class=literal>Integer.MIN_VALUE</CODE> would be among 
the first to start and the last to stop. At the other end of the spectrum, a 
phase value of <code class=literal>Integer.MAX_VALUE</CODE> 
would indicate that the object should be started last and stopped first (likely 
because it depends on other processes to be running). When considering the phase 
value, it's also important to know that the default phase for any "normal" <code 
class=interfacename>Lifecycle</CODE> object that does not 
implement <code class=interfacename>SmartLifecycle</CODE> 
would be 0. Therefore, any negative phase value would indicate that an object 
should start before those standard components (and stop after them), and vice 
versa for any positive phase value.</P>
<p>As you can see the stop method defined by <code 
class=interfacename>SmartLifecycle</CODE> accepts a 
callback. Any implementation <span class=emphasis><em>must</EM></SPAN> invoke that callback's run() method after 
that implementation's shutdown process is complete. That enables asynchronous 
shutdown where necessary since the default implementation of the <code 
class=interfacename>LifecycleProcessor</CODE> interface, 
<code class=classname>DefaultLifecycleProcessor</CODE>, 
will wait up to its timeout value for the group of objects within each phase to 
invoke that callback. The default per-phase timeout is 30 seconds. You can 
override the default lifecycle processor instance by defining a bean named 
"lifecycleProcessor" within the context. If you only want to modify the timeout, 
then defining the following would be sufficient:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"lifecycleProcessor"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.context.support.DefaultLifecycleProcessor"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-comment>&lt;!-- timeout value in milliseconds --&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"timeoutPerShutdownPhase"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"10000"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>As mentioned, the <code class=interfacename>LifecycleProcessor</CODE> interface defines callback 
methods for the refreshing and closing of the context as well. The latter will 
simply drive the shutdown process as if stop() had been called explicitly, but 
it will happen when the context is closing. The 'refresh' callback on the other 
hand enables another feature of <code class=interfacename>SmartLifecycle</CODE> beans. When the context is refreshed 
(after all objects have been instantiated and initialized), that callback will 
be invoked, and at that point the default lifecycle processor will check the 
boolean value returned by each <code class=interfacename>SmartLifecycle</CODE> object's <code class=methodname>isAutoStartup()</CODE> method. If "true", then that object 
will be started at that point rather than waiting for an explicit invocation of 
the context's or its own start() method (unlike the context refresh, the context 
start does not happen automatically for a standard context implementation). The 
"phase" value as well as any "depends-on" relationships will determine the 
startup order in the same way as described above.</P></DIV>
<div class=section 
title="Shutting down the Spring IoC container gracefully in non-web applications">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-shutdown></A>Shutting down the Spring IoC container gracefully in 
non-web applications</H4></DIV></DIV></DIV>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>This section applies only to non-web applications. 
      Spring's web-based <code class=interfacename 
      >ApplicationContext</CODE> implementations already 
      have code in place to shut down the Spring IoC container gracefully when 
      the relevant web application is shut down.</P></TD></TR></TABLE></DIV>
<p>If you are using Spring's IoC container in a non-web 
application environment; for example, in a rich client desktop environment; you 
register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and 
calls the relevant destroy methods on your singleton beans so that all resources 
are released. Of course, you must still configure and implement these destroy 
callbacks correctly.</P>
<p>To register a shutdown hook, you call the <code 
class=methodname>registerShutdownHook()</CODE> method that 
is declared on the <code class=classname>AbstractApplicationContext</CODE> class:</P><pre class=programlisting><span class=hl-keyword>import</SPAN> org.springframework.context.support.AbstractApplicationContext;
<span class=hl-keyword>import</SPAN> org.springframework.context.support.ClassPathXmlApplicationContext;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>final</SPAN> <span class=hl-keyword>class</SPAN> Boot {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(<span class=hl-keyword>final</SPAN> String[] args) <span class=hl-keyword>throws</SPAN> Exception {
      AbstractApplicationContext ctx
          = <span class=hl-keyword>new</SPAN> ClassPathXmlApplicationContext(<span class=hl-keyword>new</SPAN> String []{<span class=hl-string>"beans.xml"</SPAN>});

      <em class=lineannotation><span class=lineannotation>// add a shutdown hook for the above context... </SPAN></EM>
      ctx.registerShutdownHook();

      <em class=lineannotation><span class=lineannotation>// app runs here...</SPAN></EM>

      <em class=lineannotation><span class=lineannotation>// main method exits, hook is called prior to the app shutting down...</SPAN></EM>
  }
}</PRE></DIV></DIV>
<div class=section title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-aware></A>5.6.2&nbsp;<code class=interfacename>ApplicationContextAware</CODE> and <code 
class=interfacename>BeanNameAware</CODE></H3></DIV></DIV></DIV>
<p>When an <code class=interfacename>ApplicationContext</CODE> creates a class that implements 
the <code class=interfacename>org.springframework.context.ApplicationContextAware</CODE> 
interface, the class is provided with a reference to that <code 
class=interfacename>ApplicationContext</CODE>.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> ApplicationContextAware {

  <span class=hl-keyword>void</SPAN> setApplicationContext(ApplicationContext applicationContext) <span class=hl-keyword>throws</SPAN> BeansException;
}</PRE>
<p>Thus beans can manipulate programmatically the <code 
class=interfacename>ApplicationContext</CODE> that created 
them, through the <code class=interfacename>ApplicationContext</CODE> interface, or by casting the 
reference to a known subclass of this interface, such as <code class=classname>ConfigurableApplicationContext</CODE>, which exposes 
additional functionality. One use would be the programmatic retrieval of other 
beans. Sometimes this capability is useful; however, in general you should avoid 
it, because it couples the code to Spring and does not follow the Inversion of 
Control style, where collaborators are provided to beans as properties. Other 
methods of the ApplicationContext provide access to file resources, publishing 
application events, and accessing a MessageSource. These additional features are 
described in <A class=xref title="5.14&nbsp;Additional Capabilities of the ApplicationContext" href="beans.html#context-introduction" >Section&nbsp;5.14, “Additional 
Capabilities of the <code class=interfacename>ApplicationContext</CODE>”</A></P>
<p>As of Spring 2.5, autowiring is another alternative to 
obtain reference to the <code class=interfacename>ApplicationContext</CODE>. The "traditional" <code 
class=literal>constructor</CODE> and <code class=literal>byType</CODE> autowiring modes (as described in <A class=xref title="5.4.5&nbsp;Autowiring collaborators" href="beans.html#beans-factory-autowire" >Section&nbsp;5.4.5, 
“Autowiring collaborators”</A>) can provide a dependency of type <code 
class=interfacename>ApplicationContext</CODE> for a 
constructor argument or setter method parameter, respectively. For more 
flexibility, including the ability to autowire fields and multiple parameter 
methods, use the new annotation-based autowiring features. If you do, the <code 
class=interfacename>ApplicationContext</CODE> is autowired 
into a field, constructor argument, or method parameter that is expecting the 
<code class=interfacename>ApplicationContext</CODE> type if 
the field, constructor, or method in question carries the <code 
class=interfacename>@Autowired</CODE> annotation. For more 
information, see <A class=xref title=5.9.2&nbsp;@Autowired href="beans.html#beans-autowired-annotation" >Section&nbsp;5.9.2, “<code 
class=interfacename>@Autowired</CODE>”</A>.</P>
<p>When an ApplicationContext creates a class that 
implements the <code class=interfacename>org.springframework.beans.factory.BeanNameAware</CODE> 
interface, the class is provided with a reference to the name defined in its 
associated object definition.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> BeanNameAware {

  <span class=hl-keyword>void</SPAN> setBeanName(string name) <span class=hl-keyword>throws</SPAN> BeansException;
}</PRE>
<p>The callback is invoked after population of normal bean 
properties but before an initialization callback such as <code 
class=interfacename>InitializingBean</CODE>s <span 
class=emphasis><em>afterPropertiesSet</EM></SPAN> or a custom 
init-method.</P></DIV>
<div class=section title="5.6.3&nbsp;Other Aware interfaces">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=aware-list></A>5.6.3&nbsp;Other <code class=interfacename>Aware</CODE> interfaces</H3></DIV></DIV></DIV>
<p>Besides <code class=interfacename>ApplicationContextAware</CODE> and <code 
class=interfacename>BeanNameAware</CODE> discussed above, 
Spring offers a range of <span class=emphasis><em><code class=interfacename>Aware</CODE></EM></SPAN> interfaces that allow beans to 
indicate to the container that they require a certain <span class=emphasis><em>infrastructure</EM></SPAN> 
dependency. The most important <code class=interfacename>Aware</CODE> interfaces are summarized below - as a general 
rule, the name is a good indication of the dependency type:</P>
<div class=table><a name=beans-factory-nature-aware-list></A>
<p class=title><b>Table&nbsp;5.4.&nbsp;<code class=interfacename>Aware</CODE> interfaces</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Aware interfaces" width="100%">
  <colgroup>
  <col align=left>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >Name</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Injected Dependency</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid">Explained 
    in...</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >ApplicationContextAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Declaring <code class=interfacename 
      >ApplicationContext</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >Section&nbsp;5.6.2, “<code 
      class=interfacename>ApplicationContextAware</CODE> 
      and <code class=interfacename 
      >BeanNameAware</CODE>”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >ApplicationEventPublisherAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Event publisher of the enclosing <code 
      class=interfacename>ApplicationContext</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.14&nbsp;Additional Capabilities of the ApplicationContext" href="beans.html#context-introduction" >Section&nbsp;5.14, 
      “Additional Capabilities of the <code class=interfacename 
      >ApplicationContext</CODE>”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >BeanClassLoaderAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Class loader used to load the bean classes.</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.3.2&nbsp;Instantiating beans" href="beans.html#beans-factory-class" >Section&nbsp;5.3.2, 
      “Instantiating beans”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >BeanFactoryAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Declaring <code class=interfacename 
      >BeanFactory</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >Section&nbsp;5.6.2, “<code 
      class=interfacename>ApplicationContextAware</CODE> 
      and <code class=interfacename 
      >BeanNameAware</CODE>”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >BeanNameAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Name of the declaring bean</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >Section&nbsp;5.6.2, “<code 
      class=interfacename>ApplicationContextAware</CODE> 
      and <code class=interfacename 
      >BeanNameAware</CODE>”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >BootstrapContextAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Resource adapter <code class=interfacename 
      >BootstrapContext</CODE> the container runs in. 
      Typically available only in JCA aware <code class=interfacename 
      >ApplicationContext</CODE>s</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="25.&nbsp;JCA CCI" href="cci.html" >Chapter&nbsp;25, <i>JCA 
      CCI</I></A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >LoadTimeWeaverAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Defined <span class=emphasis 
      ><em>weaver</EM></SPAN> for 
      processing class definition at load time</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework" href="aop.html#aop-aj-ltw" >Section&nbsp;9.8.4, “Load-time weaving 
      with AspectJ in the Spring Framework”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >MessageSourceAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Configured strategy for resolving messages (with 
      support for parametrization and internationalization)</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="5.14&nbsp;Additional Capabilities of the ApplicationContext" href="beans.html#context-introduction" >Section&nbsp;5.14, 
      “Additional Capabilities of the <code class=interfacename 
      >ApplicationContext</CODE>”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >NotificationPublisherAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Spring JMX notification publisher</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title=24.7&nbsp;Notifications href="jmx.html#jmx-notifications" >Section&nbsp;24.7, 
      “Notifications”</A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >PortletConfigAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Current <code class=interfacename 
      >PortletConfig</CODE> the container runs in. Valid 
      only in a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="20.&nbsp;Portlet MVC Framework" href="portlet.html" >Chapter&nbsp;20, <i 
      >Portlet MVC Framework</I></A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >PortletContextAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Current <code class=interfacename 
      >PortletContext</CODE> the container runs in. Valid 
      only in a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="20.&nbsp;Portlet MVC Framework" href="portlet.html" >Chapter&nbsp;20, <i 
      >Portlet MVC Framework</I></A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >ResourceLoaderAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Configured loader for low-level access to 
      resources</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title=6.&nbsp;Resources href="resources.html" >Chapter&nbsp;6, <i 
      >Resources</I></A></P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p><code class=classname 
      >ServletConfigAware</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >
      <p>Current <code class=interfacename 
      >ServletConfig</CODE> the container runs in. Valid 
      only in a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE></P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p><A class=xref title="17.&nbsp;Web MVC framework" href="mvc.html" >Chapter&nbsp;17, <i>Web MVC 
      framework</I></A></P></TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid" align=left>
      <p><code class=classname 
      >ServletContextAware</CODE></P></TD>
    <td style="BORDER-RIGHT: 0.5pt solid">
      <p>Current <code class=interfacename 
      >ServletContext</CODE> the container runs in. Valid 
      only in a web-aware Spring <code class=interfacename 
      >ApplicationContext</CODE></P></TD>
    <td>
      <p><A class=xref title="17.&nbsp;Web MVC framework" href="mvc.html" >Chapter&nbsp;17, <i>Web MVC 
      framework</I></A></P></TD></TR></TBODY></TABLE></DIV></DIV><br class=table-break>
<p>Note again that usage of these interfaces ties your code 
to the Spring API and does not follow the Inversion of Control style. As such, 
they are recommended for infrastructure beans that require programmatic access 
to the container.</P></DIV></DIV>
<div class=section title="5.7&nbsp;Bean definition inheritance">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-child-bean-definitions></A>5.7&nbsp;Bean 
definition inheritance</H2></DIV></DIV></DIV>
<p>A bean definition can contain a lot of configuration 
information, including constructor arguments, property values, and 
container-specific information such as initialization method, static factory 
method name, and so on. A child bean definition inherits configuration data from 
a parent definition. The child definition can override some values, or add 
others, as needed. Using parent and child bean definitions can save a lot of 
typing. Effectively, this is a form of templating.</P>
<p>If you work with an <code class=interfacename>ApplicationContext</CODE> interface programmatically, child 
bean definitions are represented by the <code class=classname>ChildBeanDefinition</CODE> class. Most users do not work 
with them on this level, instead configuring bean definitions declaratively in 
something like the <code class=classname>ClassPathXmlApplicationContext</CODE>. When you use 
XML-based configuration metadata, you indicate a child bean definition by using 
the <code class=literal>parent</CODE> attribute, specifying 
the parent bean as the value of this attribute.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"inheritedTestBean"</SPAN> <span class=hl-attribute>abstract</SPAN>=<span class=hl-value>"true"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.TestBean"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"parent"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"age"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"1"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"inheritsWithDifferentClass"</SPAN>
      <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.DerivedTestBean"</SPAN>
      <span class=bold><strong>parent="inheritedTestBean"</STRONG></SPAN> init-method="initialize"&gt;

  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"override"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</SPAN></EM>

<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>A child bean definition uses the bean class from the 
parent definition if none is specified, but can also override it. In the latter 
case, the child bean class must be compatible with the parent, that is, it must 
accept the parent's property values.</P>
<p>A child bean definition inherits constructor argument 
values, property values, and method overrides from the parent, with the option 
to add new values. Any initialization method, destroy method, and/or <code 
class=literal>static</CODE> factory method settings that 
you specify will override the corresponding parent settings.</P>
<p>The remaining settings are <span class=emphasis><em>always</EM></SPAN> taken from the 
child definition: <span class=emphasis><em>depends on</EM></SPAN>, <span class=emphasis><em>autowire mode</EM></SPAN>, <span 
class=emphasis><em>dependency 
check</EM></SPAN>, <span class=emphasis><em>singleton</EM></SPAN>, <span class=emphasis><em>scope</EM></SPAN>, <span 
class=emphasis><em>lazy 
init</EM></SPAN>.</P>
<p>The preceding example explicitly marks the parent bean 
definition as abstract by using the <code class=literal>abstract</CODE> attribute. If the parent definition does 
not specify a class, explicitly marking the parent bean definition as <code 
class=literal>abstract</CODE> is required, as follows:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"inheritedTestBeanWithoutClass"</SPAN> <span class=hl-attribute>abstract</SPAN>=<span class=hl-value>"true"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"parent"</SPAN><span class=hl-tag>/&gt;</SPAN>
    <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"age"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"1"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"inheritsWithClass"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.DerivedTestBean"</SPAN>
    <span class=hl-attribute>parent</SPAN>=<span class=hl-value>"inheritedTestBeanWithoutClass"</SPAN> <span class=hl-attribute>init-method</SPAN>=<span class=hl-value>"initialize"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"name"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"override"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The parent bean cannot be instantiated on its own 
because it is incomplete, and it is also explicitly marked as <code 
class=literal>abstract</CODE>. When a definition is <code 
class=literal>abstract</CODE> like this, it is usable only 
as a pure template bean definition that serves as a parent definition for child 
definitions. Trying to use such an <code class=literal>abstract</CODE> parent bean on its own, by referring to it 
as a ref property of another bean or doing an explicit <code class=methodname>getBean()</CODE> call with the parent bean id, returns an 
error. Similarly, the container's internal <code class=methodname>preInstantiateSingletons()</CODE> method ignores bean 
definitions that are defined as abstract.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p><code class=literal 
      >ApplicationContext</CODE> pre-instantiates all 
      singletons by default. Therefore, it is important (at least for singleton 
      beans) that if you have a (parent) bean definition which you intend to use 
      only as a template, and this definition specifies a class, you must make 
      sure to set the <span class=emphasis><em 
      >abstract</EM></SPAN> attribute to <span 
      class=emphasis><em 
      >true</EM></SPAN>, otherwise the application context 
      will actually (attempt to) pre-instantiate the <code class=literal 
      >abstract</CODE> 
bean.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.8&nbsp;Container Extension Points">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-factory-extension></A>5.8&nbsp;Container 
Extension Points</H2></DIV></DIV></DIV>
<p>Typically, an application developer does not need to 
subclass <code class=interfacename>ApplicationContext</CODE> implementation classes. Instead, 
the Spring IoC container can be extended by plugging in implementations of 
special integration interfaces. The next few sections describe these integration 
interfaces.</P>
<div class=section 
title="5.8.1&nbsp;Customizing beans using a BeanPostProcessor">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-extension-bpp></A>5.8.1&nbsp;Customizing beans using a <code 
class=interfacename>BeanPostProcessor</CODE></H3></DIV></DIV></DIV>
<p>The <code class=interfacename>BeanPostProcessor</CODE> interface defines <em 
class=firstterm>callback methods</EM> that you can 
implement to provide your own (or override the container's default) 
instantiation logic, dependency-resolution logic, and so forth. If you want to 
implement some custom logic after the Spring container finishes instantiating, 
configuring, and initializing a bean, you can plug in one or more <code 
class=interfacename>BeanPostProcessor</CODE> 
implementations.</P>
<p>You can configure multiple <code class=literal>BeanPostProcessor</CODE> instances, and you can control the 
order in which these <code class=literal>BeanPostProcessor</CODE>s execute by setting the <code 
class=literal>order</CODE> property. You can set this 
property only if the <code class=interfacename>BeanPostProcessor</CODE> implements the <code 
class=interfacename>Ordered</CODE> interface; if you write 
your own <code class=interfacename>BeanPostProcessor</CODE> 
you should consider implementing the <code class=interfacename>Ordered</CODE> interface too. For further details, consult 
the Javadoc for the <code class=interfacename>BeanPostProcessor</CODE> and <code class=interfacename>Ordered</CODE> interfaces. See also the note below on <A class=link href="beans.html#beans-factory-programmatically-registering-beanpostprocessors" >programmatic 
registration of <code class=interfacename>BeanPostProcessors</CODE> </A></P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p><code class=literal 
      >BeanPostProcessor</CODE>s operate on bean (or object) 
      <span class=emphasis><em 
      >instances</EM></SPAN>; that is to say, the Spring IoC 
      container instantiates a bean instance and <span class=emphasis 
      ><em>then</EM></SPAN> <code 
      class=literal>BeanPostProcessor</CODE>s do their 
      work.</P>
      <p><code class=literal 
      >BeanPostProcessor</CODE>s are scoped <span 
      class=emphasis><em 
      >per-container</EM></SPAN>. This is only relevant if 
      you are using container hierarchies. If you define a <code 
      class=interfacename>BeanPostProcessor</CODE> in one 
      container, it will <span class=emphasis><em 
      >only</EM></SPAN> post-process the beans in that 
      container. In other words, beans that are defined in one container are not 
      post-processed by a <code class=literal 
      >BeanPostProcessor</CODE> defined in another 
      container, even if both containers are part of the same hierarchy.</P>
      <p>To change the actual bean definition (i.e., the 
      <span class=emphasis><em 
      >blueprint</EM></SPAN> that defines the bean), you 
      instead need to use a <code class=interfacename 
      >BeanFactoryPostProcessor</CODE> as described in <A class=xref title="5.8.2&nbsp;Customizing configuration metadata with a BeanFactoryPostProcessor" href="beans.html#beans-factory-extension-factory-postprocessors" >Section&nbsp;5.8.2, 
      “Customizing configuration metadata with a <code class=interfacename 
      >BeanFactoryPostProcessor</CODE>”</A>.</P></TD></TR></TABLE></DIV>
<p>The <code class=interfacename>org.springframework.beans.factory.config.BeanPostProcessor</CODE> 
interface consists of exactly two callback methods. When such a class is 
registered as a post-processor with the container, for each bean instance that 
is created by the container, the post-processor gets a callback from the 
container both <span class=emphasis><em>before</EM></SPAN> container initialization methods (such 
as InitializingBean's <span class=emphasis><em>afterPropertiesSet()</EM></SPAN> and any declared init 
method) are called as well as <span class=emphasis><em>after</EM></SPAN> any bean initialization callbacks. The 
post-processor can take any action with the bean instance, including ignoring 
the callback completely. A bean post-processor typically checks for callback 
interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure 
classes are implemented as bean post-processors in order to provide 
proxy-wrapping logic.</P>
<p>An <code class=interfacename>ApplicationContext</CODE> <span class=emphasis><em>automatically detects</EM></SPAN> 
any beans that are defined in the configuration metadata which implement the 
<code class=interfacename>BeanPostProcessor</CODE> 
interface. The <code class=interfacename>ApplicationContext</CODE> registers these beans as 
post-processors so that they can be called later upon bean creation. Bean 
post-processors can be deployed in the container just like any other 
beans.</P><a name=beans-factory-programmatically-registering-beanpostprocessors></A>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note 
title="Programmatically registering BeanPostProcessors">
<table border=0 
summary="Note: Programmatically registering BeanPostProcessors&#10;        ">
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Programmatically registering <code 
      class=interfacename>BeanPostProcessors </CODE></TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>While the recommended approach for <code 
      class=interfacename>BeanPostProcessor 
      </CODE>registration is through <code class=interfacename 
      >ApplicationContext </CODE>auto-detection (as 
      described above), it is also possible to register them <span 
      class=emphasis><em 
      >programmatically</EM></SPAN> against a <code 
      class=interfacename>ConfigurableBeanFactory</CODE> 
      using the <code class=methodname 
      >addBeanPostProcessor</CODE> method. This can be 
      useful when needing to evaluate conditional logic before registration, or 
      even for copying bean post processors across contexts in a hierarchy. Note 
      however that <code class=interfacename 
      >BeanPostProcessors</CODE> added programmatically 
      <span class=emphasis><em>do not 
      respect the <code class=interfacename>Ordered 
      </CODE>interface</EM></SPAN>. Here it is the <span class=emphasis 
      ><em>order of 
      registration</EM></SPAN> that dictates the order of execution. Note also 
      that <code class=interfacename 
      >BeanPostProcessors</CODE> registered programmatically 
      are always processed before those registered through auto-detection, 
      regardless of any explicit ordering. </P></TD></TR></TABLE></DIV>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note 
title="BeanPostProcessors and AOP auto-proxying">
<table border=0 
summary="Note: BeanPostProcessors and AOP&#10;        auto-proxying">
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left><code class=interfacename 
      >BeanPostProcessors</CODE> and AOP auto-proxying</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Classes that implement the <code 
      class=interfacename>BeanPostProcessor</CODE> 
      interface are <span class=emphasis><em 
      >special</EM></SPAN> and are treated differently by 
      the container. All <code class=interfacename 
      >BeanPostProcessors</CODE> <span class=emphasis 
      ><em>and beans that they 
      reference directly</EM></SPAN> are instantiated on startup, as part of the 
      special startup phase of the <code class=interfacename 
      >ApplicationContext</CODE>. Next, all <code 
      class=interfacename>BeanPostProcessors</CODE> are 
      registered in a sorted fashion and applied to all further beans in the 
      container. Because AOP auto-proxying is implemented as a <code 
      class=interfacename>BeanPostProcessor</CODE> itself, 
      neither <code class=interfacename 
      >BeanPostProcessors</CODE> nor the beans they 
      reference directly are eligible for auto-proxying, and thus do not have 
      aspects woven into them.</P>
      <p>For any such bean, you should see an informational 
      log message: <span class=quote>“<span class=quote 
      ><span class=emphasis><em 
      >Bean foo is not eligible for getting processed by all 
      BeanPostProcessor interfaces (for example: not eligible for 
      auto-proxying)</EM></SPAN></SPAN>”</SPAN>.</P></TD></TR></TABLE></DIV>
<p>The following examples show how to write, register, and 
use <code class=literal>BeanPostProcessors</CODE> in an 
<code class=interfacename>ApplicationContext</CODE>.</P>
<div class=section title="Example: Hello World, BeanPostProcessor-style">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-extension-bpp-examples-hw></A>Example: 
Hello World, <code class=interfacename>BeanPostProcessor</CODE>-style</H4></DIV></DIV></DIV>
<p>This first example illustrates basic usage. The example 
shows a custom <code class=interfacename>BeanPostProcessor</CODE> implementation that invokes the 
<code class=methodname>toString()</CODE> method of each 
bean as it is created by the container and prints the resulting string to the 
system console.</P>
<p>Find below the custom <code class=interfacename>BeanPostProcessor</CODE> implementation class 
definition:</P><pre class=programlisting><span class=hl-keyword>package</SPAN> scripting;

<span class=hl-keyword>import</SPAN> org.springframework.beans.factory.config.BeanPostProcessor;
<span class=hl-keyword>import</SPAN> org.springframework.beans.BeansException;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> InstantiationTracingBeanPostProcessor <span class=hl-keyword>implements</SPAN> BeanPostProcessor {

  <em class=lineannotation><span class=lineannotation>// simply return the instantiated bean as-is</SPAN></EM>
  <span class=hl-keyword>public</SPAN> Object postProcessBeforeInitialization(Object bean, String beanName)
                                                                     <span class=hl-keyword>throws</SPAN> BeansException {
      <span class=hl-keyword>return</SPAN> bean; <em class=lineannotation><span class=lineannotation>// we could potentially return any object reference here...</SPAN></EM>
  }

  <span class=hl-keyword>public</SPAN> Object postProcessAfterInitialization(Object bean, String beanName)
                                                                     <span class=hl-keyword>throws</SPAN> BeansException {
      System.out.println(<span class=hl-string>"Bean '"</SPAN> + beanName + <span class=hl-string>"' created : "</SPAN> + bean.toString());
      <span class=hl-keyword>return</SPAN> bean;
  }
}</PRE><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <span class=hl-attribute>xmlns:lang</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/lang"</SPAN>
     <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/lang
         http://www.springframework.org/schema/lang/spring-lang.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;lang:groovy</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"messenger"</SPAN>
        <span class=hl-attribute>script-source</SPAN>=<span class=hl-value>"classpath:org/springframework/scripting/groovy/Messenger.groovy"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;lang:property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"message"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Fiona Apple Is Just So Dreamy."</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/lang:groovy&gt;</SPAN>

  <em class=lineannotation><span class=lineannotation>&lt;!--
      when the above bean (messenger) is instantiated, this custom
      BeanPostProcessor implementation will output the fact to the system console
   --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"scripting.InstantiationTracingBeanPostProcessor"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>Notice how the <code class=classname>InstantiationTracingBeanPostProcessor</CODE> is simply 
defined. It does not even have a name, and because it is a bean it can be 
dependency-injected just like any other bean. (The preceding configuration also 
defines a bean that is backed by a Groovy script. The Spring 2.0 dynamic 
language support is detailed in the chapter entitled <A class=xref title="28.&nbsp;Dynamic language support" href="dynamic-language.html" >Chapter&nbsp;28, <i>Dynamic language support</I></A>.)</P>
<p>The following simple Java application executes the 
preceding code and configuration:</P><pre class=programlisting><span class=hl-keyword>import</SPAN> org.springframework.context.ApplicationContext;
<span class=hl-keyword>import</SPAN> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class=hl-keyword>import</SPAN> org.springframework.scripting.Messenger;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>final</SPAN> <span class=hl-keyword>class</SPAN> Boot {

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(<span class=hl-keyword>final</SPAN> String[] args) <span class=hl-keyword>throws</SPAN> Exception {
      ApplicationContext ctx = <span class=hl-keyword>new</SPAN> ClassPathXmlApplicationContext(<span class=hl-string>"scripting/beans.xml"</SPAN>);
      Messenger messenger = (Messenger) ctx.getBean(<span class=hl-string>"messenger"</SPAN>);
      System.out.println(messenger);
  }
}</PRE>
<p>The output of the preceding application resembles the 
following:</P><pre class=programlisting>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</PRE></DIV>
<div class=section title="Example: The RequiredAnnotationBeanPostProcessor">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-factory-extension-bpp-examples-rabpp></A>Example: The <code class=classname>RequiredAnnotationBeanPostProcessor</CODE></H4></DIV></DIV></DIV>
<p>Using callback interfaces or annotations in conjunction 
with a custom <code class=interfacename>BeanPostProcessor</CODE> implementation is a common means 
of extending the Spring IoC container. An example is Spring's <code 
class=classname>RequiredAnnotationBeanPostProcessor</CODE> 
— a <code class=interfacename>BeanPostProcessor</CODE> 
implementation that ships with the Spring distribution which ensures that 
JavaBean properties on beans that are marked with an (arbitrary) annotation are 
actually (configured to be) dependency-injected with a value.</P></DIV></DIV>
<div class=section 
title="5.8.2&nbsp;Customizing configuration metadata with a BeanFactoryPostProcessor">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-factory-extension-factory-postprocessors></A>5.8.2&nbsp;Customizing configuration metadata with a 
<code class=interfacename>BeanFactoryPostProcessor</CODE></H3></DIV></DIV></DIV>
<p>The next extension point that we will look at is the 
<code class=interfacename>org.springframework.beans.factory.config.BeanFactoryPostProcessor</CODE>. 
The semantics of this interface are similar to those of the <code 
class=interfacename>BeanPostProcessor</CODE>, with one 
major difference: <code class=literal>BeanFactoryPostProcessor</CODE>s operate on the <span 
class=emphasis><em>bean configuration 
metadata</EM></SPAN>; that is, the Spring IoC container allows <code 
class=literal>BeanFactoryPostProcessors</CODE> to read the 
configuration metadata and potentially change it <span class=emphasis><em>before</EM></SPAN> the container 
instantiates any beans other than <code class=literal>BeanFactoryPostProcessors</CODE>.</P>
<p>You can configure multiple <code class=literal>BeanFactoryPostProcessors</CODE>, and you can control the 
order in which these <code class=literal>BeanFactoryPostProcessors</CODE> execute by setting the 
<code class=literal>order</CODE> property. However, you can 
only set this property if the <code class=interfacename>BeanFactoryPostProcessor</CODE> implements the <code 
class=interfacename>Ordered</CODE> interface. If you write 
your own <code class=interfacename>BeanFactoryPostProcessor</CODE>, you should consider 
implementing the <code class=interfacename>Ordered</CODE> 
interface too. Consult the Javadoc for the <code class=interfacename>BeanFactoryPostProcessor</CODE> and <code 
class=interfacename>Ordered</CODE> interfaces for more 
details.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If you want to change the actual bean <span 
      class=emphasis><em 
      >instances</EM></SPAN> (i.e., the objects that are 
      created from the configuration metadata), then you instead need to use a 
      <code class=interfacename>BeanPostProcessor</CODE> 
      (described above in <A class=xref title="5.8.1&nbsp;Customizing beans using a BeanPostProcessor" href="beans.html#beans-factory-extension-bpp" >Section&nbsp;5.8.1, 
      “Customizing beans using a <code class=interfacename 
      >BeanPostProcessor</CODE>”</A>). While it is 
      technically possible to work with bean instances within a <code 
      class=interfacename>BeanFactoryPostProcessor</CODE> 
      (e.g., using <code class=methodname 
      >BeanFactory.getBean()</CODE>), doing so causes 
      premature bean instantiation, violating the standard container lifecycle. 
      This may cause negative side effects such as bypassing bean post 
      processing.</P>
      <p>Also, <code class=literal 
      >BeanFactoryPostProcessors</CODE> are scoped <span 
      class=emphasis><em 
      >per-container</EM></SPAN>. This is only relevant if 
      you are using container hierarchies. If you define a <code 
      class=interfacename>BeanFactoryPostProcessor</CODE> 
      in one container, it will <span class=emphasis><em 
      >only</EM></SPAN> be applied to the bean definitions 
      in that container. Bean definitions in one container will not be 
      post-processed by <code class=literal 
      >BeanFactoryPostProcessors</CODE> in another 
      container, even if both containers are part of the same 
  hierarchy.</P></TD></TR></TABLE></DIV>
<p>A bean factory post-processor is executed automatically 
when it is declared inside an <code class=interfacename>ApplicationContext</CODE>, in order to apply changes to the 
configuration metadata that define the container. Spring includes a number of 
predefined bean factory post-processors, such as <code class=classname>PropertyOverrideConfigurer</CODE> and <code class=classname>PropertyPlaceholderConfigurer</CODE>. A custom <code 
class=interfacename>BeanFactoryPostProcessor</CODE> can 
also be used, for example, to register custom property editors.</P><a 
name=beans-factory-autodetect-beanfactorypostprocessors></A>
<p>An <code class=interfacename>ApplicationContext</CODE> automatically detects any beans 
that are deployed into it that implement the <code class=interfacename>BeanFactoryPostProcessor</CODE> interface. It uses these 
beans as bean factory post-processors, at the appropriate time. You can deploy 
these post-processor beans as you would any other bean.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>As with <code class=interfacename 
      >BeanPostProcessor</CODE>s, you typically do not want 
      to configure <code class=interfacename 
      >BeanFactoryPostProcessor</CODE>s for lazy 
      initialization. If no other bean references a <code class=interfacename 
      >Bean(Factory)PostProcessor</CODE>, that 
      post-processor will not get instantiated at all. Thus, marking it for lazy 
      initialization will be ignored, and the <code class=interfacename 
      >Bean(Factory)PostProcessor</CODE> will be 
      instantiated eagerly even if you set the <code class=literal 
      >default-lazy-init</CODE> attribute to <code 
      class=literal>true</CODE> on the declaration of your 
      <code class=code>&lt;beans /&gt;</CODE> 
    element.</P></TD></TR></TABLE></DIV>
<div class=section title="Example: the PropertyPlaceholderConfigurer">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-placeholderconfigurer></A>Example: the <code class=interfacename>PropertyPlaceholderConfigurer</CODE></H4></DIV></DIV></DIV>
<p>You use the <code class=interfacename>PropertyPlaceholderConfigurer</CODE> to externalize 
property values from a bean definition in a separate file using the standard 
Java <code class=classname>Properties</CODE> format. Doing 
so enables the person deploying an application to customize environment-specific 
properties such as database URLs and passwords, without the complexity or risk 
of modifying the main XML definition file or files for the container.</P>
<p>Consider the following XML-based configuration metadata 
fragment, where a <code class=interfacename>DataSource</CODE> with placeholder values is defined. The 
example shows properties configured from an external <code class=classname>Properties</CODE> file. At runtime, a <code class=classname>PropertyPlaceholderConfigurer</CODE> is applied to the 
metadata that will replace some properties of the DataSource. The values to 
replace are specified as <span class=emphasis><em>placeholders</EM></SPAN> of the form ${property-name} which 
follows the Ant / log4j / JSP EL style.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"locations"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"classpath:com/foo/jdbc.properties"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"dataSource"</SPAN> <span class=hl-attribute>destroy-method</SPAN>=<span class=hl-value>"close"</SPAN>
    <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.apache.commons.dbcp.BasicDataSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"driverClassName"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.driverClassName}"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"url"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.url}"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"username"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.username}"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"password"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.password}"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The actual values come from another file in the standard 
Java <code class=classname>Properties</CODE> format:</P><pre class=programlisting>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</PRE>
<p>Therefore, the string <code class=literal>${jdbc.username}</CODE> is replaced at runtime with the 
value 'sa', and the same applies for other placeholder values that match keys in 
the properties file. The <code class=classname>PropertyPlaceholderConfigurer</CODE> checks for 
placeholders in most properties and attributes of a bean definition. 
Furthermore, the placeholder prefix and suffix can be customized.</P>
<p>With the <code class=literal>context</CODE> namespace introduced in Spring 2.5, it is 
possible to configure property placeholders with a dedicated configuration 
element. One or more locations can be provided as a comma-separated list in the 
<code class=literal>location</CODE> attribute.</P><pre class=programlisting><span class=hl-tag>&lt;context:property-placeholder</SPAN> <span class=hl-attribute>location</SPAN>=<span class=hl-value>"classpath:com/foo/jdbc.properties"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
<p>The <code class=classname>PropertyPlaceholderConfigurer</CODE> not only looks for 
properties in the <code class=classname>Properties</CODE> 
file you specify. By default it also checks against the Java <code 
class=classname>System</CODE> properties if it cannot find 
a property in the specified properties files. You can customize this behavior by 
setting the <code class=literal>systemPropertiesMode</CODE> 
property of the configurer with one of the following three supported integer 
values: </P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><span class=emphasis><em 
  >never</EM></SPAN> (0): Never check system properties</P>
  <li class=listitem>
  <p><span class=emphasis><em 
  >fallback</EM></SPAN> (1): Check system properties if not 
  resolvable in the specified properties files. This is the default.</P>
  <li class=listitem>
  <p><span class=emphasis><em 
  >override</EM></SPAN> (2): Check system properties first, 
  before trying the specified properties files. This allows system properties to 
  override any other property source.</P></LI></UL></DIV>
<p>Consult the Javadoc for the <code class=classname>PropertyPlaceholderConfigurer</CODE> for more 
information.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip 
title="Class name substitution">
<table border=0 summary="Tip: Class name substitution">
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Class name substitution</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>You can use the <code class=classname 
      >PropertyPlaceholderConfigurer</CODE> to substitute 
      class names, which is sometimes useful when you have to pick a particular 
      implementation class at runtime. For example:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"locations"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>classpath:com/foo/strategy.properties<span class=hl-tag>&lt;/value&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"properties"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>custom.strategy.class=com.foo.DefaultStrategy<span class=hl-tag>&lt;/value&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"serviceStrategy"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"${custom.strategy.class}"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE>
      <p>If the class cannot be resolved at runtime to a 
      valid class, resolution of the bean fails when it is about to be created, 
      which is during the <code class=methodname 
      >preInstantiateSingletons()</CODE> phase of an <code 
      class=interfacename>ApplicationContext</CODE> for a 
      non-lazy-init bean.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="Example: the PropertyOverrideConfigurer">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-factory-overrideconfigurer></A>Example: the <code class=classname>PropertyOverrideConfigurer</CODE></H4></DIV></DIV></DIV>
<p>The <code class=classname>PropertyOverrideConfigurer</CODE>, another bean factory 
post-processor, resembles the <code class=interfacename>PropertyPlaceholderConfigurer</CODE>, but unlike the 
latter, the original definitions can have default values or no values at all for 
bean properties. If an overriding <code class=classname>Properties</CODE> file does not have an entry for a certain 
bean property, the default context definition is used.</P>
<p>Note that the bean definition is <span class=emphasis><em>not</EM></SPAN> aware of being 
overridden, so it is not immediately obvious from the XML definition file that 
the override configurer is being used. In case of multiple <code class=classname>PropertyOverrideConfigurer</CODE> instances that define 
different values for the same bean property, the last one wins, due to the 
overriding mechanism.</P>
<p>Properties file configuration lines take this 
format:</P><pre class=programlisting>beanName.property=value</PRE>
<p>For example:</P><pre class=programlisting>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</PRE>
<p>This example file can be used with a container 
definition that contains a bean called <span class=emphasis><em>dataSource</EM></SPAN>, which has 
<span class=emphasis><em>driver</EM></SPAN> and <span class=emphasis><em>url</EM></SPAN> properties.</P>
<p>Compound property names are also supported, as long as 
every component of the path except the final property being overridden is 
already non-null (presumably initialized by the constructors). In this 
example...</P><pre class=programlisting>foo.fred.bob.sammy=123</PRE>
<p>... the <code class=literal>sammy</CODE> property of the <code class=literal>bob</CODE> property of the <code class=literal>fred</CODE> property of the <code class=literal>foo</CODE> bean is set to the scalar value <code 
class=literal>123</CODE>.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Specified override values are always <span 
      class=emphasis><em 
      >literal</EM></SPAN> values; they are not translated 
      into bean references. This convention also applies when the original value 
      in the XML bean definition specifies a bean 
reference.</P></TD></TR></TABLE></DIV>
<p>With the <code class=literal>context</CODE> namespace introduced in Spring 2.5, it is 
possible to configure property overriding with a dedicated configuration 
element:</P><pre class=programlisting><span class=hl-tag>&lt;context:property-override</SPAN> <span class=hl-attribute>location</SPAN>=<span class=hl-value>"classpath:override.properties"</SPAN><span class=hl-tag>/&gt;</SPAN></PRE></DIV></DIV>
<div class=section 
title="5.8.3&nbsp;Customizing instantiation logic with a FactoryBean">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factory-extension-factorybean></A>5.8.3&nbsp;Customizing instantiation logic with a <code 
class=interfacename>FactoryBean</CODE></H3></DIV></DIV></DIV>
<p>Implement the <code class=interfacename>org.springframework.beans.factory.FactoryBean</CODE> 
interface for objects that <span class=emphasis><em>are themselves factories</EM></SPAN>.</P>
<p>The <code class=interfacename>FactoryBean</CODE> interface is a point of pluggability 
into the Spring IoC container's instantiation logic. If you have complex 
initialization code that is better expressed in Java as opposed to a 
(potentially) verbose amount of XML, you can create your own <code 
class=interfacename>FactoryBean</CODE>, write the complex 
initialization inside that class, and then plug your custom <code 
class=interfacename>FactoryBean</CODE> into the 
container.</P>
<p>The <code class=interfacename>FactoryBean</CODE> interface provides three methods:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><code class=methodname>Object 
  getObject()</CODE>: returns an instance of the object this factory creates. 
  The instance can possibly be shared, depending on whether this factory returns 
  singletons or prototypes.</P>
  <li class=listitem>
  <p><code class=methodname>boolean 
  isSingleton()</CODE>: returns <code class=literal 
  >true</CODE> if this <code class=interfacename 
  >FactoryBean</CODE> returns singletons, <code 
  class=literal>false</CODE> otherwise.</P>
  <li class=listitem>
  <p><code class=methodname>Class 
  getObjectType()</CODE>: returns the object type returned by the <code 
  class=methodname>getObject()</CODE> method or <code 
  class=literal>null</CODE> if the type is not known in 
  advance.</P></LI></UL></DIV>
<p>The <code class=interfacename>FactoryBean</CODE> concept and interface is used in a 
number of places within the Spring Framework; more than 50 implementations of 
the <code class=interfacename>FactoryBean</CODE> interface 
ship with Spring itself.</P>
<p>When you need to ask a container for an actual <code 
class=interfacename>FactoryBean</CODE> instance itself 
instead of the bean it produces, preface the bean's id with the ampersand symbol 
(<code class=literal>&amp;</CODE>) when calling the <code 
class=methodname>getBean()</CODE> method of the <code 
class=interfacename>ApplicationContext</CODE>. So for a 
given <code class=interfacename>FactoryBean</CODE> with an 
id of <code class=literal>myBean</CODE>, invoking <code 
class=literal>getBean("myBean")</CODE> on the container 
returns the product of the <code class=interfacename>FactoryBean</CODE>; whereas, invoking <code class=literal>getBean("&amp;myBean")</CODE> returns the <code 
class=interfacename>FactoryBean</CODE> instance 
itself.</P></DIV></DIV>
<div class=section title="5.9&nbsp;Annotation-based container configuration">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-annotation-config></A>5.9&nbsp;Annotation-based 
container configuration</H2></DIV></DIV></DIV>
<div class=sidebar 
title="Are annotations better than XML for configuring Spring?">
<p class=title><b>Are annotations 
better than XML for configuring Spring?</B></P>
<p>The introduction of annotation-based configurations 
raised the question of whether this approach is 'better' than XML. The short 
answer is <span class=emphasis><em>it 
depends</EM></SPAN>. The long answer is that each approach has its pros and 
cons, and usually it is up to the developer to decide which strategy suits her 
better. Due to the way they are defined, annotations provide a lot of context in 
their declaration, leading to shorter and more concise configuration. However, 
XML excels at wiring up components without touching their source code or 
recompiling them. Some developers prefer having the wiring close to the source 
while others argue that annotated classes are no longer POJOs and, furthermore, 
that the configuration becomes decentralized and harder to control.</P>
<p>No matter the choice, Spring can accommodate both styles 
and even mix them together. It's worth pointing out that through its <A class=link title="5.12&nbsp;Java-based container configuration" href="beans.html#beans-java" >JavaConfig</A> option, Spring allows 
annotations to be used in a non-invasive way, without touching the target 
components source code and that in terms of tooling, all configuration styles 
are supported by the <a class=ulink 
href="http://www.springsource.com/products/sts" target=_top>SpringSource Tool Suite</A>.</P></DIV>
<p>An alternative to XML setups is provided by 
annotation-based configuration which rely on the bytecode metadata for wiring up 
components instead of angle-bracket declarations. Instead of using XML to 
describe a bean wiring, the developer moves the configuration into the component 
class itself by using annotations on the relevant class, method, or field 
declaration. As mentioned in <A class=xref title="Example: The RequiredAnnotationBeanPostProcessor" href="beans.html#beans-factory-extension-bpp-examples-rabpp" >the 
section called “Example: The <code class=classname>RequiredAnnotationBeanPostProcessor</CODE>”</A>, using a 
<code class=interfacename>BeanPostProcessor</CODE> in 
conjunction with annotations is a common means of extending the Spring IoC 
container. For example, Spring 2.0 introduced the possibility of enforcing 
required properties with the <A class=link title=5.9.1&nbsp;@Required href="beans.html#beans-required-annotation" >@Required</A> annotation. 
Spring 2.5 made it possible to follow that same general approach to drive 
Spring's dependency injection. Essentially, the <code class=interfacename>@Autowired</CODE> annotation provides the same capabilities 
as described in <A class=xref title="5.4.5&nbsp;Autowiring collaborators" href="beans.html#beans-factory-autowire" >Section&nbsp;5.4.5, 
“Autowiring collaborators”</A> but with more fine-grained control and wider 
applicability. Spring 2.5 also added support for JSR-250 annotations such as 
<code class=interfacename>@PostConstruct</CODE>, and <code 
class=interfacename>@PreDestroy</CODE>. Spring 3.0 added 
support for JSR-330 (Dependency Injection for Java) annotations contained in the 
javax.inject package such as <code class=classname>@Inject</CODE> and <code class=literal>@Named</CODE>. Details about those annotations can be found 
in the <A class=link title="5.11&nbsp;Using JSR 330 Standard Annotations" href="beans.html#beans-standard-annotations" >relevant section</A>. </P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Annotation injection is performed <span 
      class=emphasis><em 
      >before</EM></SPAN> XML injection, thus the latter 
      configuration will override the former for properties wired through both 
      approaches. </P></TD></TR></TABLE></DIV>
<p>As always, you can register them as individual bean 
definitions, but they can also be implicitly registered by including the 
following tag in an XML-based Spring configuration (notice the inclusion of the 
<code class=literal>context</CODE> namespace):</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <em class=lineannotation><span class=lineannotation>xmlns:context="http://www.springframework.org/schema/context"</SPAN></EM>
     xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd"&gt;

   <em class=lineannotation><span class=lineannotation>&lt;context:annotation-config/&gt;</SPAN></EM>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>(The implicitly registered post-processors include <a 
class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" 
target=_top><code class=classname>AutowiredAnnotationBeanPostProcessor</CODE></A>, <a 
class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" 
target=_top><code class=classname>CommonAnnotationBeanPostProcessor</CODE></A>, <a 
class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" 
target=_top><code class=classname>PersistenceAnnotationBeanPostProcessor</CODE></A>, as well 
as the aforementioned <a class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" 
target=_top><code class=classname>RequiredAnnotationBeanPostProcessor</CODE></A>.)</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p><code class=literal 
      >&lt;context:annotation-config/&gt;</CODE> only looks 
      for annotations on beans in the same application context in which it is 
      defined. This means that, if you put <code class=literal 
      >&lt;context:annotation-config/&gt;</CODE> in a <code 
      class=interfacename>WebApplicationContext</CODE> for 
      a <code class=classname>DispatcherServlet</CODE>, it 
      only checks for <code class=interfacename 
      >@Autowired</CODE> beans in your controllers, and not 
      your services. See <A class=xref title="17.2&nbsp;The DispatcherServlet" href="mvc.html#mvc-servlet" >Section&nbsp;17.2, “The <code 
      class=classname>DispatcherServlet</CODE>”</A> for 
      more information.</P></TD></TR></TABLE></DIV>
<div class=section title=5.9.1&nbsp;@Required>
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-required-annotation></A>5.9.1&nbsp;<code class=interfacename>@Required</CODE></H3></DIV></DIV></DIV>
<p>The <code class=interfacename>@Required</CODE> annotation applies to bean property setter 
methods, as in the following example:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Required</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>This annotation simply indicates that the affected bean 
property must be populated at configuration time, through an explicit property 
value in a bean definition or through autowiring. The container throws an 
exception if the affected bean property has not been populated; this allows for 
eager and explicit failure, avoiding <code class=classname>NullPointerException</CODE>s or the like later on. It is 
still recommended that you put assertions into the bean class itself, for 
example, into an init method. Doing so enforces those required references and 
values even when you use the class outside of a container.</P></DIV>
<div class=section title=5.9.2&nbsp;@Autowired>
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-autowired-annotation></A>5.9.2&nbsp;<code class=interfacename>@Autowired</CODE></H3></DIV></DIV></DIV>
<p>As expected, you can apply the <code class=interfacename>@Autowired</CODE> annotation to "traditional" setter 
methods:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>JSR 330's @Inject annotation can be used in place 
      of Spring's <code class=interfacename 
      >@Autowired</CODE> annotation in the examples below. 
      See <A class=link title="5.11&nbsp;Using JSR 330 Standard Annotations" href="beans.html#beans-standard-annotations" >here</A> for more 
      details</P></TD></TR></TABLE></DIV>
<p>You can also apply the annotation to methods with 
arbitrary names and/or multiple arguments:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <span class=hl-keyword>private</SPAN> MovieCatalog movieCatalog;

  <span class=hl-keyword>private</SPAN> CustomerPreferenceDao customerPreferenceDao;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> prepare(MovieCatalog movieCatalog,
                      CustomerPreferenceDao customerPreferenceDao) {
      <span class=hl-keyword>this</SPAN>.movieCatalog = movieCatalog;
      <span class=hl-keyword>this</SPAN>.customerPreferenceDao = customerPreferenceDao;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>You can apply <code class=interfacename>@Autowired</CODE> to constructors and fields:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog movieCatalog;

  <span class=hl-keyword>private</SPAN> CustomerPreferenceDao customerPreferenceDao;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
      <span class=hl-keyword>this</SPAN>.customerPreferenceDao = customerPreferenceDao;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>It is also possible to provide <span class=emphasis><em>all</EM></SPAN> beans of a 
particular type from the <code class=interfacename>ApplicationContext</CODE> by adding the annotation to a 
field or method that expects an array of that type:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog[] movieCatalogs;

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>The same applies for typed collections:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <span class=hl-keyword>private</SPAN> Set&lt;MovieCatalog&gt; movieCatalogs;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
      <span class=hl-keyword>this</SPAN>.movieCatalogs = movieCatalogs;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>Even typed Maps can be autowired as long as the expected 
key type is <code class=classname>String</CODE>. The Map 
values will contain all beans of the expected type, and the keys will contain 
the corresponding bean names:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <span class=hl-keyword>private</SPAN> Map&lt;String, MovieCatalog&gt; movieCatalogs;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
      <span class=hl-keyword>this</SPAN>.movieCatalogs = movieCatalogs;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>By default, the autowiring fails whenever <span 
class=emphasis><em>zero</EM></SPAN> 
candidate beans are available; the default behavior is to treat annotated 
methods, constructors, and fields as indicating <span class=emphasis><em>required</EM></SPAN> dependencies. 
This behavior can be changed as demonstrated below.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired(required=false)</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Only <span class=emphasis><em 
      >one annotated constructor per-class</EM></SPAN> can 
      be marked as <span class=emphasis><em 
      >required</EM></SPAN>, but multiple non-required 
      constructors can be annotated. In that case, each is considered among the 
      candidates and Spring uses the <span class=emphasis 
      ><em>greediest</EM></SPAN> 
      constructor whose dependencies can be satisfied, that is the constructor 
      that has the largest number of arguments.</P>
      <p><code class=interfacename 
      >@Autowired</CODE>'s <span class=emphasis 
      ><em>required</EM></SPAN> 
      attribute is recommended over the <code class=interfacename 
      >@Required</CODE> annotation. The <span class=emphasis 
      ><em>required</EM></SPAN> 
      attribute indicates that the property is not required for autowiring 
      purposes, the property is ignored if it cannot be autowired. <code 
      class=interfacename>@Required</CODE>, on the other 
      hand, is stronger in that it enforces the property that was set by any 
      means supported by the container. If no value is injected, a corresponding 
      exception is raised.</P></TD></TR></TABLE></DIV>
<p>You can also use <code class=interfacename>@Autowired</CODE> for interfaces that are well-known 
resolvable dependencies: <code class=interfacename>BeanFactory</CODE>, <code class=interfacename>ApplicationContext</CODE>, <code class=interfacename>Environment</CODE>, <code class=interfacename>ResourceLoader</CODE>, <code class=interfacename>ApplicationEventPublisher</CODE>, and <code 
class=interfacename>MessageSource</CODE>. These interfaces 
and their extended interfaces, such as <code class=interfacename>ConfigurableApplicationContext</CODE> or <code 
class=interfacename>ResourcePatternResolver</CODE>, are 
automatically resolved, with no special setup necessary.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>private</SPAN> ApplicationContext context;

  <span class=hl-keyword>public</SPAN> MovieRecommender() {
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p><code class=interfacename 
      >@Autowired</CODE>, <code class=interfacename 
      >@Inject</CODE>, <code class=interfacename 
      >@Resource</CODE>, and <code class=interfacename 
      >@Value</CODE> annotations are handled by a Spring 
      <code class=interfacename>BeanPostProcessor</CODE> 
      implementations which in turn means that you <span class=emphasis 
      ><em>cannot</EM></SPAN> apply 
      these annotations within your own <code class=classname 
      >BeanPostProcessor</CODE> or <code class=classname 
      >BeanFactoryPostProcessor</CODE> types (if any). These 
      types must be 'wired up' explicitly via XML or using a Spring <code 
      class=interfacename>@Bean</CODE> 
  method.</P></TD></TR></TABLE></DIV></DIV>
<div class=section 
title="5.9.3&nbsp;Fine-tuning annotation-based autowiring with qualifiers">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-autowired-annotation-qualifiers></A>5.9.3&nbsp;Fine-tuning annotation-based autowiring with 
qualifiers</H3></DIV></DIV></DIV>
<p>Because autowiring by type may lead to multiple 
candidates, it is often necessary to have more control over the selection 
process. One way to accomplish this is with Spring's <code class=interfacename>@Qualifier</CODE> annotation. You can associate qualifier 
values with specific arguments, narrowing the set of type matches so that a 
specific bean is chosen for each argument. In the simplest case, this can be a 
plain descriptive value:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=bold><strong>@Qualifier("main")</STRONG></SPAN>
  <span class=hl-keyword>private</SPAN> MovieCatalog movieCatalog;

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>The <code class=interfacename>@Qualifier</CODE> annotation can also be specified on 
individual constructor arguments or method parameters:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <span class=hl-keyword>private</SPAN> MovieCatalog movieCatalog;

  <span class=hl-keyword>private</SPAN> CustomerPreferenceDao customerPreferenceDao;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> prepare(<span class=bold><strong>@Qualifier("main")</STRONG></SPAN> MovieCatalog movieCatalog,
                      CustomerPreferenceDao customerPreferenceDao) {
      <span class=hl-keyword>this</SPAN>.movieCatalog = movieCatalog;
      <span class=hl-keyword>this</SPAN>.customerPreferenceDao = customerPreferenceDao;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>The corresponding bean definitions appear as follows. 
The bean with qualifier value "main" is wired with the constructor argument that 
is qualified with the same value.</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
  <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  <span class=hl-attribute>xmlns:context</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/context"</SPAN>
  <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;context:annotation-config/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=bold><strong>&lt;qualifier value="main"/&gt;</STRONG></SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=bold><strong>&lt;qualifier value="action"/&gt;</STRONG></SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"movieRecommender"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.MovieRecommender"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN>
</PRE>
<p>For a fallback match, the bean name is considered a 
default qualifier value. Thus you can define the bean with an id "main" instead 
of the nested qualifier element, leading to the same matching result. However, 
although you can use this convention to refer to specific beans by name, <code 
class=interfacename>@Autowired</CODE> is fundamentally 
about type-driven injection with optional semantic qualifiers. This means that 
qualifier values, even with the bean name fallback, always have narrowing 
semantics within the set of type matches; they do not semantically express a 
reference to a unique bean id. Good qualifier values are "main" or "EMEA" or 
"persistent", expressing characteristics of a specific component that are 
independent from the bean id, which may be auto-generated in case of an 
anonymous bean definition like the one in the preceding example.</P>
<p>Qualifiers also apply to typed collections, as discussed 
above, for example, to <code class=literal>Set&lt;MovieCatalog&gt;</CODE>. In this case, all matching 
beans according to the declared qualifiers are injected as a collection. This 
implies that qualifiers do not have to be unique; they rather simply constitute 
filtering criteria. For example, you can define multiple <code class=classname>MovieCatalog</CODE> beans with the same qualifier value 
"action"; all of which would be injected into a <code class=literal>Set&lt;MovieCatalog&gt;</CODE> annotated with <code 
class=literal>@Qualifier("action")</CODE>.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If you intend to express annotation-driven 
      injection by name, do not primarily use <code class=interfacename 
      >@Autowired</CODE>, even if is technically capable of 
      referring to a bean name through <code class=interfacename 
      >@Qualifier</CODE> values. Instead, use the JSR-250 
      <code class=interfacename>@Resource</CODE> 
      annotation, which is semantically defined to identify a specific target 
      component by its unique name, with the declared type being irrelevant for 
      the matching process.</P>
      <p>As a specific consequence of this semantic 
      difference, beans that are themselves defined as a collection or map type 
      cannot be injected through <code class=interfacename 
      >@Autowired</CODE>, because type matching is not 
      properly applicable to them. Use <code class=interfacename 
      >@Resource</CODE> for such beans, referring to the 
      specific collection or map bean by unique name.</P>
      <p><code class=interfacename 
      >@Autowired</CODE> applies to fields, constructors, 
      and multi-argument methods, allowing for narrowing through qualifier 
      annotations at the parameter level. By contrast, <code class=interfacename 
      >@Resource</CODE> is supported only for fields and 
      bean property setter methods with a single argument. As a consequence, 
      stick with qualifiers if your injection target is a constructor or a 
      multi-argument method.</P></TD></TR></TABLE></DIV>
<p>You can create your own custom qualifier annotations. 
Simply define an annotation and provide the <code class=interfacename>@Qualifier</CODE> annotation within your definition:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Target({ElementType.FIELD, ElementType.PARAMETER})</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Retention(RetentionPolicy.RUNTIME)</SPAN></I>
<span class=bold><strong>@Qualifier</STRONG></SPAN>
<span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@interface</SPAN></I> Genre {

  String value();
}</PRE>
<p>Then you can provide the custom qualifier on autowired 
fields and parameters:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=bold><strong>@Genre("Action")</STRONG></SPAN>
  <span class=hl-keyword>private</SPAN> MovieCatalog actionCatalog;

  <span class=hl-keyword>private</SPAN> MovieCatalog comedyCatalog;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setComedyCatalog(<span class=bold><strong>@Genre("Comedy")</STRONG></SPAN> MovieCatalog comedyCatalog) {
      <span class=hl-keyword>this</SPAN>.comedyCatalog = comedyCatalog;
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>Next, provide the information for the candidate bean 
definitions. You can add <code class=literal>&lt;qualifier/&gt;</CODE> tags as sub-elements of the <code 
class=literal>&lt;bean/&gt;</CODE> tag and then specify the 
<code class=literal>type</CODE> and <code class=literal>value</CODE> to match your custom qualifier annotations. 
The type is matched against the fully-qualified class name of the annotation. 
Or, as a convenience if no risk of conflicting names exists, you can use the 
short class name. Both approaches are demonstrated in the following example.</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
  <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  <span class=hl-attribute>xmlns:context</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/context"</SPAN>
  <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;context:annotation-config/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=bold><strong>&lt;qualifier type="Genre" value="Action"/&gt;</STRONG></SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=bold><strong>&lt;qualifier type="example.Genre" value="Comedy"/&gt;</STRONG></SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"movieRecommender"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.MovieRecommender"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN>
</PRE>
<p>In <A class=xref title="5.10&nbsp;Classpath scanning and managed components" href="beans.html#beans-classpath-scanning" >Section&nbsp;5.10, 
“Classpath scanning and managed components”</A>, you will see an 
annotation-based alternative to providing the qualifier metadata in XML. 
Specifically, see <A class=xref title="5.10.7&nbsp;Providing qualifier metadata with annotations" href="beans.html#beans-scanning-qualifiers" >Section&nbsp;5.10.7, 
“Providing qualifier metadata with annotations”</A>.</P>
<p>In some cases, it may be sufficient to use an annotation 
without a value. This may be useful when the annotation serves a more generic 
purpose and can be applied across several different types of dependencies. For 
example, you may provide an <span class=emphasis><em>offline</EM></SPAN> catalog that would be searched when no 
Internet connection is available. First define the simple annotation:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Target({ElementType.FIELD, ElementType.PARAMETER})</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Retention(RetentionPolicy.RUNTIME)</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Qualifier</SPAN></I>
<span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@interface</SPAN></I> Offline {

}</PRE>
<p>Then add the annotation to the field or property to be 
autowired:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=bold><strong>@Offline</STRONG></SPAN>
  <span class=hl-keyword>private</SPAN> MovieCatalog offlineCatalog;

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>Now the bean definition only needs a qualifier <code 
class=literal>type</CODE>:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=bold><strong>&lt;qualifier type="Offline"/&gt;</STRONG></SPAN>
  <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>You can also define custom qualifier annotations that 
accept named attributes in addition to or instead of the simple <code 
class=literal>value</CODE> attribute. If multiple attribute 
values are then specified on a field or parameter to be autowired, a bean 
definition must match <span class=emphasis><em>all</EM></SPAN> such attribute values to be considered an 
autowire candidate. As an example, consider the following annotation 
definition:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Target({ElementType.FIELD, ElementType.PARAMETER})</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Retention(RetentionPolicy.RUNTIME)</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Qualifier</SPAN></I>
<span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@interface</SPAN></I> MovieQualifier {

  String genre();

  Format format();
}</PRE>
<p>In this case <code class=literal>Format</CODE> is an enum:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> enum Format {

  VHS, DVD, BLURAY
}</PRE>
<p>The fields to be autowired are annotated with the custom 
qualifier and include values for both attributes: <code class=literal>genre</CODE> and <code class=literal>format</CODE>.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <i><span style="COLOR: gray" class=hl-annotation>@MovieQualifier(format=Format.VHS, genre="Action")</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog actionVhsCatalog;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <i><span style="COLOR: gray" class=hl-annotation>@MovieQualifier(format=Format.VHS, genre="Comedy")</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog comedyVhsCatalog;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <i><span style="COLOR: gray" class=hl-annotation>@MovieQualifier(format=Format.DVD, genre="Action")</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog actionDvdCatalog;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <i><span style="COLOR: gray" class=hl-annotation>@MovieQualifier(format=Format.BLURAY, genre="Comedy")</SPAN></I>
  <span class=hl-keyword>private</SPAN> MovieCatalog comedyBluRayCatalog;

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p>Finally, the bean definitions should contain matching 
qualifier values. This example also demonstrates that bean <span class=emphasis><em>meta</EM></SPAN> attributes may be 
used instead of the <code class=literal>&lt;qualifier/&gt;</CODE> sub-elements. If available, the 
<code class=literal>&lt;qualifier/&gt;</CODE> and its 
attributes take precedence, but the autowiring mechanism falls back on the 
values provided within the <code class=literal>&lt;meta/&gt;</CODE> tags if no such qualifier is present, 
as in the last two bean definitions in the following example.</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
  <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
  <span class=hl-attribute>xmlns:context</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/context"</SPAN>
  <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

  <span class=hl-tag>&lt;context:annotation-config/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;qualifier</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"MovieQualifier"</SPAN><span class=hl-tag>&gt;</SPAN>
          <span class=hl-tag>&lt;attribute</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"format"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"VHS"</SPAN><span class=hl-tag>/&gt;</SPAN>
          <span class=hl-tag>&lt;attribute</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"genre"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Action"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;/qualifier&gt;</SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;qualifier</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"MovieQualifier"</SPAN><span class=hl-tag>&gt;</SPAN>
          <span class=hl-tag>&lt;attribute</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"format"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"VHS"</SPAN><span class=hl-tag>/&gt;</SPAN>
          <span class=hl-tag>&lt;attribute</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"genre"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Comedy"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;/qualifier&gt;</SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;meta</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"format"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"DVD"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;meta</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"genre"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Action"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.SimpleMovieCatalog"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;meta</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"format"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"BLURAY"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;meta</SPAN> <span class=hl-attribute>key</SPAN>=<span class=hl-value>"genre"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"Comedy"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <em class=lineannotation><span class=lineannotation>&lt;!-- inject any dependencies required by this bean --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE></DIV>
<div class=section title=5.9.4&nbsp;CustomAutowireConfigurer>
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-custom-autowire-configurer></A>5.9.4&nbsp;<code class=classname>CustomAutowireConfigurer</CODE></H3></DIV></DIV></DIV>
<p>The <a class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html" 
target=_top><code class=classname>CustomAutowireConfigurer</CODE></A> is a <code 
class=interfacename>BeanFactoryPostProcessor</CODE> that 
enables you to register your own custom qualifier annotation types even if they 
are not annotated with Spring's <code class=interfacename>@Qualifier</CODE> annotation.</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"customAutowireConfigurer"</SPAN>
     <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"customQualifierTypes"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;set&gt;</SPAN>
          <span class=hl-tag>&lt;value&gt;</SPAN>example.CustomQualifier<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;/set&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>The particular implementation of <code 
class=interfacename>AutowireCandidateResolver</CODE> that 
is activated for the application context depends on the Java version. In 
versions earlier than Java 5, the qualifier annotations are not supported, and 
therefore autowire candidates are solely determined by the <code class=literal>autowire-candidate</CODE> value of each bean definition as 
well as by any <code class=literal>default-autowire-candidates</CODE> pattern(s) available on 
the <code class=literal>&lt;beans/&gt;</CODE> element. In 
Java 5 or later, the presence of <code class=interfacename>@Qualifier</CODE> annotations and any custom annotations 
registered with the <code class=classname>CustomAutowireConfigurer</CODE> will also play a role.</P>
<p>Regardless of the Java version, when multiple beans 
qualify as autowire candidates, the determination of a "primary" candidate is 
the same: if exactly one bean definition among the candidates has a <code 
class=literal>primary</CODE> attribute set to <code 
class=literal>true</CODE>, it will be selected.</P></DIV>
<div class=section title=5.9.5&nbsp;@Resource>
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-resource-annotation></A>5.9.5&nbsp;<code class=interfacename>@Resource</CODE></H3></DIV></DIV></DIV>
<p>Spring also supports injection using the JSR-250 <code 
class=interfacename>@Resource</CODE> annotation on fields 
or bean property setter methods. This is a common pattern in Java EE 5 and 6, 
for example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports 
this pattern for Spring-managed objects as well.</P>
<p><code class=interfacename>@Resource</CODE> takes a name attribute, and by default 
Spring interprets that value as the bean name to be injected. In other words, it 
follows <span class=emphasis><em>by-name</EM></SPAN> semantics, as demonstrated in this 
example:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <span class=bold><strong>@Resource(name="myMovieFinder")</STRONG></SPAN>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
}</PRE>
<p>If no name is specified explicitly, the default name is 
derived from the field name or setter method. In case of a field, it takes the 
field name; in case of a setter method, it takes the bean property name. So the 
following example is going to have the bean with name "movieFinder" injected 
into its setter method:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <span class=bold><strong>@Resource</STRONG></SPAN>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The name provided with the annotation is resolved 
      as a bean name by the <code class=interfacename 
      >ApplicationContext</CODE> of which the <code 
      class=classname 
      >CommonAnnotationBeanPostProcessor</CODE> is aware. 
      The names can be resolved through JNDI if you configure Spring's <a 
      class=ulink 
      href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html" 
      target=_top><code class=classname 
      >SimpleJndiBeanFactory</CODE></A> explicitly. However, 
      it is recommended that you rely on the default behavior and simply use 
      Spring's JNDI lookup capabilities to preserve the level of 
    indirection.</P></TD></TR></TABLE></DIV>
<p>In the exclusive case of <code class=interfacename>@Resource</CODE> usage with no explicit name specified, and 
similar to <code class=interfacename>@Autowired</CODE>, 
<code class=interfacename>@Resource</CODE> finds a primary 
type match instead of a specific named bean and resolves well-known resolvable 
dependencies: the <code class=interfacename>BeanFactory</CODE><code class=interfacename>, ApplicationContext,</CODE><code class=interfacename> ResourceLoader, ApplicationEventPublisher</CODE>, and 
<code class=interfacename>MessageSource</CODE> 
interfaces.</P>
<p>Thus in the following example, the <code class=literal>customerPreferenceDao</CODE> field first looks for a bean 
named customerPreferenceDao, then falls back to a primary type match for the 
type <code class=classname>CustomerPreferenceDao</CODE>. 
The "context" field is injected based on the known resolvable dependency type 
<code class=interfacename>ApplicationContext</CODE>.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieRecommender {

  <i><span style="COLOR: gray" class=hl-annotation>@Resource</SPAN></I>
  <span class=hl-keyword>private</SPAN> CustomerPreferenceDao customerPreferenceDao;

  <i><span style="COLOR: gray" class=hl-annotation>@Resource</SPAN></I>
  <span class=hl-keyword>private</SPAN> ApplicationContext context;

  <span class=hl-keyword>public</SPAN> MovieRecommender() {
  }

  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE></DIV>
<div class=section title="5.9.6&nbsp;@PostConstruct and @PreDestroy">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-postconstruct-and-predestroy-annotations></A>5.9.6&nbsp;<code class=interfacename>@PostConstruct</CODE> and <code class=interfacename>@PreDestroy</CODE></H3></DIV></DIV></DIV>
<p>The <code class=classname>CommonAnnotationBeanPostProcessor</CODE> not only 
recognizes the <code class=interfacename>@Resource</CODE> 
annotation but also the JSR-250 <span class=emphasis><em>lifecycle</EM></SPAN> annotations. Introduced in Spring 
2.5, the support for these annotations offers yet another alternative to those 
described in <A class=link title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" >initialization 
callbacks</A> and <A class=link title="Destruction callbacks" href="beans.html#beans-factory-lifecycle-disposablebean" >destruction 
callbacks</A>. Provided that the <code class=classname>CommonAnnotationBeanPostProcessor</CODE> is registered 
within the Spring <code class=interfacename>ApplicationContext</CODE>, a method carrying one of these 
annotations is invoked at the same point in the lifecycle as the corresponding 
Spring lifecycle interface method or explicitly declared callback method. In the 
example below, the cache will be pre-populated upon initialization and cleared 
upon destruction.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> CachingMovieLister {

  <i><span style="COLOR: gray" class=hl-annotation>@PostConstruct</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> populateMovieCache() {
      <em class=lineannotation><span class=lineannotation>// populates the movie cache upon initialization...</SPAN></EM>
  }

  <i><span style="COLOR: gray" class=hl-annotation>@PreDestroy</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> clearMovieCache() {
      <em class=lineannotation><span class=lineannotation>// clears the movie cache upon destruction...</SPAN></EM>
  }
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>For details about the effects of combining various 
      lifecycle mechanisms, see <A class=xref title="Combining lifecycle mechanisms" href="beans.html#beans-factory-lifecycle-combined-effects" >the 
      section called “Combining lifecycle 
mechanisms”</A>.</P></TD></TR></TABLE></DIV></DIV></DIV>
<div class=section title="5.10&nbsp;Classpath scanning and managed components">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-classpath-scanning></A>5.10&nbsp;Classpath 
scanning and managed components</H2></DIV></DIV></DIV>
<p>Most examples in this chapter use XML to specify the 
configuration metadata that produces each <code class=interfacename>BeanDefinition</CODE> within the Spring container. The 
previous section (<A class=xref title="5.9&nbsp;Annotation-based container configuration" href="beans.html#beans-annotation-config" >Section&nbsp;5.9, 
“Annotation-based container configuration”</A>) demonstrates how to provide a 
lot of the configuration metadata through source-level annotations. Even in 
those examples, however, the "base" bean definitions are explicitly defined in 
the XML file, while the annotations only drive the dependency injection. This 
section describes an option for implicitly detecting the <span class=emphasis><em>candidate components</EM></SPAN> 
by scanning the classpath. Candidate components are classes that match against a 
filter criteria and have a corresponding bean definition registered with the 
container. This removes the need to use XML to perform bean registration, 
instead you can use annotations (for example @Component), AspectJ type 
expressions, or your own custom filter criteria to select which classes will 
have bean definitions registered with the container.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Starting with Spring 3.0, many features provided 
      by the <a class=ulink href="http://www.springsource.org/javaconfig" 
      target=_top>Spring JavaConfig project</A> are part of 
      the core Spring Framework. This allows you to define beans using Java 
      rather than using the traditional XML files. Take a look at the <code 
      class=interfacename>@Configuration</CODE>, <code 
      class=interfacename>@Bean</CODE>, <code 
      class=interfacename>@Import</CODE>, and <code 
      class=interfacename>@DependsOn</CODE> annotations for 
      examples of how to use these new features.</P></TD></TR></TABLE></DIV>
<div class=section 
title="5.10.1&nbsp;@Component and further stereotype annotations">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-stereotype-annotations></A>5.10.1&nbsp;<code class=interfacename>@Component</CODE> and further stereotype 
annotations</H3></DIV></DIV></DIV>
<p>In Spring 2.0 and later, the <code class=interfacename>@Repository</CODE> annotation is a marker for any class 
that fulfills the role or <span class=emphasis><em>stereotype</EM></SPAN> (also known as Data Access Object or 
DAO) of a repository. Among the uses of this marker is the automatic translation 
of exceptions as described in <A class=xref title="15.2.2&nbsp;Exception translation" href="orm.html#orm-exception-translation" >Section&nbsp;15.2.2, 
“Exception translation”</A>.</P>
<p>Spring 2.5 introduces further stereotype annotations: 
<code class=interfacename>@Component</CODE>, <code 
class=interfacename>@Service</CODE>, and <code 
class=interfacename>@Controller</CODE>. <code 
class=interfacename>@Component</CODE> is a generic 
stereotype for any Spring-managed component. <code class=interfacename>@Repository</CODE>, <code class=interfacename>@Service</CODE>, and <code class=interfacename>@Controller</CODE> are specializations of <code 
class=interfacename>@Component</CODE> for more specific use 
cases, for example, in the persistence, service, and presentation layers, 
respectively. Therefore, you can annotate your component classes with <code 
class=interfacename>@Component</CODE>, but by annotating 
them with <code class=interfacename>@Repository</CODE>, 
<code class=interfacename>@Service</CODE>, or <code 
class=interfacename>@Controller</CODE> instead, your 
classes are more properly suited for processing by tools or associating with 
aspects. For example, these stereotype annotations make ideal targets for 
pointcuts. It is also possible that <code class=interfacename>@Repository</CODE>, <code class=interfacename>@Service</CODE>, and <code class=interfacename>@Controller</CODE> may carry additional semantics in future 
releases of the Spring Framework. Thus, if you are choosing between using <code 
class=interfacename>@Component</CODE> or <code 
class=interfacename>@Service</CODE> for your service layer, 
<code class=interfacename>@Service</CODE> is clearly the 
better choice. Similarly, as stated above, <code class=interfacename>@Repository</CODE> is already supported as a marker for 
automatic exception translation in your persistence layer.</P></DIV>
<div class=section 
title="5.10.2&nbsp;Automatically detecting classes and registering bean definitions">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-scanning-autodetection></A>5.10.2&nbsp;Automatically detecting classes and 
registering bean definitions</H3></DIV></DIV></DIV>
<p>Spring can automatically detect stereotyped classes and 
register corresponding <code class=interfacename>BeanDefinition</CODE>s with the <code class=interfacename>ApplicationContext</CODE>. For example, the following two 
classes are eligible for such autodetection:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Service</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I>
  <span class=hl-keyword>public</SPAN> SimpleMovieLister(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
}</PRE><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Repository</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> JpaMovieFinder <span class=hl-keyword>implements</SPAN> MovieFinder {
  <em class=lineannotation><span class=lineannotation>// implementation elided for clarity</SPAN></EM>
}</PRE>
<p>To autodetect these classes and register the 
corresponding beans, you need to include the following element in XML, where the 
base-package element is a common parent package for the two classes. 
(Alternatively, you can specify a comma-separated list that includes the parent 
package of each class.)</P><pre class=programlisting><span style="COLOR: maroon" class=hl-directive>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</SPAN>
<span class=hl-tag>&lt;beans</SPAN> <span class=hl-attribute>xmlns</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans"</SPAN>
     <span class=hl-attribute>xmlns:xsi</SPAN>=<span class=hl-value>"http://www.w3.org/2001/XMLSchema-instance"</SPAN>
     <span class=hl-attribute>xmlns:context</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/context"</SPAN>
     <span class=hl-attribute>xsi:schemaLocation</SPAN>=<span class=hl-value>"http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd"</SPAN><span class=hl-tag>&gt;</SPAN>

   <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN><span class=hl-tag>/&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The use of <code class=literal 
      >&lt;context:component-scan&gt;</CODE> implicitly 
      enables the functionality of <code class=literal 
      >&lt;context:annotation-config&gt;</CODE>. There is 
      usually no need to include the <code class=literal 
      >&lt;context:annotation-config&gt;</CODE> element when 
      using <code class=literal 
      >&lt;context:component-scan&gt;</CODE>. 
  </P></TD></TR></TABLE></DIV>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The scanning of classpath packages requires the 
      presence of corresponding directory entries in the classpath. When you 
      build JARs with Ant, make sure that you do <span class=emphasis 
      ><em>not</EM></SPAN> activate the 
      files-only switch of the JAR task.</P></TD></TR></TABLE></DIV>
<p>Furthermore, the <code class=interfacename>AutowiredAnnotationBeanPostProcessor</CODE> and <code 
class=interfacename>CommonAnnotationBeanPostProcessor</CODE> are both included 
implicitly when you use the component-scan element. That means that the two 
components are autodetected <span class=emphasis><em>and</EM></SPAN> wired together - all without any bean 
configuration metadata provided in XML.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>You can disable the registration of <code 
      class=interfacename 
      >AutowiredAnnotationBeanPostProcessor</CODE> and <code 
      class=interfacename 
      >CommonAnnotationBeanPostProcessor</CODE> by including 
      the <span class=emphasis><em 
      >annotation-config</EM></SPAN> attribute with a value 
      of false.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.10.3&nbsp;Using filters to customize scanning">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-scanning-filters></A>5.10.3&nbsp;Using filters to customize 
scanning</H3></DIV></DIV></DIV>
<p>By default, classes annotated with <code 
class=interfacename>@Component</CODE>, <code 
class=interfacename>@Repository</CODE>, <code 
class=interfacename>@Service</CODE>, <code 
class=interfacename>@Controller</CODE>, or a custom 
annotation that itself is annotated with <code class=interfacename>@Component</CODE> are the only detected candidate 
components. However, you can modify and extend this behavior simply by applying 
custom filters. Add them as <span class=emphasis><em>include-filter</EM></SPAN> or <span class=emphasis><em>exclude-filter</EM></SPAN> 
sub-elements of the <code class=literal>component-scan</CODE> element. Each filter element requires 
the <code class=literal>type</CODE> and <code class=literal>expression</CODE> attributes. The following table describes 
the filtering options.</P>
<div class=table><a name=beans-scanning-filters-tbl></A>
<p class=title><b>Table&nbsp;5.5.&nbsp;Filter Types</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Filter Types">
  <colgroup>
  <col>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Filter Type</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Example Expression</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid" 
  >Description</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >annotation</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=literal 
      >org.example.SomeAnnotation</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">An annotation 
      to be present at the type level in target components.</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >assignable</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=literal 
      >org.example.SomeClass</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">A class (or 
      interface) that the target components are assignable to 
    (extend/implement).</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >aspectj</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=literal 
      >org.example..*Service+</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">An AspectJ 
      type expression to be matched by the target components.</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >regex</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=literal 
      >org\.example\.Default.*</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">A regex 
      expression to be matched by the target components class names.</TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid">custom</TD>
    <td style="BORDER-RIGHT: 0.5pt solid"><code 
      class=literal>org.example.MyTypeFilter</CODE></TD>
    <td>A custom implementation of the <code 
      class=interfacename>org.springframework.core.type 
      .TypeFilter</CODE> interface.</TD></TR></TBODY></TABLE></DIV></DIV><br 
class=table-break>
<p>The following example shows the XML configuration 
ignoring all <code class=interfacename>@Repository</CODE> 
annotations and using "stub" repositories instead.</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>

   <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;context:include-filter</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"regex"</SPAN> <span class=hl-attribute>expression</SPAN>=<span class=hl-value>".*Stub.*Repository"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;context:exclude-filter</SPAN> <span class=hl-attribute>type</SPAN>=<span class=hl-value>"annotation"</SPAN>
                              <span class=hl-attribute>expression</SPAN>=<span class=hl-value>"org.springframework.stereotype.Repository"</SPAN><span class=hl-tag>/&gt;</SPAN>
   <span class=hl-tag>&lt;/context:component-scan&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>You can also disable the default filters by 
      providing <span class=emphasis><em 
      >use-default-filters="false"</EM></SPAN> as an 
      attribute of the &lt;component-scan/&gt; element. This will in effect 
      disable automatic detection of classes annotated with <code 
      class=interfacename>@Component</CODE>, <code 
      class=interfacename>@Repository</CODE>, <code 
      class=interfacename>@Service</CODE>, or <code 
      class=interfacename 
  >@Controller</CODE>.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.10.4&nbsp;Defining bean metadata within components">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-factorybeans-annotations></A>5.10.4&nbsp;Defining bean metadata within 
components</H3></DIV></DIV></DIV>
<p>Spring components can also contribute bean definition 
metadata to the container. You do this with the same <code class=literal>@Bean</CODE> annotation used to define bean metadata within 
<code class=literal>@Configuration</CODE> annotated 
classes. Here is a simple example:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Component</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> FactoryMethodComponent {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> <i><span style="COLOR: gray" class=hl-annotation>@Qualifier("public")</SPAN></I>
  <span class=hl-keyword>public</SPAN> TestBean publicInstance() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TestBean(<span class=hl-string>"publicInstance"</SPAN>);
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> doWork() {
      <span class=hl-comment>// Component method implementation omitted</SPAN>
  }
}</PRE>
<p>This class is a Spring component that has 
application-specific code contained in its <code class=methodname>doWork()</CODE> method. However, it also contributes a bean 
definition that has a factory method referring to the method <code 
class=methodname>publicInstance()</CODE>. The <code 
class=literal>@Bean</CODE> annotation identifies the 
factory method and other bean definition properties, such as a qualifier value 
through the <code class=classname>@Qualifier</CODE> 
annotation. Other method level annotations that can be specified are <code 
class=literal>@Scope</CODE>, <code class=literal>@Lazy</CODE>, and custom qualifier annotations. Autowired 
fields and methods are supported as previously discussed, with additional 
support for autowiring of <code class=literal>@Bean</CODE> 
methods:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Component</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> FactoryMethodComponent {

  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>int</SPAN> i;

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> <i><span style="COLOR: gray" class=hl-annotation>@Qualifier("public")</SPAN></I>
  <span class=hl-keyword>public</SPAN> TestBean publicInstance() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TestBean(<span class=hl-string>"publicInstance"</SPAN>);
  }

  <span class=hl-comment>// use of a custom qualifier and autowiring of method parameters</SPAN>

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>protected</SPAN> TestBean protectedInstance(<i><span style="COLOR: gray" class=hl-annotation>@Qualifier("public")</SPAN></I> TestBean spouse,
                                       <i><span style="COLOR: gray" class=hl-annotation>@Value("#{privateInstance.age}")</SPAN></I> String country) {
      TestBean tb = <span class=hl-keyword>new</SPAN> TestBean(<span class=hl-string>"protectedInstance"</SPAN>, <span class=hl-number>1</SPAN>);
      tb.setSpouse(tb);
      tb.setCountry(country);
      <span class=hl-keyword>return</SPAN> tb;
  }

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> <i><span style="COLOR: gray" class=hl-annotation>@Scope(BeanDefinition.SCOPE_SINGLETON)</SPAN></I>
  <span class=hl-keyword>private</SPAN> TestBean privateInstance() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TestBean(<span class=hl-string>"privateInstance"</SPAN>, i++);
  }

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> <i><span style="COLOR: gray" class=hl-annotation>@Scope(value = WebApplicationContext.SCOPE_SESSION,
               proxyMode = ScopedProxyMode.TARGET_CLASS)</SPAN></I>
  <span class=hl-keyword>public</SPAN> TestBean requestScopedInstance() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TestBean(<span class=hl-string>"requestScopedInstance"</SPAN>, <span class=hl-number>3</SPAN>);
  }
}
</PRE>
<p>The example autowires the <code class=classname>String</CODE> method parameter <code class=literal>country</CODE> to the value of the <code class=literal>Age</CODE> property on another bean named <code 
class=literal>privateInstance</CODE>. A Spring Expression 
Language element defines the value of the property through the notation <code 
class=literal>#{ &lt;expression&gt; }</CODE>. For <code 
class=literal>@Value</CODE> annotations, an expression 
resolver is preconfigured to look for bean names when resolving expression 
text.</P>
<p>The <code class=literal>@Bean</CODE> methods in a Spring component are processed 
differently than their counterparts inside a Spring <code class=literal>@Configuration</CODE> class. The difference is that <code 
class=literal>@Component</CODE> classes are not enhanced 
with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is 
the means by which invoking methods or fields within <code class=literal>@Configuration</CODE> classes <code class=literal>@Bean</CODE> methods create bean metadata references to 
collaborating objects. Methods are <span class=emphasis><em>not</EM></SPAN> invoked with normal Java semantics. In 
contrast, calling a method or field within a <code class=literal>@Component</CODE> classes <code class=literal>@Bean</CODE> method <span class=emphasis><em>has</EM></SPAN> standard Java 
semantics.</P></DIV>
<div class=section title="5.10.5&nbsp;Naming autodetected components">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-scanning-name-generator></A>5.10.5&nbsp;Naming autodetected 
components</H3></DIV></DIV></DIV>
<p>When a component is autodetected as part of the scanning 
process, its bean name is generated by the <code class=interfacename>BeanNameGenerator</CODE> strategy known to that scanner. By 
default, any Spring stereotype annotation (<code class=interfacename>@Component</CODE>, <code class=interfacename>@Repository</CODE>, <code class=interfacename>@Service</CODE>, and <code class=interfacename>@Controller</CODE>) that contains a <code class=literal>name</CODE> value will thereby provide that name to the 
corresponding bean definition.</P>
<p>If such an annotation contains no <code class=literal>name</CODE> value or for any other detected component (such 
as those discovered by custom filters), the default bean name generator returns 
the uncapitalized non-qualified class name. For example, if the following two 
components were detected, the names would be myMovieLister and 
movieFinderImpl:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Service("myMovieLister")</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Repository</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieFinderImpl <span class=hl-keyword>implements</SPAN> MovieFinder {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If you do not want to rely on the default 
      bean-naming strategy, you can provide a custom bean-naming strategy. 
      First, implement the <a class=ulink 
      href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html" 
      target=_top><code class=interfacename 
      >BeanNameGenerator</CODE></A> interface, and be sure 
      to include a default no-arg constructor. Then, provide the fully-qualified 
      class name when configuring the scanner:</P></TD></TR></TABLE></DIV><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>

   <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN>
                           <span class=hl-attribute>name-generator</SPAN>=<span class=hl-value>"org.example.MyNameGenerator"</SPAN><span class=hl-tag> /&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>As a general rule, consider specifying the name with the 
annotation whenever other components may be making explicit references to it. On 
the other hand, the auto-generated names are adequate whenever the container is 
responsible for wiring.</P></DIV>
<div class=section 
title="5.10.6&nbsp;Providing a scope for autodetected components">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-scanning-scope-resolver></A>5.10.6&nbsp;Providing a scope for autodetected 
components</H3></DIV></DIV></DIV>
<p>As with Spring-managed components in general, the 
default and most common scope for autodetected components is singleton. However, 
sometimes you need other scopes, which Spring 2.5 provides with a new <code 
class=interfacename>@Scope</CODE> annotation. Simply 
provide the name of the scope within the annotation:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Scope("prototype")</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Repository</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MovieFinderImpl <span class=hl-keyword>implements</SPAN> MovieFinder {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>To provide a custom strategy for scope resolution 
      rather than relying on the annotation-based approach, implement the <a 
      class=ulink 
      href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html" 
      target=_top><code class=interfacename 
      >ScopeMetadataResolver</CODE></A> interface, and be 
      sure to include a default no-arg constructor. Then, provide the 
      fully-qualified class name when configuring the 
scanner:</P></TD></TR></TABLE></DIV><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>

   <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN>
                           <span class=hl-attribute>scope-resolver</SPAN>=<span class=hl-value>"org.example.MyScopeResolver"</SPAN><span class=hl-tag> /&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>When using certain non-singleton scopes, it may be 
necessary to generate proxies for the scoped objects. The reasoning is described 
in <A class=xref title="Scoped beans as dependencies" href="beans.html#beans-factory-scopes-other-injection" >the section 
called “Scoped beans as dependencies”</A>. For this purpose, a <span 
class=emphasis><em>scoped-proxy</EM></SPAN> attribute is available on the 
component-scan element. The three possible values are: no, interfaces, and 
targetClass. For example, the following configuration will result in standard 
JDK dynamic proxies:</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>

   <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN>
                           <span class=hl-attribute>scoped-proxy</SPAN>=<span class=hl-value>"interfaces"</SPAN><span class=hl-tag> /&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE></DIV>
<div class=section 
title="5.10.7&nbsp;Providing qualifier metadata with annotations">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-scanning-qualifiers></A>5.10.7&nbsp;Providing qualifier metadata with 
annotations</H3></DIV></DIV></DIV>
<p>The <code class=interfacename>@Qualifier</CODE> annotation is discussed in <A class=xref title="5.9.3&nbsp;Fine-tuning annotation-based autowiring with qualifiers" href="beans.html#beans-autowired-annotation-qualifiers" >Section&nbsp;5.9.3, 
“Fine-tuning annotation-based autowiring with qualifiers”</A>. The examples in 
that section demonstrate the use of the <code class=interfacename>@Qualifier</CODE> annotation and custom qualifier 
annotations to provide fine-grained control when you resolve autowire 
candidates. Because those examples were based on XML bean definitions, the 
qualifier metadata was provided on the candidate bean definitions using the 
<code class=literal>qualifier</CODE> or <code class=literal>meta</CODE> sub-elements of the <code class=literal>bean</CODE> element in the XML. When relying upon classpath 
scanning for autodetection of components, you provide the qualifier metadata 
with type-level annotations on the candidate class. The following three examples 
demonstrate this technique:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Component</SPAN></I>
<span class=bold><strong>@Qualifier("Action")</STRONG></SPAN>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ActionMovieCatalog <span class=hl-keyword>implements</SPAN> MovieCatalog {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Component</SPAN></I>
<span class=bold><strong>@Genre("Action")</STRONG></SPAN>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ActionMovieCatalog <span class=hl-keyword>implements</SPAN> MovieCatalog {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Component</SPAN></I>
<span class=bold><strong>@Offline</STRONG></SPAN>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> CachingMovieCatalog <span class=hl-keyword>implements</SPAN> MovieCatalog {
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>As with most annotation-based alternatives, keep 
      in mind that the annotation metadata is bound to the class definition 
      itself, while the use of XML allows for multiple beans <span 
      class=emphasis><em>of the same 
      type</EM></SPAN> to provide variations in their qualifier metadata, 
      because that metadata is provided per-instance rather than 
    per-class.</P></TD></TR></TABLE></DIV></DIV></DIV>
<div class=section title="5.11&nbsp;Using JSR 330 Standard Annotations">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-standard-annotations></A>5.11&nbsp;Using JSR 330 
Standard Annotations</H2></DIV></DIV></DIV>
<p>Starting with Spring 3.0, Spring offers support for 
JSR-330 standard annotations (Dependency Injection). Those annotations are 
scanned in the same way as the Spring annotations. You just need to have the 
relevant jars in your classpath. </P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>If you are using Maven, the <code 
      class=interfacename>javax.inject</CODE> artifact is 
      available in the standard Maven repository (<a class=ulink 
      href="http://repo1.maven.org/maven2/javax/inject/javax.inject/1/" 
      target=_top 
      >http://repo1.maven.org/maven2/javax/inject/javax.inject/1/</A>). 
      You can add the following dependency to your file pom.xml: </P><pre class=programlisting><span class=hl-tag>&lt;dependency&gt;</SPAN>
    <span class=hl-tag>&lt;groupId&gt;</SPAN>javax.inject<span class=hl-tag>&lt;/groupId&gt;</SPAN>
    <span class=hl-tag>&lt;artifactId&gt;</SPAN>javax.inject<span class=hl-tag>&lt;/artifactId&gt;</SPAN>
    <span class=hl-tag>&lt;version&gt;</SPAN>1<span class=hl-tag>&lt;/version&gt;</SPAN>
<span class=hl-tag>&lt;/dependency&gt;</SPAN></PRE></TD></TR></TABLE></DIV>
<div class=section 
title="5.11.1&nbsp;Dependency Injection with @Inject and @Named">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-inject-named></A>5.11.1&nbsp;Dependency Injection with <code 
class=interfacename>@Inject</CODE> and <code 
class=interfacename>@Named</CODE></H3></DIV></DIV></DIV>
<p>Instead of <code class=interfacename>@Autowired</CODE>, <code class=interfacename>@javax.inject.Inject</CODE> may be used as follows: </P><pre class=programlisting><span class=hl-keyword>import</SPAN> javax.inject.Inject;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Inject</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p></P>
<p>As with <code class=interfacename>@Autowired</CODE>, it is possible to use <code 
class=interfacename>@Inject</CODE> at the class-level, 
field-level, method-level and constructor-argument level. If you would like to 
use a qualified name for the dependency that should be injected, you should use 
the <code class=interfacename>@Named</CODE> annotation as 
follows: </P><pre class=programlisting><span class=hl-keyword>import</SPAN> javax.inject.Inject;
<span class=hl-keyword>import</SPAN> javax.inject.Named;

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Inject</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(<i><span style="COLOR: gray" class=hl-annotation>@Named("main")</SPAN></I> MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p></P></DIV>
<div class=section 
title="5.11.2&nbsp;@Named: a standard equivalent to the @Component annotation">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-named></A>5.11.2&nbsp;<code class=interfacename>@Named</CODE>: a standard equivalent to the <code 
class=interfacename>@Component</CODE> 
annotation</H3></DIV></DIV></DIV>
<p>Instead of <code class=interfacename>@Component</CODE>, <code class=interfacename>@javax.inject.Named</CODE> may be used as follows: </P><pre class=programlisting><span class=hl-keyword>import</SPAN> javax.inject.Inject;
<span class=hl-keyword>import</SPAN> javax.inject.Named;

<i><span style="COLOR: gray" class=hl-annotation>@Named("movieListener")</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Inject</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p></P>
<p>It is very common to use <code class=interfacename>@Component</CODE> without specifying a name for the 
component. <code class=interfacename>@Named</CODE> can be 
used in a similar fashion: </P><pre class=programlisting><span class=hl-keyword>import</SPAN> javax.inject.Inject;
<span class=hl-keyword>import</SPAN> javax.inject.Named;

<i><span style="COLOR: gray" class=hl-annotation>@Named</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SimpleMovieLister {

  <span class=hl-keyword>private</SPAN> MovieFinder movieFinder;

  <i><span style="COLOR: gray" class=hl-annotation>@Inject</SPAN></I>
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMovieFinder(MovieFinder movieFinder) {
      <span class=hl-keyword>this</SPAN>.movieFinder = movieFinder;
  }
  <em class=lineannotation><span class=lineannotation>// ...</SPAN></EM>
}</PRE>
<p></P>
<p>When using <code class=interfacename>@Named</CODE>, it is possible to use component-scanning in 
the exact same way as when using Spring annotations: </P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
    <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"org.example"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p></P></DIV>
<div class=section title="5.11.3&nbsp;Limitations of the standard approach">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-standard-annotations-limitations></A>5.11.3&nbsp;Limitations of the standard 
approach</H3></DIV></DIV></DIV>
<p>When working with standard annotations, it is important 
to know that some significant features are not available as shown in the table 
below:</P>
<div class=table><a name=annotations-comparison></A>
<p class=title><b>Table&nbsp;5.6.&nbsp;Spring annotations vs. standard 
annotations</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Spring annotations vs. standard annotations">
  <colgroup>
  <col>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Spring</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >javax.inject.*</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid">javax.inject 
      restrictions / comments</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Autowired</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Inject</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">@Inject has no 
      'required' attribute</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Component</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Named</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">—</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Scope("singleton")</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Singleton</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">
      <p>The JSR-330 default scope is like Spring's <code 
      class=interfacename>prototype</CODE>. However, in 
      order to keep it consistent with Spring's general defaults, a JSR-330 bean 
      declared in the Spring container is a <code class=interfacename 
      >singleton</CODE> by default. In order to use a scope 
      other than <code class=interfacename 
      >singleton</CODE>, you should use Spring's <code 
      class=interfacename>@Scope</CODE> annotation. </P>
      <p><code class=interfacename 
      >javax.inject</CODE> also provides a <a class=ulink 
      href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html" 
      target=_top>@Scope</A> annotation. Nevertheless, this 
      one is only intended to be used for creating your own annotations. 
  </P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Qualifier</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Named</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">—</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Value</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >—</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">no 
    equivalent</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >@Required</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >—</TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">no 
    equivalent</TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid">@Lazy</TD>
    <td style="BORDER-RIGHT: 0.5pt solid">—</TD>
    <td>no equivalent</TD></TR></TBODY></TABLE></DIV></DIV>
<p><br class=table-break></P></DIV></DIV>
<div class=section title="5.12&nbsp;Java-based container configuration">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a name=beans-java></A>5.12&nbsp;Java-based container 
configuration</H2></DIV></DIV></DIV>
<div class=section title="5.12.1&nbsp;Basic concepts: @Configuration and @Bean">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-java-basic-concepts></A>5.12.1&nbsp;Basic concepts: <code class=literal>@Configuration</CODE> and <code class=literal>@Bean</CODE></H3></DIV></DIV></DIV>
<p>The central artifact in Spring's new Java-configuration 
support is the <code class=interfacename>@Configuration</CODE>-annotated class. These classes 
consist principally of <code class=interfacename>@Bean</CODE>-annotated methods that define instantiation, 
configuration, and initialization logic for objects to be managed by the Spring 
IoC container.</P>
<p>Annotating a class with the <code class=interfacename>@Configuration</CODE> indicates that the class can be used 
by the Spring IoC container as a source of bean definitions. The simplest 
possible <code class=interfacename>@Configuration</CODE> 
class would read as follows: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {
  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> MyService myService() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> MyServiceImpl();
  }
}</PRE>
<p>For those more familiar with Spring <code class=literal>&lt;beans/&gt;</CODE> XML, the <code class=literal>AppConfig</CODE> class above would be equivalent to: </P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"myService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.acme.services.MyServiceImpl"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>As you can see, the <code class=literal>@Bean</CODE> annotation plays the same role as the <code 
class=literal>&lt;bean/&gt;</CODE> element. The <code 
class=literal>@Bean</CODE> annotation will be discussed in 
depth in the sections below. First, however, we'll cover the various ways of 
creating a spring container using Java-based configuration.</P></DIV>
<div class=section 
title="5.12.2&nbsp;Instantiating the Spring container using AnnotationConfigApplicationContext">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-java-instantiating-container></A>5.12.2&nbsp;Instantiating the Spring container using 
<code class=literal>AnnotationConfigApplicationContext</CODE></H3></DIV></DIV></DIV>
<p>The sections below document Spring's <code class=literal>AnnotationConfigApplicationContext</CODE>, new in Spring 
3.0. This versatile <code class=literal>ApplicationContext</CODE> implementation is capable of 
accepting not only <code class=literal>@Configuration</CODE> classes as input, but also plain 
<code class=literal>@Component</CODE> classes and classes 
annotated with JSR-330 metadata.</P>
<p>When <code class=literal>@Configuration</CODE> classes are provided as input, the 
<code class=literal>@Configuration</CODE> class itself is 
registered as a bean definition, and all declared <code class=literal>@Bean</CODE> methods within the class are also registered 
as bean definitions.</P>
<p>When <code class=literal>@Component</CODE> and JSR-330 classes are provided, they 
are registered as bean definitions, and it is assumed that DI metadata such as 
<code class=literal>@Autowired</CODE> or <code 
class=literal>@Inject</CODE> are used within those classes 
where necessary.</P>
<div class=section title="Simple construction">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-java-instantiating-container-contstructor></A>Simple construction</H4></DIV></DIV></DIV>
<p>In much the same way that Spring XML files are used as 
input when instantiating a <code class=literal>ClassPathXmlApplicationContext</CODE>, <code class=literal>@Configuration</CODE> classes may be used as input when 
instantiating an <code class=literal>AnnotationConfigApplicationContext</CODE>. This allows for 
completely XML-free usage of the Spring container: </P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(AppConfig.<span class=hl-keyword>class</SPAN>);
  MyService myService = ctx.getBean(MyService.<span class=hl-keyword>class</SPAN>);
  myService.doStuff();
}</PRE>
<p>As mentioned above, <code class=literal>AnnotationConfigApplicationContext</CODE> is not limited to 
working only with <code class=literal>@Configuration</CODE> 
classes. Any <code class=literal>@Component</CODE> or 
JSR-330 annotated class may be supplied as input to the constructor. For 
example: </P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(MyServiceImpl.<span class=hl-keyword>class</SPAN>, Dependency1.<span class=hl-keyword>class</SPAN>, Dependency2.<span class=hl-keyword>class</SPAN>);
  MyService myService = ctx.getBean(MyService.<span class=hl-keyword>class</SPAN>);
  myService.doStuff();
}</PRE>
<p>The above assumes that <code class=literal>MyServiceImpl</CODE>, <code class=literal>Dependency1</CODE> and <code class=literal>Dependency2</CODE> use Spring dependency injection 
annotations such as <code class=literal>@Autowired</CODE>.</P></DIV>
<div class=section 
title="Building the container programmatically using register(Class<?>...)">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-java-instantiating-container-register></A>Building the container programmatically using <code 
class=literal>register(Class&lt;?&gt;...)</CODE></H4></DIV></DIV></DIV>
<p>An <code class=literal>AnnotationConfigApplicationContext</CODE> may be 
instantiated using a no-arg constructor and then configured using the <code 
class=literal>register()</CODE> method. This approach is 
particularly useful when programmatically building an <code class=literal>AnnotationConfigApplicationContext</CODE>. </P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  AnnotationConfigApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext();
  ctx.register(AppConfig.<span class=hl-keyword>class</SPAN>, OtherConfig.<span class=hl-keyword>class</SPAN>);
  ctx.register(AdditionalConfig.<span class=hl-keyword>class</SPAN>);
  ctx.refresh();
  MyService myService = ctx.getBean(MyService.<span class=hl-keyword>class</SPAN>);
  myService.doStuff();
}</PRE></DIV>
<div class=section title="Enabling component scanning with scan(String...)">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-java-instantiating-container-scan></A>Enabling 
component scanning with <code class=literal>scan(String...)</CODE></H4></DIV></DIV></DIV>
<p>Experienced Spring users will be familiar with the 
following commonly-used XML declaration from Spring's <code class=literal>context:</CODE> namespace </P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"com.acme"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>In the example above, the <code class=literal>com.acme</CODE> package will be scanned, looking for any 
<code class=literal>@Component</CODE>-annotated classes, 
and those classes will be registered as Spring bean definitions within the 
container. <code class=literal>AnnotationConfigApplicationContext</CODE> exposes the <code 
class=literal>scan(String...)</CODE> method to allow for 
the same component-scanning functionality:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  AnnotationConfigApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext();
  ctx.scan(<span class=hl-string>"com.acme"</SPAN>);
  ctx.refresh();
  MyService myService = ctx.getBean(MyService.<span class=hl-keyword>class</SPAN>);
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Remember that <code class=literal 
      >@Configuration</CODE> classes are meta-annotated with 
      <code class=literal>@Component</CODE>, so they are 
      candidates for component-scanning! In the example above, assuming that 
      <code class=literal>AppConfig</CODE> is declared 
      within the <code class=literal>com.acme</CODE> 
      package (or any package underneath), it will be picked up during the call 
      to <code class=literal>scan()</CODE>, and upon <code 
      class=literal>refresh()</CODE> all its <code 
      class=literal>@Bean</CODE> methods will be processed 
      and registered as bean definitions within the 
container.</P></TD></TR></TABLE></DIV></DIV>
<div class=section 
title="Support for web applications with AnnotationConfigWebApplicationContext">
<div class=titlepage>
<div>
<div>
<h4 class=title><a 
name=beans-java-instantiating-container-web></A>Support for 
web applications with <code class=literal>AnnotationConfigWebApplicationContext</CODE></H4></DIV></DIV></DIV>
<p>A <code class=literal>WebApplicationContext</CODE> variant of <code class=literal>AnnotationConfigApplicationContext</CODE> is available with 
<code class=literal>AnnotationConfigWebApplicationContext</CODE>. This 
implementation may be used when configuring the Spring <code class=literal>ContextLoaderListener</CODE> servlet listener, Spring MVC 
<code class=literal>DispatcherServlet</CODE>, etc. What 
follows is a <code class=literal>web.xml</CODE> snippet 
that configures a typical Spring MVC web application. Note the use of the <code 
class=literal>contextClass</CODE> context-param and 
init-param: </P><pre class=programlisting><span class=hl-tag>&lt;web-app&gt;</SPAN>
  <span class=hl-comment>&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
       instead of the default XmlWebApplicationContext --&gt;</SPAN>
  <span class=hl-tag>&lt;context-param&gt;</SPAN>
      <span class=hl-tag>&lt;param-name&gt;</SPAN>contextClass<span class=hl-tag>&lt;/param-name&gt;</SPAN>
      <span class=hl-tag>&lt;param-value&gt;</SPAN>
          org.springframework.web.context.support.AnnotationConfigWebApplicationContext
      <span class=hl-tag>&lt;/param-value&gt;</SPAN>
  <span class=hl-tag>&lt;/context-param&gt;</SPAN>

  <span class=hl-comment>&lt;!-- Configuration locations must consist of one or more comma- or space-delimited
       fully-qualified @Configuration classes. Fully-qualified packages may also be
       specified for component-scanning --&gt;</SPAN>
  <span class=hl-tag>&lt;context-param&gt;</SPAN>
      <span class=hl-tag>&lt;param-name&gt;</SPAN>contextConfigLocation<span class=hl-tag>&lt;/param-name&gt;</SPAN>
      <span class=hl-tag>&lt;param-value&gt;</SPAN>com.acme.AppConfig<span class=hl-tag>&lt;/param-value&gt;</SPAN>
  <span class=hl-tag>&lt;/context-param&gt;</SPAN>

  <span class=hl-comment>&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</SPAN>
  <span class=hl-tag>&lt;listener&gt;</SPAN>
      <span class=hl-tag>&lt;listener-class&gt;</SPAN>org.springframework.web.context.ContextLoaderListener<span class=hl-tag>&lt;/listener-class&gt;</SPAN>
  <span class=hl-tag>&lt;/listener&gt;</SPAN>

  <span class=hl-comment>&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</SPAN>
  <span class=hl-tag>&lt;servlet&gt;</SPAN>
      <span class=hl-tag>&lt;servlet-name&gt;</SPAN>dispatcher<span class=hl-tag>&lt;/servlet-name&gt;</SPAN>
      <span class=hl-tag>&lt;servlet-class&gt;</SPAN>org.springframework.web.servlet.DispatcherServlet<span class=hl-tag>&lt;/servlet-class&gt;</SPAN>
      <span class=hl-comment>&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
           instead of the default XmlWebApplicationContext --&gt;</SPAN>
      <span class=hl-tag>&lt;init-param&gt;</SPAN>
          <span class=hl-tag>&lt;param-name&gt;</SPAN>contextClass<span class=hl-tag>&lt;/param-name&gt;</SPAN>
          <span class=hl-tag>&lt;param-value&gt;</SPAN>
              org.springframework.web.context.support.AnnotationConfigWebApplicationContext
          <span class=hl-tag>&lt;/param-value&gt;</SPAN>
      <span class=hl-tag>&lt;/init-param&gt;</SPAN>
      <span class=hl-comment>&lt;!-- Again, config locations must consist of one or more comma- or space-delimited
           and fully-qualified @Configuration classes --&gt;</SPAN>
      <span class=hl-tag>&lt;init-param&gt;</SPAN>
          <span class=hl-tag>&lt;param-name&gt;</SPAN>contextConfigLocation<span class=hl-tag>&lt;/param-name&gt;</SPAN>
          <span class=hl-tag>&lt;param-value&gt;</SPAN>com.acme.web.MvcConfig<span class=hl-tag>&lt;/param-value&gt;</SPAN>
      <span class=hl-tag>&lt;/init-param&gt;</SPAN>
  <span class=hl-tag>&lt;/servlet&gt;</SPAN>

  <span class=hl-comment>&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</SPAN>
  <span class=hl-tag>&lt;servlet-mapping&gt;</SPAN>
      <span class=hl-tag>&lt;servlet-name&gt;</SPAN>dispatcher<span class=hl-tag>&lt;/servlet-name&gt;</SPAN>
      <span class=hl-tag>&lt;url-pattern&gt;</SPAN>/app/*<span class=hl-tag>&lt;/url-pattern&gt;</SPAN>
  <span class=hl-tag>&lt;/servlet-mapping&gt;</SPAN>
<span class=hl-tag>&lt;/web-app&gt;</SPAN></PRE></DIV></DIV>
<div class=section title="5.12.3&nbsp;Composing Java-based configurations">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-java-composing-configuration-classes></A>5.12.3&nbsp;Composing Java-based 
configurations</H3></DIV></DIV></DIV>
<div class=section title="Using the @Import annotation">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-using-import></A>Using the <code class=literal>@Import</CODE> annotation</H4></DIV></DIV></DIV>
<p>Much as the <code class=literal>&lt;import/&gt;</CODE> element is used within Spring XML 
files to aid in modularizing configurations, the <code class=literal>@Import</CODE> annotation allows for loading <code 
class=literal>@Bean</CODE> definitions from another 
configuration class:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ConfigA {
  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> A a() { <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> A(); }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Import(ConfigA.class)</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ConfigB {
  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> B b() { <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> B(); }
}</PRE>
<p>Now, rather than needing to specify both <code 
class=literal>ConfigA.class</CODE> and <code class=literal>ConfigB.class</CODE> when instantiating the context, only 
<code class=literal>ConfigB</CODE> needs to be supplied 
explicitly:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(ConfigB.<span class=hl-keyword>class</SPAN>);

  <span class=hl-comment>// now both beans A and B will be available...</SPAN>
  A a = ctx.getBean(A.<span class=hl-keyword>class</SPAN>);
  B b = ctx.getBean(B.<span class=hl-keyword>class</SPAN>);
}</PRE>
<p>This approach simplifies container instantiation, as 
only one class needs to be dealt with, rather than requiring the developer to 
remember a potentially large number of <code class=literal>@Configuration</CODE> classes during construction.</P>
<div class=section title="Injecting dependencies on imported @Bean definitions">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-injecting-imported-beans></A>Injecting dependencies on imported <code class=literal>@Bean</CODE> definitions</H5></DIV></DIV></DIV>
<p>The example above works, but is simplistic. In most 
practical scenarios, beans will have dependencies on one another across 
configuration classes. When using XML, this is not an issue, per se, because 
there is no compiler involved, and one can simply declare <code class=literal>ref="someBean"</CODE> and trust that Spring will work it 
out during container initialization. Of course, when using <code class=literal>@Configuration</CODE> classes, the Java compiler places 
constraints on the configuration model, in that references to other beans must 
be valid Java syntax.</P>
<p>Fortunately, solving this problem is simple. Remember 
that <code class=literal>@Configuration</CODE> classes are 
ultimately just another bean in the container - this means that they can take 
advantage of <code class=literal>@Autowired</CODE> 
injection metadata just like any other bean!</P>
<p>Let's consider a more real-world scenario with several 
<code class=literal>@Configuration</CODE> classes, each 
depending on beans declared in the others:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ServiceConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I> AccountRepository accountRepository;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> TransferService transferService() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TransferServiceImpl(accountRepository);
  }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> RepositoryConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I> DataSource dataSource;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> AccountRepository accountRepository() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> JdbcAccountRepository(dataSource);
  }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Import({ServiceConfig.class, RepositoryConfig.class})</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SystemTestConfig {
  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> DataSource dataSource() { <span class=hl-comment>/* return new DataSource */</SPAN> }
}

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(SystemTestConfig.<span class=hl-keyword>class</SPAN>);
  <span class=hl-comment>// everything wires up across configuration classes...</SPAN>
  TransferService transferService = ctx.getBean(TransferService.<span class=hl-keyword>class</SPAN>);
  transferService.transfer(<span class=hl-number>100.00</SPAN>, <span class=hl-string>"A123"</SPAN>, <span class=hl-string>"C456"</SPAN>);
}</PRE>
<div class=section 
title="Fully-qualifying imported beans for ease of navigation">
<div class=titlepage>
<div>
<div>
<h6 class=title><a 
name=beans-java-injecting-imported-beans-fq></A>Fully-qualifying imported beans for ease of 
navigation</H6></DIV></DIV></DIV>
<p>In the scenario above, using <code class=literal>@Autowired</CODE> works well and provides the desired 
modularity, but determining exactly where the autowired bean definitions are 
declared is still somewhat ambiguous. For example, as a developer looking at 
<code class=literal>ServiceConfig</CODE>, how do you know 
exactly where the <code class=literal>@Autowired 
AccountRepository</CODE> bean is declared? It's not explicit in the code, and 
this may be just fine. Remember that the <a class=ulink 
href="http://www.springsource.com/products/sts" target=_top>SpringSource Tool Suite</A> provides tooling that can 
render graphs showing how everything is wired up - that may be all you need. 
Also, your Java IDE can easily find all declarations and uses of the <code 
class=literal>AccountRepository</CODE> type, and will 
quickly show you the location of <code class=literal>@Bean</CODE> methods that return that type.</P>
<p>In cases where this ambiguity is not acceptable and you 
wish to have direct navigation from within your IDE from one <code class=literal>@Configuration</CODE> class to another, consider autowiring 
the configuration classes themselves: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ServiceConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I> RepositoryConfig repositoryConfig;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> TransferService transferService() {
      <span class=hl-comment>// navigate 'through' the config class to the @Bean method!</SPAN>
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TransferServiceImpl(repositoryConfig.accountRepository());
  }
}</PRE>
<p>In the situation above, it is completely explicit where 
<code class=literal>AccountRepository</CODE> is defined. 
However, <code class=literal>ServiceConfig</CODE> is now 
tightly coupled to <code class=literal>RepositoryConfig</CODE>; that's the tradeoff. This tight 
coupling can be somewhat mitigated by using interface-based or abstract 
class-based <code class=literal>@Configuration</CODE> 
classes. Consider the following: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> ServiceConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I> RepositoryConfig repositoryConfig;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> TransferService transferService() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TransferServiceImpl(repositoryConfig.accountRepository());
  }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>interface</SPAN> RepositoryConfig {
  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> AccountRepository accountRepository();
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> DefaultRepositoryConfig <span class=hl-keyword>implements</SPAN> RepositoryConfig {
  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> AccountRepository accountRepository() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> JdbcAccountRepository(...);
  }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Import({ServiceConfig.class, DefaultRepositoryConfig.class})</SPAN></I> <span class=hl-comment>// import the concrete config!</SPAN>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> SystemTestConfig {
  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> DataSource dataSource() { <span class=hl-comment>/* return DataSource */</SPAN> }
}

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(SystemTestConfig.<span class=hl-keyword>class</SPAN>);
  TransferService transferService = ctx.getBean(TransferService.<span class=hl-keyword>class</SPAN>);
  transferService.transfer(<span class=hl-number>100.00</SPAN>, <span class=hl-string>"A123"</SPAN>, <span class=hl-string>"C456"</SPAN>);
}</PRE>
<p>Now <code class=literal>ServiceConfig</CODE> is loosely coupled with respect to the 
concrete <code class=literal>DefaultRepositoryConfig</CODE>, and built-in IDE tooling is 
still useful: it will be easy for the developer to get a type hierarchy of <code 
class=literal>RepositoryConfig</CODE> implementations. In 
this way, navigating <code class=literal>@Configuration</CODE> classes and their dependencies 
becomes no different than the usual process of navigating interface-based 
code.</P></DIV></DIV></DIV>
<div class=section title="Combining Java and XML configuration">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-combining></A>Combining Java and XML 
configuration</H4></DIV></DIV></DIV>
<p>Spring's <code class=literal>@Configuration</CODE> class support does not aim to be a 
100% complete replacement for Spring XML. Some facilities such as Spring XML 
namespaces remain an ideal way to configure the container. In cases where XML is 
convenient or necessary, you have a choice: either instantiate the container in 
an "XML-centric" way using, for example, <code class=literal>ClassPathXmlApplicationContext</CODE>, or in a 
"Java-centric" fashion using <code class=literal>AnnotationConfigApplicationContext</CODE> and the <code 
class=literal>@ImportResource</CODE> annotation to import 
XML as needed.</P>
<div class=section title="XML-centric use of @Configuration classes">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-combining-xml-centric></A>XML-centric use of <code class=literal>@Configuration</CODE> classes</H5></DIV></DIV></DIV>
<p>It may be preferable to bootstrap the Spring container 
from XML and include <code class=literal>@Configuration</CODE> classes in an ad-hoc fashion. For 
example, in a large existing codebase that uses Spring XML, it will be easier to 
create <code class=literal>@Configuration</CODE> classes on 
an as-needed basis and include them from the existing XML files. Below you'll 
find the options for using <code class=literal>@Configuration</CODE> classes in this kind of "XML-centric" 
situation.</P>
<div class=section 
title="Declaring @Configuration classes as plain Spring <bean/> elements">
<div class=titlepage>
<div>
<div>
<h6 class=title><a 
name=beans-java-combining-xml-centric-declare-as-bean></A>Declaring <code class=literal>@Configuration</CODE> classes as plain Spring <code 
class=literal>&lt;bean/&gt;</CODE> 
elements</H6></DIV></DIV></DIV>
<p>Remember that <code class=literal>@Configuration</CODE> classes are ultimately just bean 
definitions in the container. In this example, we create a <code class=literal>@Configuration</CODE> class named <code class=literal>AppConfig</CODE> and include it within <code class=literal>system-test-config.xml</CODE> as a <code class=literal>&lt;bean/&gt;</CODE>definition. Because <code class=literal>&lt;context:annotation-config/&gt;</CODE> is switched on, 
the container will recognize the <code class=literal>@Configuration</CODE> annotation, and process the <code 
class=literal>@Bean</CODE> methods declared in <code 
class=literal>AppConfig</CODE> properly.</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Autowired</SPAN></I> DataSource dataSource;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> AccountRepository accountRepository() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> JdbcAccountRepository(dataSource);
  }

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> TransferService transferService() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TransferService(accountRepository());
  }
}</PRE>
<p></P><pre class=programlisting><em class=lineannotation><span class=lineannotation>system-test-config.xml</SPAN></EM>
<span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-comment>&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</SPAN>
  <span class=hl-tag>&lt;context:annotation-config/&gt;</SPAN>
  <span class=hl-tag>&lt;context:property-placeholder</SPAN> <span class=hl-attribute>location</SPAN>=<span class=hl-value>"classpath:/com/acme/jdbc.properties"</SPAN><span class=hl-tag>/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.acme.AppConfig"</SPAN><span class=hl-tag>/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.jdbc.datasource.DriverManagerDataSource"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"url"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.url}"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"username"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.username}"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"password"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.password}"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p></P><pre class=programlisting><em class=lineannotation><span class=lineannotation>jdbc.properties</SPAN></EM>
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</PRE>
<p></P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> ClassPathXmlApplicationContext(<span class=hl-string>"classpath:/com/acme/system-test-config.xml"</SPAN>);
  TransferService transferService = ctx.getBean(TransferService.<span class=hl-keyword>class</SPAN>);
  <span class=hl-comment>// ...</SPAN>
}</PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>In <code class=literal 
      >system-test-config.xml</CODE> above, the <code 
      class=literal>AppConfig&lt;bean/&gt;</CODE> does not 
      declare an <code class=literal>id</CODE> element. 
      While it would be acceptable to do so, it is unnecessary given that no 
      other bean will ever refer to it, and it is unlikely that it will be 
      explicitly fetched from the container by name. Likewise with the <code 
      class=literal>DataSource</CODE> bean - it is only 
      ever autowired by type, so an explicit bean id is not strictly 
      required.</P></TD></TR></TABLE></DIV></DIV>
<div class=section 
title="Using <context:component-scan/> to pick up @Configuration classes">
<div class=titlepage>
<div>
<div>
<h6 class=title><a 
name=beans-java-combining-xml-centric-component-scan></A>Using <code class=literal>&lt;context:component-scan/&gt;</CODE> to pick up <code 
class=literal>@Configuration</CODE> 
classes</H6></DIV></DIV></DIV>
<p>Because <code class=literal>@Configuration</CODE> is meta-annotated with <code 
class=literal>@Component</CODE>, <code class=literal>@Configuration</CODE>-annotated classes are automatically 
candidates for component scanning. Using the same scenario as above, we can 
redefine <code class=literal>system-test-config.xml</CODE> 
to take advantage of component-scanning. Note that in this case, we don't need 
to explicitly declare <code class=literal>&lt;context:annotation-config/&gt;</CODE>, because <code 
class=literal>&lt;context:component-scan/&gt;</CODE> 
enables all the same functionality.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation>system-test-config.xml</SPAN></EM>
<span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-comment>&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</SPAN>
  <span class=hl-tag>&lt;context:component-scan</SPAN> <span class=hl-attribute>base-package</SPAN>=<span class=hl-value>"com.acme"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;context:property-placeholder</SPAN> <span class=hl-attribute>location</SPAN>=<span class=hl-value>"classpath:/com/acme/jdbc.properties"</SPAN><span class=hl-tag>/&gt;</SPAN>

  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.jdbc.datasource.DriverManagerDataSource"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"url"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.url}"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"username"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.username}"</SPAN><span class=hl-tag>/&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"password"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"${jdbc.password}"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE></DIV></DIV>
<div class=section 
title="@Configuration class-centric use of XML with @ImportResource">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-combining-java-centric></A><code class=literal>@Configuration</CODE> class-centric use of XML with <code 
class=literal>@ImportResource</CODE></H5></DIV></DIV></DIV>
<p>In applications where <code class=literal>@Configuration</CODE> classes are the primary mechanism for 
configuring the container, it will still likely be necessary to use at least 
some XML. In these scenarios, simply use <code class=literal>@ImportResource</CODE> and define only as much XML as is 
needed. Doing so achieves a "Java-centric" approach to configuring the container 
and keeps XML to a bare minimum. </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@ImportResource("classpath:/com/acme/properties-config.xml")</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Value("${jdbc.url}")</SPAN></I> String url;
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Value("${jdbc.username}")</SPAN></I> String username;
  <span class=hl-keyword>private</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Value("${jdbc.password}")</SPAN></I> String password;

  <span class=hl-keyword>public</SPAN> <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I> DataSource dataSource() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> DriverManagerDataSource(url, username, password);
  }
}</PRE>
<p></P><pre class=programlisting><em class=lineannotation><span class=lineannotation>properties-config.xml</SPAN></EM>
<span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;context:property-placeholder</SPAN> <span class=hl-attribute>location</SPAN>=<span class=hl-value>"classpath:/com/acme/jdbc.properties"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p></P><pre class=programlisting><em class=lineannotation><span class=lineannotation>jdbc.properties</SPAN></EM>
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</PRE>
<p></P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  ApplicationContext ctx = <span class=hl-keyword>new</SPAN> AnnotationConfigApplicationContext(AppConfig.<span class=hl-keyword>class</SPAN>);
  TransferService transferService = ctx.getBean(TransferService.<span class=hl-keyword>class</SPAN>);
  <span class=hl-comment>// ...</SPAN>
}</PRE></DIV></DIV></DIV>
<div class=section title="5.12.4&nbsp;Using the @Bean annotation">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-java-bean-annotation></A>5.12.4&nbsp;Using the <code class=interfacename>@Bean</CODE> annotation</H3></DIV></DIV></DIV>
<p><code class=interfacename>@Bean</CODE> is a method-level annotation and a direct 
analog of the XML <code class=code>&lt;bean/&gt;</CODE> 
element. The annotation supports some of the attributes offered by <code 
class=code>&lt;bean/&gt;</CODE>, such as: <code class=code><A class=link title="Initialization callbacks" href="beans.html#beans-factory-lifecycle-initializingbean" >init-method</A></CODE>, 
<code class=code><A class=link title="Destruction callbacks" href="beans.html#beans-factory-lifecycle-disposablebean" >destroy-method</A></CODE>, 
<code class=code><A class=link title="5.4.5&nbsp;Autowiring collaborators" href="beans.html#beans-factory-autowire" >autowiring</A></CODE> and 
<code class=code>name</CODE>.</P>
<p>You can use the <code class=interfacename>@Bean</CODE> annotation in a <code class=interfacename>@Configuration</CODE>-annotated or in a <code 
class=interfacename>@Component</CODE>-annotated class.</P>
<div class=section title="Declaring a bean">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-declaring-a-bean></A>Declaring a bean</H4></DIV></DIV></DIV>
<p>To declare a bean, simply annotate a method with the 
<code class=interfacename>@Bean</CODE> annotation. You use 
this method to register a bean definition within an <code class=code>ApplicationContext</CODE> of the type specified as the 
method's return value. By default, the bean name will be the same as the method 
name. The following is a simple example of a <code class=interfacename>@Bean</CODE> method declaration: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> TransferService transferService() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> TransferServiceImpl();
  }

}</PRE>
<p>The preceding configuration is exactly equivalent to the 
following Spring XML: </P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"transferService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.acme.TransferServiceImpl"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN>                </PRE>
<p>Both declarations make a bean named <code class=code>transferService</CODE> available in the <code class=code>ApplicationContext</CODE>, bound to an object instance of 
type <code class=code>TransferServiceImpl</CODE>: </P><pre class=programlisting>transferService -&gt; com.acme.TransferServiceImpl
              </PRE></DIV>
<div class=section title="Injecting dependencies">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-injecting-dependencies></A>Injecting dependencies</H4></DIV></DIV></DIV>
<p>When <code class=interfacename>@Bean</CODE>s have dependencies on one another, expressing 
that dependency is as simple as having one bean method call another: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> Foo foo() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> Foo(bar());
  }

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> Bar bar() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> Bar();
  }

}                </PRE>
<p>In the example above, the <code class=code>foo</CODE> bean receives a reference to <code class=code>bar</CODE> via constructor injection.</P></DIV>
<div class=section title="Receiving lifecycle callbacks">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-lifecycle-callbacks></A>Receiving lifecycle callbacks</H4></DIV></DIV></DIV>
<p>Beans declared in a <code class=interfacename>@Configuration</CODE>-annotated class support the regular 
lifecycle callbacks. Any classes defined with the <code class=literal>@Bean</CODE> annotation can use the <code class=literal>@PostConstruct</CODE> and <code class=literal>@PreDestroy</CODE> annotations from JSR-250, see <A class=link title="5.9.6&nbsp;@PostConstruct and @PreDestroy" href="beans.html#beans-postconstruct-and-predestroy-annotations" >JSR-250 
annotations</A> for further details.</P>
<p>The regular Spring <A class=link title="5.6&nbsp;Customizing the nature of a bean" href="beans.html#beans-factory-nature" >lifecycle</A> callbacks are 
fully supported as well. If a bean implements <code class=code>InitializingBean</CODE>, <code class=code>DisposableBean</CODE>, or <code class=code>Lifecycle</CODE>, their respective methods are called by 
the container.</P>
<p>The standard set of <code class=code>*Aware</CODE> interfaces such as <code class=code><A class=link title="5.15&nbsp;The BeanFactory" href="beans.html#beans-beanfactory" >BeanFactoryAware</A></CODE>, <code 
class=code><A class=link title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >BeanNameAware</A></CODE>, <code 
class=code><A class=link title="5.14.1&nbsp;Internationalization using MessageSource" href="beans.html#context-functionality-messagesource" >MessageSourceAware</A></CODE>, 
<code class=code><A class=link title="5.6.2&nbsp;ApplicationContextAware and BeanNameAware" href="beans.html#beans-factory-aware" >ApplicationContextAware</A></CODE>, 
and so on are also fully supported.</P>
<p>The <code class=interfacename>@Bean</CODE> annotation supports specifying arbitrary 
initialization and destruction callback methods, much like Spring XML's <code 
class=code>init-method</CODE> and <code class=code>destroy-method</CODE> attributes on the <code class=code>bean</CODE> element: </P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> Foo {
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> init() {
      <span class=hl-comment>// initialization logic</SPAN>
  }
}

<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> Bar {
  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> cleanup() {
      <span class=hl-comment>// destruction logic</SPAN>
  }
}

<i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {
  <i><span style="COLOR: gray" class=hl-annotation>@Bean(initMethod = "init")</SPAN></I>
  <span class=hl-keyword>public</SPAN> Foo foo() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> Foo();
  }
  <i><span style="COLOR: gray" class=hl-annotation>@Bean(destroyMethod = "cleanup")</SPAN></I>
  <span class=hl-keyword>public</SPAN> Bar bar() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> Bar();
  }
}
</PRE>
<p>Of course, in the case of <code class=code>Foo</CODE> above, it would be equally as valid to call the 
<code class=code>init()</CODE> method directly during 
construction: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {
  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> Foo foo() {
      Foo foo = <span class=hl-keyword>new</SPAN> Foo();
      foo.init();
      <span class=hl-keyword>return</SPAN> foo;
  }

  <span class=hl-comment>// ...</SPAN>
}                    </PRE>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=tip title=Tip>
<table border=0 summary=Tip>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Tip] src="images/tip.png" ></TD>
    <th align=left>Tip</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>When you work directly in Java, you can do 
      anything you like with your objects and do not always need to rely on the 
      container lifecycle!</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="Specifying bean scope">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-specifying-bean-scope></A>Specifying bean scope</H4></DIV></DIV></DIV>
<div class=section title="Using the @Scope annotation">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-available-scopes></A>Using the <code class=interfacename>@Scope</CODE> annotation</H5></DIV></DIV></DIV>
<p>You can specify that your beans defined with the <code 
class=interfacename>@Bean</CODE> annotation should have a 
specific scope. You can use any of the standard scopes specified in the <A class=link title="5.5&nbsp;Bean scopes" href="beans.html#beans-factory-scopes" >Bean 
Scopes</A> section.</P>
<p>The default scope is <code class=literal>singleton</CODE>, but you can override this with the <code 
class=interfacename>@Scope</CODE> annotation: </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> MyConfiguration {
  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=bold><strong>@Scope("prototype")</STRONG></SPAN>
  <span class=hl-keyword>public</SPAN> Encryptor encryptor() {
      <span class=hl-comment>// ...</SPAN>
  }
}</PRE></DIV>
<div class=section title="@Scope and scoped-proxy">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-scoped-proxy></A><code class=code>@Scope and 
scoped-proxy</CODE></H5></DIV></DIV></DIV>
<p>Spring offers a convenient way of working with scoped 
dependencies through <A class=link title="Scoped beans as dependencies" href="beans.html#beans-factory-scopes-other-injection" >scoped 
proxies</A>. The easiest way to create such a proxy when using the XML 
configuration is the <code class=code>&lt;aop:scoped-proxy/&gt;</CODE> element. Configuring your 
beans in Java with a @Scope annotation offers equivalent support with the 
proxyMode attribute. The default is no proxy (<code class=varname>ScopedProxyMode.NO</CODE>), but you can specify <code 
class=classname>ScopedProxyMode.TARGET_CLASS</CODE> or 
<code class=classname>ScopedProxyMode.INTERFACES</CODE>.</P>
<p>If you port the scoped proxy example from the XML 
reference documentation (see preceding link) to our <code class=interfacename>@Bean</CODE> using Java, it would look like the following: 
</P><pre class=programlisting><span class=hl-comment>// an HTTP Session-scoped bean exposed as a proxy</SPAN>
<i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
<span class=bold><strong>@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)</STRONG></SPAN>
<span class=hl-keyword>public</SPAN> UserPreferences userPreferences() {
 <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> UserPreferences();
}

<i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
<span class=hl-keyword>public</SPAN> Service userService() {
 UserService service = <span class=hl-keyword>new</SPAN> SimpleUserService();
 <span class=hl-comment>// a reference to the proxied userPreferences bean</SPAN>
 service.setUserPreferences(userPreferences());
 <span class=hl-keyword>return</SPAN> service;
}                </PRE></DIV>
<div class=section title="Lookup method injection">
<div class=titlepage>
<div>
<div>
<h5 class=title><a name=beans-java-method-injection></A>Lookup method injection</H5></DIV></DIV></DIV>
<p>As noted earlier, <A class=link title="5.4.6&nbsp;Method injection" href="beans.html#beans-factory-method-injection" >lookup method 
injection</A> is an advanced feature that you should use rarely. It is useful in 
cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. 
Using Java for this type of configuration provides a natural means for 
implementing this pattern. </P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>abstract</SPAN> <span class=hl-keyword>class</SPAN> CommandManager {
  <span class=hl-keyword>public</SPAN> Object process(Object commandState) {
      <span class=hl-comment>// grab a new instance of the appropriate Command interface</SPAN>
      Command command = createCommand();

      <span class=hl-comment>// set the state on the (hopefully brand new) Command instance</SPAN>
      command.setState(commandState);
      <span class=hl-keyword>return</SPAN> command.execute();
  }

  <span class=hl-comment>// okay... but where is the implementation of this method?</SPAN>
  <span class=hl-keyword>protected</SPAN> <span class=hl-keyword>abstract</SPAN> Command createCommand();
}                   </PRE>
<p>Using Java-configuration support , you can create a 
subclass of <code class=code>CommandManager</CODE> where 
the abstract <code class=code>createCommand()</CODE> method 
is overridden in such a way that it looks up a new (prototype) command object: 
</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@Scope("prototype")</SPAN></I>
<span class=hl-keyword>public</SPAN> AsyncCommand asyncCommand() {
  AsyncCommand command = <span class=hl-keyword>new</SPAN> AsyncCommand();
  <span class=hl-comment>// inject dependencies here as required</SPAN>
  <span class=hl-keyword>return</SPAN> command;
}

<i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
<span class=hl-keyword>public</SPAN> CommandManager commandManager() {
  <span class=hl-comment>// return new anonymous implementation of CommandManager with command() overridden</SPAN>
  <span class=hl-comment>// to return a new prototype Command object</SPAN>
  <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> CommandManager() {
      <span class=hl-keyword>protected</SPAN> Command createCommand() {
          <span class=hl-keyword>return</SPAN> asyncCommand();
      }
  }
}                    </PRE></DIV></DIV>
<div class=section title="Customizing bean naming">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-customizing-bean-naming></A>Customizing bean naming</H4></DIV></DIV></DIV>
<p>By default, configuration classes use a <code 
class=interfacename>@Bean</CODE> method's name as the name 
of the resulting bean. This functionality can be overridden, however, with the 
<code class=code>name</CODE> attribute. </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean(name = "myFoo")</SPAN></I>
  <span class=hl-keyword>public</SPAN> Foo foo() {
      <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> Foo();
  }

}        </PRE></DIV>
<div class=section title="Bean aliasing">
<div class=titlepage>
<div>
<div>
<h4 class=title><a name=beans-java-bean-aliasing></A>Bean aliasing</H4></DIV></DIV></DIV>
<p>As discussed in <A class=xref title="5.3.1&nbsp;Naming beans" href="beans.html#beans-beanname" >Section&nbsp;5.3.1, “Naming 
beans”</A>, it is sometimes desirable to give a single bean multiple names, 
otherwise known as <span class=emphasis><em>bean aliasing</EM></SPAN>. The <code class=literal>name</CODE> attribute of the <code class=literal>@Bean</CODE> annotation accepts a String array for this 
purpose. </P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })</SPAN></I>
  <span class=hl-keyword>public</SPAN> DataSource dataSource() {
      <span class=hl-comment>// instantiate, configure and return DataSource bean...</SPAN>
  }

}        </PRE></DIV></DIV>
<div class=section 
title="5.12.5&nbsp;Further information about how Java-based configuration works internally">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=beans-java-further-information-java-config></A>5.12.5&nbsp;Further information about how Java-based 
configuration works internally</H3></DIV></DIV></DIV>
<p>The following example shows a <code class=literal>@Bean</CODE> annotated method being called twice:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> ClientService clientService1() {
    ClientServiceImpl clientService = <span class=hl-keyword>new</SPAN> ClientServiceImpl();
    clientService.setClientDao(clientDao());
    <span class=hl-keyword>return</SPAN> clientService;
  }
  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> ClientService clientService2() {
    ClientServiceImpl clientService = <span class=hl-keyword>new</SPAN> ClientServiceImpl();
    clientService.setClientDao(clientDao());
    <span class=hl-keyword>return</SPAN> clientService;
  }

  <i><span style="COLOR: gray" class=hl-annotation>@Bean</SPAN></I>
  <span class=hl-keyword>public</SPAN> ClientDao clientDao() {
    <span class=hl-keyword>return</SPAN> <span class=hl-keyword>new</SPAN> ClientDaoImpl();
  }
}
    </PRE>
<p><code class=methodname>clientDao()</CODE> has been called once in <code 
class=methodname>clientService1()</CODE> and once in <code 
class=methodname>clientService2()</CODE>. Since this method 
creates a new instance of <code class=classname>ClientDaoImpl</CODE> and returns it, you would normally 
expect having 2 instances (one for each service). That definitely would be 
problematic: in Spring, instantiated beans have a <code class=literal>singleton</CODE> scope by default. This is where the magic 
comes in: All <code class=literal>@Configuration</CODE> 
classes are subclassed at startup-time with <code class=literal>CGLIB</CODE>. In the subclass, the child method checks the 
container first for any cached (scoped) beans before it calls the parent method 
and creates a new instance. Note that as of Spring 3.2, it is no longer 
necessary to add CGLIB to your classpath because CGLIB classes have been 
repackaged under org.springframework and included directly within the 
spring-core JAR.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>The behavior could be different according to the 
      scope of your bean. We are talking about singletons here. 
  </P></TD></TR></TABLE></DIV>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>There are a few restrictions due to the fact that 
      CGLIB dynamically adds features at startup-time: </P>
      <div class=itemizedlist>
      <ul class=itemizedlist type=disc>
        <li class=listitem>
        <p>Configuration classes should not be final</P>
        <li class=listitem>
        <p>They should have a constructor with no 
        arguments</P></LI></UL></DIV>
      <p></P></TD></TR></TABLE></DIV></DIV></DIV>
<div class=section title="5.13&nbsp;Registering a LoadTimeWeaver">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=context-load-time-weaver></A>5.13&nbsp;Registering a 
<code class=interfacename>LoadTimeWeaver</CODE></H2></DIV></DIV></DIV>
<p>The <code class=interfacename>LoadTimeWeaver</CODE> is used by Spring to dynamically 
transform classes as they are loaded into the Java virtual machine (JVM).</P>
<p>To enable load-time weaving add the <code 
class=interfacename>@EnableLoadTimeWeaving</CODE> to one of 
your <code class=interfacename>@Configuration</CODE> 
classes:</P><pre class=programlisting><i><span style="COLOR: gray" class=hl-annotation>@Configuration</SPAN></I>
<i><span style="COLOR: gray" class=hl-annotation>@EnableLoadTimeWeaving</SPAN></I>
<span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> AppConfig {

}</PRE>
<p>Alternatively for XML configuration use the <code 
class=literal>context:load-time-weaver</CODE> element:</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
     <span class=hl-tag>&lt;context:load-time-weaver/&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>Once configured for the <code class=interfacename>ApplicationContext</CODE>. Any bean within that <code 
class=interfacename>ApplicationContext</CODE> may implement 
<code class=interfacename>LoadTimeWeaverAware</CODE>, 
thereby receiving a reference to the load-time weaver instance. This is 
particularly useful in combination with <A class=link title=15.5&nbsp;JPA href="orm.html#orm-jpa" >Spring's JPA support</A> where load-time 
weaving may be necessary for JPA class transformation. Consult the <code 
class=classname>LocalContainerEntityManagerFactoryBean</CODE> Javadoc for 
more detail. For more on AspectJ load-time weaving, see <A class=xref title="9.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework" href="aop.html#aop-aj-ltw" >Section&nbsp;9.8.4, “Load-time weaving with 
AspectJ in the Spring Framework”</A>.</P></DIV>
<div class=section 
title="5.14&nbsp;Additional Capabilities of the ApplicationContext">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=context-introduction></A>5.14&nbsp;Additional 
Capabilities of the <code class=interfacename>ApplicationContext</CODE></H2></DIV></DIV></DIV>
<p>As was discussed in the chapter introduction, the <code 
class=literal>org.springframework.beans.factory</CODE> 
package provides basic functionality for managing and manipulating beans, 
including in a programmatic way. The <code class=literal>org.springframework.context</CODE> package adds the <a 
class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html" 
target=_top><code class=interfacename>ApplicationContext</CODE></A> interface, which extends the 
<code class=interfacename>BeanFactory</CODE> interface, in 
addition to extending other interfaces to provide additional functionality in a 
more <span class=emphasis><em>application framework-oriented style</EM></SPAN>. Many 
people use the <code class=interfacename>ApplicationContext</CODE> in a completely declarative 
fashion, not even creating it programmatically, but instead relying on support 
classes such as <code class=classname>ContextLoader</CODE> 
to automatically instantiate an <code class=interfacename>ApplicationContext</CODE> as part of the normal startup 
process of a J2EE web application.</P>
<p>To enhance <code class=interfacename>BeanFactory</CODE> functionality in a more 
framework-oriented style the context package also provides the following 
functionality:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><span class=emphasis><em 
  >Access to messages in i18n-style</EM></SPAN>, through the 
  <code class=interfacename>MessageSource</CODE> 
  interface.</P>
  <li class=listitem>
  <p><span class=emphasis><em 
  >Access to resources</EM></SPAN>, such as URLs and files, 
  through the <code class=interfacename 
  >ResourceLoader</CODE> interface.</P>
  <li class=listitem>
  <p><span class=emphasis><em 
  >Event publication</EM></SPAN> to beans implementing the 
  <code class=interfacename>ApplicationListener</CODE> 
  interface, through the use of the <code class=interfacename 
  >ApplicationEventPublisher</CODE> interface.</P>
  <li class=listitem>
  <p><span class=emphasis><em 
  >Loading of multiple (hierarchical) contexts</EM></SPAN>, 
  allowing each to be focused on one particular layer, such as the web layer of 
  an application, through the <code class=interfacename 
  >HierarchicalBeanFactory</CODE> 
interface.</P></LI></UL></DIV>
<div class=section title="5.14.1&nbsp;Internationalization using MessageSource">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=context-functionality-messagesource></A>5.14.1&nbsp;Internationalization using <code 
class=interfacename>MessageSource</CODE></H3></DIV></DIV></DIV>
<p>The <code class=interfacename>ApplicationContext</CODE> interface extends an interface 
called <code class=interfacename>MessageSource</CODE>, and 
therefore provides internationalization (i18n) functionality. Spring also 
provides the interface <code class=classname>HierarchicalMessageSource</CODE>, which can resolve 
messages hierarchically. Together these interfaces provide the foundation upon 
which Spring effects message resolution. The methods defined on these interfaces 
include:</P>
<div class=itemizedlist>
<ul class=itemizedlist type=disc>
  <li class=listitem>
  <p><code class=methodname>String 
  getMessage(String code, Object[] args, String default, Locale loc)</CODE>: The 
  basic method used to retrieve a message from the <code class=interfacename 
  >MessageSource</CODE>. When no message is found for the 
  specified locale, the default message is used. Any arguments passed in become 
  replacement values, using the <code class=interfacename 
  >MessageFormat</CODE> functionality provided by the 
  standard library.</P>
  <li class=listitem>
  <p><code class=methodname>String 
  getMessage(String code, Object[] args, Locale loc)</CODE>: Essentially the 
  same as the previous method, but with one difference: no default message can 
  be specified; if the message cannot be found, a <code class=classname 
  >NoSuchMessageException</CODE> is thrown.</P>
  <li class=listitem>
  <p><code class=methodname>String 
  getMessage(MessageSourceResolvable resolvable, Locale locale)</CODE>: All 
  properties used in the preceding methods are also wrapped in a class named 
  <code class=interfacename>MessageSourceResolvable</CODE>, 
  which you can use with this method.</P></LI></UL></DIV>
<p>When an <code class=interfacename>ApplicationContext</CODE> is loaded, it automatically 
searches for a <code class=interfacename>MessageSource</CODE> bean defined in the context. The bean 
must have the name <code class=literal>messageSource</CODE>. If such a bean is found, all calls to 
the preceding methods are delegated to the message source. If no message source 
is found, the <code class=interfacename>ApplicationContext</CODE> attempts to find a parent 
containing a bean with the same name. If it does, it uses that bean as the <code 
class=interfacename>MessageSource</CODE>. If the <code 
class=interfacename>ApplicationContext</CODE> cannot find 
any source for messages, an empty <code class=classname>DelegatingMessageSource</CODE> is instantiated in order to 
be able to accept calls to the methods defined above.</P>
<p>Spring provides two <code class=interfacename>MessageSource</CODE> implementations, <code class=classname>ResourceBundleMessageSource</CODE> and <code 
class=classname>StaticMessageSource</CODE>. Both implement 
<code class=interfacename>HierarchicalMessageSource</CODE> 
in order to do nested messaging. The <code class=classname>StaticMessageSource</CODE> is rarely used but provides 
programmatic ways to add messages to the source. The <code class=classname>ResourceBundleMessageSource</CODE> is shown in the 
following example:</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>
<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"messageSource"</SPAN>
      <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.context.support.ResourceBundleMessageSource"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"basenames"</SPAN><span class=hl-tag>&gt;</SPAN>
    <span class=hl-tag>&lt;list&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>format<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>exceptions<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;value&gt;</SPAN>windows<span class=hl-tag>&lt;/value&gt;</SPAN>
    <span class=hl-tag>&lt;/list&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>
<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE>
<p>In the example it is assumed you have three resource 
bundles defined in your classpath called <code class=literal>format</CODE>, <code class=literal>exceptions</CODE> and <code class=literal>windows</CODE>. Any request to resolve a message will be 
handled in the JDK standard way of resolving messages through ResourceBundles. 
For the purposes of the example, assume the contents of two of the above 
resource bundle files are...</P><pre class=programlisting><em class=lineannotation><span class=lineannotation># in format.properties</SPAN></EM>
message=Alligators rock!</PRE><pre class=programlisting><em class=lineannotation><span class=lineannotation># in exceptions.properties</SPAN></EM>
argument.required=The <span class=hl-string>'{0}'</SPAN> argument is required.</PRE>
<p>A program to execute the <code class=classname>MessageSource</CODE> functionality is shown in the next 
example. Remember that all <code class=classname>ApplicationContext</CODE> implementations are also <code 
class=classname>MessageSource</CODE> implementations and so 
can be cast to the <code class=classname>MessageSource</CODE> interface.</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(String[] args) {
  MessageSource resources = <span class=hl-keyword>new</SPAN> ClassPathXmlApplicationContext(<span class=hl-string>"beans.xml"</SPAN>);
  String message = resources.getMessage(<span class=hl-string>"message"</SPAN>, null, <span class=hl-string>"Default"</SPAN>, null);
  System.out.println(message);
}</PRE>
<p>The resulting output from the above program will 
be...</P><pre class=programlisting>Alligators rock!</PRE>
<p>So to summarize, the <code class=classname>MessageSource</CODE> is defined in a file called <code 
class=literal>beans.xml</CODE>, which exists at the root of 
your classpath. The <code class=literal>messageSource</CODE> bean definition refers to a number of 
resource bundles through its <code class=literal>basenames</CODE> property. The three files that are passed 
in the list to the <code class=literal>basenames</CODE> 
property exist as files at the root of your classpath and are called <code 
class=literal>format.properties</CODE>, <code class=literal>exceptions.properties</CODE>, and <code class=literal>windows.properties</CODE> respectively.</P>
<p>The next example shows arguments passed to the message 
lookup; these arguments will be converted into Strings and inserted into 
placeholders in the lookup message.</P><pre class=programlisting><span class=hl-tag>&lt;beans&gt;</SPAN>

  <em class=lineannotation><span class=lineannotation>&lt;!-- this MessageSource is being used in a web application --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"messageSource"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"org.springframework.context.support.ResourceBundleMessageSource"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"basename"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"exceptions"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

  <em class=lineannotation><span class=lineannotation>&lt;!-- lets inject the above MessageSource into this POJO --&gt;</SPAN></EM>
  <span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"example"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"com.foo.Example"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"messages"</SPAN> <span class=hl-attribute>ref</SPAN>=<span class=hl-value>"messageSource"</SPAN><span class=hl-tag>/&gt;</SPAN>
  <span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;/beans&gt;</SPAN></PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> Example {

  <span class=hl-keyword>private</SPAN> MessageSource messages;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setMessages(MessageSource messages) {
      <span class=hl-keyword>this</SPAN>.messages = messages;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> execute() {
      String message = <span class=hl-keyword>this</SPAN>.messages.getMessage(<span class=hl-string>"argument.required"</SPAN>,
          <span class=hl-keyword>new</SPAN> Object [] {<span class=hl-string>"userDao"</SPAN>}, <span class=hl-string>"Required"</SPAN>, null);
      System.out.println(message);
  }

}</PRE>
<p>The resulting output from the invocation of the <code 
class=methodname>execute()</CODE> method will be...</P><pre class=programlisting>The userDao argument is required.</PRE>
<p>With regard to internationalization (i18n), Spring's 
various <code class=classname>MessageResource</CODE> 
implementations follow the same locale resolution and fallback rules as the 
standard JDK <code class=classname>ResourceBundle</CODE>. 
In short, and continuing with the example <code class=literal>messageSource</CODE> defined previously, if you want to 
resolve messages against the British (en-GB) locale, you would create files 
called <code class=literal>format_en_GB.properties</CODE>, 
<code class=literal>exceptions_en_GB.properties</CODE>, and 
<code class=literal>windows_en_GB.properties</CODE> 
respectively.</P>
<p>Typically, locale resolution is managed by the 
surrounding environment of the application. In this example, the locale against 
which (British) messages will be resolved is specified manually.</P><pre class=programlisting><em class=lineannotation><span class=lineannotation># in exceptions_en_GB.properties</SPAN></EM>
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.</PRE><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>static</SPAN> <span class=hl-keyword>void</SPAN> main(<span class=hl-keyword>final</SPAN> String[] args) {
  MessageSource resources = <span class=hl-keyword>new</SPAN> ClassPathXmlApplicationContext(<span class=hl-string>"beans.xml"</SPAN>);
  String message = resources.getMessage(<span class=hl-string>"argument.required"</SPAN>,
      <span class=hl-keyword>new</SPAN> Object [] {<span class=hl-string>"userDao"</SPAN>}, <span class=hl-string>"Required"</SPAN>, Locale.UK);
  System.out.println(message);
}</PRE>
<p>The resulting output from the running of the above 
program will be...</P><pre class=programlisting>Ebagum lad, the 'userDao' argument is required, I say, required.</PRE>
<p>You can also use the <code class=classname>MessageSourceAware</CODE> interface to acquire a reference 
to any <code class=classname>MessageSource</CODE> that has 
been defined. Any bean that is defined in an <code class=classname>ApplicationContext</CODE> that implements the <code 
class=classname>MessageSourceAware</CODE> interface is 
injected with the application context's <code class=classname>MessageSource</CODE> when the bean is created and 
configured.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p><span class=emphasis><em 
      >As an alternative to <code class=classname 
      >ResourceBundleMessageSource</CODE>, Spring provides a 
      <code class=classname 
      >ReloadableResourceBundleMessageSource</CODE> class. 
      This variant supports the same bundle file format but is more flexible 
      than the standard JDK based <code class=classname 
      >ResourceBundleMessageSource</CODE> 
      implementation.</EM></SPAN> In particular, it allows for reading files 
      from any Spring resource location (not just from the classpath) and 
      supports hot reloading of bundle property files (while efficiently caching 
      them in between). Check out the <code class=classname 
      >ReloadableResourceBundleMessageSource</CODE> javadoc 
      for details.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.14.2&nbsp;Standard and Custom Events">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=context-functionality-events></A>5.14.2&nbsp;Standard and Custom 
Events</H3></DIV></DIV></DIV>
<p>Event handling in the <code class=interfacename>ApplicationContext</CODE> is provided through the <code 
class=classname>ApplicationEvent</CODE> class and <code 
class=interfacename>ApplicationListener</CODE> interface. 
If a bean that implements the <code class=interfacename>ApplicationListener</CODE> interface is deployed into the 
context, every time an <code class=classname>ApplicationEvent</CODE> gets published to the <code 
class=interfacename>ApplicationContext</CODE>, that bean is 
notified. Essentially, this is the standard <span class=emphasis><em>Observer</EM></SPAN> design 
pattern. Spring provides the following standard events:</P>
<div class=table><a name=beans-ctx-events-tbl></A>
<p class=title><b>Table&nbsp;5.7.&nbsp;Built-in Events</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Built-in Events">
  <colgroup>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    >Event</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid" 
  >Explanation</TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=classname 
      >ContextRefreshedEvent</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">Published when 
      the <code class=interfacename 
      >ApplicationContext</CODE> is initialized or 
      refreshed, for example, using the <code class=methodname 
      >refresh()</CODE> method on the <code 
      class=interfacename 
      >ConfigurableApplicationContext</CODE> interface. 
      "Initialized" here means that all beans are loaded, post-processor beans 
      are detected and activated, singletons are pre-instantiated, and the <code 
      class=interfacename>ApplicationContext</CODE> object 
      is ready for use. As long as the context has not been closed, a refresh 
      can be triggered multiple times, provided that the chosen <code 
      class=interfacename>ApplicationContext</CODE> 
      actually supports such "hot" refreshes. For example, <code class=classname 
      >XmlWebApplicationContext</CODE> supports hot 
      refreshes, but <code class=classname 
      >GenericApplicationContext</CODE> does not.</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=classname 
      >ContextStartedEvent</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">Published when 
      the <code class=interfacename 
      >ApplicationContext</CODE> is started, using the <code 
      class=methodname>start()</CODE> method on the <code 
      class=interfacename 
      >ConfigurableApplicationContext</CODE> interface. 
      "Started" here means that all <code class=interfacename 
      >Lifecycle</CODE> beans receive an explicit start 
      signal. Typically this signal is used to restart beans after an explicit 
      stop, but it may also be used to start components that have not been 
      configured for autostart , for example, components that have not already 
      started on initialization.</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=classname 
      >ContextStoppedEvent</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">Published when 
      the <code class=interfacename 
      >ApplicationContext</CODE> is stopped, using the <code 
      class=methodname>stop()</CODE> method on the <code 
      class=interfacename 
      >ConfigurableApplicationContext</CODE> interface. 
      "Stopped" here means that all <code class=interfacename 
      >Lifecycle</CODE> beans receive an explicit stop 
      signal. A stopped context may be restarted through a <code 
      class=methodname>start()</CODE> call.</TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    ><code class=classname 
      >ContextClosedEvent</CODE></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid">Published when 
      the <code class=interfacename 
      >ApplicationContext</CODE> is closed, using the <code 
      class=methodname>close()</CODE> method on the <code 
      class=interfacename 
      >ConfigurableApplicationContext</CODE> interface. 
      "Closed" here means that all singleton beans are destroyed. A closed 
      context reaches its end of life; it cannot be refreshed or 
restarted.</TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid"><code 
      class=classname>RequestHandledEvent</CODE></TD>
    <td>A web-specific event telling all beans that an 
      HTTP request has been serviced. This event is published <span 
      class=emphasis><em 
      >after</EM></SPAN> the request is complete. This event 
      is only applicable to web applications using Spring's <code 
      class=classname 
  >DispatcherServlet</CODE>.</TD></TR></TBODY></TABLE></DIV></DIV><br 
class=table-break>
<p>You can also create and publish your own custom events. 
This example demonstrates a simple class that extends Spring's <code 
class=classname>ApplicationEvent</CODE> base class:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> BlackListEvent <span class=hl-keyword>extends</SPAN> ApplicationEvent {
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>final</SPAN> String address;
  <span class=hl-keyword>private</SPAN> <span class=hl-keyword>final</SPAN> String test;

  <span class=hl-keyword>public</SPAN> BlackListEvent(Object source, String address, String test) {
      <span class=hl-keyword>super</SPAN>(source);
      <span class=hl-keyword>this</SPAN>.address = address;
      <span class=hl-keyword>this</SPAN>.test = test;
  }

  <em class=lineannotation><span class=lineannotation>// accessor and other methods...</SPAN></EM>
}</PRE>
<p>To publish a custom <code class=classname>ApplicationEvent</CODE>, call the <code class=methodname>publishEvent()</CODE> method on an <code 
class=interfacename>ApplicationEventPublisher</CODE>. 
Typically this is done by creating a class that implements <code 
class=interfacename>ApplicationEventPublisherAware</CODE> 
and registering it as a Spring bean. The following example demonstrates such a 
class:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> EmailService <span class=hl-keyword>implements</SPAN> ApplicationEventPublisherAware {

  <span class=hl-keyword>private</SPAN> List&lt;String&gt; blackList;
  <span class=hl-keyword>private</SPAN> ApplicationEventPublisher publisher;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setBlackList(List&lt;String&gt; blackList) {
      <span class=hl-keyword>this</SPAN>.blackList = blackList;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setApplicationEventPublisher(ApplicationEventPublisher publisher) {
      <span class=hl-keyword>this</SPAN>.publisher = publisher;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> sendEmail(String address, String text) {
      <span class=hl-keyword>if</SPAN> (blackList.contains(address)) {
          BlackListEvent event = <span class=hl-keyword>new</SPAN> BlackListEvent(<span class=hl-keyword>this</SPAN>, address, text);
          publisher.publishEvent(event);
          <span class=hl-keyword>return</SPAN>;
      }
      <em class=lineannotation><span class=lineannotation>// send email...</SPAN></EM>
  }
}</PRE>
<p>At configuration time, the Spring container will detect 
that <code class=classname>EmailService</CODE> implements 
<code class=interfacename>ApplicationEventPublisherAware</CODE> and will 
automatically call <code class=methodname>setApplicationEventPublisher()</CODE>. In reality, the 
parameter passed in will be the Spring container itself; you're simply 
interacting with the application context via its <code class=interfacename>ApplicationEventPublisher</CODE> interface.</P>
<p>To receive the custom <code class=classname>ApplicationEvent</CODE>, create a class that implements 
<code class=interfacename>ApplicationListener</CODE> and 
register it as a Spring bean. The following example demonstrates such a 
class:</P><pre class=programlisting><span class=hl-keyword>public</SPAN> <span class=hl-keyword>class</SPAN> BlackListNotifier <span class=hl-keyword>implements</SPAN> ApplicationListener&lt;BlackListEvent&gt; {

  <span class=hl-keyword>private</SPAN> String notificationAddress;

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> setNotificationAddress(String notificationAddress) {
      <span class=hl-keyword>this</SPAN>.notificationAddress = notificationAddress;
  }

  <span class=hl-keyword>public</SPAN> <span class=hl-keyword>void</SPAN> onApplicationEvent(BlackListEvent event) {
<em class=lineannotation><span class=lineannotation>        // notify appropriate parties via notificationAddress...</SPAN></EM>
  }
}</PRE>
<p>Notice that <code class=interfacename>ApplicationListener</CODE> is generically parameterized 
with the type of your custom event, <code class=classname>BlackListEvent</CODE>. This means that the <code 
class=methodname>onApplicationEvent()</CODE> method can 
remain type-safe, avoiding any need for downcasting. You may register as many 
event listeners as you wish, but note that by default event listeners receive 
events synchronously. This means the <code class=methodname>publishEvent()</CODE> method blocks until all listeners 
have finished processing the event. One advantage of this synchronous and 
single-threaded approach is that when a listener receives an event, it operates 
inside the transaction context of the publisher if a transaction context is 
available. If another strategy for event publication becomes necessary, refer to 
the JavaDoc for Spring's <code class=interfacename>ApplicationEventMulticaster</CODE> interface.</P>
<p>The following example shows the bean definitions used to 
register and configure each of the classes above:</P><pre class=programlisting><span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"emailService"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.EmailService"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"blackList"</SPAN><span class=hl-tag>&gt;</SPAN>
      <span class=hl-tag>&lt;list&gt;</SPAN>
          <span class=hl-tag>&lt;value&gt;</SPAN>known.spammer@example.org<span class=hl-tag>&lt;/value&gt;</SPAN>
          <span class=hl-tag>&lt;value&gt;</SPAN>known.hacker@example.org<span class=hl-tag>&lt;/value&gt;</SPAN>
          <span class=hl-tag>&lt;value&gt;</SPAN>john.doe@example.org<span class=hl-tag>&lt;/value&gt;</SPAN>
      <span class=hl-tag>&lt;/list&gt;</SPAN>
  <span class=hl-tag>&lt;/property&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN>

<span class=hl-tag>&lt;bean</SPAN> <span class=hl-attribute>id</SPAN>=<span class=hl-value>"blackListNotifier"</SPAN> <span class=hl-attribute>class</SPAN>=<span class=hl-value>"example.BlackListNotifier"</SPAN><span class=hl-tag>&gt;</SPAN>
  <span class=hl-tag>&lt;property</SPAN> <span class=hl-attribute>name</SPAN>=<span class=hl-value>"notificationAddress"</SPAN> <span class=hl-attribute>value</SPAN>=<span class=hl-value>"blacklist@example.org"</SPAN><span class=hl-tag>/&gt;</SPAN>
<span class=hl-tag>&lt;/bean&gt;</SPAN></PRE>
<p>Putting it all together, when the <code class=methodname>sendEmail()</CODE> method of the <code class=literal>emailService</CODE> bean is called, if there are any emails 
that should be blacklisted, a custom event of type <code class=classname>BlackListEvent</CODE> is published. The <code class=literal>blackListNotifier</CODE> bean is registered as an <code 
class=interfacename>ApplicationListener</CODE> and thus 
receives the <code class=classname>BlackListEvent</CODE>, 
at which point it can notify appropriate parties.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Spring's eventing mechanism is designed for simple 
      communication between Spring beans within the same application context. 
      However, for more sophisticated enterprise integration needs, the 
      separately-maintained <a class=ulink 
      href="http://springsource.org/spring-integration" target=_top 
      >Spring Integration</A> project provides complete 
      support for building lightweight, <a class=ulink 
      href="http://www.enterpriseintegrationpatterns.com" target=_top 
      >pattern-oriented</A>, event-driven architectures that 
      build upon the well-known Spring programming 
model.</P></TD></TR></TABLE></DIV></DIV>
<div class=section title="5.14.3&nbsp;Convenient access to low-level resources">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=context-functionality-resources></A>5.14.3&nbsp;Convenient access to low-level 
resources</H3></DIV></DIV></DIV>
<p>For optimal usage and understanding of application 
contexts, users should generally familiarize themselves with Spring's <code 
class=interfacename>Resource</CODE> abstraction, as 
described in the chapter <A class=xref title=6.&nbsp;Resources href="resources.html" >Chapter&nbsp;6, <i>Resources</I></A>.</P>
<p>An application context is a <code class=interfacename>ResourceLoader</CODE>, which can be used to load <code 
class=interfacename>Resource</CODE>s. A <code 
class=interfacename>Resource</CODE> is essentially a more 
feature rich version of the JDK class <code class=literal>java.net.URL</CODE>, in fact, the implementations of the 
<code class=interfacename>Resource</CODE> wrap an instance 
of <code class=literal>java.net.URL</CODE> where 
appropriate. A <code class=interfacename>Resource</CODE> 
can obtain low-level resources from almost any location in a transparent 
fashion, including from the classpath, a filesystem location, anywhere 
describable with a standard URL, and some other variations. If the resource 
location string is a simple path without any special prefixes, where those 
resources come from is specific and appropriate to the actual application 
context type.</P>
<p>You can configure a bean deployed into the application 
context to implement the special callback interface, <code class=interfacename>ResourceLoaderAware</CODE>, to be automatically called back 
at initialization time with the application context itself passed in as the 
<code class=interfacename>ResourceLoader</CODE>. You can 
also expose properties of type <code class=interfacename>Resource</CODE>, to be used to access static resources; 
they will be injected into it like any other properties. You can specify those 
<code class=interfacename>Resource</CODE> properties as 
simple String paths, and rely on a special JavaBean <code class=interfacename>PropertyEditor</CODE> that is automatically registered by 
the context, to convert those text strings to actual <code class=interfacename>Resource</CODE> objects when the bean is deployed.</P>
<p>The location path or paths supplied to an <code 
class=interfacename>ApplicationContext</CODE> constructor 
are actually resource strings, and in simple form are treated appropriately to 
the specific context implementation. <code class=classname>ClassPathXmlApplicationContext</CODE> treats a simple 
location path as a classpath location. You can also use location paths (resource 
strings) with special prefixes to force loading of definitions from the 
classpath or a URL, regardless of the actual context type.</P></DIV>
<div class=section 
title="5.14.4&nbsp;Convenient ApplicationContext instantiation for web applications">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=context-create></A>5.14.4&nbsp;Convenient <code class=interfacename>ApplicationContext</CODE> instantiation for web 
applications</H3></DIV></DIV></DIV>
<p>You can create <code class=interfacename>ApplicationContext</CODE> instances declaratively by using, 
for example, a <code class=classname>ContextLoader</CODE>. 
Of course you can also create <code class=interfacename>ApplicationContext</CODE> instances programmatically by 
using one of the <code class=interfacename>ApplicationContext</CODE> implementations.</P>
<p>The <code class=classname>ContextLoader</CODE> mechanism comes in two flavors: the 
<code class=classname>ContextLoaderListener</CODE> and the 
<code class=classname>ContextLoaderServlet</CODE>. They 
have the same functionality but differ in that the listener version is not 
reliable in Servlet 2.3 containers. In the Servlet 2.4 specification, Servlet 
context listeners must execute immediately after the Servlet context for the web 
application is created and is available to service the first request (and also 
when the Servlet context is about to be shut down). As such a Servlet context 
listener is an ideal place to initialize the Spring <code class=interfacename>ApplicationContext</CODE>. All things being equal, you 
should probably prefer <code class=classname>ContextLoaderListener</CODE>; for more information on 
compatibility, have a look at the Javadoc for the <code class=classname>ContextLoaderServlet</CODE>.</P>
<p>You can register an <code class=interfacename>ApplicationContext</CODE> using the <code class=classname>ContextLoaderListener</CODE> as follows:</P><pre class=programlisting><span class=hl-tag>&lt;context-param&gt;</SPAN>
<span class=hl-tag>&lt;param-name&gt;</SPAN>contextConfigLocation<span class=hl-tag>&lt;/param-name&gt;</SPAN>
<span class=hl-tag>&lt;param-value&gt;</SPAN>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class=hl-tag>&lt;/param-value&gt;</SPAN>
<span class=hl-tag>&lt;/context-param&gt;</SPAN>

<span class=hl-tag>&lt;listener&gt;</SPAN>
<span class=hl-tag>&lt;listener-class&gt;</SPAN>org.springframework.web.context.ContextLoaderListener<span class=hl-tag>&lt;/listener-class&gt;</SPAN>
<span class=hl-tag>&lt;/listener&gt;</SPAN>

<em class=lineannotation><span class=lineannotation>&lt;!-- or use the ContextLoaderServlet instead of the above listener</SPAN></EM><span class=emphasis><em>
&lt;servlet&gt;
&lt;servlet-name&gt;context&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--</EM></SPAN>&gt;</PRE>
<p>The listener inspects the <code class=literal>contextConfigLocation</CODE> parameter. If the parameter 
does not exist, the listener uses <code class=literal>/WEB-INF/applicationContext.xml</CODE> as a default. When 
the parameter <span class=emphasis><em>does</EM></SPAN> exist, the listener separates the String 
by using predefined delimiters (comma, semicolon and whitespace) and uses the 
values as locations where application contexts will be searched. Ant-style path 
patterns are supported as well. Examples are <code class=literal>/WEB-INF/*Context.xml</CODE> for all files with names 
ending with "Context.xml", residing in the "WEB-INF" directory, and <code 
class=literal>/WEB-INF/**/*Context.xml</CODE>, for all such 
files in any subdirectory of "WEB-INF".</P>
<p>You can use <code class=classname>ContextLoaderServlet</CODE> instead of <code 
class=classname>ContextLoaderListener</CODE>. The Servlet 
uses the <code class=literal>contextConfigLocation</CODE> 
parameter just as the listener does.</P></DIV>
<div class=section 
title="5.14.5&nbsp;Deploying a Spring ApplicationContext as a J2EE RAR file">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=context-deploy-rar></A>5.14.5&nbsp;Deploying a Spring ApplicationContext as a 
J2EE RAR file</H3></DIV></DIV></DIV>
<p>In Spring 2.5 and later, it is possible to deploy a 
Spring ApplicationContext as a RAR file, encapsulating the context and all of 
its required bean classes and library JARs in a J2EE RAR deployment unit. This 
is the equivalent of bootstrapping a standalone ApplicationContext, just hosted 
in J2EE environment, being able to access the J2EE servers facilities. RAR 
deployment is a more natural alternative to scenario of deploying a headless WAR 
file, in effect, a WAR file without any HTTP entry points that is used only for 
bootstrapping a Spring ApplicationContext in a J2EE environment.</P>
<p>RAR deployment is ideal for application contexts that do 
not need HTTP entry points but rather consist only of message endpoints and 
scheduled jobs. Beans in such a context can use application server resources 
such as the JTA transaction manager and JNDI-bound JDBC DataSources and JMS 
ConnectionFactory instances, and may also register with the platform's JMX 
server - all through Spring's standard transaction management and JNDI and JMX 
support facilities. Application components can also interact with the 
application server's JCA WorkManager through Spring's <code class=interfacename>TaskExecutor</CODE> abstraction.</P>
<p>Check out the JavaDoc of the <a class=ulink 
href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html" 
target=_top>SpringContextResourceAdapter</A> class for the 
configuration details involved in RAR deployment.</P>
<p><span class=emphasis><em>For a simple deployment of a Spring ApplicationContext as a 
J2EE RAR file:</EM></SPAN> package all application classes into a RAR file, 
which is a standard JAR file with a different file extension. Add all required 
library JARs into the root of the RAR archive. Add a "META-INF/ra.xml" 
deployment descriptor (as shown in <code class=classname>SpringContextResourceAdapter</CODE>s JavaDoc) and the 
corresponding Spring XML bean definition file(s) (typically 
"META-INF/applicationContext.xml"), and drop the resulting RAR file into your 
application server's deployment directory.</P>
<div style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in" class=note title=Note>
<table border=0 summary=Note>
  
  <tr>
    <td vAlign=top rowSpan=2 width=25 align=center><IMG alt=[Note] src="images/note.png" ></TD>
    <th align=left>Note</TH></TR>
  <tr>
    <td vAlign=top align=left>
      <p>Such RAR deployment units are usually 
      self-contained; they do not expose components to the outside world, not 
      even to other modules of the same application. Interaction with a 
      RAR-based ApplicationContext usually occurs through JMS destinations that 
      it shares with other modules. A RAR-based ApplicationContext may also, for 
      example, schedule some jobs, reacting to new files in the file system (or 
      the like). If it needs to allow synchronous access from the outside, it 
      could for example export RMI endpoints, which of course may be used by 
      other application modules on the same 
machine.</P></TD></TR></TABLE></DIV></DIV></DIV>
<div class=section title="5.15&nbsp;The BeanFactory">
<div class=titlepage>
<div>
<div>
<h2 style="CLEAR: both" class=title><a 
name=beans-beanfactory></A>5.15&nbsp;The 
BeanFactory</H2></DIV></DIV></DIV>
<p>The <code class=classname>BeanFactory</CODE> provides the underlying basis for 
Spring's IoC functionality but it is only used directly in integration with 
other third-party frameworks and is now largely historical in nature for most 
users of Spring. The <code class=classname>BeanFactory</CODE> and related interfaces, such as <code 
class=classname>BeanFactoryAware</CODE>, <code 
class=classname>InitializingBean</CODE>, <code 
class=classname>DisposableBean</CODE>, are still present in 
Spring for the purposes of backward compatibility with the large number of 
third-party frameworks that integrate with Spring. Often third-party components 
that can not use more modern equivalents such as <code class=code>@PostConstruct</CODE> or <code class=code>@PreDestroy</CODE> in order to remain compatible with JDK 
1.4 or to avoid a dependency on JSR-250.</P>
<p>This section provides additional background into the 
differences between the <code class=interfacename>BeanFactory</CODE> and <code class=interfacename>ApplicationContext</CODE> and how one might access the IoC 
container directly through a classic singleton lookup.</P>
<div class=section title="5.15.1&nbsp;BeanFactory or ApplicationContext?">
<div class=titlepage>
<div>
<div>
<h3 class=title><a 
name=context-introduction-ctx-vs-beanfactory></A>5.15.1&nbsp;<code class=interfacename>BeanFactory</CODE> or <code class=interfacename>ApplicationContext</CODE>?</H3></DIV></DIV></DIV>
<p>Use an <code class=interfacename>ApplicationContext</CODE> unless you have a good reason for 
not doing so.</P>
<p>Because the <code class=interfacename>ApplicationContext</CODE> includes all functionality of the 
<code class=interfacename>BeanFactory</CODE>, it is 
generally recommended over the <code class=interfacename>BeanFactory</CODE>, except for a few situations such as in 
an <code class=classname>Applet</CODE> where memory 
consumption might be critical and a few extra kilobytes might make a difference. 
However, for most typical enterprise applications and systems, the <code 
class=interfacename>ApplicationContext</CODE> is what you 
will want to use. Spring 2.0 and later makes <span class=emphasis><em>heavy</EM></SPAN> use of the <A class=link title="5.8.1&nbsp;Customizing beans using a BeanPostProcessor" href="beans.html#beans-factory-extension-bpp" ><code class=interfacename>BeanPostProcessor</CODE> extension point</A> (to effect 
proxying and so on). If you use only a plain <code class=interfacename>BeanFactory</CODE>, a fair amount of support such as 
transactions and AOP will not take effect, at least not without some extra steps 
on your part. This situation could be confusing because nothing is actually 
wrong with the configuration.</P>
<p>The following table lists features provided by the <code 
class=interfacename>BeanFactory</CODE> and <code 
class=interfacename>ApplicationContext</CODE> interfaces 
and implementations.</P>
<div class=table><a 
name=context-introduction-ctx-vs-beanfactory-feature-matrix></A>
<p class=title><b>Table&nbsp;5.8.&nbsp;Feature Matrix</B></P>
<div class=table-contents>
<table 
style="BORDER-BOTTOM: 0.5pt solid; BORDER-LEFT: 0.5pt solid; BORDER-COLLAPSE: collapse; BORDER-TOP: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
summary="Feature Matrix" width="100%">
  <colgroup>
  <col align=left>
  <col>
  <col></COLGROUP>
  <thead>
  <tr>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>Feature</TH>
    <th style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center><code class=interfacename 
      >BeanFactory</CODE></TH>
    <th style="BORDER-BOTTOM: 0.5pt solid" align=center 
      ><code class=interfacename 
      >ApplicationContext</CODE></TH></TR></THEAD>
  <tbody>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p>Bean instantiation/wiring</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>
      <p>Yes</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid" align=center>
      <p>Yes</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p>Automatic <code class=interfacename 
      >BeanPostProcessor</CODE> registration</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>
      <p>No</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid" align=center>
      <p>Yes</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p>Automatic <code class=interfacename 
      >BeanFactoryPostProcessor</CODE> registration</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>
      <p>No</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid" align=center>
      <p>Yes</P></TD></TR>
  <tr>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" align=left 
    >
      <p>Convenient <code class=interfacename 
      >MessageSource</CODE> access (for i18n)</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid; BORDER-RIGHT: 0.5pt solid" 
    align=center>
      <p>No</P></TD>
    <td style="BORDER-BOTTOM: 0.5pt solid" align=center>
      <p>Yes</P></TD></TR>
  <tr>
    <td style="BORDER-RIGHT: 0.5pt solid" align=left>
      <p><code class=interfacename 
      >ApplicationEvent</CODE> publication</P></TD>
    <td style="BORDER-RIGHT: 0.5pt solid" align=center>
      <p>No</P></TD>
    <td align=center>
      <p>Yes</P></TD></TR></TBODY></TABLE></DIV></DIV><br 
class=table-break>
<p>To explicitly register a bean post-processor with a 
<code class=interfacename>BeanFactory</CODE> 
implementation, you must write code like this:</P><pre class=programlisting>ConfigurableBeanFactory factory = <span class=hl-keyword>new</SPAN> XmlBeanFactory(...);

<em class=lineannotation><span class=lineannotation>// now register any needed BeanPostProcessor instances</SPAN></EM>
MyBeanPostProcessor postProcessor = <span class=hl-keyword>new</SPAN> MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<em class=lineannotation><span class=lineannotation>// now start using the factory</SPAN></EM></PRE>
<p>To explicitly register a <code class=classname>BeanFactoryPostProcessor</CODE> when using a <code 
class=interfacename>BeanFactory</CODE> implementation, you 
must write code like this:</P><pre class=programlisting>XmlBeanFactory factory = <span class=hl-keyword>new</SPAN> XmlBeanFactory(<span class=hl-keyword>new</SPAN> FileSystemResource(<span class=hl-string>"beans.xml"</SPAN>));

<em class=lineannotation><span class=lineannotation>// bring in some property values from a Properties file</SPAN></EM>
PropertyPlaceholderConfigurer cfg = <span class=hl-keyword>new</SPAN> PropertyPlaceholderConfigurer();
cfg.setLocation(<span class=hl-keyword>new</SPAN> FileSystemResource(<span class=hl-string>"jdbc.properties"</SPAN>));

<em class=lineannotation><span class=lineannotation>// now actually do the replacement</SPAN></EM>
cfg.postProcessBeanFactory(factory);</PRE>
<p>In both cases, the explicit registration step is 
inconvenient, which is one reason why the various <code class=interfacename>ApplicationContext</CODE> implementations are preferred 
above plain <code class=interfacename>BeanFactory</CODE> 
implementations in the vast majority of Spring-backed applications, especially 
when using <code class=literal>BeanFactoryPostProcessors</CODE> and <code class=classname>BeanPostProcessors</CODE>. These mechanisms implement 
important functionality such as property placeholder replacement and 
AOP.</P></DIV>
<div class=section title="5.15.2&nbsp;Glue code and the evil singleton">
<div class=titlepage>
<div>
<div>
<h3 class=title><a name=beans-servicelocator></A>5.15.2&nbsp;Glue code and the evil 
singleton</H3></DIV></DIV></DIV>
<p>It is best to write most application code in a 
dependency-injection (DI) style, where that code is served out of a Spring IoC 
container, has its own dependencies supplied by the container when it is 
created, and is completely unaware of the container. However, for the small glue 
layers of code that are sometimes needed to tie other code together, you 
sometimes need a singleton (or quasi-singleton) style access to a Spring IoC 
container. For example, third-party code may try to construct new objects 
directly (<code class=literal>Class.forName()</CODE> 
style), without the ability to get these objects out of a Spring IoC container. 
If the object constructed by the third-party code is a small stub or proxy, 
which then uses a singleton style access to a Spring IoC container to get a real 
object to delegate to, then inversion of control has still been achieved for the 
majority of the code (the object coming out of the container). Thus most code is 
still unaware of the container or how it is accessed, and remains decoupled from 
other code, with all ensuing benefits. EJBs may also use this stub/proxy 
approach to delegate to a plain Java implementation object, retrieved from a 
Spring IoC container. While the Spring IoC container itself ideally does not 
have to be a singleton, it may be unrealistic in terms of memory usage or 
initialization times (when using beans in the Spring IoC container such as a 
Hibernate <code class=interfacename>SessionFactory</CODE>) 
for each bean to use its own, non-singleton Spring IoC container.</P>
<p>Looking up the application context in a service locator 
style is sometimes the only option for accessing shared Spring-managed 
components, such as in an EJB 2.1 environment, or when you want to share a 
single ApplicationContext as a parent to WebApplicationContexts across WAR 
files. In this case you should look into using the utility class <a class=ulink 
href="http://static.springsource.org/spring/docs/current/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" 
target=_top><code class=classname>ContextSingletonBeanFactoryLocator</CODE></A> locator that 
is described in this <a class=ulink 
href="http://blog.springsource.com/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/" 
target=_top>SpringSource team blog 
entry</A>.</P></DIV></DIV>
<div class=footnotes><br>
<hr align=left width=100>

<div class=footnote>
<p><sup>[<A class=para href="#d4e1140" name=ftn.d4e1140 >1</A>] </SUP>See 
<A class=xref title=Background href="overview.html#background-ioc" >Background</A></P></DIV>
<div class=footnote>
<p><sup>[<A class=para href="#d4e1974" name=ftn.d4e1974 >2</A>] </SUP>See 
<A class=xref title="5.4.1&nbsp;Dependency injection" href="beans.html#beans-factory-collaborators" >Section&nbsp;5.4.1, 
“Dependency injection”</A></P></DIV></DIV></div>
<div class=navfooter>
<hr>

<table summary="Navigation footer" width="100%">
  
  <tr>
    <td width="40%" align=left><A accessKey=p href="spring-core.html" >Prev</A>&nbsp;</TD>
    <td width="20%" align=center><A accessKey=u href="spring-core.html" >Up</A></TD>
    <td width="40%" align=right>&nbsp;<A accessKey=n href="resources.html" >Next</A></TD></TR>
  <tr>
    <td vAlign=top width="40%" align=left 
      >Part&nbsp;III.&nbsp;Core Technologies&nbsp;</TD>
    <td width="20%" align=center><A accessKey=h href="index.html" >Home</A></TD>
    <td vAlign=top width="40%" align=right 
      >&nbsp;6.&nbsp;Resources</TD></TR></TABLE></DIV></body>